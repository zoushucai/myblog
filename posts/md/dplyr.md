---
title: dplyr -- 1基本函数简介
date: '2018-01-01'
categories:
  - r
  - dplyr
---


## 0、dplyr初始
由于R语言每一个步骤没有赋值的话，是不会改变原有的数据，都是建立一个新的数据。原有数据不改变。

- **`dplyr::tbl_df(iris)`：** 将数据转化为tbl类。只会显示适合屏幕大小的数据：

- **`dplyr::glimpse(iris)`：** tbl数据的信息密集概括。 类似str()函数

- **`dplyr::%>%`：** 将左边的对象作为第一个参数（或参数 .）传递到右边的函数中。利用%>%进行“Piping”管道操作增强了代码的可读性， 
   ```R
   x %>% f(y) 相当于  f(x, y)    
   y %>% f(x, ., z) 相当于  f(x, y, z )
  ```
  

## 1、filter 行过滤

-  **`filter(iris, Sepal.Length > 7) `：**抽取符合逻辑条件的数据记录。     
-  **`distinct(iris) `：**删除重复记录。 distinct(iris, Species)  保留iris某一列的唯一值
-  **`sample_frac(iris, 0.5, replace = TRUE) `：**随机选取部分数据(占总体的0.5)记录。     
-  **`sample_n(iris, 10, replace = TRUE) `：**随机选取n条数据记录。     
-  **`slice(iris, 10:15) `：**通过位置选取数据记录。   
-  **`top_n(storms, 2, date) `：**选取并排列前n条数据记录 （若为分组数据则按组排序）  

## 2、select 列过滤

```R
rename(.data, ...)
rename_all(.tbl, .funs = list(), ...)
rename_if(.tbl, .predicate, .funs = list(), ...)
rename_at(.tbl, .vars, .funs = list(), ...)


select(.data, ...)
select_all(.tbl, .funs = list(), ...)
select_if(.tbl, .predicate, .funs = list(), ...)
select_at(.tbl, .vars, .funs = list(), ...)

```

### Arguments

| `.tbl`       | A `tbl` object.                                              |
| ------------ | ------------------------------------------------------------ |
| `.funs`      | A function `fun`, a purrr style lambda `~ fun(.)` or a list of either form. |
| `...`        | Additional arguments for the function calls in `.funs`. These are evaluated only once, with [tidy dots](http://127.0.0.1:31926/help/library/rlang/html/tidy-dots.html) support. <br>注意: .funs一般是一个函数列表,处理自变量之外,一般不知道额外参数,要指定额外参数,此时需要在这里特别指定. |
| `.predicate` | A predicate function to be applied to the columns or a logical vector. The variables for which `.predicate` is or returns `TRUE`are selected. This argument is passed to`rlang::as_function()` and thus supports quosure-style lambda functions and strings representing function names.<br>直译过来,指的是谓词函数, 必须是返回`ture` or `false` 的逻辑函数. 像`is.character,all,is.null`等等. |
| `.vars`      | A list of columns generated by `vars()`, a character vector of column names, a numeric vector of column positions, or `NULL`.<br> 可以用字符串 或者列索引(数字) 组成的列,匹配列名用 |

-   **`select(df, newname=a, b, c ) `:** 通过列名或帮助函数选取列变量。 同时也可以对列名进行重命名。 
  
  -   **`select(df, a:b)  `:** 选取在a和b之间的所有列（包含 a和b）
  -   **`select(df, -a)  `:**   选取除a以外的所有列  
  
-   **`select(df,...,funs)`:**
  
  -   **`df`:** 数据框
  -   **`funs:`** 所用函数( 注意::  一般不建议在选择列的同时,对列进行操作)
  
  > - **`contains(".") `：**   选取名称中含有字符的列。 
  >   - **`starts_with("Sepal")`  :**选取名称以指定字符串为首的列。      
  > - **`ends_with("Length")` ：**选取名称以指定字符串结尾的列。     
  > - **`matches(".t.")`：** 选取名称符合指定表达式规则的列。   
  > - **`num_range("x", 1:5) `:**选取名为x1、x2、x3、x4、x5的列。    
  > - **`one_of(c("Species", "Genus")) ` :**选取名称在指定名字组内的列。    e.g. ` a:b `  eg.  `-a`
  > - **`everything([ df ])`：**  列较多的情况下把不需要排序的列用evything()直接列出。当有df是返回1:df的列数,当为向量是返回1: 向量长度。 eg: `select(iris,Species,everything())`

- **`select_if(df, <条件>, fun)`:**对df数据集 选出满足条件为真的列执行fun。
	
	- `<条件>`是对整个列属性进行判断筛选(真则保留，假则丢弃)。然后在对列名进行处理。
	- `funs`是对列名进行筛选处理.
	- 注意： 当同时使用`<条件>, fun` 时，以条件为准，`fun`是对满足条件后的列的列名进行处理，不能对列进行进一步筛选。
	- `select(df,...,funs)` 和`select_if(df,<条件>)`的区别
		- `select_if`的条件是对列的属性进行筛选
		- `select`中的`funs`函数是对列名进行筛选
- `select_at(.tbl, .vars, .funs = list(), ...)` 是对`select_if`的加强版
	
	- `select_at(mtcars, vars(-contains("ar"), starts_with("c"))` 可以看做是多个对列名多个条件的筛选。

## 3、mutate 添加新变量，组成新数据集。 原数据不改变 。

- **`rename()`** 重命列名  eg.  `rename(iris, petal_length = Petal.Length)`

   - `rename_all(iris,funs(c(1:5)))`或`rename_all(iris,funs(c("A","B","C","D","E")))`把整个列名都重新赋值
   - `rename_at(.tbl, .vars, .funs = list())` 
   - `rename_if(.tbl, .predicate, .funs = list())`
   - 建议把参数`.vars=... , .funs = ...`显示调用，不然函数会报错   

- **`mutate(mtcars, gpm = 1/mpg)`：**  在原有数据的基础上添加新列（多列）组成新数据集。 原数据不改变 。  

- **`transmute(mtcars, gpm = 1/mpg)`：**直接创建一个新列（多列）组成新数据集。  
  - **`mutate_all(.tbl, .funs, …)`** :  对**每一列**应用 funs，组成新数据集，
  - `mutate_at(.tbl, .vars, .funs, ..., .cols = NULL) `：对**指定的列**运行窗口函数，组成新数据，
  - **`mutate_if(.tbl, .predicate, .funs, …) `**：对**指定类型的列**运行窗口函数，组成新数据，

    > **`vars() `:** 表示需要进行概述的列  
    >
    > **`.funs`的用法**
    >
    >  - 建议显示调用改参数`.funs=`  
    >  - 直接在函数中写明需要运行的函数:  `mutate_all(faithful, .funs(log))`
    >  - 结合funs写出调用的函数:  `mutate_all(faithful, funs(log(.), log2(.)))`
    >     + 运行两个以上函数，保留原数据的基础上增加新列，新列会自动根据函数名自动重命名
    >     + 也可以自己重命名,：`mutate_all(faithful, funs(a=log(.), b= log2(.)))`
    >     + 当funs只有一个时且自己进行重命名时，会保留原数据的基础上增加新列构成新数据，`mutate_all(faithful, funs(a=log2(.)))`
    >     + mutate_if(car,is.character,as.factor )也可以直接省略括号
    >
    > 还可以把NULL赋值给列，已达到删除列的效果。
    >
    > 以下用法类似：
    > `summarise_all(.tbl, .funs, ...) `
    >
    > `summarise_if(.tbl, .predicate, .funs, ...)`
    >
    > `summarise_at(.tbl, .vars, .funs, ..., .cols = NULL)`
    >
    > 
    >
    > `mutate_all(.tbl, .funs, ...)`
    >
    > `mutate_if(.tbl, .predicate, .funs, ...)`
    >
    > `mutate_at(.tbl, .vars, .funs, ..., .cols = NULL)`
    >
    > 
    >
    > `transmute_all(.tbl, .funs, ...)`  
    >
    > `transmute_if(.tbl, .predicate, .funs, ...)`  
    >
    > `transmute_at(.tbl, .vars, .funs, ..., .cols = NULL) ` 

- 窗体函数（.funs）
   - `lead(x, n = 1L, default = NA, order_by = NULL, ...)`

   - `lag(x, n = 1L, default = NA, order_by = NULL, ...)　`

     > lead和lag函数主要用于替换数据，lead表示整体向前替换，lag表示整体向后替换，n表示替换的个数，default表示要替换的结果，默认为NA 。order_by是根据某一列进行排序。

   - `cume_dist() `： 累积分布。   

   - `dense_rank() `： 无缝排序。   

   - `min_rank() `： 排序。并列时，其他序号顺延。   

   - `ntile()` ： 把向量分为n份。      

   - `percent_rank() `： 把数据在[0, 1]中重组并排列。   

   - `row_number() `： 排序。并列时，位置在前的并列数 据序号在前。     

   - `between() `： 数值是否在a和b之间？     

     

      - `cumall() `： 累积all函数      

      - `cumany()` ： 累积any函数     

      - `cummean()` ： 累积mean函数    

      - `cumsum()` ： 累积sum函数   

      - `cummax()` ： 累积max函数   

      - `cummin() `： 累积  min函数    

      - `cumprod() `： 累积prod函数    

      - `pmax()` ： 针对元素的max函数   

      - `pmin() `： 针对元素的min函数  

   


## 4、概况数据（行），组成新数据集。 原数据不改变 。

- `summarise(iris, avg = mean(Sepal.Length))` 将数据概括为单行数值。 
  - **`summarise_all(.tbl, .funs, ...)`** : 对**每一列**运行概述函数
  - **`summarise_at(.tbl, .vars, .funs, ..., .cols=NULL)`** :对**指定的列**运行概述函数
  - **`summarise_if(.tbl, .predicate, .funs)`**: 对**指定类型的列**运行概述函数
- `count(iris, Species, wt = Sepal.Length)` 计算各变量中每一个特定值的⾏行数（带权重或不带 权重）.
  - `wt`可选参数
    - 不带`wt`时：对分组进行**计数**统计
    - 带`wt`时，对分组后的变量`Sepal.Length`进行**求和**统计





利用概述函数概括数据信息，输入数值向量而返回单一数值，如：

**计数**

- **`length(x)`**：返回一组**向量（包括列表）或因子的长度**
- **`nrow() / ncol()`**：总行数/总列数
- **`n()`**：返回观测行的行数，**不能单独使用**（可被用于 `summarise()、mutate()、filter()` ）
- `n_distinct(x, na.rm=FALSE)`：返回不重复的行数
  - **`sum(!is.na())`**：计算非空值的行数

**位置与序列**

- **`first(x)/last(x)`**    向量的最后一个值。   
- **`nth(x,n)`** 返回向量的第n个值。  

**分布**

- **`IQR()`** 向量的IQR（四分位距）。
- **`min() /max()`** 向量中的最小(大)值。   
- **`mean()`** 向量中的均值。  **mean(!is.na())** ：非空值的均值
- **`median()`** 向量中的中位数。   
- **`var()`** 向量中的⽅方差。  
- **`sd()`** 向量中的标准差。
- **`range()`** 返回值域，即最大最小值
- **`colSums(x) / rowSums(x)`**：各列/行求和
- **`colMeans(x) / rowMeans(x)`**：各列/行求均值

#### 


##5、分组汇总
- `group_by(.data, ..., add = FALSE)`

- `ungroup(x, ...)  `

  > `... `： 表示用于分组的列名；
  >
  > `add= FALSE`默认)
  >
  > - `FALSE`，表示会覆盖原来的分组，相当于对源数据重新分组；
  > - 若为`TRUE`,则不覆盖，相当于在原来的基础上在进行分组；
  >
  > > `group_by(iris, Species)` 把在Species中的值相同的数据组合成行。   
  > >
  > > `ungroup(iris)` 从数据框中移除组合信息。
  > >
  > > -   `iris   %>%   group_by(Species)   %>%   summarise(…) `为每一个分组分别计算行概述。   
  > > -   `iris   %>%   group_by(Species)   %>%   mutate(…)` 按组计算新变量。      
  >
  > 同样也有
  >
  > `group_by_all(.tbl, .funs = list(), ...)   `
  >
  > `group_by_at(.tbl, .vars, .funs = list(), ..., .add = FALSE)`
  >
  > `group_by_if(.tbl, .predicate, .funs = list(), ..., .add = FALSE)`







