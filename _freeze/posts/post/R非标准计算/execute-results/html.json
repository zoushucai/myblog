{
  "hash": "62b714610ec3e24866053324105987f4",
  "result": {
    "markdown": "---\ntitle: R非标准计算\ndate: '2019-05-02'\ncategories: r\n---\n\n\n\n\n\n## 1. 捕获表达式\n\n将表达式捕获转为语言对象，捕获表达式意味着防止表达式被执行，而将其本身存储为变量的形式。具有这个功能的函数有如下几个函数，注意其不同。\n\n### 1.1 quote() :\n\n​\t\t`quote()`捕获到函数调用是会返回调用，而捕获到变量名时会返回一个符号，只要代码语法正确，它就会返回表示被捕获表达式本身的语言对象。即便函数不存在或者变量未定义，也可以捕获表达式本身。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list  = ls() )\nx =  quote(a+b)   # 定义一个表达式调用,但是这些变量没有定义\nx\n#> a + b\nclass(x)\n#> [1] \"call\"\ntypeof(x) # 变成语言对象类型，\n#> [1] \"language\"\n\nx = quote(rnorm)\nx\n#> rnorm\nclass(x)\n#> [1] \"name\"\ntypeof(x) # 变成符号对象类型，\n#> [1] \"symbol\"\n\nquote(xfun(a = 1:n)) # xfun都么有定义\n#> xfun(a = 1:n)\n```\n:::\n\n\n**理解：变量和符号对象的区别，以及函数和调用对象的区别。**\n\n变量是对象的名称，而符号对象就是名称的本身。函数是可以被调用的对象，而调用对象是不会被计算的，它表示整个函数调用的语言对象。\n\neg： `rnorm()`就是一个可以被调用的函数(可以使用`rnorm(5)`进行调用,产生5个随机数)，但是`quote(rnorm)`返回一个符号对象，`quote(rnorm(5))`返回一个调用的对象，这两者都是语言本身。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list  = ls() )\nrnorm(5)\n#> [1] -0.1316684  1.1643017 -0.1560567 -1.3104017  0.5226794\nx = quote(rnorm)\ntypeof(x) # 返回一个符号对象\n#> [1] \"symbol\"\n\nx1 = quote(rnorm(5))\ntypeof(x1) # 返回一个调用对象\n#> [1] \"language\"\n\nas.list(x1) # 将调用对象转变为list，以便查看其内部结构， 可以看出本次调用有两部分组成：函数符号和一个参数\n#> [[1]]\n#> rnorm\n#> \n#> [[2]]\n#> [1] 5\nx1[[1]]\n#> rnorm\ntypeof(x1[[1]]) # 第一个元素是一个符号对象\n#> [1] \"symbol\"\nclass(x1[[1]])\n#> [1] \"name\"\n\nx1[[2]] \n#> [1] 5\ntypeof(x1[[2]]) # 第二个元素是一个数值\n#> [1] \"double\"\nclass(x1[[2]])\n#> [1] \"numeric\"\n## 总结：\n# 1.quote()将变量名捕获为符号对象，将一个函数捕获为调用对象。这两者都是语言对象\n# 2.可以用is.symbol() / is.name() 和 is.call 分别检查对象是否为符号对象或调用对象\n# 3.可以用is.language()同时检查符号和调用\n# 4. quote不把字面值(这里指的的表达式里使用数值等，而非数值变量。eg：数字、逻辑值、字符串)转变为语言对象，而是使其保持原样。--- 少用\n```\n:::\n\n\n\n\n**常常捕获全局环境中的表达式，函数环境中建议用`substitute()`，`substitute()`用于捕获表达式，并且用捕获的表达式替换现有的符号,而`quote()`不会进行第二步，把表达式替换成现有的符号** \n\n### 1.2 substitute\n\n##### 1.2.1 用来捕获函数参数表达式\n\n​\t\t\t`substitute()`可以作用任意的用户输入，该函数用于捕获表达式，并且用捕获的表达式替换现有的符号。常常与`deparse()`连用，出现在函数环境中(对表达式进行替换, 不能替换的则保留下来)。\n\n`deparse(substitute())`函数以`substitute()` 的结果(一个表达式)为参数，并把它转变成一个字符串。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list  = ls() )\n### 1.substitute() 的使用对比\na = 1\nb = 2\nsubstitute(a + b + z)\n#> a + b + z\n\nf = function(){\n  a= 1\n  b = 2\n  substitute(a+b+z)\n}\nf()\n#> 1 + 2 + z\n\n\nsubstitute(a+b+z)\n#> a + b + z\nsubstitute(a+b+z , list(a = 1,b = 2))# 可以指定list(用名称--值的形式)，进行表达式替换\n#> 1 + 2 + z\n```\n:::\n\n\n`substitute()`还可以替换表达式中的函数.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list  = ls() )\nsubstitute(a+b+z ,list('+' =quote(f)) )\n#> f(f(a, b), z)\nsubstitute(a+b+z ,list('+' =quote(sin)) )\n#> sin(sin(a, b), z)\nsubstitute(a+b+z ,list('+' =quote(`*`)) )\n#> a * b * z\n```\n:::\n\n\n总结： 形式上，通过用list的形式对表达式中的所有名字进行检查替换(注意R中的所有动作都是函数，也可以对函数进行替换，如上)，其表达式中的名字替换规则如下：\n\n1. 一个普通变量，它就被变量的值替换。\n2. 一个函数参数，它就被与约定相关联的表达式替换。\n3. `...`，它被`...`的内容替换。\n4. 以上都没有，则名字原样保留不变\n\n##### 1.2.2.  substitute的缺点\n\n- 如果某个表达式存储在变量中，则它不会对表达式进行替换。这时需要用到pryr::substitute_q()函数。\n- 如果substitute它在全局环境中运行时(不特殊指定替换)，它从不进行替换，最好用作函数环境中。这时可以用pryr::subs()函数\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list  = ls() )\nx  = quote(a + b)  # x存储了一个表达式\nsubstitute(x,list(a = 1,b = 2)) # 对x调用参数替换，无效\n#> x\n\na = 3 \nb = 5\nsubstitute(a+b+z) # 无效\n#> a + b + z\n```\n:::\n\n\n**注意：**`subs()`和`substitute()`函数都可以用第二个参数重写正在使用的当前环境，并通过名字—值的列表对来提供替换。后面讲解`subs()`函数\n\n### 1. 3. 创建函数调用\n\n前面已学习函数调用相关内容，我们可以通过以下方式创建函数调用，注意：下面方式得到的结果等价(一模一样)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list  = ls() )\ncall_1 = quote(rnorm(5,mean = 3))\ncall_2 = call(\"rnorm\",5,mean = 3)\ncall_3 = as.call( list(quote(rnorm),5,mean = 3) )\n\ncall_1\n#> rnorm(5, mean = 3)\n\nidentical(call_1,call_2)\n#> [1] TRUE\nidentical(call_2,call_3)\n#> [1] TRUE\n```\n:::\n\n\n### 1.4 .substitute_q() 对substituted()的补充\n\n前面提到`substitute()`存在缺点，当某个表达式存储在变量中，则它不会对表达式进行替换。此时可以用`substitute_q()`函数。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list  = ls() )\nx  = quote(a + b)  # x存储了一个表达式\nsubstitute(x,list(a = 1,b = 2)) # 对x调用参数替换，无效\n#> x\nsubstitute(a+b,list(a = 1,b = 2))  # 对直接变量参数替换,有效\n#> 1 + 2\n\npryr::substitute_q(x, list(a = 1,b=2)) # 对x调用参数替换，有效\n#> 1 + 2\n```\n:::\n\n\n\n\n### 1.5. subs()函数\n\n`subs()`函数，可以在全局环境中直接对变量表达式替换。**subs() 和substitute()的第二个参数都可以重写正在使用的当前环境**。并通过名字—值的列表对来提供替换。这里就不在多说。subs的其它的工作方式与substitute()函数相同。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list  = ls() )\na = 1\nb = 2\nsubstitute(a+b) #  对变量表达式替换，无效\n#> a + b\npryr::subs(a+b) # 对变量表达式替换\n#> 1 + 2\n\nsubstitute(a+b,list(a =10,b =20)) \n#> 10 + 20\npryr::subs(a+b,list(a =10,b =20)) \n#> 10 + 20\n```\n:::\n\n\n\n\n## 2. 对捕获表达式后的处理方式\n\n### 2.1. 执行表达式 — — eval()\n\n​\t\t前面提到的几种方法都可以捕获表达式，捕获表达式之后，下一步就是对其进行求值，可以用eval()函数完成。 \n\n​\t\t比如：我们直接在控制台输入sin(1),其本质相当于执行了两个步骤：1.先捕获这个表达式，2在执行这个这个表达式。于是我们可以通过quote和eval进行分步计算.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list  = ls() )\nsin(1) # 直接一步完成。\n#> [1] 0.841471\n\n## 分步进行\ncall_1 = quote(sin(1))\ncall_1\n#> sin(1)\neval(call_1)\n#> [1] 0.841471\n\n\n# 由于quote可以捕获未定义的变量，故eval执行时可能会报错,eg:\ncall_2 = quote(sin(xx))\ncall_2\n#> sin(xx)\ntry( eval(call_2) )\n#> Error in eval(call_2) : object 'xx' not found\n\ntry( sin(xx) ) # 报错信息和上面的类似\n#> Error in try(sin(xx)) : object 'xx' not found\n\n\n# eval()可以允许我们提供一个list来计算给定的表达式，从而可以不需要创建一个变量x\n\neval(call_2 ,list(xx =1))\n#> [1] 0.841471\n```\n:::\n\n\n### 2.2 eval 函数的用法\n\n```\neval(expr, envir = parent.frame(),\n           enclos = if(is.list(envir) || is.pairlist(envir))\n                       parent.frame() else baseenv())\n```\n\n`expr` :  要计算的表达式，如果只提供这一个参数，即在当前环境中对表达式求值\n\n`envir`： 是一个用于计算`expr`的环境，数据框或者列表。\n\n`encols`： 如果在`envir`中找不到相应的变量，它会在`encols`参数中找，然后在`encols`参数的父环境中查找。如果能在`envir`参数中找到，则`encols`会被忽略。\n\n以下有是哪个便捷函数：(其实本质上都可以用eval来实现)\n\n- `evalq(expr, envir, enclos)`     等价于 ` eval(quote(expr),…)`  ，在当前环境中计算表达式。\n- `eval.parent(expr, n = 1) `         等价于 `eval(expr,parent.frame(n))`，在父环境中计算表达式。\n- `local(expr, envir = new.env())` 等价于 `eval(quote(expr),environment = new.nev())`，在新环境中计算表达式。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list  = ls() )\n## 参考《R语言编程指南》\nrm(list = ls())\nqs = function(x,range){\n  range = substitute(range)\n  selector = eval(range,list(. = length(x)), parent.frame())\n  # parent.frame()指的是eval()的调用环境，也就是qs()的执行环境。\n  return( x[selector])\n}\n\n# trim_margin删除向量x的前n个元素和后n个元素，保留中间的元素\ntrim_margin = function(x,n){\n  qs(x,(n+1):(.-n-1))\n}\nx= 1:10\ntrim_margin(x,3)\n#> [1] 4 5 6\n```\n:::\n\n\n### 2 .3 .表达式与字符串相互转变 \n\n- `deparse()`: 将表达式转变为字符串.\n- `parse()`: 将字符串转变成表达式.由于parse的主要用途是将代码文件解析到硬盘，所以第一个参数是文件路径。注意如果代码是字符向量，那么需要使用text参数。\n\n```\nparse(file = \"\", n = NULL, text = NULL, prompt = \"?\",\n      keep.source = getOption(\"keep.source\"), srcfile,\n      encoding = \"unknown\")\n      \ndeparse(expr, width.cutoff = 60L,\n        backtick = mode(expr) %in% c(\"call\", \"expression\", \"(\", \"function\"),\n        control = c(\"keepNA\", \"keepInteger\", \"niceNames\", \"showAttributes\"),\n        nlines = -1L)\n```\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list = ls())\n\nz <- quote(y <- x*10) # 表达式里面用 <- ,等号为出错\ndeparse(z)\n#> [1] \"y <- x * 10\"\n\nparse(text = deparse(z))\n#> expression(y <- x * 10)\n\n## 把代码写入一个文件中\n# cat(\"x <- c(1, 4)\\n  x ^ 3 -10 ; outer(1:7, 5:9)\\n\", file = 'aa.txt')\n# parse(file = 'a.txt', n = 3)# 把文件中的代码转变为表达式\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n#> R version 4.2.1 (2022-06-23)\n#> Platform: aarch64-apple-darwin20 (64-bit)\n#> Running under: macOS Monterey 12.5.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n#> \n#> locale:\n#> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] Rcpp_1.0.9        codetools_0.2-18  digest_0.6.29     jsonlite_1.8.0   \n#>  [5] magrittr_2.0.3    evaluate_0.16     rlang_1.0.4       stringi_1.7.8    \n#>  [9] cli_3.3.0         pryr_0.1.5        rstudioapi_0.14   rmarkdown_2.16.1 \n#> [13] tools_4.2.1       stringr_1.4.1     htmlwidgets_1.5.4 xfun_0.32        \n#> [17] yaml_2.3.5        fastmap_1.1.0     compiler_4.2.1    htmltools_0.5.3  \n#> [21] knitr_1.40\n```\n:::\n\n\n## 参考\n\n《高级R语言编程》\n\n《R语言编程指南》\n\n《R语言核心编程技巧第二版》\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}