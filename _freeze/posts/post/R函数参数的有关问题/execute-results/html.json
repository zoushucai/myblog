{
  "hash": "12f4e0fc3bf7b1cc89c293302802800c",
  "result": {
    "markdown": "---\ntitle: R函数参数的有关问题\ndate: '2019-05-01'\ncategories: r\n---\n\n\n\n\n\n###  1. args 可以用来查看某个函数包含了哪些参数\n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs(sin)\n#> function (x) \n#> NULL\nargs(lm)\n#> function (formula, data, subset, weights, na.action, method = \"qr\", \n#>     model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, \n#>     contrasts = NULL, offset, ...) \n#> NULL\nargs(paste)\n#> function (..., sep = \" \", collapse = NULL, recycle0 = FALSE) \n#> NULL\n```\n:::\n\n\n### 2. 匹配参数--- match.arg()\n\n我们经常看见函数中有多个可选的字符串，用来做不同的模型，比如：这里的例子没有意义，但是做法值得注意。\n\n方法一：\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## 方法一：\ncenter <- function(x, type = c(\"mean\", \"median\", \"trimmed\")) {\n  type <- match.arg(type)\n  switch(type,\n         mean = mean(x),\n         median = median(x),\n         trimmed = mean(x, trim = .1))\n}\ncenter(c(1:4,100),\"mean\") # 返回向量的均值\n#> [1] 22\ncenter(c(1:4,100),\"median\") # 返回向量的中位数\n#> [1] 3\ncenter(c(1:4,100)) # 默认为第一个候选值，\n#> [1] 22\n```\n:::\n\n\n方法二：\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## 方法二：\ncenter <- function(x, type) {\n  type <- match.arg(type,choices = c(\"mean\", \"median\", \"trimmed\"))\n  switch(type,\n         mean = mean(x),\n         median = median(x),\n         trimmed = mean(x, trim = .1))\n}\ncenter(c(1:4,100),\"mean\") # 返回向量的均值\n#> [1] 22\ncenter(c(1:4,100),\"median\") # 返回向量的中位数\n#> [1] 3\ntry( center(c(1:4,100)) )# 这里由于没有默认值会报错\n#> Error in match.arg(type, choices = c(\"mean\", \"median\", \"trimmed\")) : \n#>   argument \"type\" is missing, with no default\n```\n:::\n\n\n**match.arg()**函数的功能是，根据输入来进行匹配, 比如，上面的式子，我们输入的type是\"mean\"，然后经过**match.arg()**以后通过**switch**可以直接调用该**mean**函数。\n\n还可以这样操作，（方法三）\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 检查一个参数在函数内部是否已被初始化。\n# 对参数进行默认值处理，当然为了更方面也可以直接在函数参数处直接赋予默认值\nh = function(x,y){\n  args = as.list(match.call())\n  if(is.null(args$y)){\n    y = 10\n  }\n  x+y\n}\nh(2)\n#> [1] 12\nh(2,19)\n#> [1] 21\n```\n:::\n\n\n 类似的还有 **match.call()** 和**match.fun()**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# match.call()创建一个只使用命名参数的调用， 常用于某些指定参数的更新\n# sys.call() 准确地捕获用户的输入。\n\nf <- function(abc = 1, def = 2, ghi = 3){\n  list(s = sys.call(),m = match.call())\n}\nf(d =2,2)\n#> $s\n#> f(d = 2, 2)\n#> \n#> $m\n#> f(abc = 2, def = 2)\n```\n:::\n\n\n**match.fun()** 类似下面介绍的**get()函数**, 都可以把字符串变成我们想要调用的对象。\n\n### 3. 以字符串作为函数名 — get函数\n\n巧妙的利用get函数，把字符串变成我们想要调用的函数，因为get函数输入一个字符串，返回一个函数对象\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# eg： 前面的函数---可以进行对比\ncenter <- function(x, type = c(\"mean\", \"median\", \"trimmed\")) {\n  type <- match.arg(type)\n  f = get(type)\n  f(x)\n}\ncenter(c(1:4,100),\"mean\")\n#> [1] 22\ncenter(c(1:4,100),\"median\")\n#> [1] 3\ncenter(c(1:4,100))\n#> [1] 22\n\n\n\n# eg： 用match.fun  来替代get()\ncenter2 <- function(x, type = c(\"mean\", \"median\", \"trimmed\")) {\n  type <- match.arg(type)\n  f = match.fun(type)\n  f(x)\n}\ncenter2(c(1:4,100),\"mean\")\n#> [1] 22\ncenter2(c(1:4,100),\"median\")\n#> [1] 3\ncenter2(c(1:4,100))\n#> [1] 22\n```\n:::\n\n\n两者的区别是get还可以返回某个对象，比如数据框、向量等，而match.fun 只能返回函数类型\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv = 1:10\n# match.fun('v') # 这里会报错\nget('v')\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n\n\nouter <- 1:5\ntry(match.fun(outer, descend = FALSE)) #-> Error:  not a function\n#> function (X, Y, FUN = \"*\", ...) \n#> {\n#>     if (is.array(X)) {\n#>         dX <- dim(X)\n#>         nx <- dimnames(X)\n#>         no.nx <- is.null(nx)\n#>     }\n#>     else {\n#>         dX <- length(X)\n#>         no.nx <- is.null(names(X))\n#>         if (!no.nx) \n#>             nx <- list(names(X))\n#>     }\n#>     if (is.array(Y)) {\n#>         dY <- dim(Y)\n#>         ny <- dimnames(Y)\n#>         no.ny <- is.null(ny)\n#>     }\n#>     else {\n#>         dY <- length(Y)\n#>         no.ny <- is.null(names(Y))\n#>         if (!no.ny) \n#>             ny <- list(names(Y))\n#>     }\n#>     robj <- if (is.character(FUN) && FUN == \"*\") {\n#>         if (!missing(...)) \n#>             stop(\"using ... with FUN = \\\"*\\\" is an error\")\n#>         tcrossprod(as.vector(X), as.vector(Y))\n#>     }\n#>     else {\n#>         FUN <- match.fun(FUN)\n#>         Y <- rep(Y, rep.int(length(X), length(Y)))\n#>         if (length(X)) \n#>             X <- rep(X, times = ceiling(length(Y)/length(X)))\n#>         FUN(X, Y, ...)\n#>     }\n#>     dim(robj) <- c(dX, dY)\n#>     if (!(no.nx && no.ny)) {\n#>         if (no.nx) \n#>             nx <- vector(\"list\", length(dX))\n#>         else if (no.ny) \n#>             ny <- vector(\"list\", length(dY))\n#>         dimnames(robj) <- c(nx, ny)\n#>     }\n#>     robj\n#> }\n#> <bytecode: 0x122e9df78>\n#> <environment: namespace:base>\nmatch.fun(outer) # finds it anyway，由于outer是R内部的函数，只不过现在被覆盖了，但是还是能找到\n#> function (X, Y, FUN = \"*\", ...) \n#> {\n#>     if (is.array(X)) {\n#>         dX <- dim(X)\n#>         nx <- dimnames(X)\n#>         no.nx <- is.null(nx)\n#>     }\n#>     else {\n#>         dX <- length(X)\n#>         no.nx <- is.null(names(X))\n#>         if (!no.nx) \n#>             nx <- list(names(X))\n#>     }\n#>     if (is.array(Y)) {\n#>         dY <- dim(Y)\n#>         ny <- dimnames(Y)\n#>         no.ny <- is.null(ny)\n#>     }\n#>     else {\n#>         dY <- length(Y)\n#>         no.ny <- is.null(names(Y))\n#>         if (!no.ny) \n#>             ny <- list(names(Y))\n#>     }\n#>     robj <- if (is.character(FUN) && FUN == \"*\") {\n#>         if (!missing(...)) \n#>             stop(\"using ... with FUN = \\\"*\\\" is an error\")\n#>         tcrossprod(as.vector(X), as.vector(Y))\n#>     }\n#>     else {\n#>         FUN <- match.fun(FUN)\n#>         Y <- rep(Y, rep.int(length(X), length(Y)))\n#>         if (length(X)) \n#>             X <- rep(X, times = ceiling(length(Y)/length(X)))\n#>         FUN(X, Y, ...)\n#>     }\n#>     dim(robj) <- c(dX, dY)\n#>     if (!(no.nx && no.ny)) {\n#>         if (no.nx) \n#>             nx <- vector(\"list\", length(dX))\n#>         else if (no.ny) \n#>             ny <- vector(\"list\", length(dY))\n#>         dimnames(robj) <- c(nx, ny)\n#>     }\n#>     robj\n#> }\n#> <bytecode: 0x122e9df78>\n#> <environment: namespace:base>\nmatch.fun(\"outer\")\n#> function (X, Y, FUN = \"*\", ...) \n#> {\n#>     if (is.array(X)) {\n#>         dX <- dim(X)\n#>         nx <- dimnames(X)\n#>         no.nx <- is.null(nx)\n#>     }\n#>     else {\n#>         dX <- length(X)\n#>         no.nx <- is.null(names(X))\n#>         if (!no.nx) \n#>             nx <- list(names(X))\n#>     }\n#>     if (is.array(Y)) {\n#>         dY <- dim(Y)\n#>         ny <- dimnames(Y)\n#>         no.ny <- is.null(ny)\n#>     }\n#>     else {\n#>         dY <- length(Y)\n#>         no.ny <- is.null(names(Y))\n#>         if (!no.ny) \n#>             ny <- list(names(Y))\n#>     }\n#>     robj <- if (is.character(FUN) && FUN == \"*\") {\n#>         if (!missing(...)) \n#>             stop(\"using ... with FUN = \\\"*\\\" is an error\")\n#>         tcrossprod(as.vector(X), as.vector(Y))\n#>     }\n#>     else {\n#>         FUN <- match.fun(FUN)\n#>         Y <- rep(Y, rep.int(length(X), length(Y)))\n#>         if (length(X)) \n#>             X <- rep(X, times = ceiling(length(Y)/length(X)))\n#>         FUN(X, Y, ...)\n#>     }\n#>     dim(robj) <- c(dX, dY)\n#>     if (!(no.nx && no.ny)) {\n#>         if (no.nx) \n#>             nx <- vector(\"list\", length(dX))\n#>         else if (no.ny) \n#>             ny <- vector(\"list\", length(dY))\n#>         dimnames(robj) <- c(nx, ny)\n#>     }\n#>     robj\n#> }\n#> <bytecode: 0x122e9df78>\n#> <environment: namespace:base>\n```\n:::\n\n\n\n\n### 4. 以字符串作为函数名 — call()函数\n\ncall函数，可以直接通过字符串的形式调用某个函数(只要环境空间中存在)，\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget(\"rnorm\")(5,mean = 300)\n#> [1] 299.7240 300.7482 302.8964 299.5659 300.5361\n\neval( call('rnorm',5,mean=300) ) # 执行函数调用，本质上call是创建一个函数调用，最后通过eval进行执行\n#> [1] 299.8097 300.0864 298.5465 299.4390 298.9760\n\ncall_1 = quote(rnorm(5,mean = 3))\ncall_2 = call(\"rnorm\",5,mean = 3)\ncall_3 = as.call( list(quote(rnorm),5,mean = 3) )\n# 这里call_1,call_2,call_3 完全等价，是一个表达式。需要进一步执行表达式需要利用eval来执行。\n```\n:::\n\n\n\n\n### 5. 把函数参数(不带字符串参数)转变为字符串\n\ndeparse(substitute(函数参数)) \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnicePlot = function(X,Y,...){\n  xlabel = deparse(substitute(X)) # 捕获X的输入\n  ylabel = deparse(substitute(Y)) # 捕获Y的输入\n  \n  plot(X,Y,type ='o',xlab = xlabel,ylab = ylabel,main = paste(xlabel,ylabel,sep = '--'), ...)\n}\n\nDate = 1:7\nSales = c(100,120,150,130,160,210,120)\nnicePlot(Date,Sales,col='red')\n```\n\n::: {.cell-output-display}\n![](R函数参数的有关问题_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n#> R version 4.2.1 (2022-06-23)\n#> Platform: aarch64-apple-darwin20 (64-bit)\n#> Running under: macOS Monterey 12.5.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n#> \n#> locale:\n#> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] digest_0.6.29     jsonlite_1.8.0    magrittr_2.0.3    evaluate_0.16    \n#>  [5] rlang_1.0.4       stringi_1.7.8     cli_3.3.0         rstudioapi_0.14  \n#>  [9] rmarkdown_2.16.1  tools_4.2.1       stringr_1.4.1     htmlwidgets_1.5.4\n#> [13] xfun_0.32         yaml_2.3.5        fastmap_1.1.0     compiler_4.2.1   \n#> [17] htmltools_0.5.3   knitr_1.40\n```\n:::\n",
    "supporting": [
      "R函数参数的有关问题_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}