{
  "hash": "7dfd6776992083fc0e4d8a5e82797dff",
  "result": {
    "markdown": "---\ntitle: R计算微积分\ndate: '2018-02-10'\nslug: test-toc\nsimpletoc: true\ncategories:\n  - r\n  - 符号计算\n  - 微积分\n---\n\n\n\n\n\n### 1.1差分\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx=1:12\ndiff(x)  #向量差分  后面一个数减去前面一个数\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 1 1 1 1 1 1 1 1 1 1\n```\n:::\n\n```{.r .cell-code}\nz=matrix(x,3,4)\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n```\n:::\n\n```{.r .cell-code}\ndiff(z) #矩阵差分 前行减去后行\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    1    1    1\n[2,]    1    1    1    1\n```\n:::\n:::\n\n\n### 1.2 符号计算--微分\n\n##### 1.2.1求一元函数导数--- \t\t$\\sin{x}$  的一阶导数为： $\\cos{x}$\n\n 在R里，声明表达式对象使用 expression() 函数, 计算一阶导数用D()函数,格式：D(表达式,对谁求导)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfun=expression(sin(x))# 声明表达式\nD(fun,\"x\")#---方法1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncos(x)\n```\n:::\n\n```{.r .cell-code}\nderiv(fun,\"x\")#---方法2  其中.grad[, \"x\"]为求x的导数表达式\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nexpression({\n    .value <- sin(x)\n    .grad <- array(0, c(length(.value), 1L), list(NULL, c(\"x\")))\n    .grad[, \"x\"] <- cos(x)\n    attr(.value, \"gradient\") <- .grad\n    .value\n})\n```\n:::\n\n```{.r .cell-code}\nderiv3(fun,\"x\")#---方法3 其中.grad[, \"x\"]为求x的导数表达式\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nexpression({\n    .expr1 <- sin(x)\n    .value <- .expr1\n    .grad <- array(0, c(length(.value), 1L), list(NULL, c(\"x\")))\n    .hessian <- array(0, c(length(.value), 1L, 1L), list(NULL, \n        c(\"x\"), c(\"x\")))\n    .grad[, \"x\"] <- cos(x)\n    .hessian[, \"x\", \"x\"] <- -.expr1\n    attr(.value, \"gradient\") <- .grad\n    attr(.value, \"hessian\") <- .hessian\n    .value\n})\n```\n:::\n:::\n\n\n##### 1.2.2 计算n阶导数\n\n1. 计算n阶导数---方法一:\t结合一阶导数写递归函数\n\n   函数： $\\sin{x}+\\cos{2x}+x^2+xy+y^2+2x^3+y^3$  的3阶导数为：$12 + 8\\sin{2x} -\\cos{x}$\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   fun=expression(sin(x)+cos(2*x)+x^2+x*y+y^2+2*x^3+y^3)\n   DD <- function(expr, name, order = 1) {\n     if (order < 1)\n       stop(\"'order' must be >= 1\")\n     if (order == 1){\n       D(expr, name)\n     }else{\n       DD(D(expr, name), name, order - 1)\n     }\n   }\n   DD(fun,\"x\",3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2 * (3 * 2) - (cos(x) - sin(2 * x) * 2 * 2 * 2)\n```\n:::\n:::\n\n\n2. 计算n阶导数---方法二:\tDeriv 包中Simplify()化简表达式\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   library(Deriv)\n   DD(fun,\"x\",3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2 * (3 * 2) - (cos(x) - sin(2 * x) * 2 * 2 * 2)\n```\n:::\n\n```{.r .cell-code}\n   Simplify(DD(fun, \"x\", 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n12 + 8 * sin(2 * x) - cos(x)\n```\n:::\n:::\n\n\n##### 1.2.3 通过函数计算导数\n\n有时候我们有的就是函数，这怎么计算导数呢？---还是用上面的函数\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf=function(x,y)sin(x)+cos(2*x)+x^2+x*y+y^2+2*x^3+y^3 #这里是函数，而不是表达式\nbody(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsin(x) + cos(2 * x) + x^2 + x * y + y^2 + 2 * x^3 + y^3\n```\n:::\n\n```{.r .cell-code}\nSimplify(D(body(f), \"x\"))# 注意：函数体有花括号{}会出错\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncos(x) + x * (2 + 6 * x) + y - 2 * sin(2 * x)\n```\n:::\n:::\n\n\n##### 1.2.4 求二元函数偏导数及梯度 \n\n\n::: {.cell}\n\n```{.r .cell-code}\nD(expression(x^2+x*y+y^2),\"x\")# x偏导数\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2 * x + y\n```\n:::\n\n```{.r .cell-code}\nD(expression(x^2+x*y+y^2),\"y\")# y偏导数\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx + 2 * y\n```\n:::\n:::\n\n\n##### 1.2.5 符号计算扩展包 Ryacas\n\n想要做更多的符号计算内容，如解方程，泰勒展开等，可以借助第三方 R 扩展包 Ryacas \n\n解方程: $\\frac{x}{1+x}=a$   求解$x=\\frac{a}{1-a}$  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Ryacas)\nysym(\"Solve(x/(1+x) == a, x)\") \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{x==a/(1-a)} \n```\n:::\n:::\n\n\n多项式展开：如$(1+x)^3$ 展开\n\n\n::: {.cell}\n\n```{.r .cell-code}\nysym(expression(Expand((1 + x)^3)))# 把(1+x)^3展开\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ny: x^3+3*x^2+3*x+1\n```\n:::\n:::\n\n\n求解常微分方程：$y''=4y$ \n\n\n::: {.cell}\n\n```{.r .cell-code}\nysym(\"OdeSolve(y''== 4 * y)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ny: C105*Exp(2*x)+C109*Exp((-2)*x)\n```\n:::\n:::\n\n\n泰勒展开：$\\cos{x}=1-\\frac{1}{2!}x^2+\\frac{1}{4!}x^4+o(x^4)$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nysym(\"Taylor(x, a, 3) cos(x)\") # cos(x)函数在a点的3阶泰勒展开\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ny: cos(a)+(Deriv(a)cos(a))*(x-a)+((x-a)^2*(Deriv(a)Deriv(a)cos(a)))/2+((x-a)^3*(Deriv(a)Deriv(a)Deriv(a)cos(a)))/6\n```\n:::\n:::\n\n\n##### 1.3 表达式转为函数值\n\n很多时候我们使用 R 目的是计算，符号计算后希望可以直接代入计算，那么只需要在 deriv 中指定 function.arg 参数为 TRUE。\n$$\n\\sin{x}+\\cos{2x}+x^2+xy+y^2对x求偏导为：\\cos{x}-2sin{2x}+2x+y\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfun=expression(sin(x)+cos(2*x)+x^2+x*y+y^2)\ndx=D(fun,\"x\") #用D()函数得到符号运算结果，然后代入数值即可得到最后结果\ndx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncos(x) - sin(2 * x) * 2 + 2 * x + y\n```\n:::\n\n```{.r .cell-code}\nx=0;y=pi# 对x、y赋值\neval(dx)#求出数值解\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4.141593\n```\n:::\n\n```{.r .cell-code}\nDfun=deriv(fun,c(\"x\",\"y\"),function.arg = TRUE)# 同时对x、y求偏导--D()函数不可以同时求偏导\nDfun(x=0,y=pi/2) # 代值计算，其中attr(,\"gradient\")的值为导数值 ，另一个为原函数在该处的函数值\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.467401\nattr(,\"gradient\")\n            x        y\n[1,] 2.570796 3.141593\n```\n:::\n\n```{.r .cell-code}\n#我们可以作如下简单验证：\nfun=function(x,y){sin(x)+cos(2*x)+x^2+x*y+y^2}\nfun(x=0,y=pi/2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.467401\n```\n:::\n:::\n\n\n### 1.3、求积分---暂时只找到数值计算的--没找到符号计算的\n\n积分函数： `integrate(fun,a,b)`  fun被积函数，不需要表达式，因为这是数值计算, a,b为上下限\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function (x) sin(x)\nintegrate(f,0,pi/2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 with absolute error < 1.1e-14\n```\n:::\n:::\n\n\n有些时候只想要值输入\t` integrate(f,0,1)$value`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nintegrate(f,0,pi/2)$value\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.5.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] Ryacas_1.1.3.1 Deriv_4.1.3   \n\nloaded via a namespace (and not attached):\n [1] Rcpp_1.0.9        digest_0.6.29     jsonlite_1.8.0    magrittr_2.0.3   \n [5] evaluate_0.16     rlang_1.0.4       stringi_1.7.8     cli_3.3.0        \n [9] rstudioapi_0.14   rmarkdown_2.16.1  tools_4.2.1       stringr_1.4.1    \n[13] htmlwidgets_1.5.4 pkgload_1.3.0     xfun_0.32         yaml_2.3.5       \n[17] fastmap_1.1.0     compiler_4.2.1    htmltools_0.5.3   knitr_1.40       \n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}