{
  "hash": "c3601dbfd922654d74a4b55e7076c068",
  "result": {
    "markdown": "---\ntitle: R语言标准化数据处理\ndate: '2017-11-13'\ncategories: r\n---\n\n\n\n\n##　1、标准化——数据处理\n\n```R\npreProcess(x, method = c(\"center\", \"scale\"),  \n  　　　　　thresh = 0.95, 　pcaComp = NULL, 　na.remove = TRUE, 　k = 5,  \n  　　　　　knnSummary = mean, 　outcome = NULL, 　fudge = 0.2, 　numUnique = 3,  \n  　　　　　verbose = FALSE, 　freqCut = 95/5,　 uniqueCut = 10, 　cutoff = 0.9, ...)   predict(object, newdata, ...)  \n  　　　　　\n# 解释\n1. x: 为一个矩阵或数据框，对于非数值型变量将被忽略　　\n\n2. method: 指定数据标准化的方法，默认为\"center\"和\"scale\"。（必须同时使用这两个，若选一个只能对应中心化或均值化）  \n   - 其中center表示预测变量值减去均值；scale表示预测变量值除以标准差，故默认标准化方法就是$(x-mu)/std$。   \n   - 如果使用range方法，则数据标准为[0,1]的范围，即$(x-min)/(max-min)$。  \n```\n\n\n\n\n```R\nppMethods <- c(\"BoxCox\", \"YeoJohnson\", \"expoTrans\", \"invHyperbolicSine\",\n               \"center\", \"scale\", \"range\", \n               \"knnImpute\", \"bagImpute\", \"medianImpute\", \n               \"pca\", \"ica\", \n               \"spatialSign\", \n               \"ignore\", \"keep\", \n               \"remove\", \n               \"zv\", \"nzv\", \"conditionalX\",\n               \"corr\")\n```\n- **thresh:**如果使用主成分分析（PCA)方法，该参数指定累计方差至少达到0.95  \n\n- **pcaComp:**如果使用主成分分析（PCA)方法，该参数可指定保留的主成分个数，该参数的优先级高于thresh  \n\n- **na.remove:**默认剔除缺失值数据  \n\n- **k:**如果使用k-近邻方法填补缺失值的话，可以指定具体的k值，默认为5  \n\n- **knnSummary:**使用k个近邻的均值替代缺失值  \n\n- **outcome:**指定数据集的输出变量，当使用BOX-COX变换数据时，该参数需要指定输出变量  \n\n- **fudge:**指定BOX-COX变换的lambda值波动范围  \n\n- **numUnique:**指定多少个唯一值需要因变量y估计BOX-COX转换  \n\n- **verbose:**指定是否需要输出详细的结果  \n\n- **object:**为preProcess对象  \n\n- **newdata:**指定需要处理的新数据集  \n\n\n\n## 2. iris实例 ———— scale（均值方差标准化）\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(caret)\nlibrary(dplyr)\nhead(scale(iris[,1:4]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Sepal.Length Sepal.Width Petal.Length Petal.Width\n[1,]   -0.8976739  1.01560199    -1.335752   -1.311052\n[2,]   -1.1392005 -0.13153881    -1.335752   -1.311052\n[3,]   -1.3807271  0.32731751    -1.392399   -1.311052\n[4,]   -1.5014904  0.09788935    -1.279104   -1.311052\n[5,]   -1.0184372  1.24503015    -1.335752   -1.311052\n[6,]   -0.5353840  1.93331463    -1.165809   -1.048667\n```\n:::\n\n```{.r .cell-code}\nstand_scale <- preProcess(iris)  #采用(x-mu)/std的标准化方法，与scale()函数效果一样\nhead(predict(stand_scale ,iris[,1:4]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width\n1   -0.8976739  1.01560199    -1.335752   -1.311052\n2   -1.1392005 -0.13153881    -1.335752   -1.311052\n3   -1.3807271  0.32731751    -1.392399   -1.311052\n4   -1.5014904  0.09788935    -1.279104   -1.311052\n5   -1.0184372  1.24503015    -1.335752   -1.311052\n6   -0.5353840  1.93331463    -1.165809   -1.048667\n```\n:::\n\n```{.r .cell-code}\nall(scale(iris[,1:4])==predict(stand_scale ,iris[,1:4])) #中间存在误差，但是大多数以及相等了\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n## 3. iris实例————max-min(标准化)\n\n::: {.cell}\n\n```{.r .cell-code}\nnormalize <- function(x) {\n  return ((x - min(x)) / (max(x) - min(x)))\n}\niris_max=as.data.frame(lapply(iris[1:4],normalize))\nhead(iris_max)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width\n1   0.22222222   0.6250000   0.06779661  0.04166667\n2   0.16666667   0.4166667   0.06779661  0.04166667\n3   0.11111111   0.5000000   0.05084746  0.04166667\n4   0.08333333   0.4583333   0.08474576  0.04166667\n5   0.19444444   0.6666667   0.06779661  0.04166667\n6   0.30555556   0.7916667   0.11864407  0.12500000\n```\n:::\n\n```{.r .cell-code}\nstand_range <- preProcess(iris[1:4],method = \"range\")\niris_max_prePro=predict(stand_range ,iris[1:4])\nhead(iris_max_prePro)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width\n1   0.22222222   0.6250000   0.06779661  0.04166667\n2   0.16666667   0.4166667   0.06779661  0.04166667\n3   0.11111111   0.5000000   0.05084746  0.04166667\n4   0.08333333   0.4583333   0.08474576  0.04166667\n5   0.19444444   0.6666667   0.06779661  0.04166667\n6   0.30555556   0.7916667   0.11864407  0.12500000\n```\n:::\n\n```{.r .cell-code}\nall(iris_max==iris_max_prePro)# 正常，和我们预期的一样，两个数据相等\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n## 4. 还原标准化数据-----salce(均值-方差标准化)   \n\n比如: 我们经常对train数据进行标准化，并且用train数据的参数去标准化test数据,R中没有内置的函数。   \n还有：有些模型和数据 存在量纲差异，需要标准化后建模，并预测，预测出来的值是标准化后的数据，此时需要把预测的数据还原成真实数据，此时就需要原始数据的标准化参数了   \n\n::: {.cell}\n\n```{.r .cell-code}\nstand_scale <- preProcess(iris)  #采用(x-mu)/std的标准化方法，与scale()函数效果一样\niris_scale=predict(stand_scale,iris[,1:4])\n\n\niris_new <- t(apply(iris_scale,1,function(x){x*stand_scale$std+stand_scale$mean}))\niris_new %>% head(.,10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Sepal.Length Sepal.Width Petal.Length Petal.Width\n [1,]          5.1         3.5          1.4         0.2\n [2,]          4.9         3.0          1.4         0.2\n [3,]          4.7         3.2          1.3         0.2\n [4,]          4.6         3.1          1.5         0.2\n [5,]          5.0         3.6          1.4         0.2\n [6,]          5.4         3.9          1.7         0.4\n [7,]          4.6         3.4          1.4         0.3\n [8,]          5.0         3.4          1.5         0.2\n [9,]          4.4         2.9          1.4         0.2\n[10,]          4.9         3.1          1.5         0.1\n```\n:::\n\n```{.r .cell-code}\nhead(iris,10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1           5.1         3.5          1.4         0.2  setosa\n2           4.9         3.0          1.4         0.2  setosa\n3           4.7         3.2          1.3         0.2  setosa\n4           4.6         3.1          1.5         0.2  setosa\n5           5.0         3.6          1.4         0.2  setosa\n6           5.4         3.9          1.7         0.4  setosa\n7           4.6         3.4          1.4         0.3  setosa\n8           5.0         3.4          1.5         0.2  setosa\n9           4.4         2.9          1.4         0.2  setosa\n10          4.9         3.1          1.5         0.1  setosa\n```\n:::\n:::\n\n\n\n## 5. 还原标准化数据-----max-min\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstand_range <- preProcess(iris[1:4],method = \"range\")\niris_max_prePro=predict(stand_range ,iris[1:4])\n\nt(apply(iris_max_prePro,1,function(x){x*(stand_range$ranges[2,]-stand_range$ranges[1,])+stand_range$ranges[1,] })) %>% head(.,10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Sepal.Length Sepal.Width Petal.Length Petal.Width\n [1,]          5.1         3.5          1.4         0.2\n [2,]          4.9         3.0          1.4         0.2\n [3,]          4.7         3.2          1.3         0.2\n [4,]          4.6         3.1          1.5         0.2\n [5,]          5.0         3.6          1.4         0.2\n [6,]          5.4         3.9          1.7         0.4\n [7,]          4.6         3.4          1.4         0.3\n [8,]          5.0         3.4          1.5         0.2\n [9,]          4.4         2.9          1.4         0.2\n[10,]          4.9         3.1          1.5         0.1\n```\n:::\n\n```{.r .cell-code}\nhead(iris,10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1           5.1         3.5          1.4         0.2  setosa\n2           4.9         3.0          1.4         0.2  setosa\n3           4.7         3.2          1.3         0.2  setosa\n4           4.6         3.1          1.5         0.2  setosa\n5           5.0         3.6          1.4         0.2  setosa\n6           5.4         3.9          1.7         0.4  setosa\n7           4.6         3.4          1.4         0.3  setosa\n8           5.0         3.4          1.5         0.2  setosa\n9           4.4         2.9          1.4         0.2  setosa\n10          4.9         3.1          1.5         0.1  setosa\n```\n:::\n:::\n\n\n## 6. 还原标准化数据---DMwR::unscale()函数\n\n```R\nunscale(vals, norm.data, col.ids)\n\n    vals\t: 要还原标准化的数值型矩阵，或者数值型数据框  \n    norm.data\t ： 以及标准化后的数据，必须是用scale()函数标准化后的数据  \n    col.ids\t： 那些列可以不用标准化（默认全部列都有进行)  \n```\n\n::: {.cell}\n\n```{.r .cell-code}\n############ 新版本的的R好像没有这个包了\n# 我把iris数据集分为7:3\nlibrary(caret)\nlibrary(dplyr)\nlibrary(DMwR)\nlibrary(e1071)\n\n\n\n#############################################################\n########## 标准化数据\n# \ndata(algae)\nalgae[,4:12] %>% head() # 可以发现数据存在量纲的差异，我们要预测a1（因变量） ,其他为自变量\nnormData <- scale(algae[,4:12]) # 把train数据进行标准化\nt <- svm(a1 ~ .,normData[1:100,] %>% as.data.frame() ) #决策树模型\nnormPs <- predict(t,as.data.frame(normData[101:nrow(normData),])) # 可以发现预测的数据不是最终的数据，需要进行标准化还原\nnormPs %>% head() # 预测值 ,预测数据,都在0--1范围\nalgae[101:nrow(normData),\"a1\"] %>% head()# 真实值\nunscale(normPs,normData) %>% head()#于是还原预测数据\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.5.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] dplyr_1.0.9     caret_6.0-93    lattice_0.20-45 ggplot2_3.3.6  \n\nloaded via a namespace (and not attached):\n [1] Rcpp_1.0.9           lubridate_1.8.0      listenv_0.8.0       \n [4] class_7.3-20         assertthat_0.2.1     digest_0.6.29       \n [7] ipred_0.9-13         foreach_1.5.2        utf8_1.2.2          \n[10] parallelly_1.32.1    R6_2.5.1             plyr_1.8.7          \n[13] stats4_4.2.1         hardhat_1.2.0        evaluate_0.16       \n[16] pillar_1.8.1         rlang_1.0.4          data.table_1.14.2   \n[19] rstudioapi_0.14      rpart_4.1.16         Matrix_1.4-1        \n[22] rmarkdown_2.16.1     splines_4.2.1        gower_1.0.0         \n[25] stringr_1.4.1        htmlwidgets_1.5.4    munsell_0.5.0       \n[28] compiler_4.2.1       xfun_0.32            pkgconfig_2.0.3     \n[31] globals_0.16.0       htmltools_0.5.3      nnet_7.3-17         \n[34] tidyselect_1.1.2     tibble_3.1.8         prodlim_2019.11.13  \n[37] codetools_0.2-18     fansi_1.0.3          future_1.27.0       \n[40] withr_2.5.0          ModelMetrics_1.2.2.2 MASS_7.3-58.1       \n[43] recipes_1.0.1        grid_4.2.1           nlme_3.1-159        \n[46] jsonlite_1.8.0       gtable_0.3.0         lifecycle_1.0.1     \n[49] DBI_1.1.3            magrittr_2.0.3       pROC_1.18.0         \n[52] scales_1.2.1         future.apply_1.9.0   cli_3.3.0           \n[55] stringi_1.7.8        reshape2_1.4.4       timeDate_4021.104   \n[58] generics_0.1.3       vctrs_0.4.1          lava_1.6.10         \n[61] iterators_1.0.14     tools_4.2.1          glue_1.6.2          \n[64] purrr_0.3.4          parallel_4.2.1       fastmap_1.1.0       \n[67] survival_3.4-0       yaml_2.3.5           colorspace_2.0-3    \n[70] knitr_1.40          \n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}