{
  "hash": "d899e144a5e908c064677b82e5cb00fd",
  "result": {
    "markdown": "---\ntitle: 4.1 基于可能度的多属性决策方法\ndate: '2019-02-26'\ncategories: uncertain\n---\n\n\n\n\n# 第四章--属性权重为实数且属性值为区间数的多属性决策方法及应用\n## 徐泽水《不确定多属性决策方法与应用》109页\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#####  第四章--属性权重为实数且属性值为区间数的多属性决策方法及应用\n## 4.1 基于可能度的多属性决策方法---徐泽水《不确定多属性决策方法与应用》109页 \n## 4.1.4 实例分析\n\n#####  第一步： 求出规范化矩阵\nA = c(0.214,0.220,0.166,0.178,0.184,0.190,\n      0.206,0.225,0.220,0.229,0.182,0.191,\n      0.195,0.204,0.192,0.198,0.220,0.231,\n      0.181,0.190,0.195,0.205,0.185,0.195,\n      0.175,0.184,0.193,0.201,0.201,0.211) \nR = matrix(A,nrow = 5,byrow = T) # R为规范化后的决策矩阵\nR # 矩阵R的奇数列代表属性的下界 ，偶数列代表属性的上界\n#>       [,1]  [,2]  [,3]  [,4]  [,5]  [,6]\n#> [1,] 0.214 0.220 0.166 0.178 0.184 0.190\n#> [2,] 0.206 0.225 0.220 0.229 0.182 0.191\n#> [3,] 0.195 0.204 0.192 0.198 0.220 0.231\n#> [4,] 0.181 0.190 0.195 0.205 0.185 0.195\n#> [5,] 0.175 0.184 0.193 0.201 0.201 0.211\n\n#####  第二步：通过规范化的决策矩阵和指定的权重（利用WAA算子）求出个方案的综合属性值\nzongheshuxin_z = function(R,w){\n  # zongheshuxin_z 函数，输入参数为规范化后的决策矩阵R，以及属性权重值w向量，\n  # 返回一个n*2的矩阵，代表输出各个方案的综合属性值得区间数，第一列为下界，第二列为上界，行代表个方案\n  stopifnot( length(w) == (ncol(R)/2) ) #检验输入的权重长度与决策矩阵的属性个数是否相等\n  col_L = seq(1, ncol(R)-1, by = 2) # 属性的下界\n  col_U = seq(2, ncol(R), by = 2)# 属性的上界  \n  z_L = apply(R[,col_L],1,function(x)sum(x*w))\n  z_U = apply(R[,col_U],1,function(x)sum(x*w))\n  z = matrix(c(z_L,z_U), ncol= 2 )\n  return(z)\n}\nw = c(0.4,0.4, 0.2) # 指定属性的权重\nZ = zongheshuxin_z(R,w) # 返回一个n*2的矩阵，每一行代表输出各个方案的综合属性值得区间数\n \n##### 第三步，利用区间数两两比较，得出可能度矩阵\nprobability_matrix = function(Z){\n  #probability_matrix函数输入一个n*2的矩阵，每一行代表输出各个方案的综合属性值得区间数\n  # 此函数输出各方案两两比较的可能度矩阵。\n  \n  #degree_probability函数求两个区间数的可能度，\n  # a，b代表输入的区间数，输入这两个 \n  degree_probability = function(a,b){\n    stopifnot(length(a) == length(b) ,length(b)==2)\n    stopifnot(a[1] <= a[2], b[1] <= b[2])\n    l_a = a[2] - a[1];l_b = b[2]- b[1];\n    p = min(l_a + l_b, max(a[2]-b[1],0) ) / (l_a + l_b)\n    return(p)\n  } \n  \n  P = matrix(0, ncol = nrow(Z),nrow = nrow(Z))\n  for (i in 1:nrow(Z)) {\n    for(j in 1:nrow(Z)){\n      P[i,j] = degree_probability(Z[i,],Z[j,])\n    }\n  }\n  return(P)\n}\nP = probability_matrix(Z)\n\n##### 第四步。根据可能度矩阵，利用4.6式求出可能度矩阵的排序向量,值越大越好\nprobability_matrix_oder_v = function(P){\n  v = rep(0,nrow(P))\n  n = nrow(P)\n  for(i in 1:nrow(P)){\n    v[i] =  ( 1 / (n*(n-1)) ) * ( sum(P[i,]) + n/2 -1)\n  }\n  return(v)\n}\n\nprobability_matrix_oder_v(P)\n#> [1] 0.1557106 0.2995283 0.2504717 0.1488647 0.1454247\nlibrary(magrittr)\nprobability_matrix_oder_v(P) %>% rank() %>% order(.,decreasing = T)\n#> [1] 2 3 1 4 5\n# 故方案2综合评估结果最好\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}