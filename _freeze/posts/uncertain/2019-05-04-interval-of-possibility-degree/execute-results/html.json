{
  "hash": "ca2abe867e633eaaf270954b6dbc1599",
  "result": {
    "markdown": "---\ntitle: 求区间可能度矩阵的算法(Liu 2009)\ndate: '2019-05-04'\ncategories: uncertain\n---\n\n\n\n\n# 求区间可能度矩阵的算法\n\n## 0. 参考论文:\n\n徐泽水： [A consistency improving method in the analytic hierarchy process](http://www.sciencedirect.com/science/article/pii/S037722179800109X) 1999年\n\n刘芳：[Acceptable consistency analysis of interval reciprocal comparison matrices](http://dl.acm.org/citation.cfm?id=1619182)  2009年\n\n\n\n## 1. 主要思路：\n\n1. 把区间乘性互反矩阵U拆成两个正互反判断矩阵B和D,B，D都是正的互反判断矩阵。其中B的下三角元素大于D矩阵的下三角元素，B的上三角小于D的上三角元素 ，简称B的下三角大，上三角小\n2. 一致性检验，若拆分后的B，D矩阵一致性不满足条件(即$CR<= 0.1$) ，则用徐泽水(1999年)的文章方法进行调整，直到满足一致性条件为准($CR <=0.1$).\n3.  然后分别计算矩阵$B，D$的权重向量$w(B),w(D)$ ,注意这里的权重没有归一化处理.\n4. 通过公式$w_i = [min(w_i(B),w_i(D)),max(w_i(B),w_i(D))]$,把两个权重向量组合成一个区间向量。\n5. 通过区间向量$w$计算出区间向量的可能度矩阵$P$。\n\n\n\n## 2.主要函数构建：\n\n0. `consistency(A):` 求正互反判断矩阵的一致性指标，返回一个list\n\n1. `em_get_w(A) :` 特征值求权重 ——  没有归一化权重\n2. `gm_get_w(A)：` 几何平均求权重 — — 没有归一化权重\n3. `get_w(B,D):` 分别获取B，D的权重（可以指定几何平均或者特征值求权重），然后组成区间权重向量（即小的在前，大的在后），这里返回的是一个矩阵，把每一个区间数看做矩阵的一行。\n4. `fenjie(U ):` 把区间矩阵U分解成正互反判断矩阵B和D\n5. `adjust_w(A,lambda) :` 利用论文的方法进行调整，返回调整后符合一致性条件的一致性矩阵。\n6. `degree_probability(a,b)` 函数计算两个区间数的可能度\n7. `probability_matrix(w)` 给一个n*2 的区间数，求其可能度矩阵\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nrm(list = ls())\n# 0。 一致性指标的求解\nconsistency = function(A){\n  lambda = Re(eigen(A)$values[1]) # 矩阵A的最大特征值\n  n  = nrow(A)\n  RI = c(0,0,0.58,0.90,1.12,1.24,1.32,1.41,1.45);\n  CI = (lambda-n) / (n-1);\n  CR = CI / RI[n];\n  eig_w = eigen(A)$vectors[,1] / sum( eigen(A)$vectors[,1]);\n  return(list(\"eig_value\"=lambda,\"CI\"=CI,\"RI\"=RI[n],\"CR\"=CR,'eig_w'=Re( eig_w )))\n}\n\n\n\n# 1. 特征值求权重\nem_get_w = function(A){\n  n = nrow(A)\n  stopifnot(nrow(A) ==  ncol(A))\n  \n  lambda = Re(eigen(A)$values[1]) # 矩阵A的最大特征值\n  n = nrow(A)\n  RI = c(0,0,0.58,0.90,1.12,1.24,1.32,1.41,1.45);\n  CI=(lambda-n)/(n-1);\n  CR=CI/RI[n];\n  eig_origin = eigen(A)$vectors[,1]\n  eig_w = eigen(A)$vectors[,1] # /sum(eigen(A)$vectors[,1]);\n  eig_w = Re(eig_w)\n  return(eig_w)\n}\n# 2. 几何平均求权重 -- \ngm_get_w =function(A){\n  n = nrow(A)\n  stopifnot(nrow(A) ==  ncol(A))\n  temp = apply(A, 1, function(x) prod(x)^(1/n) )\n  w = temp # /sum(temp) \n  return(w)\n}\n# 3. 合并权重\nget_w = function(B,D,method = c('gm_get_w','em_get_w') ){\n  n = nrow(B)\n  stopifnot(n == nrow(D))\n  method <- match.arg(method)\n  f = get(method)\n  w_B = f(B)\n  w_D = f(D)\n  w_L = rep(0,length(w_B))\n  w_U = rep(0,length(w_B))\n  for(i in 1:length(w_B)){\n    w_L[i] = min(w_B[i],w_D[i])\n    w_U[i] = max(w_B[i],w_D[i])\n  }\n  w = matrix(c(w_L,w_U), ncol= 2 )\n  return(w)\n}\n\n\n\n# 4. 通过U进行分解，分解出B，D矩阵，\nfenjie = function(U){\n  n = nrow(U)\n  stopifnot(ncol(U) == 2*n)\n  \n  B = matrix(0,nrow = n,ncol = n)\n  D = matrix(0,nrow = n,ncol = n)\n  \n  for(i in 1:n){\n    for(j in 1:n){\n      if(i<j){\n        B[i,j] = U[i,j*2]\n        D[i,j] = U[i,2*j-1]\n      }else if(i>j){\n        B[i,j] = U[i,2*j-1]\n        D[i,j] = U[i,j*2]\n      }else{\n        B[i,j] = U[i,2*j]\n        D[i,j] =U[i,2*j]\n      }\n    }\n  }\n  return(list('B'=B,'D'=D))\n}\n\n\n# 5. 徐泽水(1999年)的文章方法进行调整，直到满足一致性条件为准(CR <=0.1).\nadjust_w <- function(A, lambda) {\n  k <- 0\n  n = nrow(A)\n  m = ncol(A)\n  stopifnot(n == m)\n  temp_CR <- consistency(A)$CR\n  temp_w <- consistency(A)$eig_w\n  while (temp_CR >= 0.1 && k < 1000) {\n    for (i in 1:n) {\n      for (j in 1:n) {\n          A[i, j] <- (A[i, j]^lambda) * (temp_w[i] / temp_w[j])^(1 - lambda)\n      }\n    }\n    temp_CR <- consistency(A)$CR\n    temp_w <- consistency(A)$eig_w\n    k <- k + 1\n  }\n  return(A)\n}\n\n\n\n# 6. degree_probability 函数计算两个区间数的可能度\ndegree_probability <- function(a, b) {\n  # 输入的a,b代表一个区间，即是一个二维向量，且小的在前面，大的元素在后面\n  stopifnot(length(a) == length(b), length(a) == 2, a[1] <= a[2], b[1] <= b[2])\n  temp <- 0\n  if (a[1] == a[2] && b[1] == b[2]) {\n    if (a[1] > b[1]) {\n      temp <- 1\n    } else if (a[1] == b[1]) {\n      temp <- 0.5\n    } else {\n      temp <- 0\n    }\n  } else if (a[1] == a[2] && b[1] != b[2]) {\n    if (a[1] > b[2]) {\n      temp <- 1\n    } else if (b[1] <= a[1] & a[1] <= b[2]) {\n      temp <- (a[1] - b[1]) / (b[2] - b[1])\n    } else {\n      temp <- 0\n    }\n  } else if (a[1] != a[2] && b[1] == b[2]) {\n    if (a[1] > b[1]) {\n      temp <- 1\n    } else if (a[1] <= b[1] & b[1] <= a[2]) {\n      temp <- (a[2] - b[1]) / (a[2] - a[1])\n    } else {\n      temp <- 0\n    }\n  } else if (a[1] != a[2] && b[1] != b[2]) {\n    if (a[1] < a[2] && a[2] <= b[1] && b[1] < b[2]) {\n      temp <- 0\n    } else if (a[1] <= b[1] && b[1] < a[2] && a[2] <= b[2]) {\n      s_t <- (a[2] - b[1]) * (a[2] - b[1]) * 0.5\n      s <- (b[2] - b[1]) * (a[2] - a[1])\n      temp <- s_t / s\n    } else if (a[1] <= b[1] && b[1] <= b[2] && b[2] <= a[2]) {\n      s_t <- ((a[2] - b[2]) + (a[2] - b[1])) * (b[2] - b[1]) * 0.5\n      s <- (b[2] - b[1]) * (a[2] - a[1])\n      temp <- s_t / s\n    } else if (b[1] < a[1] && a[1] < a[2] && a[2] < b[2]) { \n      # 可写等号b[1] <= a[1] && a[1]<a[2] &&a[2]<=b[2]\n      s_t <- ((a[1] - b[1]) + (a[2] - b[1])) * (a[2] - a[1]) * 0.5\n      s <- (b[2] - b[1]) * (a[2] - a[1])\n      temp <- s_t / s\n    } else if (b[1] < a[1] && a[1] < b[2] && b[2] < a[2]) {\n      s_tt <- (b[2] - a[1]) * (b[2] - a[1]) * 0.5\n      s <- (b[2] - b[1]) * (a[2] - a[1])\n      s_t <- s - s_tt\n      temp <- s_t / s\n    } else if (b[1] < b[2] && b[2] <= a[1] && a[1] < a[2]) {\n      temp <- 1\n    } else {\n      stop(\"运行出错\")\n    }\n  } else {\n    stop(\"运行出错,请检查\")\n  }\n  return(temp)\n}\n\n# 7. probability_matrix 给一个n*2 的区间数，求其可能度矩阵\nprobability_matrix <- function(Z) {\n  # probability_matrix函数输入一个n*2的矩阵，每一行代表输出各个方案的综合属性值得区间数\n  # 此函数输出各方案两两比较的可能度矩阵。\n  # degree_probability函数求两个区间数的可能度，\n  # a，b代表输入的区间数，输入这两个\n  P <- matrix(0, ncol = nrow(Z), nrow = nrow(Z))\n  for (i in 1:nrow(Z)) {\n    for (j in 1:nrow(Z)) {\n      P[i, j] <- degree_probability(Z[i, ], Z[j, ])\n    }\n  }\n  return(P)\n}\n\n```\n:::\n\n\n总结: 只需给出一个区间判断矩阵，返回最终的权重(前提是B和D要满足一致性条件$CR<=0.1$)\n\n##  3. 测试\n\n### 3.1 例1： B 和D都满足一致性指标\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nU = matrix(c(1,1,2,5,2,4,1,3,\n             1/5,1/2,1,1,1,3,1,2,\n             1/4,1/2,1/3,1,1,1,1/2,1,\n             1/3,1,1/2,1,1,2,1,1),nrow = 4,byrow = T)\nfenjie(U) \n#> $B\n#>           [,1]      [,2] [,3] [,4]\n#> [1,] 1.0000000 5.0000000    4    3\n#> [2,] 0.2000000 1.0000000    3    2\n#> [3,] 0.2500000 0.3333333    1    1\n#> [4,] 0.3333333 0.5000000    1    1\n#> \n#> $D\n#>      [,1] [,2] [,3] [,4]\n#> [1,]  1.0    2    2  1.0\n#> [2,]  0.5    1    1  1.0\n#> [3,]  0.5    1    1  0.5\n#> [4,]  1.0    1    2  1.0\n\n## 一致性检验\nlibrary(purrr)\nfenjie(U) %>% map(function(x)consistency(x)$CR) # 求解矩阵B，D的一致性指标\n#> $B\n#> [1] 0.08209909\n#> \n#> $D\n#> [1] 0.02246186\n\n# 直接求出区间权重，以及根据权重求出区间可能度矩阵\n( w = get_w(B= fenjie(U)$B ,D = fenjie(U)$D) ) #每一行对应第i个方案的区间权重\n#>           [,1]      [,2]\n#> [1,] 1.4142136 2.7831577\n#> [2,] 0.8408964 1.0466351\n#> [3,] 0.5372850 0.7071068\n#> [4,] 0.6389431 1.1892071\n\n( P = probability_matrix(w) ) # 可能度矩阵P\n#>      [,1]      [,2]      [,3]       [,4]\n#> [1,]  0.5 1.0000000 1.0000000 1.00000000\n#> [2,]  0.0 0.5000000 1.0000000 0.55395713\n#> [3,]  0.0 0.0000000 0.5000000 0.02486059\n#> [4,]  0.0 0.4460429 0.9751394 0.50000000\n```\n:::\n\n\n\n\n\n\n### 3.2   例2： B 和D不满足一致性指标\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nU  = matrix(c(1,1,1,2,1,2,2,3,\n              1/2,1,1,1,3,5,4,5,\n              1/2,1,1/5,1/3,1,1,6,8,\n              1/3,1/2,1/5,1/4,1/8,1/6,1,1),nrow = 4,byrow = T)\nfenjie(U)\n#> $B\n#>           [,1] [,2]  [,3] [,4]\n#> [1,] 1.0000000  2.0 2.000    3\n#> [2,] 0.5000000  1.0 5.000    5\n#> [3,] 0.5000000  0.2 1.000    8\n#> [4,] 0.3333333  0.2 0.125    1\n#> \n#> $D\n#>      [,1]      [,2]      [,3] [,4]\n#> [1,]  1.0 1.0000000 1.0000000    2\n#> [2,]  1.0 1.0000000 3.0000000    4\n#> [3,]  1.0 0.3333333 1.0000000    6\n#> [4,]  0.5 0.2500000 0.1666667    1\nfenjie(U) %>% map(function(x)consistency(x)$CR) # 可以发现B和D的一致性不满足条件\n#> $B\n#> [1] 0.2752221\n#> \n#> $D\n#> [1] 0.1232627\n\n## 方法一： 进行调整\nadjust_w(fenjie(U)$B,lambda = 0.6) %>% round(4)\n#>        [,1]   [,2]   [,3]   [,4]\n#> [1,] 1.0000 1.4696 1.9339 3.9751\n#> [2,] 0.6805 1.0000 3.4564 5.5703\n#> [3,] 0.5171 0.2893 1.0000 5.6119\n#> [4,] 0.2516 0.1795 0.1782 1.0000\nadjust_w(fenjie(U)$D,lambda = 0.88) %>% round(4)\n#>        [,1]   [,2]   [,3]   [,4]\n#> [1,] 1.0000 0.9428 0.9943 2.1061\n#> [2,] 1.0607 1.0000 2.7732 4.1112\n#> [3,] 1.0057 0.3606 1.0000 5.5695\n#> [4,] 0.4748 0.2432 0.1795 1.0000\n\n## 方法二:进行调整 --  多参数映射\ntemp = fenjie(U) %>% map2(.,list(0.6,0.88),function(x,y)round( adjust_w(x,y),4) )\ntemp\n#> $B\n#>        [,1]   [,2]   [,3]   [,4]\n#> [1,] 1.0000 1.4696 1.9339 3.9751\n#> [2,] 0.6805 1.0000 3.4564 5.5703\n#> [3,] 0.5171 0.2893 1.0000 5.6119\n#> [4,] 0.2516 0.1795 0.1782 1.0000\n#> \n#> $D\n#>        [,1]   [,2]   [,3]   [,4]\n#> [1,] 1.0000 0.9428 0.9943 2.1061\n#> [2,] 1.0607 1.0000 2.7732 4.1112\n#> [3,] 1.0057 0.3606 1.0000 5.5695\n#> [4,] 0.4748 0.2432 0.1795 1.0000\ntemp %>% map(function(x)consistency(x)$CR)#检验权重情况\n#> $B\n#> [1] 0.09525181\n#> \n#> $D\n#> [1] 0.09474896\n\n\n# 求出调整后的B和D的权重\n( w = get_w(B= temp$B ,D = temp$D) ) #每一行对应第i个方案的区间权重\n#>           [,1]      [,2]\n#> [1,] 1.1853702 1.8333497\n#> [2,] 1.8648143 1.9025351\n#> [3,] 0.9572122 1.1921409\n#> [4,] 0.2995165 0.3794326\n( P = probability_matrix(w) ) # 可能度矩阵P\n#>              [,1] [,2]      [,3] [,4]\n#> [1,] 0.5000000000  0.0 0.9998494  1.0\n#> [2,] 1.0000000000  0.5 1.0000000  1.0\n#> [3,] 0.0001505719  0.0 0.5000000  1.0\n#> [4,] 0.0000000000  0.0 0.0000000  0.5\n```\n:::\n\n\n## 4. 总结:\n\n无论什么样的区间矩阵(一致性是否满足)，都可以用步骤\n\n```R \n# list(0.6,0.88)中的0.6和0.88 为调整adjust_w()函数参数中的lambda值对应\ntemp = fenjie(U) %>% map2(., list(0.6,0.88),function(x,y)round( adjust_w(x,y),4) )\nw = get_w(B= temp$B ,D = temp$D)#每一行对应第i个方案的区间权重\nw\n\nP = probability_matrix(w)\nP\n```\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}