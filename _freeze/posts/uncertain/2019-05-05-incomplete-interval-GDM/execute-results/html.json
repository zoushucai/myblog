{
  "hash": "6213889558a969dfe6d6a7340af7fa93",
  "result": {
    "markdown": "---\ntitle: 残缺区间群体决策模型（GDM Liu 2012)\ndate: '2019-05-05'\ncategories: uncertain\n---\n\n\n\n\n# 残缺区间群体决策模型（GDM）\n\n## 0. 参考论文:\n\n徐泽水： [A consistency improving method in the analytic hierarchy process](http://www.sciencedirect.com/science/article/pii/S037722179800109X) 1999年\n\n刘芳：[Acceptable consistency analysis of interval reciprocal comparison matrices](http://dl.acm.org/citation.cfm?id=1619182)  2009年\n\n刘芳： [A goal programming model for incomplete interval multiplicative preference relations and its application in group decision-making](http://www.sciencedirect.com/science/article/pii/S0377221711010514) 2012年\n\n## 1. 主要思路（刘芳2012年）：\n\n1. 先把残缺区间矩阵$U_k$通过某种方法(LOP2)或者利用粒子群算法)进行补全成$U_k^{’}$，\n2. 检查补全以后的矩阵$U_{k}^{'}$是否具有一致性($U_{k}^{'}$具有一致性  的充要条件 是 $U_{k}^{'}$ 分解成单个的正互反判断矩阵B 和D，矩阵B和D的CR <= 0.1)，不具有则调整（按照徐泽水1999年提出的论文进行调整)\n3. 若$U_{k}^{'}$具有一致性，则进行群体决策模型构建，生成最终的区间判断矩阵U\n4. 通过最终的区间判断矩阵U生成区间权重，注意生成区间权重并没有归一化权重，根据区间权重生成可能度矩阵P.\n\n\n\n## 2.主要函数构建：\n\n0. `consistency(A):` 求正互反判断矩阵的一致性指标，返回一个list\n\n1. `em_get_w(A) :` 特征值求权重 ——  没有归一化权重\n2. `gm_get_w(A)：` 几何平均求权重 — — 没有归一化权重\n3. `get_w(B,D):` 分别获取B，D的权重（可以指定几何平均或者特征值求权重），然后组成区间权重向量（即小的在前，大的在后），这里返回的是一个矩阵，把每一个区间数看做矩阵的一行。\n4. `fenjie(U ):` 把区间矩阵U分解成正互反判断矩阵B和D\n5. `adjust_w(A,lambda) :` 利用论文的方法进行调整，返回调整后符合一致性条件的一致性矩阵。\n6. `degree_probability(a,b)` 函数计算两个区间数的可能度\n7. `probability_matrix(w)` 给一个n*2 的区间数，求其可能度矩阵\n\n\n\n介绍几个函数----这几个函数都是利用粒子群算法把$U_{k}$变成$U_{k}^{'}$\n\n以下是补全区间的关键元素。\n\n8. `index_matrix():`此函数可以查找到区间正互反判断矩阵中那些元素是缺失的（缺失用0表示)，并生成一个矩阵，每一列都有其相关含义。\n\n9. `hecheng(B,D):`  对应fenjie的逆向操作，把两个正互反矩阵进行合并成一个区间判断矩阵。`  \n\n10.  `jianyan_yuesu(U): `检验输入的区间判断矩阵U是否满足要求，即有没有输入上的出错。\n\n11. `set_x(x,U):`函数把x向量赋值给U中缺失的元素\n\n12. `obj_fun(Ut): `求补全好的区间矩阵的目标函数值\n\n13. 随机初始化残缺元素\n\n\t1. `U_to_UU()` 函数是把区间矩阵U 重塑成(n * n ) 2形式的矩阵，以两列为单位，因为每两列是一个区间，第一列代表区间的下界，第二列代表区间的上界，故 形成2列矩阵，每一行代表一个区间数，\n\t2. `UU_to_U()`  函数是通过找出UU中的缺失元素，然后赋予缺失元素一个随机值（ 该随机值保证了在1/9 ~ 9之间，且保证了UU中的下界与上界的关系，若某行只缺失一个数据，也能得到相应的保证），并把赋予好的完整矩阵变成区间判断矩阵的形式。\n\t3. `U_runif()`是` U_to_UU()` 和`UU_to_U()` 函数的融合，先利用`U_to_UU()`变成我们需要的格式，然后利用`UU_to_U() `产生随机值进行填充最后返回我们随机填充好的区间判断矩阵\n\t4. `init_x()`    通过随机初始化U，找出解\n\n14. `GDM_PSO() `主要的函数，通过利用粒子群算法把$U_{k}$变成$U_{k}^{'}$\n\n15. `DGM_U()`群体决策，把若干个完整的区间判断矩阵合并成一个区间判断矩阵。\n\n\t\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list = ls())\n# 0。 一致性指标的求解\nconsistency = function(A){\n  lambda = Re(eigen(A)$values[1]) # 矩阵A的最大特征值\n  n  = nrow(A)\n  RI = c(0,0,0.58,0.90,1.12,1.24,1.32,1.41,1.45);\n  CI = (lambda-n) / (n-1);\n  CR = CI / RI[n];\n  eig_w = eigen(A)$vectors[,1] / sum( eigen(A)$vectors[,1]);\n  return(list(\"eig_value\"=lambda,\"CI\"=CI,\"RI\"=RI[n],\"CR\"=CR,'eig_w'=Re( eig_w )))\n}\n\n\n# 1. 特征值求权重\nem_get_w = function(A){\n  n = nrow(A)\n  stopifnot(nrow(A) ==  ncol(A))\n  \n  lambda = Re(eigen(A)$values[1]) # 矩阵A的最大特征值\n  n = nrow(A)\n  RI = c(0,0,0.58,0.90,1.12,1.24,1.32,1.41,1.45);\n  CI=(lambda-n)/(n-1);\n  CR=CI/RI[n];\n  eig_origin = eigen(A)$vectors[,1]\n  eig_w = eigen(A)$vectors[,1] # /sum(eigen(A)$vectors[,1]);\n  eig_w = Re(eig_w)\n  return(eig_w)\n}\n# 2. 几何平均求权重\ngm_get_w =function(A){\n  n = nrow(A)\n  stopifnot(nrow(A) ==  ncol(A))\n  temp = apply(A, 1, function(x) prod(x)^(1/n) )\n  w = temp # /sum(temp)\n  return(w)\n}\n# 3. 合并权重\nget_w = function(B,D,method = c('gm_get_w','em_get_w') ){\n  n = nrow(B)\n  stopifnot(n == nrow(D))\n  method <- match.arg(method)\n  f = get(method)\n  w_B = f(B)\n  w_D = f(D)\n  w_L = rep(0,length(w_B))\n  w_U = rep(0,length(w_B))\n  for(i in 1:length(w_B)){\n    w_L[i] = min(w_B[i],w_D[i])\n    w_U[i] = max(w_B[i],w_D[i])\n  }\n  w = matrix(c(w_L,w_U), ncol= 2 )\n  return(w)\n}\n\n\n\n# 4. 通过U进行分解，分解出B，D矩阵，\nfenjie = function(U){\n  n = nrow(U)\n  stopifnot(ncol(U) == 2*n)\n  \n  B = matrix(0,nrow = n,ncol = n)\n  D = matrix(0,nrow = n,ncol = n)\n  \n  for(i in 1:n){\n    for(j in 1:n){\n      if(i<j){\n        B[i,j] = U[i,j*2]\n        D[i,j] = U[i,2*j-1]\n      }else if(i>j){\n        B[i,j] = U[i,2*j-1]\n        D[i,j] = U[i,j*2]\n      }else{\n        B[i,j] = U[i,2*j]\n        D[i,j] =U[i,2*j]\n      }\n    }\n  }\n  return(list('B'=B,'D'=D))\n}\n\n\n# 5. 徐泽水(1999年)的文章方法进行调整，直到满足一致性条件为准(CR <=0.1).\nadjust_w <- function(A, lambda) {\n  k <- 0\n  n = nrow(A)\n  m = ncol(A)\n  stopifnot(n == m)\n  temp_CR <- consistency(A)$CR\n  temp_w <- consistency(A)$eig_w\n  while (temp_CR >= 0.1 && k < 1000) {\n    for (i in 1:n) {\n      for (j in 1:n) {\n          A[i, j] <- (A[i, j]^lambda) * (temp_w[i] / temp_w[j])^(1 - lambda)\n      }\n    }\n    temp_CR <- consistency(A)$CR\n    temp_w <- consistency(A)$eig_w\n    k <- k + 1\n  }\n  return(A)\n}\n\n\n\n# 6. degree_probability 函数计算两个区间数的可能度\ndegree_probability <- function(a, b) {\n  # 输入的a,b代表一个区间，即是一个二维向量，且小的在前面，大的元素在后面\n  stopifnot(length(a) == length(b), length(a) == 2, a[1] <= a[2], b[1] <= b[2])\n  temp <- 0\n  if (a[1] == a[2] && b[1] == b[2]) {\n    if (a[1] > b[1]) {\n      temp <- 1\n    } else if (a[1] == b[1]) {\n      temp <- 0.5\n    } else {\n      temp <- 0\n    }\n  } else if (a[1] == a[2] && b[1] != b[2]) {\n    if (a[1] > b[2]) {\n      temp <- 1\n    } else if (b[1] <= a[1] & a[1] <= b[2]) {\n      temp <- (a[1] - b[1]) / (b[2] - b[1])\n    } else {\n      temp <- 0\n    }\n  } else if (a[1] != a[2] && b[1] == b[2]) {\n    if (a[1] > b[1]) {\n      temp <- 1\n    } else if (a[1] <= b[1] & b[1] <= a[2]) {\n      temp <- (a[2] - b[1]) / (a[2] - a[1])\n    } else {\n      temp <- 0\n    }\n  } else if (a[1] != a[2] && b[1] != b[2]) {\n    if (a[1] < a[2] && a[2] <= b[1] && b[1] < b[2]) {\n      temp <- 0\n    } else if (a[1] <= b[1] && b[1] < a[2] && a[2] <= b[2]) {\n      s_t <- (a[2] - b[1]) * (a[2] - b[1]) * 0.5\n      s <- (b[2] - b[1]) * (a[2] - a[1])\n      temp <- s_t / s\n    } else if (a[1] <= b[1] && b[1] <= b[2] && b[2] <= a[2]) {\n      s_t <- ((a[2] - b[2]) + (a[2] - b[1])) * (b[2] - b[1]) * 0.5\n      s <- (b[2] - b[1]) * (a[2] - a[1])\n      temp <- s_t / s\n    } else if (b[1] < a[1] && a[1] < a[2] && a[2] < b[2]) { \n      # 可写等号b[1] <= a[1] && a[1]<a[2] &&a[2]<=b[2]\n      s_t <- ((a[1] - b[1]) + (a[2] - b[1])) * (a[2] - a[1]) * 0.5\n      s <- (b[2] - b[1]) * (a[2] - a[1])\n      temp <- s_t / s\n    } else if (b[1] < a[1] && a[1] < b[2] && b[2] < a[2]) {\n      s_tt <- (b[2] - a[1]) * (b[2] - a[1]) * 0.5\n      s <- (b[2] - b[1]) * (a[2] - a[1])\n      s_t <- s - s_tt\n      temp <- s_t / s\n    } else if (b[1] < b[2] && b[2] <= a[1] && a[1] < a[2]) {\n      temp <- 1\n    } else {\n    stop(\"运行出错,请检查\")\n    }\n  } else {\n    stop(\"运行出错,请检查\")\n  }\n  return(temp)\n}\n\n# 7. probability_matrix 给一个n*2 的区间数，求其可能度矩阵\nprobability_matrix <- function(Z) {\n  # probability_matrix函数输入一个n*2的矩阵，每一行代表输出各个方案的综合属性值得区间数\n  # 此函数输出各方案两两比较的可能度矩阵。\n  # degree_probability函数求两个区间数的可能度，\n  # a，b代表输入的区间数，输入这两个\n  P <- matrix(0, ncol = nrow(Z), nrow = nrow(Z))\n  for (i in 1:nrow(Z)) {\n    for (j in 1:nrow(Z)) {\n      P[i, j] <- degree_probability(Z[i, ], Z[j, ])\n    }\n  }\n  return(P)\n}\n\n\n# 8. index_matrix此函数可以查找到区间正互反判断矩阵中那些元素是缺失的（缺失用0表示)\nindex_matrix <- function(U) {\n  nnn <- which(U == 0, arr.ind = T)[, 1] # 行\n  mmm <- which(U == 0, arr.ind = T)[, 2] # 列\n  index <- matrix(0, nrow = length(nnn), ncol = 8)\n  # 矩阵index 每一行相当于一个变量\n  # 第一列代表 X索引，即变量X1,X2,...Xn\n  # 第二三列 代表变量Xi 所在U中的位置，用行和列表示\n  # 第四列，第五列，根据变量Xi在U的位置，\n  # 第6 列，判断Xi与Xj 是否为同一个位置，\n  index[, 1] <- 1:length(nnn)\n  index[, 2] <- nnn #\n  index[, 3] <- mmm\n  index\n  for (i in 1:nrow(index)) {\n    if (index[i, 3] %% 2 == 0) {\n      # 第3列的数字是偶数,检查U矩阵向前一列是否为0\n      if (U[index[i, 2], index[i, 3] - 1] == 0) {\n        index[i, 4] <- 0\n        index[i, 5] <- 0\n      } else {\n        index[i, 4] <- U[index[i, 2], index[i, 3] - 1]\n        index[i, 5] <- 0\n      }\n    } else {\n      if (U[index[i, 2], index[i, 3] + 1] == 0) {\n        index[i, 4] <- 0\n        index[i, 5] <- 0\n      } else {\n        index[i, 4] <- 0\n        index[i, 5] <- U[index[i, 2], index[i, 3] + 1]\n      }\n    }\n  }\n  \n  for (i in 1:nrow(index)) {\n    if (index[i, 4] != 0 & index[i, 5] == 0) {\n      index[i, 5] <- 9\n    }\n  }\n  for (i in 1:nrow(index)) {\n    if (index[i, 5] != 0 & index[i, 4] == 0) {\n      index[i, 4] <- 1 / 9\n    }\n  }\n  index[, 6] <- ifelse((index[, 4] == index[, 5] & index[, 4] == 0), 1, 0)\n  jinjibiao <- c()\n  for (i in 1:nrow(index)) {\n    for (j in 1:nrow(index)) {\n      if (index[i, 6] == 1 & index[j, 6] == 1 & j != i) {\n        if (index[i, 2] == index[j, 2] & abs(index[i, 3] - index[j, 3]) == 1) {\n          if (!(index[i, 7] %in% jinjibiao)) {\n            jinjibiao <- c(jinjibiao, j)\n            index[i, 7] <- index[i, 1]\n            index[i, 8] <- index[j, 1]\n          }\n        }\n      }\n    }\n  }\n  for (i in 1:nrow(index)) {\n    if (index[i, 7] > index[i, 8]) {\n      t <- index[i, 8]\n      index[i, 8] <- index[i, 7]\n      index[i, 7] <- t\n    }\n  }\n  \n  return(index)\n}\n\n\n# 9. 合成\nhecheng <- function(B, D) {\n  n = nrow(B)\n  m = ncol(B)\n  stopifnot(n == m, n == nrow(D) )\n  UU <- matrix(0, nrow = n, ncol = n * 2)\n  \n  for (i in 1:n) {\n    for (j in 1:(2*n) ) {\n      k <- (j + 1) %/% 2\n      if (i > k) {\n        if (j %% 2 == 0) {\n          UU[i, j] <- D[i, k]\n        } else {\n          UU[i, j] <- B[i, k]\n        }\n      } else if (i < k) {\n        if (j %% 2 == 0) {\n          UU[i, j] <- B[i, k]\n        } else {\n          UU[i, j] <- D[i, k]\n        }\n      } else {\n        UU[i, j] <- 1\n      }\n    }\n  }\n  return(UU)\n}\n\n\n####################################################################################\n######################## 构建 目标函数 补全区间残缺矩阵 ################## \n# 10. 检验U矩阵是否符合条件 \njianyan_yuesu <- function(U) {\n  if (!all(U >= 1 / 9 & U <= 9)) {\n    stop(\"U矩阵不满足约束条件\")\n  }\n  B <- fenjie(U)$B # 先对U进行分解，分解成B，D约束条件\n  D <- fenjie(U)$D\n  R <- matrix(0, nrow = nrow(D), ncol = ncol(D)) # 存储C与D比较的结果\n  for (i in 1:nrow(B)) {\n    for (j in 1:ncol(B)) {\n      if (i < j) {\n        R[i, j] <- (B[i, j] >= D[i, j])\n      } else if (i > j) {\n        R[i, j] <- (B[i, j] <= D[i, j])\n      } else {\n        R[i, j] <- all(B[i, j] == D[i, j], B[i, j] == 1)\n      }\n    }\n  }\n  if (!all(R == 1)) {\n    stop(\"U矩阵分解后的B,D矩阵不满足约束条件\")\n  }\n  return(1) # 返回结果为1 即满足约束\n}\n\n\n# 11. 把x的值赋予U中的残缺元素\nset_x <- function(x, U) {\n  U[which(U == 0)] <- x\n  return(U)\n}\n\n# 12，U补全后的矩阵记为Ut，计算补全后的目标函数值\nobj_fun <- function(Ut) {\n  s_sum <- 0\n  B_sum <- 0\n  D_sum <- 0\n  B <- fenjie(Ut)$B\n  D <- fenjie(Ut)$D\n  n <- nrow(B)\n  if (jianyan_yuesu(Ut)) {\n    for (i in 1:n) {\n      for (j in 1:n) {\n        for (k in 1:n) {\n          B_sum <- B_sum + (log(B[i, j], 9) - log(B[i, k], 9) - log(B[k, j], 9))^2\n          D_sum <- D_sum + (log(D[i, j], 9) - log(D[i, k], 9) - log(D[k, j], 9))^2\n        }\n      }\n    }\n    s_sum <- s_sum + B_sum + D_sum\n    return(s_sum)\n  } else {\n    stop(\"!!!输入的矩阵不符合约束条件\")\n  }\n}\n\n\n\n#########################################################\n#######################################################\n######################## 13. 初始化x #######\n######### U_runif 通过U产生 符合要求的随机矩阵U2\n# 13.1 重塑U ---把U变成UU（即(n*n )*2)形式的矩阵）\nU_to_UU <- function(U) {\n  n <- nrow(U)\n  m <- ncol(U) / 2\n  stopifnot(m >= 4, m == nrow(U))\n  # 先重塑U,U的每两列进行列合并成UU，通过UU产生0所在位置的随机数，并返回0所在的行下标，\n  # 即矩阵B，D为0的下标\n  UU <- U[, 1:2]\n  for (j in 2:(ncol(U) / 2)) {\n    temp1 <- U[, c(2 * j - 1, 2 * j)]\n    UU <- rbind(UU, temp1)\n  }\n  return(UU)\n}\n\n# 13.2 UU 转变成U的形式，并赋予随机值\nUU_to_U <- function(UU) {\n  n <- sqrt(nrow(UU))\n  if (!as.integer(n)) stop(\"n不是整数\")\n  BD_index2 <- t(apply(UU, 1, function(x) {\n    temp <- c(0, 0)\n    if (x[1] == 0 && x[2] != 0) {\n      temp[1] <- runif(1, 1 / 9, x[2])\n      temp[2] <- x[2]\n    } else if (x[1] != 0 && x[2] == 0) {\n      temp[1] <- x[1]\n      temp[2] <- runif(1, x[1], 9)\n    } else if (x[1] == 0 && x[2] == 0) {\n      temp <- sort(runif(2, 1 / 9, 9))\n    } else {\n      temp <- x\n    }\n    return(temp)\n  }))\n  # 把BD_index2 转变为 U的形式\n  stopifnot(nrow(BD_index2) %% n == 0)\n  U2 <- BD_index2[1:n, ]\n  for (j in 2:(nrow(BD_index2) / n)) {\n    temp2 <- BD_index2[(n * j - n + 1):(n * j), ]\n    U2 <- cbind(U2, temp2)\n  }\n  return(U2)\n}\n\n# 13.3 直接通过U随机初始化U\nU_runif <- function(U) {\n  UU <- U_to_UU(U)\n  # 对UU的每一行进行判断，产生出符合要求的随机数，并使BD_index2的形式与UU的形式一样，都为 (n*m) * 2矩阵\n  U2 <- UU_to_U(UU)\n  return(U2)\n}\n\n# 13.4 通过随机初始化U，找出解\ninit_x <- function(U) {\n  U2 <- U_runif(U)\n  return(U2[which(U == 0)])\n}\n\n\n###############################################################\n## 14。通过粒子群算法求目标函数最小值，来补全残缺区间矩阵的元素\nGDM_PSO <- function(U) {\n  Popsize <- 100 # 种群的大小\n  Dim <- sum(U == 0) # 粒子的维度\n  c1 <- 2 # 学习因子\n  c2 <- 2 # 学习因子\n  LB <- 1 / 9 # 下限\n  UB <- 9 # 上限\n  w_start <- 0.9\n  w_end <- 0.4\n  Vmax <- 5\n  Vmin <- -Vmax\n  MaxIter <- 3000\n  \n  \n  index <- index_matrix(U)\n  \n  # 初始化粒子位置和速度\n  X <- matrix(0, nrow = Popsize, ncol = Dim)\n  for (i in 1:Popsize) {\n    X[i, ] <- init_x(U)\n  }\n  V <- matrix(runif(Popsize * Dim), nrow = Popsize, ncol = Dim)\n  \n  # 设置当前位置为粒子的最好位置，并记录其最好值\n  PBest <- X\n  FPBest <- apply(X, 1, function(xx) obj_fun(set_x(xx, U)))\n  # FPBest\n  \n  if (anyNA(FPBest)) {\n    stop(\"适应度函数出现NA 或NaN，请检查\")\n  }\n  # 找出初始微粒群体的最好微粒\n  Best <- PBest[which.min(FPBest), ] # 最好的微粒\n  FGBest <- min(FPBest) # 以及最好的微粒对应的适应度值\n  \n  FX <- c(FGBest, rep(0, MaxIter - 1)) # 用来记录每一代的最粒子对应的适应度值\n  iter <- 0 # 初始迭代次数\n  \n  while (iter < MaxIter) {\n    # if(iter%%100 == 0) print(iter) # 显示循环进度条\n    iter <- iter + 1\n    # 更新权重的值\n    w_now <- (w_start - (w_start - w_end) / MaxIter * iter)\n    A <- matrix(rep(Best, each = Popsize), nrow = Popsize, ncol = Dim)\n    # 生成随机数\n    R1 <- matrix(runif(Popsize * Dim), nrow = Popsize, ncol = Dim)\n    R2 <- matrix(runif(Popsize * Dim), nrow = Popsize, ncol = Dim)\n    \n    # 速度更新\n    V <- w_now * V + c1 * R1 * (PBest - X) + c2 * R2 * (A - X)\n    \n    # 对进化后速度大于最大素的的微粒进行处理\n    changes <- V > Vmax\n    V[changes] <- Vmax\n    changes <- V < Vmin\n    V[changes] <- Vmin\n    \n    # 微粒位置进行更新\n    X <- X + 1.0 * V\n    # 对进化后微粒位置 大于搜索空间的的微粒进行处理\n    changes <- X > UB\n    X[changes] <- UB\n    changes <- X < LB\n    X[changes] <- LB\n    # 并再次检验是否满足约束，如果不满足约束，则进行调整\n    \n    for (ii in 1:nrow(index)) {\n      if (index[ii, 6] == 0) {\n        X[which(X[, ii] < index[ii, 4]), ii ] <- index[ii, 4]\n        X[which(X[, ii] > index[ii, 5]), ii] <- index[ii, 5]\n      } else {\n        X[which(X[, ii] < 1 / 9), ii ] <- 1 / 9\n        X[which(X[, ii] > 9), ii] <- 9\n        # 交换值 ，\n        if (ii %in% index[, 7] & index[ii, 7] != 0) {\n          kkkk <- ii\n          jjjj <- index[ii, 8]\n          \n          Low <- ifelse(X[, kkkk] > X[, jjjj], X[, jjjj], X[, kkkk])\n          UP <- ifelse(X[, kkkk] > X[, jjjj], X[, kkkk], X[, jjjj])\n          X[, kkkk] <- Low\n          X[, jjjj] <- UP\n        }\n      }\n    }\n    \n    \n    # 重新计算新位置的适应度值\n    \n    FPBest2 <- apply(X, 1, function(xx) obj_fun(set_x(xx, U)))\n    \n    # 更新每个微粒最好的位置\n    P <- (FPBest2 < FPBest)\n    FPBest[P] <- FPBest2[P] # 适应度值更换\n    PBest[P, ] <- X[P, ] # 粒子位置更换\n    \n    # 保存最好的粒子和适应度值\n    Best <- PBest[which.min(FPBest), ]\n    FGBest <- min(FPBest)\n    FX[iter] <- FGBest\n  }\n  # Best 为找到的最优解，把最优解赋值给区间型矩阵\n  Ut = set_x(Best,U) # Ut 即补全后的区间型矩阵\n  obj = obj_fun(Ut ) # 最优区间矩阵对于的目标函数值\n  return(list(\"best\" = Best, \"FGBest\" = FGBest,\"Ut\" = Ut,\"obj\"= obj))\n}\n\n## 15. DGM_U()群体决策，把若干个完整的区间判断矩阵合并成一个区间判断矩阵。\nDGM_U = function(...){\n  #######  第一部分是对参数的检查 #####################\n  # 输入的参数为U_{k}，U_{k}代表一个完整的区间乘积互反判断矩阵。\n  n = nrow(..1)\n  m = ncol(..1)\n  args <- list(...)\n  stopifnot( length(args) >=2, all( map_lgl(args,is.matrix)),2*n ==m )\n  # 检查所有的矩阵维度是否一样\n  library(purrr)\n  t = map(args,dim) %>% do.call(rbind, .) \n  stopifnot( nrow(unique(t)) == 1)\n  \n  ####### 第二部分 对参数的操作，达到想要的目的###########\n  ## 1. 使用快捷的函数\n  k = 1 / length(args)\n  UB = reduce( map(args,function(x)fenjie(x)$B),`*`)^k\n  UD = reduce( map(args, function(x)fenjie(x)$D), `*`)^k\n  \n  return( hecheng(UB,UD))\n}\n```\n:::\n\n\n\t\n\n\t\n\n## 3.测试\n\n### 3.1 测试1\n\n先利用一个区间残缺矩阵进行补全操作，然后计算其可能度矩阵P。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nU = matrix(c(1,1,1,2,0,2,2,3,\n             1/2,1,1,1,0,0,2,5,\n             1/2,0,0,0,1,1,3,0,\n             1/3,1/2,1/5,1/2,0,1/3,1,1),nrow = 4,byrow = T)\nU\n#>           [,1] [,2] [,3] [,4] [,5]      [,6] [,7] [,8]\n#> [1,] 1.0000000  1.0  1.0  2.0    0 2.0000000    2    3\n#> [2,] 0.5000000  1.0  1.0  1.0    0 0.0000000    2    5\n#> [3,] 0.5000000  0.0  0.0  0.0    1 1.0000000    3    0\n#> [4,] 0.3333333  0.5  0.2  0.5    0 0.3333333    1    1\nbest_U = GDM_PSO(U)\nbest_U\n#> $best\n#> [1] 1.5000000 0.7745967 1.5000000 0.6666667 0.6666667 0.3333333 1.2909944 3.0000000\n#> \n#> $FGBest\n#> [1] 2.560765\n#> \n#> $Ut\n#>           [,1] [,2]      [,3] [,4]      [,5]      [,6] [,7] [,8]\n#> [1,] 1.0000000  1.0 1.0000000  2.0 0.6666667 2.0000000    2    3\n#> [2,] 0.5000000  1.0 1.0000000  1.0 0.6666667 1.2909944    2    5\n#> [3,] 0.5000000  1.5 0.7745967  1.5 1.0000000 1.0000000    3    3\n#> [4,] 0.3333333  0.5 0.2000000  0.5 0.3333333 0.3333333    1    1\n#> \n#> $obj\n#> [1] 2.560765\n\nlibrary(magrittr)\nlibrary(purrr)\n## # 矩阵U进行分解成B，D，并检验B，D的CR值\nbest_U$Ut %>%fenjie() %>%  map(.,function(x)consistency(x)$CR)\n#> $B\n#> [1] 0.04881706\n#> \n#> $D\n#> [1] 7.949838e-10\n\n# 直接求出区间权重，以及根据权重求出区间可能度矩阵\n( w = get_w(B= fenjie(best_U$Ut)$B ,D = fenjie(best_U$Ut)$D) ) #每一行对应第i个方案的区间权重\n#>           [,1]     [,2]\n#> [1,] 1.0745699 1.861210\n#> [2,] 1.0745699 1.340343\n#> [3,] 1.0382256 1.611855\n#> [4,] 0.3860974 0.537285\n( P = probability_matrix(w) ) # 可能度矩阵P\n#>           [,1]      [,2]      [,3] [,4]\n#> [1,] 0.5000000 0.8310704 0.6801310  1.0\n#> [2,] 0.1689296 0.5000000 0.2950182  1.0\n#> [3,] 0.3198690 0.7049818 0.5000000  1.0\n#> [4,] 0.0000000 0.0000000 0.0000000  0.5\n```\n:::\n\n\n### 3.2 测试2 \n\n多个区间矩阵的操作\n\n\n::: {.cell}\n\n```{.r .cell-code}\nU1 = matrix(c(1,1,2,4,0,0,0,0,\n              1/4,1/2,1,1,1,3,0,0,\n              0,0,1/3,1,1,1,1/2,1,\n              0,0,0,0,1,2,1,1),nrow = 4,byrow = T)\nU2 = matrix(c(1,1,1,3,2,5,3,6,\n              1/3,1,1,1,3,0,1/2,4,\n              1/5,1/2,0,1/3,1,1,0,0,\n              1/6,1/3,1/4,2,0,0,1,1),nrow = 4,byrow = T)\nU3 = matrix(c(1,1,0,0,1/3,2,2,4,\n              0,0,1,1,0,0,1/3,2,\n              1/2,3,0,0,1,1,1/2,3,\n              1/4,1/2,1/2,3,1/3,2,1,1),nrow = 4,byrow = T)\n\n#########################################################################\n############### 对U1进行操作 ###########\nbest_U1 = GDM_PSO(U1) \nbest_U1\n#> $best\n#>  [1] 0.1111111 0.1111111 0.5000000 1.0000000 0.3849002 2.0000000 2.0000000 9.0000000 1.0000000 0.5000000 9.0000000 2.5980762\n#> \n#> $FGBest\n#> [1] 0.1542834\n#> \n#> $Ut\n#>           [,1] [,2]      [,3] [,4] [,5] [,6] [,7]     [,8]\n#> [1,] 1.0000000  1.0 2.0000000    4    2    9  1.0 9.000000\n#> [2,] 0.2500000  0.5 1.0000000    1    1    3  0.5 2.598076\n#> [3,] 0.1111111  0.5 0.3333333    1    1    1  0.5 1.000000\n#> [4,] 0.1111111  1.0 0.3849002    2    1    2  1.0 1.000000\n#> \n#> $obj\n#> [1] 0.1542834\n### 矩阵U进行分解成B，D，并检验B，D的CR值\nbest_U1$Ut %>%fenjie() %>%  map(.,function(x)consistency(x)$CR)\n#> $B\n#> [1] 0.002877359\n#> \n#> $D\n#> [1] -4.504035e-11\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#########################################################################\n############### 对U2进行操作 ###########\nbest_U2 = GDM_PSO(U2)\nbest_U2\n#> $best\n#> [1] 0.3333333 0.7905694 3.0000000 2.0000000 0.5000000 1.2649111\n#> \n#> $FGBest\n#> [1] 8.227604\n#> \n#> $Ut\n#>           [,1]      [,2]      [,3]      [,4]      [,5] [,6] [,7]     [,8]\n#> [1,] 1.0000000 1.0000000 1.0000000 3.0000000 2.0000000    5  3.0 6.000000\n#> [2,] 0.3333333 1.0000000 1.0000000 1.0000000 3.0000000    3  0.5 4.000000\n#> [3,] 0.2000000 0.5000000 0.3333333 0.3333333 1.0000000    1  0.5 1.264911\n#> [4,] 0.1666667 0.3333333 0.2500000 2.0000000 0.7905694    2  1.0 1.000000\n#> \n#> $obj\n#> [1] 8.227604\n## # 矩阵U进行分解成B，D，并检验B，D的CR值\nbest_U2$Ut %>%fenjie() %>%  map(.,function(x)consistency(x)$CR)\n#> $B\n#> [1] 0.01941419\n#> \n#> $D\n#> [1] 0.1401432\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#########################################################################\n############### 对U3进行操作 ###########\nbest_U3 = GDM_PSO(U3)\nbest_U3\n#> $best\n#> [1] 0.4030941 0.4048632 2.4678983 1.3926094 2.4679007 3.3078502 0.2999835 0.7129858\n#> \n#> $FGBest\n#> [1] 10.52412\n#> \n#> $Ut\n#>           [,1]      [,2]     [,3]     [,4]      [,5]      [,6]      [,7] [,8]\n#> [1,] 1.0000000 1.0000000 2.467898 2.467901 0.3333333 2.0000000 2.0000000    4\n#> [2,] 0.4030941 0.4048632 1.000000 1.000000 0.2999835 0.7129858 0.3333333    2\n#> [3,] 0.5000000 3.0000000 1.392609 3.307850 1.0000000 1.0000000 0.5000000    3\n#> [4,] 0.2500000 0.5000000 0.500000 3.000000 0.3333333 2.0000000 1.0000000    1\n#> \n#> $obj\n#> [1] 10.52412\n## # 矩阵U进行分解成B，D，并检验B，D的CR值\nbest_U3$Ut %>%fenjie() %>%  map(.,function(x)consistency(x)$CR)\n#> $B\n#> [1] 0.004191067\n#> \n#> $D\n#> [1] 0.2094884\n```\n:::\n\n\n发现U2 和U3 填充后没有满足一致性条件，于是需要调整\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## U2调整后的矩阵\ntemp2 = best_U2$Ut %>% fenjie() %>% map2(.,list(0.6,0.88),adjust_w) \nhecheng(temp2$B,temp2$D)\n#>           [,1]      [,2]      [,3]      [,4]      [,5]     [,6]      [,7]     [,8]\n#> [1,] 1.0000000 1.0000000 1.0902384 3.0000000 2.2142197 5.000000 2.5464288 6.000000\n#> [2,] 0.3333333 0.9172306 1.0000000 1.0000000 2.7801250 3.000000 0.5831896 4.000000\n#> [3,] 0.2000000 0.4516264 0.3333333 0.3596961 1.0000000 1.000000 0.4911658 1.264911\n#> [4,] 0.1666667 0.3927068 0.2500000 1.7147083 0.7905694 2.035972 1.0000000 1.000000\n\n## U3调整后的矩阵\ntemp3 = best_U3$Ut %>% fenjie() %>% map2(.,list(0.6,0.88),adjust_w) \nhecheng(temp3$B,temp3$D)\n#>           [,1]      [,2]     [,3]     [,4]      [,5]      [,6]      [,7] [,8]\n#> [1,] 1.0000000 1.0000000 2.614291 2.467901 0.4338405 2.0000000 1.5314546    4\n#> [2,] 0.4030941 0.3822943 1.000000 1.000000 0.2858496 0.7129858 0.3197585    2\n#> [3,] 0.5000000 2.3049946 1.392609 3.479965 1.0000000 1.0000000 0.6491458    3\n#> [4,] 0.2500000 0.6529740 0.500000 3.127361 0.3333333 1.5404860 1.0000000    1\n```\n:::\n\n\n​\t\t如果分解后的B和D没有达到一致性，则进行调整，由于这里用的是PSO算法进行残缺元素的填充，因此带有一定的随机值。于是我们用以下三个矩阵代代替补全后的矩阵(论文中给出的)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nU_t1 = matrix(c(1,1,2,4,2,9,1,9,\n                1/4,1/2,1,1,1,3,0.5,2.25,\n                1/9,1/2,1/3,1,1,1,1/2,1,\n                1/9,1,0.4444,2,1,2,1,1),nrow = 4,byrow = T)\n\nU_t2 = matrix(c(1,1,1.0815,3,2.0609,5,2.5209,6,\n                 1/3,0.9246,1,1,2.5515,3,0.6414,4,\n                 1/5,0.4852,1/3,0.3919,1,1,1.1237,1.3333,\n                 1/6,0.3967,1/4,1.5587,0.75,0.8899,1,1),nrow = 4,byrow = T)\n\n\nU_t3 = matrix(c(1,1,0.7256,2.1183,0.4837,2,1.2234,4,\n                 0.4721,1.3782,1,1,0.6666,0.8008,0.4299,2,\n                 1/2,2.0675,1.2488,1.5001,1,1,0.6449,3,\n                 1/4,0.8174,1/2,2.3262,1/3,1.5507,1,1),nrow = 4,byrow = T)\n( U = DGM_U(U_t1,U_t2,U_t3) ) # 多个区间矩阵融合为一个综合的区间矩阵\n#>           [,1]      [,2]      [,3]      [,4]      [,5]     [,6]      [,7]     [,8]\n#> [1,] 1.0000000 1.0000000 1.1621208 2.9402860 1.2585998 4.481405 1.4555977 6.000000\n#> [2,] 0.3401086 0.8604891 1.0000000 1.0000000 1.1936774 1.931622 0.5166013 2.620741\n#> [3,] 0.2231443 0.7945333 0.5177063 0.8377192 1.0000000 1.000000 0.7129147 1.587388\n#> [4,] 0.1666667 0.6870140 0.3815587 1.9355892 0.6299605 1.402705 1.0000000 1.000000\n( w = get_w(fenjie(U)$B,fenjie(U)$D) )# 对综合区间矩阵进行求权重--注意：权重没归一化\n#>           [,1]      [,2]\n#> [1,] 1.2079392 2.9818703\n#> [2,] 0.8534871 1.1454892\n#> [3,] 0.6543922 0.8299693\n#> [4,] 0.4473844 1.1686549\nprobability_matrix(w)#可能度矩阵\n#>      [,1]    [,2]      [,3]      [,4]\n#> [1,]  0.5 1.00000 1.0000000 1.0000000\n#> [2,]  0.0 0.50000 1.0000000 0.7654600\n#> [3,]  0.0 0.00000 0.5000000 0.4087181\n#> [4,]  0.0 0.23454 0.5912819 0.5000000\n```\n:::\n\n\n## 4 .总结\n\n如果区间矩阵是残缺的，那么用以下函数去补全：\n\n```R\nU = matrix(c(1,1,1,2,0,2,2,3,\n             1/2,1,1,1,0,0,2,5,\n             1/2,0,0,0,1,1,3,0,\n             1/3,1/2,1/5,1/2,0,1/3,1,1),nrow = 4,byrow = T)\nU\nbest_U = GDM_PSO(U)\nbest_U\n\n## 补全以后要进行一致性检验：\nbest_U$Ut %>%fenjie() %>%  map(.,function(x)consistency(x)$CR\n\n## 一致性检验没通过，则用下面的方法进行调整\ntemp = best_U$Ut %>% fenjie() %>% map2(.,list(0.6,0.88),adjust_w) \nU1 = hecheng(temp$B,temp$D) # 一定是一致性检验通过的区间判断矩阵\n```\n\n若是多个完整的区间矩阵，要综合成一个矩阵，则可以直接用下面的方法：\n\n```R\n# U_t1 ,U_t2,... ,是完整的区间判断矩阵，且符合一致性检验条件\n( U = DGM_U(U_t1,U_t2,U_t3) ) # 多个区间矩阵融合为一个综合的区间矩阵，\n( w = get_w(fenjie(U)$B,fenjie(U)$D) )# 对综合区间矩阵进行求权重--注意：权重没归一化\nprobability_matrix(w)#可能度矩阵\n```\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}