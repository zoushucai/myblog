{
  "hash": "038ce40b16a7690b6b30e66ef6a1739b",
  "result": {
    "markdown": "---\ntitle: 3.3 基于方差最大化模型的多属性决策方法\ndate: '2019-02-26'\ncategories: uncertain\n---\n\n\n\n\n\n## 徐泽水《不确定多属性决策方法与应用》84页\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n##  3.3 基于方差最大化模型的多属性决策方法---徐泽水《不确定多属性决策方法与应用》84页 --3.3.2 实例分析\nlibrary(data.table)\nlibrary(dplyr)\nA = c(18400,3,100,80,300,60,40,1.2,\n      19600,4,120,100,400,80,40,1.3,\n      29360,6,540,120,150,100,50,1.5) \n\nA= matrix(A,nrow = 3,ncol = 8,byrow = T) %>% data.table()\nA # 原始决策矩阵\n#>       V1 V2  V3  V4  V5  V6 V7  V8\n#> 1: 18400  3 100  80 300  60 40 1.2\n#> 2: 19600  4 120 100 400  80 40 1.3\n#> 3: 29360  6 540 120 150 100 50 1.5\n\n#### 第一步: 把原始决策矩阵A 利用适当的方法进行规范化为R，R为归一化后的矩阵\n### norm_matrix()函数，根据书中收益型属性（按公式1.2）与成本型属性(按公式1.4)分别进行归一化\n#####  注意这个与前面的norm_matrix 函数结果相同，只是代码显得更少了,保证了列名不变\nnorm_matrix = function(A, shouyi = NULL, chengben = NULL) {\n  stopifnot(!is.null(shouyi) | !is.null(chengben))\n  if (is.matrix(A)) A = data.table(A)\n  m = ncol(A)\n  if (is.null(chengben)) chengben = setdiff(1:m, shouyi)\n  if (is.null(shouyi)) shouyi = setdiff(1:m, chengben)\n  # 如果输入的shouyi与chengben向量交集不为空，且并集不是全集，则算法出错\n  stopifnot(length(intersect(shouyi, chengben)) == 0, setequal(union(shouyi, chengben), 1:m))\n  R =copy(A) # 重新赋值\n  if (length(chengben) == 0) {\n    R[, colnames(R)[shouyi] := lapply(.SD, function(x) x / max(x)), .SDcols = shouyi] # 收益型属性归一化 （书中1.2式）\n  } else if (length(shouyi) == 0) {\n    R[, colnames(R)[chengben] := lapply(.SD, function(x) min(x) / x  ), .SDcols = chengben]# 成本型属性归一化 （书中1.3式）\n  } else{\n    R[, colnames(R)[shouyi] := lapply(.SD, function(x) x / max(x)), .SDcols = shouyi] # 收益型属性归一化 （书中1.2式）\n    R[, colnames(R)[chengben] := lapply(.SD, function(x) min(x) / x  ), .SDcols = chengben]# 成本型属性归一化 （书中1.3式）\n  }\n  return(setDF(R))\n}\nR = norm_matrix(A, chengben = c(1:3))\nround(R,3)\n#>      V1   V2    V3    V4    V5  V6  V7    V8\n#> 1 1.000 1.00 1.000 0.667 0.750 0.6 0.8 0.800\n#> 2 0.939 0.75 0.833 0.833 1.000 0.8 0.8 0.867\n#> 3 0.627 0.50 0.185 1.000 0.375 1.0 1.0 1.000\n\n\n\n#### 第二步 ： 利用模型 M-3.11 求解线性规划\nM_w = function(R,lower_c,upper_c){\n  n = nrow(R)\n  m = ncol(R)\n  deta = matrix(0,nrow = n,ncol = m)\n  for(i in 1:n){\n    for(j in 1:m){\n      for(k in 1:n){\n        deta[i,j] = deta[i,j] + (R[i,j] - R[k,j])^2\n      }\n    }\n  }\n  \n  library(Rglpk)\n  obj = c(apply(deta, 2, sum)) # 设置目标函数\n  mat = matrix(rep(1,m),nrow = 1) # 约束条件，权和向量为1 \n  dir = c(\"==\")\n  rhs = c(1)\n  types = c(\"C\")\n  bounds <- list(lower = list(ind = 1L:m, val = lower_c),\n                 upper = list(ind = 1L:m, val = upper_c))\n  return(Rglpk_solve_LP(obj, mat, dir, rhs, bounds, types,max =TRUE )$solution)\n}\nw = M_w(R,lower_c = c(0.1,0.12,0.11,0.12,0.07,0.2,0.18,0.09),\n        upper_c = c(0.2,0.14,0.15,0.16,0.12,0.3,0.21,0.22))\nw # 权重\n#> [1] 0.10 0.12 0.12 0.12 0.07 0.20 0.18 0.09\n\n##### 第三步： 求出各方案的综合属性值\nz = apply(R, 1, function(x)sum(x*w))\nz\n#> [1] 0.8085000 0.8358776 0.7611425\n#########第四步，#按降序排列，最大的为方案最优\nround(z,4)%>% rank %>% order(.,decreasing=T)#按降序排列，最大的为最优\n#> [1] 2 1 3\n```\n:::\n",
    "supporting": [
      "2019-02-26-3-3基于方差最大化模型的多属性决策方法_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}