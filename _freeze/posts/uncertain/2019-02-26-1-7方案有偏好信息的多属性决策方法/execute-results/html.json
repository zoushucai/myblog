{
  "hash": "3bb58550a69a53dc6cd2f7841c8aca60",
  "result": {
    "markdown": "---\ntitle: 1.7方案有偏好信息的多属性决策方法\ndate: '2019-02-26'\ncategories: uncertain\n---\n\n\n\n\n## 徐泽水《不确定多属性决策方法与应用》27--37页\n### 1.对方案的偏好信息为互反判断矩阵的情形\n\n::: {.cell}\n\n```{.r .cell-code}\n## 1 对方案的偏好信息为互反判断矩阵的情形\nlibrary(data.table)\nlibrary(dplyr)\nA = c(3.0,100,10,7,\n      2.5,80,8,5,\n      1.8,50,20,11,\n      2.2,70,12,9)\nA= matrix(A,nrow = 4,ncol = 4,byrow = T) %>% data.table()\nA # 原始决策矩阵\n#>     V1  V2 V3 V4\n#> 1: 3.0 100 10  7\n#> 2: 2.5  80  8  5\n#> 3: 1.8  50 20 11\n#> 4: 2.2  70 12  9\n\n#######################################################\n##### 第一步把原始决策矩阵A 利用适当的方法进行规范化为R，R为归一化后的矩阵\n##########################################################\n### norm_matrix()函数，根据书中收益型属性（按公式1.2）与成本型属性(按公式1.4)分别进行归一化\n# 参数A表示决策矩阵,shouyi参数代表收益型属性，输入收益型属性在决策矩阵中第几列，若有多列，用数值型向量即可，\n# chengben参数代表成本型属性，与收益型属性类型。\n# 该参数可任选其一输入，也可同时指定。\nnorm_matrix = function(A,shouyi=NULL,chengben=NULL){\n  if(is.matrix(A))A = data.table(A)\n  stopifnot(!is.null(shouyi) | !is.null(chengben))\n  m = ncol(A)\n  if(is.null(chengben)) chengben =setdiff(1:m,shouyi) \n  if(is.null(shouyi)) shouyi = setdiff(1:m,chengben)\n  stopifnot(length(intersect(shouyi,chengben))==0,setequal(union(shouyi,chengben),1:m))\n  #对决策矩阵进行重命名\n  names(A)=paste0('V',1:m)\n  shouyi = paste0(\"V\",shouyi)\n  chengben = paste0(\"V\",chengben)\n  R = A\n  R[,':='(c(shouyi),lapply(.SD, function(x)x/max(x))),.SDcols =shouyi] # 收益型属性归一化 （书中1.2式）\n  R[,':='(c(chengben),lapply(.SD,function(x)min(x)/x)),.SDcol = chengben]# 成本型属性归一化 （书中1.3式）\n  R = as.data.frame(R)\n  return(R)\n}\n\nR = norm_matrix(A,chengben = c(1,3))\nround(R,3)\n#>      V1  V2    V3    V4\n#> 1 0.600 1.0 0.800 0.636\n#> 2 0.720 0.8 1.000 0.455\n#> 3 1.000 0.5 0.400 1.000\n#> 4 0.818 0.7 0.667 0.818\n#########################################################\n##### 第二步 根据决策方案(即决策矩阵的行)进行成对比较，构造出判断矩阵\n#################################################\n# 假设如下判断矩阵\nH = c(1,2,1/4,1/5,\n      1/2,1,1/2,1/3,\n      4,2,1,1/2,\n      5,3,2,1)\nH = matrix(H, nrow = 4, ncol = 4, byrow = T)\nH\n#>      [,1] [,2] [,3]      [,4]\n#> [1,]  1.0    2 0.25 0.2000000\n#> [2,]  0.5    1 0.50 0.3333333\n#> [3,]  4.0    2 1.00 0.5000000\n#> [4,]  5.0    3 2.00 1.0000000\nQ = matrix(0,nrow = 4,ncol = 4)\nfor(k in 1:4) {\n  for (l in 1:4) {\n    for (i in 1:4) {\n      for (j in 1:4) {\n        Q[k, l] = Q[k, l] + (H[i, j] * R[i, k] - R[i, k]) * ((H[i, j] * R[i, l] - R[i, l]))\n      }\n    }\n  }\n}\nQ\n#>          [,1]     [,2]     [,3]     [,4]\n#> [1,] 25.59035 19.01777 17.29175 25.45790\n#> [2,] 19.01777 15.65944 14.36756 18.89730\n#> [3,] 17.29175 14.36756 13.32738 17.10511\n#> [4,] 25.45790 18.89730 17.10511 25.39491\ne_m = matrix(rep(1,4),nrow = 1)\nt(e_m)\n#>      [,1]\n#> [1,]    1\n#> [2,]    1\n#> [3,]    1\n#> [4,]    1\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n\n(solve(Q) %*% t(e_m) )/as.vector(e_m %*% solve(Q) %*% t(e_m))\n#>           [,1]\n#> [1,] -8.823475\n#> [2,] -6.429099\n#> [3,]  7.436625\n#> [4,]  8.815949\n(solve(Q) %*% t(e_m) ) /0.2014189\n#>           [,1]\n#> [1,] -8.823476\n#> [2,] -6.429100\n#> [3,]  7.436626\n#> [4,]  8.815950\n```\n:::\n\n\n### 2.对方案的偏好信息为模糊互补判断矩阵的情形\n（待完善）\n\n### 3.对方案的偏好信息为效用值的情形\n（待完善）\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}