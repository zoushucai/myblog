{
  "hash": "e21f2acccc012aa6568f2bc8b8f186ee",
  "result": {
    "markdown": "---\ntitle: 3.2 基于方案满意度的多属性决策方法\ndate: '2019-02-26'\ncategories: uncertain\n---\n\n\n\n\n# 徐泽水《不确定多属性决策方法与应用》81页\n\n\n::: {.cell}\n\n```{.r .cell-code}\n##  3.2 基于方案满意度的多属性决策方法---徐泽水《不确定多属性决策方法与应用》81页 --3.2.2 实例分析\nlibrary(data.table)\nlibrary(dplyr)\nA = c(47177, 16.61, 8.89, 31.05, 15.77,\n      43323, 9.08, 3.65, 29.80, 8.44,\n      59023, 13.84, 6.06, 26.55, 12.87,\n      46821, 10.59, 3.51, 22.46, 7.41,\n      41646, 13.24, 4.64, 24.33, 9.33,\n      26446, 10.16, 2.38, 26.80, 9.85,\n      38381, 11.97, 4.79, 26.45, 10.64,\n      57808, 10.29, 4.54, 23.00, 9.23,\n      28869, 7.68, 2.12, 31.08, 9.05,\n      38812, 8.92, 3.38, 25.68, 8.73,\n      30721, 10.87, 4.15, 30.36, 11.44,\n      24848, 10.77,2.42, 30.71, 11.37,\n      26925, 9.34, 3.06, 30.11, 10.84,\n      23269, 8.25, 2.58, 32.57, 8.62,\n      28267, 8.13, 3.17, 29.25, 9.17,\n      21583, 7.14, 4.66, 35.35, 11.27)\n\nA= matrix(A,nrow = 16,ncol = 5,byrow = T) %>% data.table()\nA # 原始决策矩阵\n#>        V1    V2   V3    V4    V5\n#>  1: 47177 16.61 8.89 31.05 15.77\n#>  2: 43323  9.08 3.65 29.80  8.44\n#>  3: 59023 13.84 6.06 26.55 12.87\n#>  4: 46821 10.59 3.51 22.46  7.41\n#>  5: 41646 13.24 4.64 24.33  9.33\n#>  6: 26446 10.16 2.38 26.80  9.85\n#>  7: 38381 11.97 4.79 26.45 10.64\n#>  8: 57808 10.29 4.54 23.00  9.23\n#>  9: 28869  7.68 2.12 31.08  9.05\n#> 10: 38812  8.92 3.38 25.68  8.73\n#> 11: 30721 10.87 4.15 30.36 11.44\n#> 12: 24848 10.77 2.42 30.71 11.37\n#> 13: 26925  9.34 3.06 30.11 10.84\n#> 14: 23269  8.25 2.58 32.57  8.62\n#> 15: 28267  8.13 3.17 29.25  9.17\n#> 16: 21583  7.14 4.66 35.35 11.27\n```\n:::\n\n\n## 第一步: 把原始决策矩阵A 利用适当的方法进行规范化为R，R为归一化后的矩阵\n\n::: {.cell}\n\n```{.r .cell-code}\n#### 第一步: 把原始决策矩阵A 利用适当的方法进行规范化为R，R为归一化后的矩阵\n### norm_matrix()函数，根据书中收益型属性（按公式1.2）与成本型属性(按公式1.4)分别进行归一化\n#####  注意这个与前面的norm_matrix函数(即下面norm_matrix2)结果相同，只是代码显得更少了,保证了列名不变\nnorm_matrix = function(A, shouyi = NULL, chengben = NULL) {\n  stopifnot(!is.null(shouyi) | !is.null(chengben))\n  if (is.matrix(A)) A = data.table(A)\n  m = ncol(A)\n  if (is.null(chengben)) chengben = setdiff(1:m, shouyi)\n  if (is.null(shouyi)) shouyi = setdiff(1:m, chengben)\n  # 如果输入的shouyi与chengben向量交集不为空，且并集不是全集，则算法出错\n  stopifnot(length(intersect(shouyi, chengben)) == 0, setequal(union(shouyi, chengben), 1:m))\n  R =copy(A) # 重新赋值\n  if (length(chengben) == 0) {\n    R[, colnames(R)[shouyi] := lapply(.SD, function(x) x / max(x)), .SDcols = shouyi] # 收益型属性归一化 （书中1.2式）\n  } else if (length(shouyi) == 0) {\n    R[, colnames(R)[chengben] := lapply(.SD, function(x) min(x) / x  ), .SDcols = chengben]# 成本型属性归一化 （书中1.3式）\n  } else{\n    R[, colnames(R)[shouyi] := lapply(.SD, function(x) x / max(x)), .SDcols = shouyi] # 收益型属性归一化 （书中1.2式）\n    R[, colnames(R)[chengben] := lapply(.SD, function(x) min(x) / x  ), .SDcols = chengben]# 成本型属性归一化 （书中1.3式）\n  }\n  return(setDF(R))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnorm_matrix2 = function(A,shouyi=NULL,chengben=NULL){\n  if(is.matrix(A))A = data.table(A)\n  stopifnot(!is.null(shouyi) | !is.null(chengben))\n  m = ncol(A)\n  if(is.null(chengben)) chengben =setdiff(1:m,shouyi) \n  if(is.null(shouyi)) shouyi = setdiff(1:m,chengben)\n  stopifnot(length(intersect(shouyi,chengben))==0,setequal(union(shouyi,chengben),1:m))\n  \n  if( length(chengben) == 0 ){\n    # 对决策矩阵进行重命名\n    colnames(A)=paste0('V',1:m)\n    shouyi = paste0(\"V\",shouyi)\n    R = A    \n    # 归一化\n    R[,':='(c(shouyi),lapply(.SD, function(x)x/max(x))),.SDcols =shouyi] # 收益型属性归一化 （书中1.2式）\n  }else if( length(shouyi) == 0 ){\n    #对决策矩阵进行重命名\n    names(A)=paste0('V',1:m)\n    chengben = paste0(\"V\",chengben)\n    R = A\n    # 归一化\n    R[,':='(c(chengben),lapply(.SD,function(x)min(x)/x)),.SDcol = chengben]# 成本型属性归一化 （书中1.3式）\n  }else{\n    #对决策矩阵进行重命名\n    names(A)=paste0('V',1:m)\n    shouyi = paste0(\"V\",shouyi)\n    chengben = paste0(\"V\",chengben)\n    R = A\n    # 归一化\n    R[,':='(c(shouyi),lapply(.SD, function(x)x/max(x))),.SDcols =shouyi] # 收益型属性归一化 （书中1.2式）\n    R[,':='(c(chengben),lapply(.SD,function(x)min(x)/x)),.SDcol = chengben]# 成本型属性归一化 （书中1.3式）    \n  }\n  R = as.data.frame(R)\n  return(R)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nR = norm_matrix(A, chengben = 4)\nround(R,3)\n#>       V1    V2    V3    V4    V5\n#> 1  0.799 1.000 1.000 0.723 1.000\n#> 2  0.734 0.547 0.411 0.754 0.535\n#> 3  1.000 0.833 0.682 0.846 0.816\n#> 4  0.793 0.638 0.395 1.000 0.470\n#> 5  0.706 0.797 0.522 0.923 0.592\n#> 6  0.448 0.612 0.268 0.838 0.625\n#> 7  0.650 0.721 0.539 0.849 0.675\n#> 8  0.979 0.620 0.511 0.977 0.585\n#> 9  0.489 0.462 0.238 0.723 0.574\n#> 10 0.658 0.537 0.380 0.875 0.554\n#> 11 0.520 0.654 0.467 0.740 0.725\n#> 12 0.421 0.648 0.272 0.731 0.721\n#> 13 0.456 0.562 0.344 0.746 0.687\n#> 14 0.394 0.497 0.290 0.690 0.547\n#> 15 0.479 0.489 0.357 0.768 0.581\n#> 16 0.366 0.430 0.524 0.635 0.715\n```\n:::\n\n## 第二步 ： 求出综合属性正理想值z_max,以及综合属性负理想值z_min\n\n::: {.cell}\n\n```{.r .cell-code}\n###### 第二步 ： 求出综合属性正理想值z_max,以及综合属性负理想值z_min\nM_zonghe_position = function(R,lower_c,upper_c){\n   #综合属性正理想值z_max\n    library(Rglpk)\n    n = nrow(R)\n    m = ncol(R)\n    ## 约束条件，权和向量为1 \n    mat = matrix(rep(1,m),nrow = 1) \n    dir = c(\"==\")\n    rhs = c(1)\n    ## \n    types = c(\"C\") # 表示解为实数\n    bounds <- list(lower = list(ind = 1L:m, val = lower_c),\n                   upper = list(ind = 1L:m, val = upper_c))\n    ###  下面 max_obj 函数中的xx为R矩阵的某一行\n    max_obj = function(xx) Rglpk_solve_LP(xx, mat, dir, rhs, bounds, types,max = TRUE)$optimum\n    return(apply(R, 1, max_obj))\n}\nz_max = M_zonghe_position(R,lower_c = c(0.22,0.18,0.15,0.23,0.16),upper_c = c(0.24,0.20,0.17,0.26,0.17))\nround(z_max,3)\n#>  [1] 0.890 0.623 0.851 0.706 0.735 0.585 0.703 0.777 0.522 0.633 0.631 0.576\n#> [13] 0.575 0.502 0.555 0.534\n\n\n## 求出综合属性负理想值\nM_zonghe_negative = function(R,lower_c,upper_c){\n  #综合属性负理想值z_min\n  if(is.data.table(R)) R = as.data.frame(R)\n  library(Rglpk)\n  n = nrow(R)\n  m = ncol(R)\n  ## 约束条件，权和向量为1 \n  mat = matrix(rep(1,m),nrow = 1) \n  dir = c(\"==\")\n  rhs = c(1)\n  ## \n  types = c(\"C\") # 表示解为实数\n  bounds <- list(lower = list(ind = 1L:m, val = lower_c),\n                 upper = list(ind = 1L:m, val = upper_c))\n  ###  下面 max_obj 函数中的xx为R矩阵的某一行\n  min_obj = function(xx) Rglpk_solve_LP(xx, mat, dir, rhs, bounds, types)$optimum\n  return(apply(R, 1, min_obj))\n}\nz_min = M_zonghe_negative(R,lower_c = c(0.22,0.18,0.15,0.23,0.16),upper_c = c(0.24,0.20,0.17,0.26,0.17))\nz_min\n#>  [1] 0.8799025 0.6122816 0.8442960 0.6869648 0.7224206 0.5680731 0.6945892\n#>  [8] 0.7600534 0.5084315 0.6185512 0.6213819 0.5605654 0.5620055 0.4893540\n#> [15] 0.5430971 0.5233214\n```\n:::\n\n\n##  第三步： 求出各方按的满意度，PW 矩阵的每一行为对应方案的满意度矩阵\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#####  第三步： 求出各方按的满意度，PW 矩阵的每一行为对应方案的满意度矩阵，\n# 把满意度矩阵的每一行乘以对应属性的权重，则为该方案的满意度，但此时属性权重未知\n# 通过建立线性目标函数，求解出属性权重\nPW = matrix(0,ncol = ncol(R),nrow = nrow(R))\nfor(i in 1:nrow(R)){\n  for(j in 1:ncol(R)){\n    PW[i,j] = (R[i,j] - z_min[i])/(z_max[i] - z_min[i])\n  }\n}\nPW\n#>             [,1]        [,2]         [,3]        [,4]       [,5]\n#>  [1,]  -7.820666 11.65256149  11.65256149 -15.1896961  11.652561\n#>  [2,]  11.145778 -6.00900673 -18.47012741  12.9486991  -7.058863\n#>  [3,]  22.923509 -1.62874601 -23.94335797   0.2436666  -4.150187\n#>  [4,]   5.606157 -2.60510136 -15.40681623  16.5088261 -11.448630\n#>  [5,]  -1.373481  6.09491123 -16.36028397  16.3793613 -10.672955\n#>  [6,]  -7.029567  2.55423994 -17.59326739  15.8143586   3.311256\n#>  [7,]  -4.979815  2.92839875 -17.50474858  17.3674915  -2.235035\n#>  [8,]  13.013027 -8.33758206 -14.79304717  12.8414038 -10.367462\n#>  [9,]  -1.441419 -3.43690273 -20.14420736  15.9848337   4.883279\n#> [10,]   2.696916 -5.63428706 -16.47249835  17.6965044  -4.490027\n#> [11,] -10.399110  3.40588154 -15.93163587  12.2046922  10.724431\n#> [12,]  -9.130713  5.74617525 -18.86296457  11.1727327  10.494447\n#> [13,]  -7.990561  0.02312869 -16.44500376  13.8874395   9.466552\n#> [14,]  -7.630903  0.58843249 -15.97617926  16.0642115   4.593201\n#> [15,]  -5.286466 -4.41756470 -15.36276214  18.5132509   3.161791\n#> [16,] -15.310838 -9.07672150   0.08382542  10.8811429  18.581452\n\n### 通过满意度矩阵，求出属性权重\nM_w = function(R,lower_c,upper_c){\n  library(Rglpk)\n  n = nrow(R)\n  m = ncol(R)\n  obj = c(apply(R, 2, sum)) # 设置目标函数\n  mat = matrix(rep(1,m),nrow = 1) # 约束条件，权和向量为1 \n  dir = c(\"==\")\n  rhs = c(1)\n  types = c(\"C\")\n  bounds <- list(lower = list(ind = 1L:m, val = lower_c),\n                 upper = list(ind = 1L:m, val = upper_c))\n  return(Rglpk_solve_LP(obj, mat, dir, rhs, bounds, types,max =TRUE )$solution)\n}\nw = M_w(PW,lower_c = c(0.22,0.18,0.15,0.23,0.16),upper_c = c(0.24,0.20,0.17,0.26,0.17))\nw # 权重\n#> [1] 0.22 0.20 0.15 0.26 0.17\n### 通过权重确定方案综合指标值\nz = apply(R, 1, function(x)sum(x*w))\nz\n#>  [1] 0.8839165 0.6193408 0.8475817 0.7011357 0.7335354 0.5851453 0.7034886\n#>  [8] 0.7693701 0.5212981 0.6306097 0.6310837 0.5758520 0.5752496 0.5018189\n#> [15] 0.5552379 0.5317315\n```\n:::\n\n##第四步，#按降序排列，最大的为方案最优\n\n::: {.cell}\n\n```{.r .cell-code}\n#########第四步，#按降序排列，最大的为方案最优\n\nround(z,4)%>% rank %>% order(.,decreasing=T)#按降序排列，最大的为最优\n#>  [1]  1  3  8  5  7  4 11 10  2  6 12 13 15 16  9 14\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}