{
  "hash": "26922f26c5a0eeb41a39371b47bee199",
  "result": {
    "markdown": "---\ntitle: 2.1 模糊互补判断矩阵的排序方法\ndate: '2019-02-26'\ncategories: uncertain\n---\n\n\n\n\n## 徐泽水《不确定多属性决策方法与应用》59页\n\n\n::: {.cell}\n\n```{.r .cell-code}\n###  2.1 模糊互补判断矩阵的排序方法---徐泽水《不确定多属性决策方法与应用》59页 --2.1.6 实例分析\n# 以及55页 例 2.1\nB = c(0.5,0.7,0.6,0.8,\n      0.3,0.5,0.4,0.6,\n      0.4,0.6,0.5,0.7,\n      0.2,0.4,0.3,0.5) \nB = matrix(B, nrow = 4,ncol = 4,byrow = T)\n######## MTM 排序法---模糊互补判断矩阵的中转法\n# MTM 函数直接输入模糊互补判断矩阵B，直接即可求出对应案例（即行，决策矩阵行代表案例，列代表属性）的权重向量w.\nMTM = function(B){\n  w = 0\n  n = nrow(B)\n  m = ncol(B)\n  stopifnot(n==m)\n  for(i in 1:n){\n    w[i] =( sum(B[i,]) + n/2 -1) /(n*(n-1))\n  }\n  return(w)\n}\nMTM(B)\n#> [1] 0.3000000 0.2333333 0.2666667 0.2000000\n\n########## LVM 排序---- 模糊互补判断矩阵排序的最小方差法\n# LVM函数直接输入模糊互补判断矩阵B，直接即可求出对应案例（即行，决策矩阵行代表案例，列代表属性）的权重向量w.\nLVM = function(x){\n  w =0\n  n = nrow(B)\n  m = ncol(B)\n  stopifnot(n==m)\n  for(i in 1:n){\n    w[i] =( sum(B[i,]) + 1 - n/2 )/n \n  }\n  return(w)\n}\nLVM(B)\n#> [1] 0.4 0.2 0.3 0.1\n### LDM 排序 -------模糊互补判断矩阵排序的最小偏差法\n# LDM 函数 --本质是求解一个线性规划问题。\nLDM = function(B){\n  n = nrow(B)\n  m =  ncol(B)\n  stopifnot(n == m)\n  w = matrix(runif(n, min = 0.1, max = 0.9),nrow = 1,byrow = T)# 随机初始化正向量w\n  e = 0.0001 # 迭代精度，要求权向量的每一个分量都小于此精度，则迭代结束。\n  k = 0 # 迭代次数\n  repeat{\n    eta = rep(0,n) # 初始化中间变量\n    for(i in 1:n){\n      for(j in 1:n){\n        eta[i] = eta[i] + (B[i, j]/B[j, i]) * (w[j]/w[i]) - (B[j, i]/B[i, j]) * (w[i]/w[j])\n      }\n    }\n    v = 0; w1 = rep(0,n);v_fenzi = 0; v_fenmu = 0 # 初始化中间变量\n    if( all( abs(eta) < e) ) {\n      break\n    }else{\n      l = which.max(abs(eta))\n      for(j in 1:n){\n        if(j != l) {\n          v_fenzi = v_fenzi + B[l,j]/B[j,l] * w[j]/w[l]\n          v_fenmu = v_fenmu + B[j,l]/B[l,j] * w[l]/w[j]\n        }\n      }\n      v =  sqrt(v_fenzi/v_fenmu)\n      for(i in 1:n){\n        if(i != l){\n          w1[i] = w[i]\n        }else{\n          w1[i] = v * w[l]\n        }\n      }\n      k = k+1\n      w = w1/sum(w1)\n    }\n  }\n  return(w)  \n}\nLDM(B)\n#> [1] 0.4302060 0.1799470 0.2748736 0.1149734\n\n##### CEM -- 模糊互补判断矩阵排序的特征向量法\n# CEM函数\nCEM = function(B){\n  # 第一步 ---通过转换公式，得出转换矩阵H\n  n = nrow(B)\n  H = matrix(0, ncol = n, nrow = n)\n  for( i in 1:n){\n    for(j in 1:n){\n      H[i,j] = B[i,j]/B[j,i]\n    }\n  }\n  # 第二步 -- 求转换矩阵H的最大特征值对应的特征向量,此特征向量即模糊互补判断矩阵的排序向量\n  #### 直接调用系统函数求矩阵的特征值以及特征向量\n  # w = Re(eigen(H)$vectors[,1] / sum(eigen(H)$vectors[,1]))\n  # return(w)\n  ####  数值方法求矩阵H的最大特征值对应的特征向量,\n  max_eigen_w =  function(M) {\n    n = nrow(M)\n    m =  ncol(M)\n    stopifnot(n == m)\n    w = matrix(runif(n, min = 0.1, max = 0.9),nrow = 1,byrow = T)# 随机初始化正向量w\n    q = max(w)\n    w = w / q # 并初始化权向量\n    # 进行迭代\n    repeat{\n      w = M %*% t(w)\n      w = t(w)\n      q1 = max(w)\n      w = w/q1\n      e = q1 - q # 迭代的精度\n      if(abs(e) < 0.000001) {\n        break\n      }\n      q = q1\n    }\n    return(w)\n  }\n  w = max_eigen_w(H)\n  # 第三步 ---- 并对特征向量进行归一化处理\n  w = w / sum(w)\n  return(w)\n}\n\nCEM(B)\n#>           [,1]      [,2]      [,3]      [,4]\n#> [1,] 0.4303074 0.1798951 0.2747969 0.1150005\n\n\n##### 检验模糊互补判断矩阵一致性\n# 直接输入模糊互补判断矩阵可得CR指标，CR<0.1 ,一般检验通过\nCEM_CR_test =  function(B, w = CEM(B)){\n  # 第一步 -- 先要先求出权重向量w -- 即模糊互补矩阵对应的最大特征值的特征向量 ,直接进行默认参数设置。\n  # 注意调用此函数之前，要调用CEM函数\n  \n  n = nrow(B)\n  CI = 0\n  for(i in 1:n) {\n    for (j in 1:n) {\n      if (i < j) {\n        CI = CI + (B[i, j] / B[j, i]) * (w[j] / w[i]) + (B[j, i] / B[i, j]) * (w[i] / w[j]) -2\n      }\n    }\n  }\n  CI = CI /(n*(n-1))  \n  RI = c(0,0,0.52,0.89,1.12,1.26,1.36,1.41,1.46,1.49,1.52,1.56,1.58,1.59)\n  return( CI/RI[n]) \n}\n\nCEM_CR_test(B)\n#> [1] 0.0008969988\n\n\n######  55 页 -----例2.1 \nB = c(0.5,0.6,0.4,0.3,\n      0.4,0.5,0.6,0.6,\n      0.6,0.4,0.5,0.7,\n      0.7,0.4,0.3,0.5) \nB = matrix(B, nrow = 4,ncol = 4,byrow = T)\nCEM(B)\n#>           [,1]      [,2]     [,3]      [,4]\n#> [1,] 0.2043336 0.2697384 0.297326 0.2286019\nCEM_CR_test(B)\n#> [1] 0.1609257\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}