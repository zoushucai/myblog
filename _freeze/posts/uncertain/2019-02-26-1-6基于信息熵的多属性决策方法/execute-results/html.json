{
  "hash": "77677b9027b68f7ada112ee013742f85",
  "result": {
    "markdown": "---\ntitle: 1.6 基于信息熵的多属性决策方法\ndate: '2019-02-26'\ncategories: uncertain\n---\n\n\n\n\n## 徐泽水《不确定多属性决策方法与应用》26页\n\n\n::: {.cell}\n\n```{.r .cell-code}\n##  1.6 基于信息熵的多属性决策方法---徐泽水《不确定多属性决策方法与应用》26页 --1.62 实例分析\n\nlibrary(data.table)\nlibrary(dplyr)\nA = c(2,1.5,2,5.5,5,9,\n      2.5,2.7,1.8,6.5,3,5,\n      1.8,2,2.1,4.5,7,7,\n      2.2,1.8,2,5,5,5)\nA= matrix(A,nrow = 4,ncol = 6,byrow = T) %>% data.table()\nA # 原始决策矩阵\n#>     V1  V2  V3  V4 V5 V6\n#> 1: 2.0 1.5 2.0 5.5  5  9\n#> 2: 2.5 2.7 1.8 6.5  3  5\n#> 3: 1.8 2.0 2.1 4.5  7  7\n#> 4: 2.2 1.8 2.0 5.0  5  5\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#######################################################\n##### 第一步把原始决策矩阵A 利用适当的方法进行规范化为R，R为归一化后的矩阵\n##########################################################\n### norm_matrix()函数，根据书中收益型属性（按公式1.2）与成本型属性(按公式1.4)分别进行归一化\n# 参数A表示决策矩阵,shouyi参数代表收益型属性，输入收益型属性在决策矩阵中第几列，若有多列，用数值型向量即可，\n# chengben参数代表成本型属性，与收益型属性类型。\n# 该参数可任选其一输入，也可同时指定。\nnorm_matrix = function(A,shouyi=NULL,chengben=NULL){\n  if(is.matrix(A))A = data.table(A)\n  stopifnot(!is.null(shouyi) | !is.null(chengben))\n  m = ncol(A)\n  if(is.null(chengben)) chengben =setdiff(1:m,shouyi) \n  if(is.null(shouyi)) shouyi = setdiff(1:m,chengben)\n  stopifnot(length(intersect(shouyi,chengben))==0,setequal(union(shouyi,chengben),1:m))\n  #对决策矩阵进行重命名\n  names(A)=paste0('V',1:m)\n  shouyi = paste0(\"V\",shouyi)\n  chengben = paste0(\"V\",chengben)\n  R = A\n  R[,':='(c(shouyi),lapply(.SD, function(x)x/max(x))),.SDcols =shouyi] # 收益型属性归一化 （书中1.2式）\n  R[,':='(c(chengben),lapply(.SD,function(x)min(x)/x)),.SDcol = chengben]# 成本型属性归一化 （书中1.3式）\n  R = as.data.frame(R)\n  return(R)\n}\n\nR = norm_matrix(A,chengben = 4)\nround(R,3)\n#>     V1    V2    V3    V4    V5    V6\n#> 1 0.80 0.556 0.952 0.818 0.714 1.000\n#> 2 1.00 1.000 0.857 0.692 0.429 0.556\n#> 3 0.72 0.741 1.000 1.000 1.000 0.778\n#> 4 0.88 0.667 0.952 0.900 0.714 0.556\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#########################################################\n##### 第二步 计算矩阵R，得到列归一化矩阵R'\n#################################################\nR_t = sapply(R, function(x)x/sum(x))\nround(R_t,3)\n#>         V1    V2    V3    V4   V5    V6\n#> [1,] 0.235 0.188 0.253 0.240 0.25 0.346\n#> [2,] 0.294 0.338 0.228 0.203 0.15 0.192\n#> [3,] 0.212 0.250 0.266 0.293 0.35 0.269\n#> [4,] 0.259 0.225 0.253 0.264 0.25 0.192\n#########################################################\n##### 第三步 根据R_t计算属性u_j的信息熵\n#################################################\nentropy = function(R_t){\n  if(!is.data.frame(R_t)) R_t = as.data.frame(R_t)\n  n = nrow(R_t)\n  E = sapply(R_t, function(x) (-1/log(n)) * sum( ifelse(x == 0 , 0 , x*log(x) ) ) )\n  return(E)\n}\nE = entropy(R_t)\nE\n#>        V1        V2        V3        V4        V5        V6 \n#> 0.9946889 0.9829482 0.9988876 0.9936177 0.9703227 0.9771412\n#########################################################\n##### 第四步 根据信息熵计算权重向量\n#################################################\nw = (1-E)/sum(1-E)\nround(w,3)\n#>    V1    V2    V3    V4    V5    V6 \n#> 0.064 0.207 0.014 0.077 0.360 0.277\n#########################################################\n##### 第五步 根据权重向量按照1.12式计算每一个方案的综合属性值Z\n#################################################\nz = t(as.matrix(R) %*% as.matrix(w,ncol=1)) %>% as.data.frame() # 计算综合属性值\nround(z,4)\n#>       V1     V2     V3     V4\n#> 1 0.7775 0.6451 0.8666 0.6887\n#########################################################\n##### 第六步 根据综合属性值Z对方案进行排序\n#################################################\n#rank(z) #输出排序\nsort(rank(z),decreasing = T)\n#> V3 V1 V4 V2 \n#>  4  3  2  1\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}