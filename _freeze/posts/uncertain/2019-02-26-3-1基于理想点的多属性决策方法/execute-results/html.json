{
  "hash": "111e53a86f687778add6bbd8caf1ef90",
  "result": {
    "markdown": "---\ntitle: 3.1 基于理想点的多属性决策方法\ndate: '2019-02-26'\ncategories: uncertain\n---\n\n\n\n\n## 徐泽水《不确定多属性决策方法与应用》78页\n\n\n::: {.cell}\n\n```{.r .cell-code}\n##  3.1 基于理想点的多属性决策方法---徐泽水《不确定多属性决策方法与应用》78页 --3.1.2 实例分析\n\nlibrary(data.table)\nlibrary(dplyr)\nA = c(0.37,1800,2,19,90,\n      0.58,2800,5,28,105,\n      0.52,3500,5,32,130,\n      0.43,1900,3,27,98)\n      \nA= matrix(A,nrow = 4,ncol = 5,byrow = T) %>% data.table()\nA # 原始决策矩阵\n#>      V1   V2 V3 V4  V5\n#> 1: 0.37 1800  2 19  90\n#> 2: 0.58 2800  5 28 105\n#> 3: 0.52 3500  5 32 130\n#> 4: 0.43 1900  3 27  98\n\n####################################################### ##############################\n##################  正理想点偏差 -----  且 决策者不能提供任何权重信息  ###############\n####################################################### ##############################\n#### 第一步把原始决策矩阵A 利用适当的方法进行规范化为R，R为归一化后的矩阵\n### norm_matrix()函数，根据书中收益型属性（按公式1.2）与成本型属性(按公式1.4)分别进行归一化\nnorm_matrix = function(A,shouyi=NULL,chengben=NULL){\n  if(is.matrix(A))A = data.table(A)\n  stopifnot(!is.null(shouyi) | !is.null(chengben))\n  m = ncol(A)\n  if(is.null(chengben)) chengben =setdiff(1L:m,shouyi) \n  if(is.null(shouyi)) shouyi = setdiff(1:m,chengben)\n  stopifnot(length(intersect(shouyi,chengben))==0,setequal(union(shouyi,chengben),1:m))\n\n  if( length(chengben) == 0 ){\n    # 对决策矩阵进行重命名\n    names(A)=paste0('V',1:m)\n    shouyi = paste0(\"V\",shouyi)\n    R = A    \n    # 归一化\n    R[,':='(c(shouyi),lapply(.SD, function(x)x/max(x))),.SDcols =shouyi] # 收益型属性归一化 （书中1.2式）\n  }else if( length(shouyi) == 0 ){\n    #对决策矩阵进行重命名\n    names(A)=paste0('V',1:m)\n    chengben = paste0(\"V\",chengben)\n    R = A\n    # 归一化\n    R[,':='(c(chengben),lapply(.SD,function(x)min(x)/x)),.SDcols = chengben]# 成本型属性归一化 （书中1.3式）\n  }else{\n    #对决策矩阵进行重命名\n    names(A)=paste0('V',1:m)\n    shouyi = paste0(\"V\",shouyi)\n    chengben = paste0(\"V\",chengben)\n    R = A\n    # 归一化\n    R[,':='(c(shouyi),lapply(.SD, function(x)x/max(x))),.SDcols =shouyi] # 收益型属性归一化 （书中1.2式）\n    R[,':='(c(chengben),lapply(.SD,function(x)min(x)/x)),.SDcols = chengben]# 成本型属性归一化 （书中1.3式）    \n  }\n  R = as.data.frame(R)\n  return(R)\n}\nR = norm_matrix(A,shouyi = c(1:5))\nR\n#>          V1        V2  V3      V4        V5\n#> 1 0.6379310 0.5142857 0.4 0.59375 0.6923077\n#> 2 1.0000000 0.8000000 1.0 0.87500 0.8076923\n#> 3 0.8965517 1.0000000 1.0 1.00000 1.0000000\n#> 4 0.7413793 0.5428571 0.6 0.84375 0.7538462\n#### 第二步  最小化方案与正理想点之间的偏差，得出属性权重向量\nM_position = function(R){ # 输入归一化后的决策矩阵。\n  m =  ncol(R)\n  n = nrow(R)\n  # ## 程序 1 \n   temp = apply(R, 2, FUN = function(x)1/(n-sum(x)) )\n   w = temp/sum(temp) \n   return(w)\n  # ## 程序 2 \n  # w = rep(0,m)\n  # s = 0\n  # for(j in 1:m){\n  #   s = s + 1/(n - sum(R[,j]))\n  # }\n  # for(j in 1:m){\n  #   w[j] = (1/(n - sum(R[,j])))/s \n  # }\n  # return(w)\n}\nw = M_position(R)\nw\n#>        V1        V2        V3        V4        V5 \n#> 0.2282300 0.1446113 0.1652700 0.2403928 0.2214959\n#### 第三步  计算出的权重向量，带入目标函数，并对目标函数值升序排序，排序结果，即为方案的优劣结果\nf_obj = apply(R, 1, function(x){ sum( (1-x)*w*w ) })\nround(f_obj,4) # 按升序排列，则最优结果为: x3 > x2 > x4 > x1\n#> [1] 0.0840 0.0208 0.0054 0.0551\n\n\n####################################################### ##############################\n##################  负（或正）理想点偏差 -----  且 决策者提供权重信息  ########## \n######################   （本质求解线性规划问题） 书中77页M3.3 和 M-3.6###############################\n####################################################### ##############################\n########  方法一： 正理想点偏差\n# 第一步： 归一化决策矩阵\n# 第二步： 得出属性权重向量\n# M_position_tigong_w 输入决策矩阵(为规范化后的决策矩阵)，以及提供权重信息,以向量形式给出\n# 该函数输入结果为： 得出属性权重向量\n\nM_position_tigong_w = function(R,lower_c,upper_c){\n  library(Rglpk)\n  n = nrow(R)\n  m = ncol(R)\n  obj = n - c(apply(R, 2, sum)) # 设置目标函数\n  mat = matrix(rep(1,m),nrow = 1) # 约束条件，权和向量为1 \n  dir = c(\"==\")\n  rhs = c(1)\n  types = c(\"C\")\n  bounds <- list(lower = list(ind = 1L:m, val = lower_c),\n                 upper = list(ind = 1L:m, val = upper_c))\n  return(Rglpk_solve_LP(obj, mat, dir, rhs, bounds, types)$solution)\n}\n\n\nw = M_position_tigong_w(R,lower_c = c(0.15,0.13,0.15,0.20,0.20),\n                    upper_c = c(0.25,0.15,0.20,0.25,0.23))\nw\n#> [1] 0.25 0.13 0.15 0.25 0.22\nround(w,2)\n#> [1] 0.25 0.13 0.15 0.25 0.22\n####  第三步： 把计算出的权重向量，带入目标函数，并对目标函数值升序排序，排序结果，即为方案的优劣结果\napply(R, 1, function(x) sum( (1-x)*w ) )\n#> [1] 0.41291491 0.09955769 0.02586207 0.27730009\napply(R, 1, function(x) sum( (1-x)*w ) ) %>% rank %>% order()# 按升序排列，则最优结果为: x3 > x2 > x4 > x1\n#> [1] 3 2 4 1\n\n\n\n########  方法二： 负理想点偏差\n# 第一步： 归一化决策矩阵\n# 第二步： 得出属性权重向量\n# M_negative_w 输入决策矩阵(为规范化后的决策矩阵)，以及提供权重信息,以向量形式给出\n# 该函数输入结果为： 得出属性权重向量\nM_negative_w = function(R,lower_c,upper_c){\n  library(Rglpk)\n  n = nrow(R)\n  m = ncol(R)\n  obj = c(apply(R, 2, sum)) # 设置目标函数\n  mat = matrix(rep(1,m),nrow = 1) # 约束条件，权和向量为1 \n  dir = c(\"==\")\n  rhs = c(1)\n  types = c(\"C\")\n  bounds <- list(lower = list(ind = 1L:m, val = lower_c),\n                 upper = list(ind = 1L:m, val = upper_c))\n  return(Rglpk_solve_LP(obj, mat, dir, rhs, bounds, types,max =TRUE )$solution)\n}\nw = M_position_tigong_w(R,lower_c = c(0.15,0.13,0.15,0.20,0.20),\n                        upper_c = c(0.25,0.15,0.20,0.25,0.23))\nw\n#> [1] 0.25 0.13 0.15 0.25 0.22\nround(w,2)\n#> [1] 0.25 0.13 0.15 0.25 0.22\n####  第三步： 把计算出的权重向量，带入目标函数，并对目标函数值升序排序，排序结果，即为方案的优劣结果\napply(R, 1, function(x) sum( (1-x)*w ) )\n#> [1] 0.41291491 0.09955769 0.02586207 0.27730009\napply(R, 1, function(x) sum( (1-x)*w ) ) %>% rank %>% order()# 按升序排列，则最优结果为: x3 > x2 > x4 > x1\n#> [1] 3 2 4 1\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}