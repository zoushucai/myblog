[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "笔记",
    "section": "",
    "text": "排序方式\n       缺省\n         \n          日期 - 日期升序\n        \n         \n          日期 - 日期降序\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n日期\n\n\n标题\n\n\n\n\n\n\n2022-08-28\n\n\nmac重装系统6抹掉所有内容和设置\n\n\n\n\n2021-05-16\n\n\nmatlab优化工具04二次规划之quadprog\n\n\n\n\n2021-05-16\n\n\nmatlab优化工具03全局优化之ga\n\n\n\n\n2021-05-16\n\n\nmatlab优化工具01线性规划之linprog\n\n\n\n\n2021-05-16\n\n\nmatlab优化工具02非线性规划之fmincon\n\n\n\n\n2020-10-07\n\n\nmac重装系统5sublime配置\n\n\n\n\n2020-10-06\n\n\nmac重装系统4软件安装\n\n\n\n\n2020-10-05\n\n\nmac重装系统3系统设置\n\n\n\n\n2020-10-04\n\n\nmac重装系统2系统制作与安装\n\n\n\n\n2020-10-03\n\n\nmac重装系统1起因\n\n\n\n\n2020-08-16\n\n\nR动画\n\n\n\n\n2020-08-15\n\n\n画函数图像–R语言\n\n\n\n\n2020-08-14\n\n\nlatex 参考文献格式: GB/7714\n\n\n\n\n2020-08-13\n\n\nlatex 参考文献生成(总结)\n\n\n\n\n2020-08-11\n\n\nlatex 缩写期刊\n\n\n\n\n2020-08-10\n\n\nlatex 笔记\n\n\n\n\n2020-07-29\n\n\nbib与enw文件之间的相互转换\n\n\n\n\n2020-07-01\n\n\nmactex卸载\n\n\n\n\n2020-05-18\n\n\n创建属于自己的rmarkdown模板文件\n\n\n\n\n2020-05-18\n\n\nR&shiny自动截图\n\n\n\n\n2020-03-10\n\n\n基本绘图中添加指定中文字体\n\n\n\n\n2019-12-11\n\n\n计算各种距离 （matlab）\n\n\n\n\n2019-12-11\n\n\ncorr详解(MATLAB)\n\n\n\n\n2019-11-22\n\n\nmacOS tcping 检测IP端口\n\n\n\n\n2019-11-21\n\n\nmac硬盘文件变灰色\n\n\n\n\n2019-11-20\n\n\ngit 笔记\n\n\n\n\n2019-11-20\n\n\nmac 常用软件\n\n\n\n\n2019-11-19\n\n\nmac终端样式PS1\n\n\n\n\n2019-11-19\n\n\n常用的批处理操作\n\n\n\n\n2019-11-15\n\n\nMATLAB 与 R 在排序上的区别\n\n\n\n\n2019-11-14\n\n\nArmadillo + Rcpp VS MATLAB/octave\n\n\n\n\n2019-11-13\n\n\nmatlab 问题集合基础\n\n\n\n\n2019-11-13\n\n\nMATLAB函数中参数的问题\n\n\n\n\n2019-11-04\n\n\nlatex + bib + csl\n\n\n\n\n2019-06-25\n\n\n非线性规划\n\n\n\n\n2019-06-24\n\n\nMATLAB集合\n\n\n\n\n2019-05-26\n\n\n动态可视化如此简单\n\n\n\n\n2019-05-24\n\n\nR结合C++\n\n\n\n\n2019-05-11\n\n\n测试rmarkdown输出页面\n\n\n\n\n2019-05-05\n\n\n残缺区间群体决策模型（GDM Liu 2012)\n\n\n\n\n2019-05-04\n\n\n求区间可能度矩阵的算法(Liu 2009)\n\n\n\n\n2019-05-03\n\n\n正互反矩阵一致性调整方法(徐泽水1999)\n\n\n\n\n2019-05-02\n\n\nR非标准计算\n\n\n\n\n2019-05-02\n\n\n环境\n\n\n\n\n2019-05-01\n\n\nR函数参数的有关问题\n\n\n\n\n2019-05-01\n\n\n数据框删除列的方法汇总\n\n\n\n\n2019-04-30\n\n\nlist操作\n\n\n\n\n2019-04-30\n\n\n省略号参数— 可变长参数\n\n\n\n\n2019-04-26\n\n\nR画带箭头的坐标轴\n\n\n\n\n2019-04-26\n\n\n学术论文写作工具\n\n\n\n\n2019-04-01\n\n\nR语言绘制双坐标图\n\n\n\n\n2019-02-26\n\n\n3.3 基于方差最大化模型的多属性决策方法\n\n\n\n\n2019-02-26\n\n\n4.1 基于可能度的多属性决策方法\n\n\n\n\n2019-02-26\n\n\n1.6 基于信息熵的多属性决策方法\n\n\n\n\n2019-02-26\n\n\n1.5.2离差最大化的多属性决策方法\n\n\n\n\n2019-02-26\n\n\n3.2 基于方案满意度的多属性决策方法\n\n\n\n\n2019-02-26\n\n\n3.1 基于理想点的多属性决策方法\n\n\n\n\n2019-02-26\n\n\n2.1 模糊互补判断矩阵的排序方法\n\n\n\n\n2019-02-26\n\n\n4.2基于投影的多属性决策方法(含4.3区间归一化)\n\n\n\n\n2019-02-26\n\n\n1.7方案有偏好信息的多属性决策方法\n\n\n\n\n2019-02-25\n\n\n不确定多属性决策方法徐泽水pdf\n\n\n\n\n2019-02-21\n\n\n智能算法测试函数可视化\n\n\n\n\n2019-02-20\n\n\n遗传算法（待完善）\n\n\n\n\n2019-02-19\n\n\n模拟退火算法（待完善）\n\n\n\n\n2019-02-18\n\n\n运筹学与最优化–在R软件中的实现\n\n\n\n\n2019-01-13\n\n\n混合粒子群算法matlab\n\n\n\n\n2018-11-22\n\n\n运筹学最短路问题\n\n\n\n\n2018-11-21\n\n\nR语言输出latex或html\n\n\n\n\n2018-11-20\n\n\n用c语言设置定时关机\n\n\n\n\n2018-11-18\n\n\n运筹学与最优化matlab\n\n\n\n\n2018-11-17\n\n\n重装系统后一些有用的激活工具\n\n\n\n\n2018-11-17\n\n\n线性规划的一般模型(草稿)\n\n\n\n\n2018-11-14\n\n\nR金融分析以及VaR\n\n\n\n\n2018-11-13\n\n\nR语言发邮件–mailR包\n\n\n\n\n2018-11-06\n\n\n谈谈字符编码问题\n\n\n\n\n2018-11-06\n\n\nGitHubDesktop权限问题解决办法\n\n\n\n\n2018-09-13\n\n\nglmnet包解读\n\n\n\n\n2018-08-31\n\n\n独热编码–哑变量\n\n\n\n\n2018-08-10\n\n\nScrapy框架+selenium爬取京东相机\n\n\n\n\n2018-07-15\n\n\nggplot2一页多图(图独立)\n\n\n\n\n2018-07-15\n\n\n相关图之corrplot\n\n\n\n\n2018-07-15\n\n\n相关图之ggplot系列扩展\n\n\n\n\n2018-07-15\n\n\n猫眼电影票房抓取\n\n\n\n\n2018-07-15\n\n\n相关图之corrgram\n\n\n\n\n2018-07-14\n\n\n泰坦尼克号预测(kaggle)\n\n\n\n\n2018-07-08\n\n\nseq*函数族\n\n\n\n\n2018-05-19\n\n\n正则表达式(通用)\n\n\n\n\n2018-04-14\n\n\nR中时间类型概念\n\n\n\n\n2018-04-08\n\n\n并行化计算之foreach包\n\n\n\n\n2018-04-07\n\n\nRSelenium应用–京东商品\n\n\n\n\n2018-04-06\n\n\n利用RSelenium包模拟浏览器爬取网页信息\n\n\n\n\n2018-04-05\n\n\nR语言字符处理函数包—stringr包\n\n\n\n\n2018-04-05\n\n\nR语言字符处理—基本函数\n\n\n\n\n2018-03-10\n\n\nWindows系统下R Markdown 设置中文pdf完美解决方案\n\n\n\n\n2018-02-10\n\n\nR计算微积分\n\n\n\n\n\n2018-01-18\n\n\ndata.table – 3常见操作\n\n\n\n\n\n2018-01-17\n\n\ndata.table – 2基本概念\n\n\n\n\n\n2018-01-16\n\n\ndata.table – 1基本函数\n\n\n\n\n2018-01-14\n\n\n因子数据类型处理\n\n\n\n\n2018-01-07\n\n\nR软件常见问题\n\n\n\n\n2018-01-05\n\n\n1、go语言安装与LiteIDE的配置\n\n\n\n\n2018-01-03\n\n\ndplyr – 2实战\n\n\n\n\n2018-01-01\n\n\ndplyr – 1基本函数简介\n\n\n\n\n2017-12-31\n\n\ntibble包的列和行名相互转换以及添加行和列\n\n\n\n\n2017-12-30\n\n\n添加谷歌网站分析\n\n\n\n\n2017-12-30\n\n\nhugo–分类标签添加\n\n\n\n\n2017-12-30\n\n\nhugo–blogdown生成的目录\n\n\n\n\n2017-12-29\n\n\n博客搭建——blogdown之md\n\n\n\n\n2017-12-28\n\n\nhugo-blogdown搭建网页过程中的小问题\n\n\n\n\n2017-11-13\n\n\nR语言标准化数据处理\n\n\n\n\n2017-11-13\n\n\n数据集划分—-训练集和测试集方法\n\n\n\n\n2017-11-04\n\n\ninstall old hugo version\n\n\n\n\n2017-04-08\n\n\nR语言文件目录相关操作\n\n\n\n\n2017-03-23\n\n\nknn算法简介\n\n\n\n\n2017-02-18\n\n\n回归树与模型树\n\n\n\n\n2017-02-12\n\n\nggfortify包简介\n\n\n\n\n2017-01-15\n\n\nR语言与可视化\n\n\n\n\n2015-11-16\n\n\nRweka包解读\n\n\n\n\n2015-11-09\n\n\nGA包—遗传算法\n\n\n\n\n2000-01-01\n\n\n测试文件\n\n\n\n\n\n\n无匹配项"
  },
  {
    "objectID": "posts/macnote/mac重装系统4软件安装.html",
    "href": "posts/macnote/mac重装系统4软件安装.html",
    "title": "mac重装系统4软件安装",
    "section": "",
    "text": "xcode-select --install\n此文章于2022-08-28 修改, 因为不适合最新的m1/m2了 ## 2.homebrew 安装\n\n\n官网主页: https://brew.sh/\n国内加速安装: https://gitee.com/cunkai/HomebrewCN\n\n\n\n方法一: 网上找的,\n可参考: https://blog.csdn.net/qq_41234116/article/details/79366454\n方法 2: 官方版本\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\"\nhttps://github.com/Homebrew/brew/blob/master/docs/FAQ.md\nhttps://stackoverflow.com/questions/23251665/how-to-uninstall-homebrew\n\n\n\nbrew install <packageName>      # 这个安装的是只有命令行的工具\n\nbrew install --cask google-chrome   #  安装的是有图像界面的 app\n\nbrew uninstall <packageName>\n\nbrew uninstall --cask <packageName> \n\nbrew list    % 已安装列表\n\nbrew update   % 注意每次使用这个是 都很慢, 可进行源的更新\n\nbrew cask search <packageName>  %查询<packageName>\n\nbrew cask info <packageName>   % 查看版本信息\n\nbrew config             %查看brew配置\n\nbrew outdated   % 查看那些包（软件）可以更新\n\nbrew upgrade             # 更新所有的包，Homebrew 会安装新版本的包，但旧版本仍然会保留\nbrew upgrade $FORMULA    # 更新指定的包\n\nbrew cleanup             # 清理所有包的旧版本，将旧有的软件安装包进行清理\nbrew cleanup $FORMULA    # 清理指定包的旧版本\nbrew cleanup -n          # 查看可清理的旧版本包，不执行实际操作\n\n\n\nbrew cleanup --prune 0\n\ncleanup [options] [formula|cask]\n       Remove stale lock files and outdated downloads for all formulae and casks,  and  remove  old\n       versions  of installed formulae. If arguments are specified, only do this for the given for-\n       mulae and casks. Removes all downloads more than 120 days old. This  can  be  adjusted  with\n       HOMEBREW_CLEANUP_MAX_AGE_DAYS.\n\n       --prune\n              Remove all cache files older than specified days.\n\n       -n, --dry-run\n              Show what would be removed, but do not actually remove anything.\n\n       -s     Scrub the cache, including downloads for even the latest versions. Note downloads for\n              any installed formulae or casks will still not be deleted.  If  you  want  to  delete\n              those too: rm -rf \"$(brew --cache)\"\n\n       --prune-prefix\n              Only prune the symlinks and directories from the prefix and remove no other files.\n\n\n\n\nexport A = B 把 B 写入 A中,不过重启后无效, 还可以设置环境变量,不过 mac 一般会自动配置,不怎么用这个,用的较多的是~/.bash_profile文件来管理环境变量.\necho 'xxx' >>  file 把'xxx'内容追加到 file 文件末尾, 用一个>表示覆盖 file文件.\nsource ~/.bash_profile 刷新配置文件\ncat file 查看 file 文件\nvim file 利用 vim 打开 file文件,vim 可以编辑修改 file 文件"
  },
  {
    "objectID": "posts/macnote/mac重装系统4软件安装.html#常用软件",
    "href": "posts/macnote/mac重装系统4软件安装.html#常用软件",
    "title": "mac重装系统4软件安装",
    "section": "3. 常用软件",
    "text": "3. 常用软件\n\n谷歌浏览器 ,\nTypora 写作软件,\nsublime-text3,\ngithub桌面版,\nmathpix-snipping-tool公式识别器,\ntencent-lemon : 腾讯柠檬垃圾清理软件\ncontexts: 快速切换 mac 窗口\nfirefox(火狐浏览器,虽然 Google 浏览器很强了,不过国内有些软件需要这个)\nthe-unarchiver (只能)解压软件\nkeka 解压压缩都行,\nqq : mac上只有 qq,暂时没有 TIM\niina % 视频播放器\nmounty %挂着 NTFS\nbaidunetdisk %百度网盘\nloopback: 收费软件,需要找到破解版,不建议用这个安装,结合 mac 自带的录屏软件,可以录制有声音的视频,不管是系统声音还是软件声音都行.\njava 的安装,个人建议还是从官网下载安装对应的版本,我记得第一次试的时候,好像没有配置成功\n\n% 先安装 r 以及 rstudio 在安装java, 看能否配置成功\nbrew install –cask  r\nbrew install –cask  rstudio     \nbrew install –cask  java   %将会安装jdk的最新版本，jdk内嵌jre\nbrew install –cask  java8  %安装jdk8的最新版本\n\ngrammarly : 语法安装软件, 个人不推荐,因为有浏览器插件就够了\ncajviewer: caj 云阅读\nzotero: 论文参考文献管理, 可以快速进行期刊缩写与展开\nmendeley : 论文参考文献管理，可以快速进行期刊缩写与展开\njabref : 论文管理软件, 只适合 bibtex 文件的管理, 这个可以缩写期刊, 以及查找文献的 doi, 并且不修改原有的bibtex 文件信息(除非手动修改), 注意一定要找到对应期刊的 bst 文件,才能显示出适合的参考文献格式, 可以集合 zotero 以及 mendeley 的软件查找相应的参考文献样式或者直接从网站https://www.zotero.org/styles查找下载相关参考文献的样式, 最终结合 bibtex 生成最终的 pdf(bibtex文件生成的临时文件 *.bbl 就是对应的的thebibliography环境以及bibitem条目 ), 备注: 个人推荐 jabref, 然后全部的参考文献都去 Google 学术上下载 bibtex 文件,不能一会从百度学术一会从谷歌学术下载,或者从相应的参考软件下载,这样会很乱, 注意:谷歌浏览器插件MyBibCitation Generator 也能产生相应的参考文献样式\n\njabref % 建议安装开发版本,这个默认是稳定版本\n\n# 个人基础\nbrew install –cask  sogouinput  # 搜狗输入法\nbrew install –cask  google-chrome # Google浏览器\nbrew install –cask  sublime-text     \nbrew install –cask  github\nbrew install –cask  mathpix-snipping-tool\nbrew install –cask  tencent-lemon   #  腾讯柠檬清理软件\nbrew install –cask  qq\nbrew install –cask  iina \nbrew install –cask  typora     # 收费\nbrew install –cask  contexts\n#brew install –cask  firefox    # 火狐浏览器, \nbrew install –cask  baidunetdisk # 百度云\nbrew install –cask  mailmaster       # 网易邮箱大师\nbrew install –cask  grammarly        \n#brew install –cask  cajviewer  \nbrew install –cask  zotero          # 文献管理工具\n#brew install –cask  jabref      # 建议安装开发版本,这个默认是稳定版本s\n\n\n# 免费\nbrew install –cask  the-unarchiver     # 解压工具\nbrew install –cask  keka               # 解压缩工具\n# 可以购买myzip专业版,这个软件具有上述两个软件的常用功能,解压缩\n\n# 免费   \nbrew install –cask  mounty            # U盘挂在软件\n## mounty开源的. 但是不推荐,一旦和win混用,易出问题\n## 推荐付费软件: tuxera ntfs for mac\n\nbrew install –cask  loopback  #(收费,可以免费试用)结合 mac 自带的录屏软件,可以录制有声音的视频,不管是系统声音还是软件声音都行.\n\n\n### 文本预览,在最新的mac 12中不可以了, 好像不支持m1\nbrew install –cask  qlstephen    # 下面三个是增加mac自带的文件预览功能\nbrew install –cask  qlcolorcode\nbrew install –cask  qlmarkdown  # markdown预览\n### 推荐付费 peek \n参考:\nhttps://mirrors.tuna.tsinghua.edu.cn/help/homebrew/\nhttps://blog.cnrainbird.com/index.php/2020/05/19/osx_geng_huan_brew_yuan_jie_jue_xia_zai_man_wen_ti/\n补充： 利用homebrew这个方法虽然好，但是对于旧电脑可能不适合，下载对应软件的二进制文件来的更可靠些"
  },
  {
    "objectID": "posts/macnote/mac重装系统2系统制作与安装.html",
    "href": "posts/macnote/mac重装系统2系统制作与安装.html",
    "title": "mac重装系统2系统制作与安装",
    "section": "",
    "text": "参考https://www.iplaysoft.com/macos-usb-install-drive.html 这篇文章制作U盘系统盘\n我个人推荐使用DiskMaker X启动盘制作.官网: https://diskmakerx.com/"
  },
  {
    "objectID": "posts/macnote/mac重装系统2系统制作与安装.html#如何进入系统盘",
    "href": "posts/macnote/mac重装系统2系统制作与安装.html#如何进入系统盘",
    "title": "mac重装系统2系统制作与安装",
    "section": "如何进入系统盘",
    "text": "如何进入系统盘\n关机重启, 长按Option 即可选择进入U盘, 先利用磁盘工具,格式化主磁盘,然后,退出,在安装.\n注意: 也可以在线安装…\n\nCommand（⌘） + R ：安装Mac之前安装的最新macOS，而不升级到更高的版本。\nOption  +  Command + R：升级到与Mac兼容的最新macOS。\nShift + Option + Command + R：安装Mac原本出厂搭载的macOS，或是最接近且依然可用的版本。\n\nhttps://blog.csdn.net/qq285744011/article/details/106987147"
  },
  {
    "objectID": "posts/macnote/mac重装系统2系统制作与安装.html#macos-u盘安装提示副本损坏听语音",
    "href": "posts/macnote/mac重装系统2系统制作与安装.html#macos-u盘安装提示副本损坏听语音",
    "title": "mac重装系统2系统制作与安装",
    "section": "MacOS U盘安装提示副本损坏听语音",
    "text": "MacOS U盘安装提示副本损坏听语音\n解决办法:\n\n断网以后 打开左上角实用工具-->终端, 输入\n\ndate 032208102015.20\n按回车键确认\n03是月，22是日，08是时，10是分，2015是年，20是秒 注意:先修改为现在的时间 , 还是不行再改往前修改为其他年份\n当提示时间修改完成后，推出终端，重新安装MacOS即可\nhttps://blog.csdn.net/li1339023842/article/details/102913864\nhttps://xitongtiankong.com/archives/58221\nhttps://jingyan.baidu.com/article/4d58d54155bd079dd5e9c043.html\n然后一直等着就好了. 感觉比win的U盘安装慢,(mac基本上安装了1个小时左右)"
  },
  {
    "objectID": "posts/macnote/mac重装系统3系统设置.html",
    "href": "posts/macnote/mac重装系统3系统设置.html",
    "title": "mac重装系统3系统设置",
    "section": "",
    "text": "新系统, 首先我们要安装一些必要的软件,和做一些基本的设置.\n本文做一些基本的设置\n\n\nsudo echo \"export CLICOLOR=1\" >> ~/.bash_profile\nsudo echo \"export LSCOLORS=gxfxcxdxbxegedabagacad\" >> ~/.bash_profile\nsudo echo \"export PS1='\\[\\e[01;33m\\][\\[\\e[01;35m\\]\\u\\[\\e[01;33m\\]@\\[\\e[01;34m\\]\\h:\\[\\e[01;33m\\]] \\[\\e[01;36m\\]\\w \\[\\e[01;32m\\]\\$ '\">> ~/.bash_profile\n\nsource ~/.bash_profile \n参考: 2019-11-19mac终端样式PS1\n命令行更改主机名\nscutil --set HostName lucky  # 重启终端\nhostname   #查看主机名\n\n备注： 还有在mac中使用vim, 可以有更好的方法 使用sublime\n\nvim a.txt \n# 可以用  \nsubl a.txt\nopen a.txt\n\n\n\n\n如果不能用则设置\n\n\n\n打开–wifi —>> 高级—> 设置 DNS ,\n添加\n114.114.114.114\n8.8.8.8\n\n\n\n\n不推荐 修改这个文件啦\n找到一个更好用的软件， https://gitee.com/docmirror/dev-sidecar 因此可以不设置/etc/hosts 文件啦\n\n$ sudo vim /etc/hosts\n#### 把下面的信息添加到 该文件中即可\n199.232.69.194   github.global.ssl.fastly.net\n140.82.113.4      github.com\n199.232.69.194    github.global.ssl.fastly.net\n185.199.110.153   assets-cdn.github.com\n140.82.113.4      gist.github.com\n\n#192.30.253.119    gist.github.com\n#199.232.28.133    assets-cdn.github.com\n199.232.68.133    raw.githubusercontent.com\n199.232.68.133    gist.githubusercontent.com\n199.232.68.133    cloud.githubusercontent.com\n199.232.68.133    camo.githubusercontent.com\n199.232.68.133    avatars0.githubusercontent.com\n199.232.68.133    avatars1.githubusercontent.com\n199.232.68.133    avatars2.githubusercontent.com\n199.232.68.133    avatars3.githubusercontent.com\n链接1\n链接2\n下一节,讲解软件的安装(主要用homebrew),如果上述不设置,可能软件安装不了"
  },
  {
    "objectID": "posts/macnote/tcping检测IP端口.html",
    "href": "posts/macnote/tcping检测IP端口.html",
    "title": "macOS tcping 检测IP端口",
    "section": "",
    "text": "$ brew install tcping\n$ which tcping\n\n\n\n$ tcping 14.215.177.39 80"
  },
  {
    "objectID": "posts/macnote/mac重装系统5sublime配置.html",
    "href": "posts/macnote/mac重装系统5sublime配置.html",
    "title": "mac重装系统5sublime配置",
    "section": "",
    "text": "1, 官网下载地址: http://www.sublimetext.com/\n2, 如果不安装插件,那还不如不装 sublime, 参考: https://packagecontrol.io/installation"
  },
  {
    "objectID": "posts/macnote/mac重装系统5sublime配置.html#插件的安装",
    "href": "posts/macnote/mac重装系统5sublime配置.html#插件的安装",
    "title": "mac重装系统5sublime配置",
    "section": "2. 插件的安装",
    "text": "2. 插件的安装\n\n2.1 安装Package Control\n\n现在sublime 4 已出，自带这个功能啦 （2021年11月更新）\n\n\n\n2.2 使用Package Control组件安装插件\nmac: Cmd+Shift+P（Win：Ctrl+Shift+P），输入 install 选中 Install Package 并回车，输入或选择你需要的插件回车就安装了（注意左下角的小文字变化，会提示安装成功），安装其它插件也类似."
  },
  {
    "objectID": "posts/macnote/mac重装系统5sublime配置.html#插件推荐",
    "href": "posts/macnote/mac重装系统5sublime配置.html#插件推荐",
    "title": "mac重装系统5sublime配置",
    "section": "3. 插件推荐",
    "text": "3. 插件推荐\n\n3.1 软件风格\n风格包网站: https://packagecontrol.io](https://packagecontrol.io/)\n风格包: Spacegray：\nhttps://packagecontrol.io/packages/Theme%20-%20Spacegray\n\nPreferences > color scheme >theme-spacegray\nPreferences-> setting 中设置以下\n\n\"theme\": \"Spacegray.sublime-theme\",\n\"color_scheme\": \"Packages/Theme - Spacegray/base16-ocean.dark.tmTheme\"\n\n\n3.2 主题推荐\n\n3.2.1 Material 主题\n\n安装主题\n\n快捷键 ⌘(Command) + ⇧(Shift) + P回车后输入Package Control:Install再回车，输入Material搜索主题进行安装。\n\n启用主题\n\n快捷键⌘(Command) + ⇧(Shift) + P回车后输入Material Theme: Activate theme回车后选择自己喜欢的配色方案。\n\n推荐Material Theme或者Material Theme Darker都相当赞。\n\n\n\n3.2.2 Materialize 主题\n\n安装主题\n\n快捷键 ⌘(Command) + ⇧(Shift) + P回车后输入Package Control:Install再回车，输入Materialize搜索主题进行安装。\n\n启用主题\n\n快捷键⌘(Command) + ⇧(Shift) + P回车后输入Activate Materialize Theme回车后选择自己喜欢的配色方案。\n\n推荐 Material Dracula或者Material Flatland\n\n\n\n\n3.2 常用插件推荐\n\nEmmet 写前端 html/css 用的\nHTM5\nConvertToUTF8 防止打开文件出现乱码\nCodecs33 同理打开文件防止出现乱码 ,建议和ConvertToUTF8一起安装\nChineseLocalizations 汉化 sublime\nSideBarEnhancements： 增强左边面板 https://packagecontrol.io/packages/SideBarEnhancements,可惜只能在project中使用\nAdvancedNewFile： 快速创建文件. (alt+ command +N)\nA File Icon : 左边面板显示图标\ndocblockr：代码注释提示插件 https://packagecontrol.io/packages/DocBlockr\nSideBarTools：扩展左侧面板（相对SideBarEnhancements少了一些功能）\nLocal History：本地历史记录 https://packagecontrol.io/packages/Local%20History\nColor Highlight: css中使得颜色直接在sublime中展示,(注意网上有很多人推荐Color Hightlighter插件,试了一下,此软件我的mac电脑不行), Color Highlight 插件直接下载即可用\n\n\n\nimage-20200520150836677\n\n\nColorPicker(调色板): CSS 中直接使用快捷键即可调出调色板,更改颜色.据说默认的快捷键有冲突,建议更改\n打开Sublime Text --> Preferences --> Browse Packages找到ColorPicker文件夹并进入（注意此处进入文件夹的方式），分别有linux mac和windows的快捷键设置文件，根据你的操作系统，打开相应文件即可设置, 如图\n\n\n\nimage-20200520151522130\n\n\n\n\n\n3.3 格式化代码\n首先通过以下路径打开用户按键绑定文件：\nPreferences → Key Bindings – User\n然后在其中添加以下代码（如果你有需要的话，其中的快捷键组合是可以自己定义的）：\n[\n    //格式化代码,single_line参数删除时，格式化只影响当前光标所在行\n    {\"keys\": [\"ctrl+alt+l\"], \"command\": \"reindent\" , \"args\": {\"single_line\": false}}\n]\n\n\n3.4 内容检索\n快速查找\n默认情况下，Sublime Text支持函数快速查找，按Ctrl+Shift+R打开查找面板，就可以快速定位函数所在的文件，如果安装了emmet插件将会失效，我们需要做以下操作进行修复。\n编辑 emmet插件配置项：\n{\"disabled_keymap_actions\": \"reflect_css_value\"}\n代码跟踪\n鼠标移动到函数上面，会自动显示方法的文件列表。或按 f12 键显示函数的文件列表\n\n\n3.5 快捷键\n使用快捷键可以显著提高开发效率，所以还是有必要掌握的。\n\n搜索文件：ctrl+p 输入文件名\n搜索函数/方法：ctrl+p 输入“文件名@方法名” 如 User@show\n跳转到指定行：ctrl+p 输入文件名:行号,只输入: 时在当前文件跳转\n查找当前文件方法：ctrl+r\n返回/前进编辑位置：Alt + -、Alt + Shift + -\n切换标签页：Ctrl + PgUp、Ctrl + PgDn\n选中单词：Ctrl + D 连续按会选中页面中所有单词，以实现批量编辑\n以单词为单位快速移动光标：Ctrl + ←、Ctrl + →\n选中当前行：Ctrl + L\n跳转到第几行：Ctrl+G\n跳转到对应括号：Ctrl+M\n开关侧栏：Ctrl+K+B\n选中当前括号内容，重复可选着括号本身：Ctrl+Shift+M\n注释当前html标签块：Ctrl+Shift+/\n专注编写模式：Shift+F11\n分屏显示：Alt+Shift+数字\nCtrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。\nCtrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。\nCtrl+Shift+[ 选中代码，按下快捷键，折叠代码。\nCtrl+Shift+] 选中代码，按下快捷键，展开代码。\n\n参考： https://curder.gitbooks.io/blog/"
  },
  {
    "objectID": "posts/macnote/mac硬盘文件变灰色.html",
    "href": "posts/macnote/mac硬盘文件变灰色.html",
    "title": "mac硬盘文件变灰色",
    "section": "",
    "text": "Mac下使用Mounty挂载NTFS出现了文件不能拷贝的解决办法，即文件出现灰色的现象。 或者使用付费的Tuxera 软件都会出现灰色文件,\n解决办法(在终端的灰色文件目录下面的命令即可)\nxattr -d com.apple.FinderInfo *"
  },
  {
    "objectID": "posts/macnote/mac重装系统1起因.html",
    "href": "posts/macnote/mac重装系统1起因.html",
    "title": "mac重装系统1起因",
    "section": "",
    "text": "gpl ghostscript 9.50: can't find initialization file gs_init.ps.\n\ngpl ghostscript 9.53.2: unrecoverable error, exit code 1\n心想不管了. 后又发现, 自己的毕业论文不能运行了? 心想我干脆更新了mactex(手贱)吧, 更新以后,有发现毕业论文还是报错, 以及以前的一些latex文稿都不能运行了. 我怀疑mactex 坏了, 于是卸载了, 重新安装……..,来回试了几遍,咦,咋回事,都不行??? 开始着急了. 心想该不是我把重要的文件删了吧? (巧在我这个时候, 利用了一个清理软件—–且输入了密码…) 于是开始了重装系统的想法……\n加上以前制作了U盘的mac系统.顺便尝试一下…….\n由于我设置的是时间作为顺序,因此更改一下时间,看起来有序"
  },
  {
    "objectID": "posts/macnote/mac终端样式PS1.html",
    "href": "posts/macnote/mac终端样式PS1.html",
    "title": "mac终端样式PS1",
    "section": "",
    "text": "首先，弄明白bash 和zsh….\n\n\nunix核的系统如linux、macos的shell 默认都是bash\n就如第一张图查询所示，mac有6个shell，默认是/bin/bash\n\n\ncat /etc/shells\n\n\n\necho $SHELL   # 方法一\necho $0       # 方法二\n\n\n\n切换到bash\nchsh -s /bin/bash\n切换到zsh\nchsh -s /bin/zsh\n记得输入切换命令后，要重新打开终端terminal才生效哦！\n\n\n\n\n\n\n我不能确定zsh是否需要iterm2作为基础，因此我安装了iterm2\n\n官网下载安装： https://www.iterm2.com/\nbrew 安装，$  brew cask install iterm2\n\n\n\n\n要自定义各种配置 我们就要修改默认shell 改用zsh，据说zsh比bash更强大（都是浮云 读者自行查找为啥强大吧），oh my zsh是开源的 a delightful & open source framework for Z-Shell，也就是说我们用它 配置zsh更容易\n直接去官网https://ohmyz.sh/ 找到如下命令复制到终端即可（如果遇到提示则输入Yes和回车即可）：\n$ sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n下载完毕后打开终端 样式已经变成zsh的默认样式robbyrussell了\n\n\n\n如果不喜欢oh my zsh的自带主题，可以通过修改配置文件 修改主题\n主题查看 -》oh my zsh github主题列表\n我认为好看的主题，mh 、ys、cloud\n打开配置文件\nvim ~/.zshrc\n找到ZSH_THEME，按‘ i ’编辑修改主题，编辑完毕后按键盘ese退出并输入”:wq”保存\nZSH_THEME=\"cloud\"\n双引号的内容就是你想修改成的主题名，我修改成的 就是cloud主题 还蛮可爱的\n然后重启终端就能发现样式起作用啦，或者不重启，使用命令更新配置\nsource  ~/.zshrc\n\n\n必须在处于zsh环境下才能卸载zsh, 它讲默认还原为系统指定的环境（mac则还原为 bash）,卸载命令如下.\nuninstall_oh_my_zsh\n\n\n\n\n\n还有一种方法是用mac自带的bash 进行修改， 这与上面的zsh有冲突，要么使用bash 要么使用zsh,不过zsh也有类似修改样式参数的命令。自行百度\n\n\n在osx系统下，对系统自带的终端进行配色可以通过设置PS1环境变量来实现的\n\n\n\n[\\u@\\h: ] \\w \\$\n示例：\n[elmman@192: ] ~ $\n\n\n\n把一下内容追加到 ~/.bash_profile这个文件中保存并退出\nexport CLICOLOR=1\nexport LSCOLORS=gxfxcxdxbxegedabagacad\nexport PS1='\\[\\e[01;33m\\][\\[\\e[01;32m\\]\\u\\[\\e[01;33m\\]@\\[\\e[01;35m\\]\\h:\\[\\e[01;33m\\]] \\[\\e[01;36m\\]\\w \\[\\e[01;32m\\]\\$ '\n$ vim ~/.bash_profile  % 把上述文件追加到这个文件末尾\n$ source ~/.bash_profile  % 使配置文件生效\n以一个颜色开始直到遇到另一个颜色命令结束\n上述有一个问题,就是当输入字符过多以后,不会自动换行,会导致字符重叠,建议后改为后面的这个\nexport CLICOLOR=1\nexport LSCOLORS=gxfxcxdxbxegedabagacad\nexport PS1='\\[\\e[01;33m\\][\\[\\e[01;35m\\]\\u\\[\\e[01;33m\\]@\\[\\e[01;34m\\]\\h:\\[\\e[01;33m\\]] \\[\\e[01;36m\\]\\w \\[\\e[01;32m\\]\\$ '\n参考: https://my.oschina.net/6tao/blog/1587040?p=1\n\n\n\n在mac下 一般用下面的结构来表示终端\n[\\u@\\h: ] \\w \\$\n实例：\n[zsc@zscdeMacBook-Air:] ~ $ \n\n（这里是elmman）\n@表示@（这里是@）\n（我的电脑是：zscdeMacBook-Air）\n:也是个无意义符号（这里是:） 一一对应的\n（这里是~，即家目录）\n$表示命令提示符（这里是$）\n如果发现用户名太长,可以修改, 参考: https://zhidao.baidu.com/question/1819212125670125468.html\n改成短的名字,有利用查看(个人觉得)\n\n\n\n\n默认 : [00m | 黄色 : [01;33m |\n—————- | —————– |\n黑色 : [01;30m | 蓝色 : [01;34m< |\n红色 : [01;31m | 洋红 : [01;35m |\n绿色 : [01;32m | 青色 : [01;36m< |\n                 | 白色 : [01;37m |\n其中还有两个命令：\n\nCLICOLOR=1表示开启命令行颜色设置。\nLSCOLORS=gxfxcxdxbxegedabagacad这个参数是对ls命令展示的内容进行配色，\n\n参考： https://blog.csdn.net/maotianyi941005/article/details/86505688\n参考 https://blog.csdn.net/xchenhao/article/details/90648636\n注意，如果使用mac –默认使用的是bash，因此推荐使用bash，这样能够保证mac 系统有些配置能正常运行，不然可能需要重新去配置zsh。\n\n\n\necho \"PS1='\\[\\e[01;33m\\][\\[\\e[01;32m\\]\\u\\[\\e[01;33m\\]@\\[\\e[01;35m\\]\\h:\\[\\e[01;33m\\]] \\[\\e[01;36m\\]\\w \\[\\e[01;32m\\]\\$ '\" >> ~/.bashrc \n\n# 记得重新运行\n$ source ~/.bashrc  % 使配置文件生效\n\n\n\n\nparse_git_branch() {\n    git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \\(.*\\)/ (\\1)/'\n}\nexport CLICOLOR=1\nexport LSCOLORS=gxfxcxdxbxegedabagacad\nexport PS1='\\[\\e[01;33m\\][\\[\\e[01;32m\\]\\u\\[\\e[01;33m\\]@\\[\\e[01;35m\\]\\h:\\[\\e[01;33m\\]] \\[\\e[01;36m\\]\\w\\[\\e[01;34m\\]$(parse_git_branch) \\[\\e[01;32m\\]\\$ '\n\n\n\n04"
  },
  {
    "objectID": "posts/macnote/mac重装系统6重置系统.html",
    "href": "posts/macnote/mac重装系统6重置系统.html",
    "title": "mac重装系统6抹掉所有内容和设置",
    "section": "",
    "text": "使用“系统偏好设置”中的“抹掉所有内容和设置”功能, 参考: https://support.apple.com/zh-cn/HT212749"
  },
  {
    "objectID": "posts/post/Nonstandard-calculation.html",
    "href": "posts/post/Nonstandard-calculation.html",
    "title": "非标准计算",
    "section": "",
    "text": "将表达式捕获转为语言对象，捕获表达式意味着防止表达式被执行，而将其本身存储为变量的形式。具有这个功能的函数有如下几个函数，注意其不同。\n\n​ quote()捕获到函数调用是会返回调用，而捕获到变量名时会返回一个符号，只要代码语法正确，它就会返回表示被捕获表达式本身的语言对象。即便函数不存在或者变量未定义，也可以捕获表达式本身。\n\nShow the coderm(list  = ls() )\nx =  quote(a+b)   # 定义一个表达式调用,但是这些变量没有定义\nx\n#> a + b\nclass(x)\n#> [1] \"call\"\ntypeof(x) # 变成语言对象类型，\n#> [1] \"language\"\n\nx = quote(rnorm)\nx\n#> rnorm\nclass(x)\n#> [1] \"name\"\ntypeof(x) # 变成符号对象类型，\n#> [1] \"symbol\"\n\nquote(xfun(a = 1:n)) # xfun都么有定义\n#> xfun(a = 1:n)\n\n\n理解：变量和符号对象的区别，以及函数和调用对象的区别。\n变量是对象的名称，而符号对象就是名称的本身。函数是可以被调用的对象，而调用对象是不会被计算的，它表示整个函数调用的语言对象。\neg： rnorm()就是一个可以被调用的函数(可以使用rnorm(5)进行调用,产生5个随机数)，但是quote(rnorm)返回一个符号对象，quote(rnorm(5))返回一个调用的对象，这两者都是语言本身。\n\nShow the coderm(list  = ls() )\nrnorm(5)\n#> [1]  0.6234336 -0.3239481  0.9412338  1.0596836 -0.1199735\nx = quote(rnorm)\ntypeof(x) # 返回一个符号对象\n#> [1] \"symbol\"\n\nx1 = quote(rnorm(5))\ntypeof(x1) # 返回一个调用对象\n#> [1] \"language\"\n\nas.list(x1) # 将调用对象转变为list，以便查看其内部结构， 可以看出本次调用有两部分组成：函数符号和一个参数\n#> [[1]]\n#> rnorm\n#> \n#> [[2]]\n#> [1] 5\nx1[[1]]\n#> rnorm\ntypeof(x1[[1]]) # 第一个元素是一个符号对象\n#> [1] \"symbol\"\nclass(x1[[1]])\n#> [1] \"name\"\n\nx1[[2]] \n#> [1] 5\ntypeof(x1[[2]]) # 第二个元素是一个数值\n#> [1] \"double\"\nclass(x1[[2]])\n#> [1] \"numeric\"\n## 总结：\n# 1.quote()将变量名捕获为符号对象，将一个函数捕获为调用对象。这两者都是语言对象\n# 2.可以用is.symbol() / is.name() 和 is.call 分别检查对象是否为符号对象或调用对象\n# 3.可以用is.language()同时检查符号和调用\n# 4. quote不把字面值(这里指的的表达式里使用数值等，而非数值变量。eg：数字、逻辑值、字符串)转变为语言对象，而是使其保持原样。--- 少用\n\n\n常常捕获全局环境中的表达式，函数环境中建议用substitute()，substitute()用于捕获表达式，并且用捕获的表达式替换现有的符号,而quote()不会进行第二步，把表达式替换成现有的符号\n\n\n​ substitute()可以作用任意的用户输入，该函数用于捕获表达式，并且用捕获的表达式替换现有的符号。常常与deparse()连用，出现在函数环境中(对表达式进行替换, 不能替换的则保留下来)。\ndeparse(substitute())函数以substitute() 的结果(一个表达式)为参数，并把它转变成一个字符串。\n\nShow the coderm(list  = ls() )\n### 1.substitute() 的使用对比\na = 1\nb = 2\nsubstitute(a + b + z)\n#> a + b + z\n\nf = function(){\n  a= 1\n  b = 2\n  substitute(a+b+z)\n}\nf()\n#> 1 + 2 + z\n\n\nsubstitute(a+b+z)\n#> a + b + z\nsubstitute(a+b+z , list(a = 1,b = 2))# 可以指定list(用名称--值的形式)，进行表达式替换\n#> 1 + 2 + z\n\n\nsubstitute()还可以替换表达式中的函数.\n\nShow the coderm(list  = ls() )\nsubstitute(a+b+z ,list('+' =quote(f)) )\n#> f(f(a, b), z)\nsubstitute(a+b+z ,list('+' =quote(sin)) )\n#> sin(sin(a, b), z)\nsubstitute(a+b+z ,list('+' =quote(`*`)) )\n#> a * b * z\n\n\n总结： 形式上，通过用list的形式对表达式中的所有名字进行检查替换(注意R中的所有动作都是函数，也可以对函数进行替换，如上)，其表达式中的名字替换规则如下：\n\n一个普通变量，它就被变量的值替换。\n一个函数参数，它就被与约定相关联的表达式替换。\n\n...，它被...的内容替换。\n以上都没有，则名字原样保留不变\n\n\n如果某个表达式存储在变量中，则它不会对表达式进行替换。这时需要用到pryr::substitute_q()函数。\n如果substitute它在全局环境中运行时(不特殊指定替换)，它从不进行替换，最好用作函数环境中。这时可以用pryr::subs()函数\n\n\nShow the coderm(list  = ls() )\nx  = quote(a + b)  # x存储了一个表达式\nsubstitute(x,list(a = 1,b = 2)) # 对x调用参数替换，无效\n#> x\n\na = 3 \nb = 5\nsubstitute(a+b+z) # 无效\n#> a + b + z\n\n\n注意：subs()和substitute()函数都可以用第二个参数重写正在使用的当前环境，并通过名字—值的列表对来提供替换。后面讲解subs()函数\n\n前面已学习函数调用相关内容，我们可以通过以下方式创建函数调用，注意：下面方式得到的结果等价(一模一样)\n\nShow the coderm(list  = ls() )\ncall_1 = quote(rnorm(5,mean = 3))\ncall_2 = call(\"rnorm\",5,mean = 3)\ncall_3 = as.call( list(quote(rnorm),5,mean = 3) )\n\ncall_1\n#> rnorm(5, mean = 3)\n\nidentical(call_1,call_2)\n#> [1] TRUE\nidentical(call_2,call_3)\n#> [1] TRUE\n\n\n\n前面提到substitute()存在缺点，当某个表达式存储在变量中，则它不会对表达式进行替换。此时可以用substitute_q()函数。\n\nShow the coderm(list  = ls() )\nx  = quote(a + b)  # x存储了一个表达式\nsubstitute(x,list(a = 1,b = 2)) # 对x调用参数替换，无效\n#> x\nsubstitute(a+b,list(a = 1,b = 2))  # 对直接变量参数替换,有效\n#> 1 + 2\n\npryr::substitute_q(x, list(a = 1,b=2)) # 对x调用参数替换，有效\n#> 1 + 2\n\n\n\nsubs()函数，可以在全局环境中直接对变量表达式替换。subs() 和substitute()的第二个参数都可以重写正在使用的当前环境。并通过名字—值的列表对来提供替换。这里就不在多说。subs的其它的工作方式与substitute()函数相同。\n\nShow the coderm(list  = ls() )\na = 1\nb = 2\nsubstitute(a+b) #  对变量表达式替换，无效\n#> a + b\npryr::subs(a+b) # 对变量表达式替换\n#> 1 + 2\n\nsubstitute(a+b,list(a =10,b =20)) \n#> 10 + 20\npryr::subs(a+b,list(a =10,b =20)) \n#> 10 + 20"
  },
  {
    "objectID": "posts/post/Nonstandard-calculation.html#对捕获表达式后的处理方式",
    "href": "posts/post/Nonstandard-calculation.html#对捕获表达式后的处理方式",
    "title": "非标准计算",
    "section": "2. 对捕获表达式后的处理方式",
    "text": "2. 对捕获表达式后的处理方式\n2.1. 执行表达式 — — eval()\n​ 前面提到的几种方法都可以捕获表达式，捕获表达式之后，下一步就是对其进行求值，可以用eval()函数完成。\n​ 比如：我们直接在控制台输入sin(1),其本质相当于执行了两个步骤：1.先捕获这个表达式，2在执行这个这个表达式。于是我们可以通过quote和eval进行分步计算.\n\nShow the coderm(list  = ls() )\nsin(1) # 直接一步完成。\n#> [1] 0.841471\n\n## 分步进行\ncall_1 = quote(sin(1))\ncall_1\n#> sin(1)\neval(call_1)\n#> [1] 0.841471\n\n\n# 由于quote可以捕获未定义的变量，故eval执行时可能会报错,eg:\ncall_2 = quote(sin(xx))\ncall_2\n#> sin(xx)\ntry( eval(call_2) )\n#> Error in eval(call_2) : object 'xx' not found\n\ntry( sin(xx) ) # 报错信息和上面的类似\n#> Error in try(sin(xx)) : object 'xx' not found\n\n\n# eval()可以允许我们提供一个list来计算给定的表达式，从而可以不需要创建一个变量x\n\neval(call_2 ,list(xx =1))\n#> [1] 0.841471\n\n\n2.2 eval 函数的用法\neval(expr, envir = parent.frame(),\n           enclos = if(is.list(envir) || is.pairlist(envir))\n                       parent.frame() else baseenv())\nexpr : 要计算的表达式，如果只提供这一个参数，即在当前环境中对表达式求值\nenvir： 是一个用于计算expr的环境，数据框或者列表。\nencols： 如果在envir中找不到相应的变量，它会在encols参数中找，然后在encols参数的父环境中查找。如果能在envir参数中找到，则encols会被忽略。\n以下有是哪个便捷函数：(其实本质上都可以用eval来实现)\n\n\nevalq(expr, envir, enclos) 等价于 eval(quote(expr),…) ，在当前环境中计算表达式。\n\neval.parent(expr, n = 1) 等价于 eval(expr,parent.frame(n))，在父环境中计算表达式。\n\nlocal(expr, envir = new.env()) 等价于 eval(quote(expr),environment = new.nev())，在新环境中计算表达式。\n\n\nShow the coderm(list  = ls() )\n## 参考《R语言编程指南》\nrm(list = ls())\nqs = function(x,range){\n  range = substitute(range)\n  selector = eval(range,list(. = length(x)), parent.frame())\n  # parent.frame()指的是eval()的调用环境，也就是qs()的执行环境。\n  return( x[selector])\n}\n\n# trim_margin删除向量x的前n个元素和后n个元素，保留中间的元素\ntrim_margin = function(x,n){\n  qs(x,(n+1):(.-n-1))\n}\nx= 1:10\ntrim_margin(x,3)\n#> [1] 4 5 6\n\n\n2 .3 .表达式与字符串相互转变\n\n\ndeparse(): 将表达式转变为字符串.\n\nparse(): 将字符串转变成表达式.由于parse的主要用途是将代码文件解析到硬盘，所以第一个参数是文件路径。注意如果代码是字符向量，那么需要使用text参数。\n\nparse(file = \"\", n = NULL, text = NULL, prompt = \"?\",\n      keep.source = getOption(\"keep.source\"), srcfile,\n      encoding = \"unknown\")\n      \ndeparse(expr, width.cutoff = 60L,\n        backtick = mode(expr) %in% c(\"call\", \"expression\", \"(\", \"function\"),\n        control = c(\"keepNA\", \"keepInteger\", \"niceNames\", \"showAttributes\"),\n        nlines = -1L)\n\nShow the coderm(list = ls())\n\nz <- quote(y <- x*10) # 表达式里面用 <- ,等号为出错\ndeparse(z)\n#> [1] \"y <- x * 10\"\n\nparse(text = deparse(z))\n#> expression(y <- x * 10)\n\n## 把代码写入一个文件中\n# cat(\"x <- c(1, 4)\\n  x ^ 3 -10 ; outer(1:7, 5:9)\\n\", file = 'aa.txt')\n# parse(file = 'a.txt', n = 3)# 把文件中的代码转变为表达式\n\n\n\nShow the codesessionInfo()\n#> R version 4.2.1 (2022-06-23)\n#> Platform: aarch64-apple-darwin20 (64-bit)\n#> Running under: macOS Monterey 12.5.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n#> \n#> locale:\n#> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] Rcpp_1.0.9        codetools_0.2-18  digest_0.6.29     jsonlite_1.8.0   \n#>  [5] magrittr_2.0.3    evaluate_0.16     rlang_1.0.4       stringi_1.7.8    \n#>  [9] cli_3.3.0         pryr_0.1.5        rstudioapi_0.14   rmarkdown_2.16.1 \n#> [13] tools_4.2.1       stringr_1.4.1     htmlwidgets_1.5.4 xfun_0.32        \n#> [17] yaml_2.3.5        fastmap_1.1.0     compiler_4.2.1    htmltools_0.5.3  \n#> [21] knitr_1.40"
  },
  {
    "objectID": "posts/post/Nonstandard-calculation.html#参考",
    "href": "posts/post/Nonstandard-calculation.html#参考",
    "title": "非标准计算",
    "section": "参考",
    "text": "参考\n《高级R语言编程》\n《R语言编程指南》\n《R语言核心编程技巧第二版》"
  },
  {
    "objectID": "posts/post/独热编码--哑变量.html",
    "href": "posts/post/独热编码--哑变量.html",
    "title": "独热编码–哑变量",
    "section": "",
    "text": "独热编码： n种状态 转变为n列\n哑变量： n种状态转变为n-1列（目的：为了防止共线性的问题）\n\nShow the codetestFrame <- data.frame(First=sample(1:10, 20, replace=TRUE),\n                        Second=sample(1:20, 20, replace=TRUE),\n                        Third=sample(1:10, 20, replace=TRUE),\n                        Fourth=factor(rep(c(\"=A\", \"=B\", \"=C\", \"=D\"),5)),\n                        Fifth=ordered(rep(c(\"=E\", \"=F\", \"=G\",\"=H\", \"=I\"), 4)),\n                        Sixth=rep(c(\"=a\", \"=b\"), 10),\n                        Seventh=factor(c(rep(c(\"=J\",\"=K\",\"=L\"),6),\"=J\",\"=K\")) , \n                        stringsAsFactors=F)\n\nhead(testFrame)\n#>   First Second Third Fourth Fifth Sixth Seventh\n#> 1     8     14    10     =A    =E    =a      =J\n#> 2     2     14     4     =B    =F    =b      =K\n#> 3     8      5     7     =C    =G    =a      =L\n#> 4     4     14     4     =D    =H    =b      =J\n#> 5     2      6     3     =A    =I    =a      =K\n#> 6    10     14     9     =B    =E    =b      =L\nstr(testFrame)\n#> 'data.frame':    20 obs. of  7 variables:\n#>  $ First  : int  8 2 8 4 2 10 8 2 4 3 ...\n#>  $ Second : int  14 14 5 14 6 14 16 6 4 4 ...\n#>  $ Third  : int  10 4 7 4 3 9 7 3 3 10 ...\n#>  $ Fourth : Factor w/ 4 levels \"=A\",\"=B\",\"=C\",..: 1 2 3 4 1 2 3 4 1 2 ...\n#>  $ Fifth  : Ord.factor w/ 5 levels \"=E\"<\"=F\"<\"=G\"<..: 1 2 3 4 5 1 2 3 4 5 ...\n#>  $ Sixth  : chr  \"=a\" \"=b\" \"=a\" \"=b\" ...\n#>  $ Seventh: Factor w/ 3 levels \"=J\",\"=K\",\"=L\": 1 2 3 1 2 3 1 2 3 1 ...\n\n\n\n\nShow the code###########################################################################\n#### 以下涉及公式的地方，\n#### 公式右边,-1代表不要截距项同时生成独热编码（只在一个因子变量的情况下）\n#### 公式左边为要排除的变量\n###########################################################################\n\n\n###### 独热编码1  \nlibrary(data.table)\nlibrary(magrittr)\niris_dt = data.table(iris)\nlibrary(mltools)## 此编码必须依赖data.table\none_hot(iris_dt)%>% head()\n#>    Sepal.Length Sepal.Width Petal.Length Petal.Width Species_setosa\n#> 1:          5.1         3.5          1.4         0.2              1\n#> 2:          4.9         3.0          1.4         0.2              1\n#> 3:          4.7         3.2          1.3         0.2              1\n#> 4:          4.6         3.1          1.5         0.2              1\n#> 5:          5.0         3.6          1.4         0.2              1\n#> 6:          5.4         3.9          1.7         0.4              1\n#>    Species_versicolor Species_virginica\n#> 1:                  0                 0\n#> 2:                  0                 0\n#> 3:                  0                 0\n#> 4:                  0                 0\n#> 5:                  0                 0\n#> 6:                  0                 0\n\n\n\n\nShow the code###### 独热编码2\nlibrary(onehot) #先编码后预测输出独热编码\nencoder <- onehot(iris)\nx <- predict(encoder, iris)\nx %>% head()\n#>      Sepal.Length Sepal.Width Petal.Length Petal.Width Species=setosa\n#> [1,]          5.1         3.5          1.4         0.2              1\n#> [2,]          4.9         3.0          1.4         0.2              1\n#> [3,]          4.7         3.2          1.3         0.2              1\n#> [4,]          4.6         3.1          1.5         0.2              1\n#> [5,]          5.0         3.6          1.4         0.2              1\n#> [6,]          5.4         3.9          1.7         0.4              1\n#>      Species=versicolor Species=virginica\n#> [1,]                  0                 0\n#> [2,]                  0                 0\n#> [3,]                  0                 0\n#> [4,]                  0                 0\n#> [5,]                  0                 0\n#> [6,]                  0                 0\n\n## 类似的还有 caret::dummyVars函数\nlibrary(caret)\ndummy <- dummyVars(~ ., data = iris, fullRank = TRUE)\npredict(dummy,iris)  %>% head()\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species.versicolor\n#> 1          5.1         3.5          1.4         0.2                  0\n#> 2          4.9         3.0          1.4         0.2                  0\n#> 3          4.7         3.2          1.3         0.2                  0\n#> 4          4.6         3.1          1.5         0.2                  0\n#> 5          5.0         3.6          1.4         0.2                  0\n#> 6          5.4         3.9          1.7         0.4                  0\n#>   Species.virginica\n#> 1                 0\n#> 2                 0\n#> 3                 0\n#> 4                 0\n#> 5                 0\n#> 6                 0\n\ndummy <- dummyVars(~.-1, data = iris, fullRank = TRUE)\npredict(dummy,iris)  %>% head()\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species.setosa\n#> 1          5.1         3.5          1.4         0.2              1\n#> 2          4.9         3.0          1.4         0.2              1\n#> 3          4.7         3.2          1.3         0.2              1\n#> 4          4.6         3.1          1.5         0.2              1\n#> 5          5.0         3.6          1.4         0.2              1\n#> 6          5.4         3.9          1.7         0.4              1\n#>   Species.versicolor Species.virginica\n#> 1                  0                 0\n#> 2                  0                 0\n#> 3                  0                 0\n#> 4                  0                 0\n#> 5                  0                 0\n#> 6                  0                 0\n\n\n\n\nShow the code###### 独热编码3\nmodel.matrix(~.-1,iris)  %>% head()\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Speciessetosa\n#> 1          5.1         3.5          1.4         0.2             1\n#> 2          4.9         3.0          1.4         0.2             1\n#> 3          4.7         3.2          1.3         0.2             1\n#> 4          4.6         3.1          1.5         0.2             1\n#> 5          5.0         3.6          1.4         0.2             1\n#> 6          5.4         3.9          1.7         0.4             1\n#>   Speciesversicolor Speciesvirginica\n#> 1                 0                0\n#> 2                 0                0\n#> 3                 0                0\n#> 4                 0                0\n#> 5                 0                0\n#> 6                 0                0\n#### 类似Matrix包，只不过这个包用的是系数矩阵，这个包对大数据的时候特别友好\nlibrary(Matrix)\nsparse.model.matrix(~.-1, data = iris)%>% head()\n#> 6 x 7 sparse Matrix of class \"dgCMatrix\"\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Speciessetosa\n#> 1          5.1         3.5          1.4         0.2             1\n#> 2          4.9         3.0          1.4         0.2             1\n#> 3          4.7         3.2          1.3         0.2             1\n#> 4          4.6         3.1          1.5         0.2             1\n#> 5          5.0         3.6          1.4         0.2             1\n#> 6          5.4         3.9          1.7         0.4             1\n#>   Speciesversicolor Speciesvirginica\n#> 1                 .                .\n#> 2                 .                .\n#> 3                 .                .\n#> 4                 .                .\n#> 5                 .                .\n#> 6                 .                .\n\n\n\n\nShow the code\n###### 独热编码4\nlibrary(qdapTools)\n#只适用于factor向量，不能用数据框，必须是一列，生成的列名为因子水平\nmtabulate(iris$Species) %>% head()\n#>   setosa versicolor virginica\n#> 1      1          0         0\n#> 2      1          0         0\n#> 3      1          0         0\n#> 4      1          0         0\n#> 5      1          0         0\n#> 6      1          0         0\n# 同理,下面这个也只能适用于只含有因子的向量（不能用于数据框），生成的列名为因子水平\nlibrary(nnet)\nclass.ind(iris$Species) %>% head()\n#>      setosa versicolor virginica\n#> [1,]      1          0         0\n#> [2,]      1          0         0\n#> [3,]      1          0         0\n#> [4,]      1          0         0\n#> [5,]      1          0         0\n#> [6,]      1          0         0\n\n\n\n\nShow the code###### 独热编码5\n## 只能用于因子的数据框，不能包含向量or数字列\nlibrary(ade4)\nacm.disjonctif(iris[,5,drop=F]) %>% head()\n#>   Species.setosa Species.versicolor Species.virginica\n#> 1              1                  0                 0\n#> 2              1                  0                 0\n#> 3              1                  0                 0\n#> 4              1                  0                 0\n#> 5              1                  0                 0\n#> 6              1                  0                 0\n\n\n\n\n好像没有这个dummies包了\n\n\nShow the code###### 独热编码 6  ************\nlibrary(dummies)\n# 全部转换，指定列, 设置all=F  只显示被转换的因子变量\nalldata <- dummy.data.frame(iris, names=c(\"Species\"), sep=\"_\",all=T)\nalldata %>% head() \n\n#把所有factor类型都转变为独热编码\ndummy.data.frame(iris, dummy.class=\"factor\") %>% head()\ndummy.data.frame(testFrame, dummy.class=\"factor\") %>% head() \n\n\n\n\nShow the code###### 独热编码7\nlibrary(useful)\nbuild.x(~.,iris)%>% head()\n#>   (Intercept) Sepal.Length Sepal.Width Petal.Length Petal.Width\n#> 1           1          5.1         3.5          1.4         0.2\n#> 2           1          4.9         3.0          1.4         0.2\n#> 3           1          4.7         3.2          1.3         0.2\n#> 4           1          4.6         3.1          1.5         0.2\n#> 5           1          5.0         3.6          1.4         0.2\n#> 6           1          5.4         3.9          1.7         0.4\n#>   Speciesversicolor Speciesvirginica\n#> 1                 0                0\n#> 2                 0                0\n#> 3                 0                0\n#> 4                 0                0\n#> 5                 0                0\n#> 6                 0                0\nbuild.x(~.-1,iris)%>% head()\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Speciessetosa\n#> 1          5.1         3.5          1.4         0.2             1\n#> 2          4.9         3.0          1.4         0.2             1\n#> 3          4.7         3.2          1.3         0.2             1\n#> 4          4.6         3.1          1.5         0.2             1\n#> 5          5.0         3.6          1.4         0.2             1\n#> 6          5.4         3.9          1.7         0.4             1\n#>   Speciesversicolor Speciesvirginica\n#> 1                 0                0\n#> 2                 0                0\n#> 3                 0                0\n#> 4                 0                0\n#> 5                 0                0\n#> 6                 0                0\nbuild.y(Species~.,data = iris) # 直接把公式左边的保留即可，不做任何修改\n#>   [1] setosa     setosa     setosa     setosa     setosa     setosa    \n#>   [7] setosa     setosa     setosa     setosa     setosa     setosa    \n#>  [13] setosa     setosa     setosa     setosa     setosa     setosa    \n#>  [19] setosa     setosa     setosa     setosa     setosa     setosa    \n#>  [25] setosa     setosa     setosa     setosa     setosa     setosa    \n#>  [31] setosa     setosa     setosa     setosa     setosa     setosa    \n#>  [37] setosa     setosa     setosa     setosa     setosa     setosa    \n#>  [43] setosa     setosa     setosa     setosa     setosa     setosa    \n#>  [49] setosa     setosa     versicolor versicolor versicolor versicolor\n#>  [55] versicolor versicolor versicolor versicolor versicolor versicolor\n#>  [61] versicolor versicolor versicolor versicolor versicolor versicolor\n#>  [67] versicolor versicolor versicolor versicolor versicolor versicolor\n#>  [73] versicolor versicolor versicolor versicolor versicolor versicolor\n#>  [79] versicolor versicolor versicolor versicolor versicolor versicolor\n#>  [85] versicolor versicolor versicolor versicolor versicolor versicolor\n#>  [91] versicolor versicolor versicolor versicolor versicolor versicolor\n#>  [97] versicolor versicolor versicolor versicolor virginica  virginica \n#> [103] virginica  virginica  virginica  virginica  virginica  virginica \n#> [109] virginica  virginica  virginica  virginica  virginica  virginica \n#> [115] virginica  virginica  virginica  virginica  virginica  virginica \n#> [121] virginica  virginica  virginica  virginica  virginica  virginica \n#> [127] virginica  virginica  virginica  virginica  virginica  virginica \n#> [133] virginica  virginica  virginica  virginica  virginica  virginica \n#> [139] virginica  virginica  virginica  virginica  virginica  virginica \n#> [145] virginica  virginica  virginica  virginica  virginica  virginica \n#> Levels: setosa versicolor virginica\n\n\n\n\nShow the code###### 独热编码8\nhead(model.matrix(First~ Second + Fourth + Fifth, testFrame)) \n#>   (Intercept) Second Fourth=B Fourth=C Fourth=D       Fifth.L    Fifth.Q\n#> 1           1     14        0        0        0 -6.324555e-01  0.5345225\n#> 2           1     14        1        0        0 -3.162278e-01 -0.2672612\n#> 3           1      5        0        1        0 -1.481950e-18 -0.5345225\n#> 4           1     14        0        0        1  3.162278e-01 -0.2672612\n#> 5           1      6        0        0        0  6.324555e-01  0.5345225\n#> 6           1     14        1        0        0 -6.324555e-01  0.5345225\n#>         Fifth.C    Fifth^4\n#> 1 -3.162278e-01  0.1195229\n#> 2  6.324555e-01 -0.4780914\n#> 3 -3.893692e-16  0.7171372\n#> 4 -6.324555e-01 -0.4780914\n#> 5  3.162278e-01  0.1195229\n#> 6 -3.162278e-01  0.1195229\nhead(model.matrix(First~ .-1, testFrame))\n#>   Second Third Fourth=A Fourth=B Fourth=C Fourth=D       Fifth.L    Fifth.Q\n#> 1     14    10        1        0        0        0 -6.324555e-01  0.5345225\n#> 2     14     4        0        1        0        0 -3.162278e-01 -0.2672612\n#> 3      5     7        0        0        1        0 -1.481950e-18 -0.5345225\n#> 4     14     4        0        0        0        1  3.162278e-01 -0.2672612\n#> 5      6     3        1        0        0        0  6.324555e-01  0.5345225\n#> 6     14     9        0        1        0        0 -6.324555e-01  0.5345225\n#>         Fifth.C    Fifth^4 Sixth=b Seventh=K Seventh=L\n#> 1 -3.162278e-01  0.1195229       0         0         0\n#> 2  6.324555e-01 -0.4780914       1         1         0\n#> 3 -3.893692e-16  0.7171372       0         0         1\n#> 4 -6.324555e-01 -0.4780914       1         0         0\n#> 5  3.162278e-01  0.1195229       0         1         0\n#> 6 -3.162278e-01  0.1195229       1         0         1\nhead(model.matrix(First~ ., testFrame))\n#>   (Intercept) Second Third Fourth=B Fourth=C Fourth=D       Fifth.L    Fifth.Q\n#> 1           1     14    10        0        0        0 -6.324555e-01  0.5345225\n#> 2           1     14     4        1        0        0 -3.162278e-01 -0.2672612\n#> 3           1      5     7        0        1        0 -1.481950e-18 -0.5345225\n#> 4           1     14     4        0        0        1  3.162278e-01 -0.2672612\n#> 5           1      6     3        0        0        0  6.324555e-01  0.5345225\n#> 6           1     14     9        1        0        0 -6.324555e-01  0.5345225\n#>         Fifth.C    Fifth^4 Sixth=b Seventh=K Seventh=L\n#> 1 -3.162278e-01  0.1195229       0         0         0\n#> 2  6.324555e-01 -0.4780914       1         1         0\n#> 3 -3.893692e-16  0.7171372       0         0         1\n#> 4 -6.324555e-01 -0.4780914       1         0         0\n#> 5  3.162278e-01  0.1195229       0         1         0\n#> 6 -3.162278e-01  0.1195229       1         0         1\n\n\n\n\nShow the code##独热编码 转变为原始变量 （即逆运算）\n\nd = model.matrix(~Species-1 ,iris) \nd =data.frame(d)\nifelse(rowSums(d)>=1,names(d)[max.col(d)],NA)\n#>                   1                   2                   3                   4 \n#>     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\" \n#>                   5                   6                   7                   8 \n#>     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\" \n#>                   9                  10                  11                  12 \n#>     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\" \n#>                  13                  14                  15                  16 \n#>     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\" \n#>                  17                  18                  19                  20 \n#>     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\" \n#>                  21                  22                  23                  24 \n#>     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\" \n#>                  25                  26                  27                  28 \n#>     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\" \n#>                  29                  30                  31                  32 \n#>     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\" \n#>                  33                  34                  35                  36 \n#>     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\" \n#>                  37                  38                  39                  40 \n#>     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\" \n#>                  41                  42                  43                  44 \n#>     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\" \n#>                  45                  46                  47                  48 \n#>     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\"     \"Speciessetosa\" \n#>                  49                  50                  51                  52 \n#>     \"Speciessetosa\"     \"Speciessetosa\" \"Speciesversicolor\" \"Speciesversicolor\" \n#>                  53                  54                  55                  56 \n#> \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \n#>                  57                  58                  59                  60 \n#> \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \n#>                  61                  62                  63                  64 \n#> \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \n#>                  65                  66                  67                  68 \n#> \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \n#>                  69                  70                  71                  72 \n#> \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \n#>                  73                  74                  75                  76 \n#> \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \n#>                  77                  78                  79                  80 \n#> \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \n#>                  81                  82                  83                  84 \n#> \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \n#>                  85                  86                  87                  88 \n#> \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \n#>                  89                  90                  91                  92 \n#> \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \n#>                  93                  94                  95                  96 \n#> \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \n#>                  97                  98                  99                 100 \n#> \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \"Speciesversicolor\" \n#>                 101                 102                 103                 104 \n#>  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\" \n#>                 105                 106                 107                 108 \n#>  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\" \n#>                 109                 110                 111                 112 \n#>  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\" \n#>                 113                 114                 115                 116 \n#>  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\" \n#>                 117                 118                 119                 120 \n#>  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\" \n#>                 121                 122                 123                 124 \n#>  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\" \n#>                 125                 126                 127                 128 \n#>  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\" \n#>                 129                 130                 131                 132 \n#>  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\" \n#>                 133                 134                 135                 136 \n#>  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\" \n#>                 137                 138                 139                 140 \n#>  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\" \n#>                 141                 142                 143                 144 \n#>  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\" \n#>                 145                 146                 147                 148 \n#>  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\"  \"Speciesvirginica\" \n#>                 149                 150 \n#>  \"Speciesvirginica\"  \"Speciesvirginica\"\n\n\n\nShow the codesessionInfo()\n#> R version 4.2.1 (2022-06-23)\n#> Platform: aarch64-apple-darwin20 (64-bit)\n#> Running under: macOS Monterey 12.5.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n#> \n#> locale:\n#> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> other attached packages:\n#>  [1] useful_1.2.6      ade4_1.7-19       nnet_7.3-17       qdapTools_1.3.5  \n#>  [5] Matrix_1.4-1      caret_6.0-93      lattice_0.20-45   ggplot2_3.3.6    \n#>  [9] onehot_0.1.1      mltools_0.3.5     magrittr_2.0.3    data.table_1.14.2\n#> \n#> loaded via a namespace (and not attached):\n#>  [1] Rcpp_1.0.9           lubridate_1.8.0      listenv_0.8.0       \n#>  [4] class_7.3-20         assertthat_0.2.1     digest_0.6.29       \n#>  [7] ipred_0.9-13         foreach_1.5.2        utf8_1.2.2          \n#> [10] parallelly_1.32.1    chron_2.3-57         R6_2.5.1            \n#> [13] plyr_1.8.7           stats4_4.2.1         hardhat_1.2.0       \n#> [16] evaluate_0.16        pillar_1.8.1         rlang_1.0.4         \n#> [19] rstudioapi_0.14      rpart_4.1.16         rmarkdown_2.16.1    \n#> [22] splines_4.2.1        gower_1.0.0          stringr_1.4.1       \n#> [25] htmlwidgets_1.5.4    RCurl_1.98-1.8       munsell_0.5.0       \n#> [28] compiler_4.2.1       xfun_0.32            pkgconfig_2.0.3     \n#> [31] globals_0.16.0       htmltools_0.5.3      tidyselect_1.1.2    \n#> [34] tibble_3.1.8         prodlim_2019.11.13   codetools_0.2-18    \n#> [37] fansi_1.0.3          future_1.27.0        dplyr_1.0.9         \n#> [40] withr_2.5.0          bitops_1.0-7         ModelMetrics_1.2.2.2\n#> [43] MASS_7.3-58.1        recipes_1.0.1        grid_4.2.1          \n#> [46] nlme_3.1-159         jsonlite_1.8.0       gtable_0.3.0        \n#> [49] lifecycle_1.0.1      DBI_1.1.3            pROC_1.18.0         \n#> [52] scales_1.2.1         future.apply_1.9.0   cli_3.3.0           \n#> [55] stringi_1.7.8        reshape2_1.4.4       timeDate_4021.104   \n#> [58] generics_0.1.3       vctrs_0.4.1          lava_1.6.10         \n#> [61] iterators_1.0.14     tools_4.2.1          glue_1.6.2          \n#> [64] purrr_0.3.4          parallel_4.2.1       fastmap_1.1.0       \n#> [67] survival_3.4-0       yaml_2.3.5           colorspace_2.0-3    \n#> [70] knitr_1.40"
  },
  {
    "objectID": "posts/post/GA.html",
    "href": "posts/post/GA.html",
    "title": "GA包—遗传算法",
    "section": "",
    "text": "2022年3月23更新\n参考: Genetic Algorithms • GA (luca-scr.github.io)"
  },
  {
    "objectID": "posts/post/GA.html#用法默认求解最大值",
    "href": "posts/post/GA.html#用法默认求解最大值",
    "title": "GA包—遗传算法",
    "section": "1、用法：(默认求解最大值)",
    "text": "1、用法：(默认求解最大值)\n\n注意: 默认求解最大值\n\n\n\nga(type = c(\"binary\", \"real-valued\", \"permutation\"),   \n   fitness, ...,                            #  fitness:适应度函数 \n   lower, upper,                                #解得下界/解得上界(多元变量为一个向量)\n   nBits,                               #一个种群用二进制编码的长度是多少(长度越大代表精度越高,一般等于变量的个数即可)\n   population = gaControl(type)$population,     # 初始种群\n   selection = gaControl(type)$selection,       #选择\n   crossover = gaControl(type)$crossover,       #交叉\n   mutation = gaControl(type)$mutation,         #变异\n   popSize = 50,                               #种群大小\n   pcrossover = 0.8,                           #交叉概率（默认0.8）\n   pmutation = 0.1,                            #变异概率（默认0.1）\n   elitism = base::max(1, round(popSize*0.05)),   #代沟(默认情况下,前5%个体将在每个迭代中保留)\n   updatePop = FALSE,\n   postFitness = NULL,\n   maxiter = 100,                               # 最大迭代次数(默认100)\n   run = maxiter,                                #表示连续出现一定数目的目标函数值未改变,则GA终止搜索\n   maxFitness = Inf,                            # 适应度函数的上界,GA搜索后中断\n   names = NULL,                                # 表示决策变量名的向量\n   suggestions = NULL,                          # 包含某些指定的初始种群\n   optim = FALSE,                             \n   # optim默认值为FALSE，用于确定是否应使用使用通用优化算法的局部搜索。有关更多详细信息和更精细的控制，请参阅参数optimArgs。\n   # 简单理解, 即optim= T时, 表面进过一定次数的迭代后从 GA 最优解开始最为 optim函数的初始值,开始进行局部优化\n   # optimArgs 控制本地搜索算法的列表，具有以下组件：\n   optimArgs = list(method = \"L-BFGS-B\", # 可以是optim函数中的方法\n                    poptim = 0.1,# 范围[0，1]中的值，指定在每次GA迭代时执行局部搜索的概率(默认值为0.1)。\n                    pressel = 0.5,\n                    control = list(fnscale = -1, maxit = 100)),\n   keepBest = FALSE,                 #一个逻辑参数，指定每次迭代的最佳解决方案是否应该保存在一个名为 bestSol 的槽中。\n   parallel = FALSE,                 #是否采用并行运算\n   monitor = if(interactive())        #绘图用的,监控遗传算法的运行状况\n               { if(is.RStudio()) gaMonitor else gaMonitor2 } \n             else FALSE,\n   seed = NULL)         #一个整数值包含随机数发生器的状态。这个参数可以用来复制GA搜索的结果。"
  },
  {
    "objectID": "posts/post/GA.html#参数说明",
    "href": "posts/post/GA.html#参数说明",
    "title": "GA包—遗传算法",
    "section": "2、参数说明",
    "text": "2、参数说明\ntype: 解得编码类型\n    1.  binary :二进制编码\n    2.  real-valued：实数浮点编码\n    3.  permutation：问题涉及到重新排序的列表，字符串编码。可求解TSP问题\n通过gaControl设置默认的遗传算子。检索当前设置操作:\n    gaControl(“binary”)\n    gaControl(“real-valued”)\n    gaControl(“permutation”)"
  },
  {
    "objectID": "posts/post/GA.html#举例",
    "href": "posts/post/GA.html#举例",
    "title": "GA包—遗传算法",
    "section": "3.举例",
    "text": "3.举例\n3.1. 一元函数:\n\n函数为: $ |x|+cos(x) $\n该函数有最小值$ f(0)=1（−R x R)$\n\n\nShow the coderm(list = ls())\nlibrary(GA)\n#>  Loading required package: foreach\n#>  Loading required package: iterators\n#>  Package 'GA' version 3.2.2\n#>  Type 'citation(\"GA\")' for citing this R package in publications.\n#>  \n#>  Attaching package: 'GA'\n#>  The following object is masked from 'package:utils':\n#>  \n#>      de\nf = function(x)  abs(x)+cos(x)\ncurve(f, -20, 20)\n\n\n\n\n\nShow the codefitness = function(x) -f(x)  #由于这个函数默认求解最大值，所以我们求-f(x)的最大值\nGA = ga(type = \"real-valued\", fitness = fitness, lower = -20, upper = 20,monitor=F)# monitor 禁止打印信息\n\nGA  ##返回的结果GA为S4对象，一个GA类型 调用其属性用@符号 \n#>  An object of class \"ga\"\n#>  \n#>  Call:\n#>  ga(type = \"real-valued\", fitness = fitness, lower = -20, upper = 20,     monitor = F)\n#>  \n#>  Available slots:\n#>   [1] \"call\"         \"type\"         \"lower\"        \"upper\"        \"nBits\"       \n#>   [6] \"names\"        \"popSize\"      \"iter\"         \"run\"          \"maxiter\"     \n#>  [11] \"suggestions\"  \"population\"   \"elitism\"      \"pcrossover\"   \"pmutation\"   \n#>  [16] \"optim\"        \"fitness\"      \"summary\"      \"bestSol\"      \"fitnessValue\"\n#>  [21] \"solution\"\nGA@solution # 返回最优解\n#>                  x1\n#>  [1,] -3.048778e-05\nsummary(GA)\n#>  ── Genetic Algorithm ─────────────────── \n#>  \n#>  GA settings: \n#>  Type                  =  real-valued \n#>  Population size       =  50 \n#>  Number of generations =  100 \n#>  Elitism               =  2 \n#>  Crossover probability =  0.8 \n#>  Mutation probability  =  0.1 \n#>  Search domain = \n#>         x1\n#>  lower -20\n#>  upper  20\n#>  \n#>  GA results: \n#>  Iterations             = 100 \n#>  Fitness function value = -1.00003 \n#>  Solution = \n#>                  x1\n#>  [1,] -3.048778e-05\n\n\n\n## 画图--- 展示迭代信息\nplot(GA)  #  #默认情况下，ga函数通过打印每个迭代的平均值和最佳适应度值来监视搜索,画出每代最佳的适应度函数值与每代的平均适应度函数值\n\n\n\nShow the code\n\n# ####画出最优值\n# curve(f, -20, 20)  #\n# abline(v = GA@solution, lty = 3)\n\n\n\nShow the code### binary 测试\nGA2 = ga(type = \"binary\", fitness = fitness, nBits = 1,lower = -20, upper = 20,monitor=F)\nGA2@solution # 返回最优解\n#>       x1\n#>  [1,]  0\n\n\n监视功能\n\nShow the codexfun::pkg_load2('gifski') # 安装并加载该软件包\n\n########################\n##编写自己的跟踪功能,点代表一个解，来监视搜索\n## 定义一个新的监视器函数，然后将此函数作为可选参数传递给ga:\nmonitor = function(obj) { \n    curve(f, -10, 10, main = paste(\"iteration =\", obj@iter))\n    points(obj@population, obj@fitness, pch = 20, col = 2)\n    rug(obj@population, col = 2)\n    Sys.sleep(0.2)}\n## 监视函数--  运行了会输出很多静态图\n# GA = ga(type = \"real-valued\", fitness = f, lower = -10, upper = 10, monitor = monitor)\n\n\n\n\nShow the code##############\n## 也可以储存为视频，观看，利用动画的函数做出视频  \n# library(animation)    \n# oopts = ani.options(ffmpeg = \"F:/ffmpeg/bin/ffmpeg.exe\")#在winds中设置ffmpeg    \n# saveVideo({    \n#   #打印图片    \n#   GA = ga(type = \"real-valued\", fitness = f, lower = -10, upper = 10, monitor = monitor)    \n#   ani.options(interval = 0.1, nmax = 250)    \n# }, video.name = \"jianshi.mp4\", other.opts = \"-b 500k\")    \n# \n################  \n\n\n3.2. 二元函数:\n\\[\n20 + x_1^2 + x_2^2 - 10 (\\cos(2 \\pi  x_1) + \\cos(2  pix_2))\n\\]\n\nShow the coderm(list = ls())\n\nRastrigin = function(x1, x2) {\n    20 + x1^2 + x2^2 - 10 * (cos(2 * pi * x1) + cos(2 * pi * x2))\n}\n# 画图\n# x1 = seq(-5.12, 5.12, by = 0.1)\n# x2 = seq(-5.12, 5.12, by = 0.1)\n# f = outer(x1, x2, Rastrigin)\n# persp3D(x1, x2, f, theta = 50, phi = 20)# 3D图\n# filled.contour(x1, x2, f, color.palette = jet.colors)# 热力图\n\n\nmonitor = function(obj) {\n    contour(x1, x2, f, drawlabels = FALSE, col = gray(0.5))\n    title(paste(\"iteration =\", obj@iter), font.main = 1)\n    points(obj@population, pch = 20, col = 2)\n    Sys.sleep(0.2)\n}\n\nGA = ga(type = \"real-valued\", fitness = function(x) -Rastrigin(x[1], x[2]),\n        lower = c(-5.12,-5.12), upper = c(5.12, 5.12), \n        popSize = 50, maxiter = 100, monitor = NULL)  #定义monitor,暂时不运行\n\n\nGA@solution\n#>                  x1           x2\n#>  [1,] -0.0001989624 1.942699e-06\n\n\n3.3 最小二乘法\n删除该例子\n3.4 子集的选择\n给定一组预测因子，子集选择的目的是确定最相关的预测因子，以解释响应变量的变化。我们可以利用遗传算法来赛选出更好的相关因子，从而产生更好的估计和更清晰的回归系数解释。使用二进制字符串可以自然地处理赛选子集问题，其中1表示选择该变量，0表示不选择该变量。\n候选子集的适合度可以通过几种模型选择标准之一来衡量，比如AIC、BIC等\n我们首先从UsingR包中加载数据集，然后通过OLS拟合线性回归模型:\n\nShow the coderm(list = ls())\nxfun::pkg_load2(\"UsingR\")\ndata(\"fat\", package = \"UsingR\")#252*19\nmod = lm(body.fat.siri ~ age + weight + height + \n           neck + chest + abdomen +\n           hip + thigh + knee + ankle + \n           bicep + forearm + wrist, \n         data = fat)#通过观察，因变量（body.fat.siri） 与上述 13个自变量有关系\nsummary(mod)\n#>  \n#>  Call:\n#>  lm(formula = body.fat.siri ~ age + weight + height + neck + chest + \n#>      abdomen + hip + thigh + knee + ankle + bicep + forearm + \n#>      wrist, data = fat)\n#>  \n#>  Residuals:\n#>       Min       1Q   Median       3Q      Max \n#>  -11.1687  -2.8639  -0.1014   3.2085  10.0068 \n#>  \n#>  Coefficients:\n#>               Estimate Std. Error t value Pr(>|t|)    \n#>  (Intercept) -18.18849   17.34857  -1.048  0.29551    \n#>  age           0.06208    0.03235   1.919  0.05618 .  \n#>  weight       -0.08844    0.05353  -1.652  0.09978 .  \n#>  height       -0.06959    0.09601  -0.725  0.46925    \n#>  neck         -0.47060    0.23247  -2.024  0.04405 *  \n#>  chest        -0.02386    0.09915  -0.241  0.81000    \n#>  abdomen       0.95477    0.08645  11.044  < 2e-16 ***\n#>  hip          -0.20754    0.14591  -1.422  0.15622    \n#>  thigh         0.23610    0.14436   1.636  0.10326    \n#>  knee          0.01528    0.24198   0.063  0.94970    \n#>  ankle         0.17400    0.22147   0.786  0.43285    \n#>  bicep         0.18160    0.17113   1.061  0.28966    \n#>  forearm       0.45202    0.19913   2.270  0.02410 *  \n#>  wrist        -1.62064    0.53495  -3.030  0.00272 ** \n#>  ---\n#>  Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#>  \n#>  Residual standard error: 4.305 on 238 degrees of freedom\n#>  Multiple R-squared:  0.749, Adjusted R-squared:  0.7353 \n#>  F-statistic: 54.65 on 13 and 238 DF,  p-value: < 2.2e-16\n\n\n设计矩阵(没有截距)和响应变量从拟合模型对象中提取:\n\nShow the codex = model.matrix(mod)[, -1] # 252*13  选取13 个自变量的列，构建自变量\ny = model.response(model.frame(mod)) # 提取因变量的列，\n\n###### 那么，最大化的适应度函数可以定义为:\n\n fitness = function(string) {\n   inc = which(string == 1)\n   X = cbind(1, x[,inc])\n   mod = lm.fit(X, y)\n   class(mod) = \"lm\"\n  -AIC(mod)\n}\n\n\n这仅仅是利用字符串对应位置上的1所标识的预测因子来估计回归模型，并返回所选标准的负值。注意，截取项总是包含在内，并且我们使用基本的lm。拟合函数加速计算。下面的R代码运行GA:\n\nShow the codeGA = ga(\"binary\", fitness = fitness, nBits = ncol(x),\n        names = colnames(x),monitor = F,parallel = T)# monitor = plot\n\n\nGA@solution\n#>       age weight height neck chest abdomen hip thigh knee ankle bicep forearm\n#>  [1,]   1      1      0    1     0       1   1     1    0     0     0       1\n#>       wrist\n#>  [1,]     1\n\n#####利用GA找到的最优子集得到的线性回归模型如下:\n\nmod2 = lm(body.fat.siri ~ .,\n             data = data.frame(body.fat.siri = y, x[,GA@solution == 1]))\nsummary(mod2)\n#>  \n#>  Call:\n#>  lm(formula = body.fat.siri ~ ., data = data.frame(body.fat.siri = y, \n#>      x[, GA@solution == 1]))\n#>  \n#>  Residuals:\n#>       Min       1Q   Median       3Q      Max \n#>  -10.9757  -2.9937  -0.1644   2.9766  10.2244 \n#>  \n#>  Coefficients:\n#>               Estimate Std. Error t value Pr(>|t|)    \n#>  (Intercept) -22.65637   11.71385  -1.934  0.05426 .  \n#>  age           0.06578    0.03078   2.137  0.03356 *  \n#>  weight       -0.08985    0.03991  -2.252  0.02524 *  \n#>  neck         -0.46656    0.22462  -2.077  0.03884 *  \n#>  abdomen       0.94482    0.07193  13.134  < 2e-16 ***\n#>  hip          -0.19543    0.13847  -1.411  0.15940    \n#>  thigh         0.30239    0.12904   2.343  0.01992 *  \n#>  forearm       0.51572    0.18631   2.768  0.00607 ** \n#>  wrist        -1.53665    0.50939  -3.017  0.00283 ** \n#>  ---\n#>  Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#>  \n#>  Residual standard error: 4.282 on 243 degrees of freedom\n#>  Multiple R-squared:  0.7466,    Adjusted R-squared:  0.7382 \n#>  F-statistic: 89.47 on 8 and 243 DF,  p-value: < 2.2e-16\n\n\n上述两种解决方案相比，\n3.5 约束优化\n\n约束优化,可以通过对目标函数加入惩罚函数来实现,即不在约束范围内的目标函数值设置为 \\(- \\infty\\)\n\n\n背包问题:假定背包的最大容量为W，N件物品，每件物品都有自己的价值和重量，将物品放入背包中使得背包内物品的总价值最大。\n如果第\\(i\\)项选择为背包，则\\(x_i = 1\\)，不选则\\(x_i = 0\\)。考虑以下数据，利润(p)，权重(w)和容量(V):\n\nShow the coderm(list = ls())\np = c(6, 5, 8, 9, 6, 7, 3)\nw = c(2, 3, 6, 7, 5, 9, 4)\nV = 14\n\n##### 利用二进制遗传算法可以解决背包问题，但由于不等式约束，并不是所有可行解都可行。\n##### 我们可以通过惩罚不可行的解决办法来考虑约束。因此，适应度函数可以定义如下:\nknapsack = function(x) {\n f = sum(x * p)\n penalty = sum(w) * abs(sum(x * w)-V)\n f - penalty\n}\n\n#####  当目标函数f被惩罚时，一个量取决于提出的解决方案的容量与背包容量之间的距离。然后:\nGA = ga(type = \"binary\", fitness = knapsack, nBits = length(w),\n           maxiter = 1000, run = 200, popSize = 20)\n\nGA@solution# 解\n#>       x1 x2 x3 x4 x5 x6 x7\n#>  [1,]  1  0  0  1  1  0  0\n\nsum(p * GA@solution)\n#>  [1] 21\n\nsum(w * GA@solution)\n#>  [1] 14\n\n\n3.7. 解决TSP问题\n有若干个城市(n个)，任何两个城市之间的距离都是确定的，现要求一旅行商从某城市出发必须经过每一个城市且只在一个城市逗留一次，最后回到出发的城市，问如何事先确定一条最短的线路。可行的解决方案的设置是由可能的途径的总数,等于(n−1)!/2.\n考虑一个简单的例子，现在共有A、B、C、D四个城市。\n\n为了将图中关系数据化，可用如下规则来描述：  \n\n城市映射为编号：A——1，B——2，C——3，D——4；  \n\n城市之间的距离用二维数组来表示，记为D[i,j]，如：D[1,2]表示城市A与城市B之间的距离，于是D[1,2]=7，同时也表示我现在处于A–1城市，将要去B–2城市；  \n可用遗传算法解决此类问题\n\nShow the coderm(list = ls())\n#city数据结构 一共有31个城市，计算出每两个城市之间的距离，用距离矩阵表示\nD=as.matrix(dist(city)) # 距离矩阵\n#定义总的路线长度\ntourLength = function(tour, distMatrix) {\n   tour = c(tour, tour[1]) #设置为回路，代表所走的路径\n   route = embed(tour, 2)[,2:1]#根据回路,产生对应的距离矩阵的下标,每一行代表一个坐标，第一行处于i坐标\n   sum(distMatrix[route])\n}\ntspFitness = function(tour, ...) 1/tourLength(tour, ...)\n\nGA3 = ga(type = \"permutation\", fitness = tspFitness, distMatrix = D,\n          lower  = 1, upper = dim(D)[1], popSize = 50, maxiter = 5000,\n          run = 500, pmutation = 0.2,monitor = F, parallel = T)\n\nsummary(GA3)\n\n\napply(GA3@solution, 1, tourLength, D)#找到的解决方案对应于一条独特的路径，其行程长度等于:\n\n\n图形对比\n\nShow the codelibrary(ggplot2)\nlibrary(tibble)\ncity=rownames_to_column(city, var = \"rowname\")\n#原始图像\n# p=ggplot(data=city,aes(x=X1,y=X2))+geom_point(shape=19,size=4,col=\"red\")+theme_bw()+\n#   geom_text(aes(label=rowname),size=4,vjust=1.5)+geom_path(linetype=2)+ggtitle(\"初始顺序\")\nlibrary(dplyr)\ncity_solution=data.frame(solution=as.factor(GA3@solution[1,]))\nre_city=inner_join(city_solution,city,by=c(\"solution\"=\"rowname\"))\n#re_city #最优解城市顺序\n##最优解城市图像\nj=ggplot(data=re_city,aes(x=X1,y=X2))+geom_point(shape=19,size=4,col=\"red\")+theme_bw()+\n  geom_text(aes(label=solution),size=4,vjust=1.5)+geom_path(linetype=2)+\n  ggtitle(\"最优解\")+\n  geom_point(x=re_city[1,2],y=re_city[1,3],shape=17,size=5,col=\"blue\")+\n   theme(plot.title = element_text(hjust = 0.5)) + theme(text=element_text(family=\"Songti SC\"))\n\nj \n\n\n\n\nShow the codesessionInfo()\n#>  R version 4.2.1 (2022-06-23)\n#>  Platform: aarch64-apple-darwin20 (64-bit)\n#>  Running under: macOS Monterey 12.5.1\n#>  \n#>  Matrix products: default\n#>  BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n#>  LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n#>  \n#>  locale:\n#>  [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#>  \n#>  attached base packages:\n#>  [1] stats     graphics  grDevices utils     datasets  methods   base     \n#>  \n#>  other attached packages:\n#>  [1] GA_3.2.2         iterators_1.0.14 foreach_1.5.2   \n#>  \n#>  loaded via a namespace (and not attached):\n#>   [1] Rcpp_1.0.9          lattice_0.20-45     deldir_1.0-6       \n#>   [4] png_0.1-7           assertthat_0.2.1    digest_0.6.29      \n#>   [7] utf8_1.2.2          R6_2.5.1            backports_1.4.1    \n#>  [10] evaluate_0.16       ggplot2_3.3.6       pillar_1.8.1       \n#>  [13] rlang_1.0.4         data.table_1.14.2   rstudioapi_0.14    \n#>  [16] HistData_0.8-7      gifski_1.6.6-1      UsingR_2.0-7       \n#>  [19] rpart_4.1.16        Matrix_1.4-1        checkmate_2.1.0    \n#>  [22] rmarkdown_2.16.1    splines_4.2.1       stringr_1.4.1      \n#>  [25] foreign_0.8-82      htmlwidgets_1.5.4   munsell_0.5.0      \n#>  [28] compiler_4.2.1      xfun_0.32           pkgconfig_2.0.3    \n#>  [31] base64enc_0.1-3     htmltools_0.5.3     nnet_7.3-17        \n#>  [34] tidyselect_1.1.2    tibble_3.1.8        gridExtra_2.3      \n#>  [37] htmlTable_2.4.1     Hmisc_4.7-1         codetools_0.2-18   \n#>  [40] fansi_1.0.3         crayon_1.5.1        dplyr_1.0.9        \n#>  [43] MASS_7.3-58.1       grid_4.2.1          jsonlite_1.8.0     \n#>  [46] gtable_0.3.0        lifecycle_1.0.1     DBI_1.1.3          \n#>  [49] magrittr_2.0.3      scales_1.2.1        cli_3.3.0          \n#>  [52] stringi_1.7.8       doParallel_1.0.17   latticeExtra_0.6-30\n#>  [55] generics_0.1.3      vctrs_0.4.1         Formula_1.2-4      \n#>  [58] RColorBrewer_1.1-3  tools_4.2.1         interp_1.1-3       \n#>  [61] glue_1.6.2          purrr_0.3.4         jpeg_0.1-9         \n#>  [64] parallel_4.2.1      fastmap_1.1.0       survival_3.4-0     \n#>  [67] yaml_2.3.5          colorspace_2.0-3    cluster_2.1.4      \n#>  [70] knitr_1.40"
  },
  {
    "objectID": "posts/post/R对象输出latex或html格式.html",
    "href": "posts/post/R对象输出latex或html格式.html",
    "title": "R语言输出latex或html",
    "section": "",
    "text": "有一些时候，我们想把R对象输出为LaTeX格式或者HTML格式，怎么办呢？"
  },
  {
    "objectID": "posts/post/R对象输出latex或html格式.html#简介knitr常用参数",
    "href": "posts/post/R对象输出latex或html格式.html#简介knitr常用参数",
    "title": "R语言输出latex或html",
    "section": "简介knitr常用参数",
    "text": "简介knitr常用参数"
  },
  {
    "objectID": "posts/post/R对象输出latex或html格式.html#xtable包",
    "href": "posts/post/R对象输出latex或html格式.html#xtable包",
    "title": "R语言输出latex或html",
    "section": "xtable包",
    "text": "xtable包\n输出为纯HTML格式或者LaTeX格式\n\nShow the codett <- head(iris) # 普通的输出\n\nlibrary(xtable)\nprint(xtable(tt),type=\"html\") # 输出为纯HTML格式\n\n<!-- html table generated in R 4.2.1 by xtable 1.8-4 package -->\n<!-- Tue Aug 30 00:39:00 2022 -->\n<table border=1>\n<tr> <th>  </th> <th> Sepal.Length </th> <th> Sepal.Width </th> <th> Petal.Length </th> <th> Petal.Width </th> <th> Species </th>  </tr>\n  <tr> <td align=\"right\"> 1 </td> <td align=\"right\"> 5.10 </td> <td align=\"right\"> 3.50 </td> <td align=\"right\"> 1.40 </td> <td align=\"right\"> 0.20 </td> <td> setosa </td> </tr>\n  <tr> <td align=\"right\"> 2 </td> <td align=\"right\"> 4.90 </td> <td align=\"right\"> 3.00 </td> <td align=\"right\"> 1.40 </td> <td align=\"right\"> 0.20 </td> <td> setosa </td> </tr>\n  <tr> <td align=\"right\"> 3 </td> <td align=\"right\"> 4.70 </td> <td align=\"right\"> 3.20 </td> <td align=\"right\"> 1.30 </td> <td align=\"right\"> 0.20 </td> <td> setosa </td> </tr>\n  <tr> <td align=\"right\"> 4 </td> <td align=\"right\"> 4.60 </td> <td align=\"right\"> 3.10 </td> <td align=\"right\"> 1.50 </td> <td align=\"right\"> 0.20 </td> <td> setosa </td> </tr>\n  <tr> <td align=\"right\"> 5 </td> <td align=\"right\"> 5.00 </td> <td align=\"right\"> 3.60 </td> <td align=\"right\"> 1.40 </td> <td align=\"right\"> 0.20 </td> <td> setosa </td> </tr>\n  <tr> <td align=\"right\"> 6 </td> <td align=\"right\"> 5.40 </td> <td align=\"right\"> 3.90 </td> <td align=\"right\"> 1.70 </td> <td align=\"right\"> 0.40 </td> <td> setosa </td> </tr>\n   </table>\n\n\n\nShow the codeprint(xtable(tt),type=\"latex\") # 输出为纯LaTeX格式\n\n% latex table generated in R 4.2.1 by xtable 1.8-4 package\n% Tue Aug 30 00:39:00 2022\n\\begin{table}[ht]\n\\centering\n\\begin{tabular}{rrrrrl}\n  \\hline\n & Sepal.Length & Sepal.Width & Petal.Length & Petal.Width & Species \\\\ \n  \\hline\n1 & 5.10 & 3.50 & 1.40 & 0.20 & setosa \\\\ \n  2 & 4.90 & 3.00 & 1.40 & 0.20 & setosa \\\\ \n  3 & 4.70 & 3.20 & 1.30 & 0.20 & setosa \\\\ \n  4 & 4.60 & 3.10 & 1.50 & 0.20 & setosa \\\\ \n  5 & 5.00 & 3.60 & 1.40 & 0.20 & setosa \\\\ \n  6 & 5.40 & 3.90 & 1.70 & 0.40 & setosa \\\\ \n   \\hline\n\\end{tabular}\n\\end{table}\n\n\n若想在rmarkdown中输出时能正常显示上面的格式怎么办了？\n只需添加参数即可\nShow the codelibrary(xtable)\nprint(xtable(tt),type=\"html\") # 输出latex 失效\n\n\n\n\n\nSepal.Length\n\n\nSepal.Width\n\n\nPetal.Length\n\n\nPetal.Width\n\n\nSpecies\n\n\n\n\n1\n\n\n5.10\n\n\n3.50\n\n\n1.40\n\n\n0.20\n\n\nsetosa\n\n\n\n\n2\n\n\n4.90\n\n\n3.00\n\n\n1.40\n\n\n0.20\n\n\nsetosa\n\n\n\n\n3\n\n\n4.70\n\n\n3.20\n\n\n1.30\n\n\n0.20\n\n\nsetosa\n\n\n\n\n4\n\n\n4.60\n\n\n3.10\n\n\n1.50\n\n\n0.20\n\n\nsetosa\n\n\n\n\n5\n\n\n5.00\n\n\n3.60\n\n\n1.40\n\n\n0.20\n\n\nsetosa\n\n\n\n\n6\n\n\n5.40\n\n\n3.90\n\n\n1.70\n\n\n0.40\n\n\nsetosa"
  },
  {
    "objectID": "posts/post/R对象输出latex或html格式.html#kableextra包",
    "href": "posts/post/R对象输出latex或html格式.html#kableextra包",
    "title": "R语言输出latex或html",
    "section": "kableExtra包",
    "text": "kableExtra包\n这个包在原有的输出上，做出了很大的改进，使得原有输出很丑的表格，瞬间变得高大上。而且不需要设置knit参数。很方便，推荐使用\n\nShow the codelibrary(knitr)\nlibrary(kableExtra)\ndt <- mtcars[1:5, 1:6]\n\n\n基于HTML的table\n\nShow the codekable(dt)\n\n\n\n\n   \n    mpg \n    cyl \n    disp \n    hp \n    drat \n    wt \n  \n\n\n Mazda RX4 \n    21.0 \n    6 \n    160 \n    110 \n    3.90 \n    2.620 \n  \n\n Mazda RX4 Wag \n    21.0 \n    6 \n    160 \n    110 \n    3.90 \n    2.875 \n  \n\n Datsun 710 \n    22.8 \n    4 \n    108 \n    93 \n    3.85 \n    2.320 \n  \n\n Hornet 4 Drive \n    21.4 \n    6 \n    258 \n    110 \n    3.08 \n    3.215 \n  \n\n Hornet Sportabout \n    18.7 \n    8 \n    360 \n    175 \n    3.15 \n    3.440 \n  \n\n\n\n\n设置主题\n\nShow the codedt %>%\n  kable() %>%\n  kable_styling()\n\n\n\n\n   \n    mpg \n    cyl \n    disp \n    hp \n    drat \n    wt \n  \n\n\n Mazda RX4 \n    21.0 \n    6 \n    160 \n    110 \n    3.90 \n    2.620 \n  \n\n Mazda RX4 Wag \n    21.0 \n    6 \n    160 \n    110 \n    3.90 \n    2.875 \n  \n\n Datsun 710 \n    22.8 \n    4 \n    108 \n    93 \n    3.85 \n    2.320 \n  \n\n Hornet 4 Drive \n    21.4 \n    6 \n    258 \n    110 \n    3.08 \n    3.215 \n  \n\n Hornet Sportabout \n    18.7 \n    8 \n    360 \n    175 \n    3.15 \n    3.440 \n  \n\n\n\n\n表格样式\n表格样式1\n\nShow the codekable(dt) %>%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\"))\n\n\n\n\n   \n    mpg \n    cyl \n    disp \n    hp \n    drat \n    wt \n  \n\n\n Mazda RX4 \n    21.0 \n    6 \n    160 \n    110 \n    3.90 \n    2.620 \n  \n\n Mazda RX4 Wag \n    21.0 \n    6 \n    160 \n    110 \n    3.90 \n    2.875 \n  \n\n Datsun 710 \n    22.8 \n    4 \n    108 \n    93 \n    3.85 \n    2.320 \n  \n\n Hornet 4 Drive \n    21.4 \n    6 \n    258 \n    110 \n    3.08 \n    3.215 \n  \n\n Hornet Sportabout \n    18.7 \n    8 \n    360 \n    175 \n    3.15 \n    3.440 \n  \n\n\n\n\n表格样式2\n\nShow the codekable(dt) %>%\n  kable_styling(bootstrap_options = \"striped\", full_width = F)\n\n\n\n\n   \n    mpg \n    cyl \n    disp \n    hp \n    drat \n    wt \n  \n\n\n Mazda RX4 \n    21.0 \n    6 \n    160 \n    110 \n    3.90 \n    2.620 \n  \n\n Mazda RX4 Wag \n    21.0 \n    6 \n    160 \n    110 \n    3.90 \n    2.875 \n  \n\n Datsun 710 \n    22.8 \n    4 \n    108 \n    93 \n    3.85 \n    2.320 \n  \n\n Hornet 4 Drive \n    21.4 \n    6 \n    258 \n    110 \n    3.08 \n    3.215 \n  \n\n Hornet Sportabout \n    18.7 \n    8 \n    360 \n    175 \n    3.15 \n    3.440 \n  \n\n\n\n\n\nShow the codesessionInfo()\n\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.5.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] kableExtra_1.3.4 knitr_1.40       xtable_1.8-4    \n\nloaded via a namespace (and not attached):\n [1] rstudioapi_0.14   xml2_1.3.3        magrittr_2.0.3    rvest_1.0.3      \n [5] munsell_0.5.0     viridisLite_0.4.1 colorspace_2.0-3  R6_2.5.1         \n [9] rlang_1.0.4       fastmap_1.1.0     highr_0.9         stringr_1.4.1    \n[13] httr_1.4.4        tools_4.2.1       webshot_0.5.3     xfun_0.32        \n[17] cli_3.3.0         systemfonts_1.0.4 htmltools_0.5.3   yaml_2.3.5       \n[21] digest_0.6.29     lifecycle_1.0.1   htmlwidgets_1.5.4 glue_1.6.2       \n[25] evaluate_0.16     rmarkdown_2.16.1  stringi_1.7.8     compiler_4.2.1   \n[29] scales_1.2.1      svglite_2.1.0     jsonlite_1.8.0"
  },
  {
    "objectID": "posts/post/R对象输出latex或html格式.html#gt-包",
    "href": "posts/post/R对象输出latex或html格式.html#gt-包",
    "title": "R语言输出latex或html",
    "section": "gt 包",
    "text": "gt 包\n可以官网看看"
  },
  {
    "objectID": "posts/post/ggplot2一页多图独立图.html",
    "href": "posts/post/ggplot2一页多图独立图.html",
    "title": "ggplot2一页多图(图独立)",
    "section": "",
    "text": "在一个页面上自由组合各种图(可以毫无关联)，省空间，又能表达自己需求。\n这里有三张图p1,p1,p3，我想把它输出到一个页面上，不单独输出，可以用一些方法"
  },
  {
    "objectID": "posts/post/ggplot2一页多图独立图.html#方法一-使用grid包",
    "href": "posts/post/ggplot2一页多图独立图.html#方法一-使用grid包",
    "title": "ggplot2一页多图(图独立)",
    "section": "方法一: 使用grid包",
    "text": "方法一: 使用grid包\n\nShow the code########新建画图页面###########\ngrid.newpage()  ##新建页面\npushViewport(viewport(layout = grid.layout(2,2))) ####将页面分成2*2矩阵\nvplayout <- function(x,y){\n  viewport(layout.pos.row = x, layout.pos.col = y)\n}\nprint(p3, vp = vplayout(1,1:2))   ###将（1,1)和(1,2)的位置画图p3\nprint(p2, vp = vplayout(2,1))   ###将(2,1)的位置画图p2\nprint(p1, vp = vplayout(2,2))  ###将（2,2)的位置画图p1\n\n\n\nShow the code#dev.off() ##画下一幅图，记得关闭窗口"
  },
  {
    "objectID": "posts/post/ggplot2一页多图独立图.html#方法二-使用patchwork包",
    "href": "posts/post/ggplot2一页多图独立图.html#方法二-使用patchwork包",
    "title": "ggplot2一页多图(图独立)",
    "section": "方法二: 使用patchwork包",
    "text": "方法二: 使用patchwork包\n这个包需要从github上安装\ndevtools::install_github(\"thomasp85/patchwork\")\n\nShow the codelibrary(ggplot2)\nlibrary(patchwork)\np1 <- ggplot(mtcars, aes(mpg, wt, colour = factor(cyl))) + geom_point()\np2 <- ggplot(diamonds, aes(carat, depth, colour = color)) + geom_point()\np1 + p2 #把图p1 ,p2画在一页上\n\n\n\n\n\nShow the code# 可以直接进行拼凑\nggplot(mtcars, aes(mpg, wt, colour = factor(cyl))) + geom_point() + \n  ggplot(diamonds, aes(carat, depth, colour = color)) + geom_point()# 默认的页面布局是1行多列\n\n\n\n\n使用plot_layout()函数调整页面布局\n\nShow the codep1 + p2 + plot_layout(ncol = 1, heights = c(3, 1))\n\n\n\n\n图表之间添加或删除空格–plot_spacer()\n\n\nShow the codep1 + plot_spacer() + p2\n\n\n\n\n拼凑提供的一个非常有用的功能是它使用户能够创建“子图”\n\nShow the codep3 <- ggplot(mtcars) + geom_smooth(aes(disp, qsec), method = 'loess',formula= y ~ x)\np4 <- ggplot(mtcars) + geom_bar(aes(carb))\n\np4 + {\n    p1 + {\n        p2 +p3 +plot_layout(ncol = 1)\n      }\n  } +plot_layout(ncol = 1)\n\n\n\n\n高级功能\n拼凑的有趣之处在于您可以使用+,-运算符来定义嵌套级别：\n\nShow the codep1 + p2 + p3 + plot_layout(ncol = 1)\n\n\n\nShow the code\n# 看看下面的代码并注意到现在p1和p2是“嵌套的”：\np1 + p2 - p3 + plot_layout(ncol = 1)\n\n\n\nShow the code\n\n## 接下来两个操作是|和/分别用于水平和垂直布局。您可以在同一操作中使用它们\n(p1 | p2 | p3) /p4\n\n\n\n\n最后，您可以使用＆或*而不必为每个单独的绘图设置布局设置。这是非常有用的功能，特别是如果您需要将多个图组合在一起。 *修改当前嵌套级别的图：\n\nShow the code(p1 + (p2 + p3) + p4 + plot_layout(ncol = 1)) * theme_bw() # * 只会影响当前嵌套级别的图\n\n\n\nShow the codep1 + (p2 + p3) + p4 + plot_layout(ncol = 1) & theme_bw() # & 将递归到嵌套级别\n\n\n\n\n\nShow the codesessionInfo()\n#> R version 4.2.1 (2022-06-23)\n#> Platform: aarch64-apple-darwin20 (64-bit)\n#> Running under: macOS Monterey 12.5.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n#> \n#> locale:\n#> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#> \n#> attached base packages:\n#> [1] grid      stats     graphics  grDevices utils     datasets  methods  \n#> [8] base     \n#> \n#> other attached packages:\n#> [1] patchwork_1.1.2 ggplot2_3.3.6  \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] pillar_1.8.1      compiler_4.2.1    tools_4.2.1       digest_0.6.29    \n#>  [5] lattice_0.20-45   nlme_3.1-159      viridisLite_0.4.1 jsonlite_1.8.0   \n#>  [9] evaluate_0.16     lifecycle_1.0.1   tibble_3.1.8      gtable_0.3.0     \n#> [13] mgcv_1.8-40       pkgconfig_2.0.3   rlang_1.0.4       Matrix_1.4-1     \n#> [17] cli_3.3.0         DBI_1.1.3         rstudioapi_0.14   yaml_2.3.5       \n#> [21] xfun_0.32         fastmap_1.1.0     withr_2.5.0       stringr_1.4.1    \n#> [25] dplyr_1.0.9       knitr_1.40        generics_0.1.3    htmlwidgets_1.5.4\n#> [29] vctrs_0.4.1       tidyselect_1.1.2  glue_1.6.2        R6_2.5.1         \n#> [33] fansi_1.0.3       rmarkdown_2.16.1  farver_2.1.1      purrr_0.3.4      \n#> [37] magrittr_2.0.3    splines_4.2.1     scales_1.2.1      htmltools_0.5.3  \n#> [41] assertthat_0.2.1  colorspace_2.0-3  labeling_0.4.2    utf8_1.2.2       \n#> [45] stringi_1.7.8     munsell_0.5.0"
  },
  {
    "objectID": "posts/post/testfunctionVisualization.html",
    "href": "posts/post/testfunctionVisualization.html",
    "title": "智能算法测试函数可视化",
    "section": "",
    "text": "\\[\nf(x) = \\sum^n_{i=1}x_i^2\n\\]\n全局最优点为\\(x =(0,0,\\cdots ,0 ),f(x) =0\\)\n\nShow the code#############################\n#### 二维函数 --- 可视化\n##############################\n\n## 1 、 Sphere 函数\nf1_Sphere2 = function(x,y){\n  return(x^2 + y^2)\n}\n\n\n\nShow the codey = x <- seq(-10, 10, 0.1)\nz <- outer(x, y, f1_Sphere2)\nlibrary(plotly)\n\nLoading required package: ggplot2\n\n\n\nAttaching package: 'plotly'\n\n\nThe following object is masked from 'package:ggplot2':\n\n    last_plot\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\n\nThe following object is masked from 'package:graphics':\n\n    layout\n\nShow the codelibrary(widgetframe)\n\nLoading required package: htmlwidgets\n\nShow the codep = plot_ly() %>% add_surface(x = ~x, y = ~y, z = ~z)\nframeWidget(p)\n\n\n\n\n\n\n\\[\nf(x) = \\sum^n_i|x_i| + \\prod^n_i|x_i|\n\\]\n全局最优点为\\(x =(0,0,\\cdots ,0 ),f(x) =0\\)\n\nShow the code## 2、Schwefel 函数\nf2_Schwefel2 = function(x,y){\n  sum(abs(x),abs(y)) + abs(x)*abs(y)\n}\n\n\n\nShow the codey = x <- seq(-10, 10, 0.1)\nz <- outer(x, y, f2_Schwefel2)\np = plot_ly() %>% add_surface(x = ~x, y = ~y, z = ~z)\nframeWidget(p)\n\n\n\n\n\n\n\\[\nf(x) = \\sum^n_{i=1}  \\left( 100 ( x_{i+1}- x_i^2 )^2+ (x_i -1)^2 \\right)\n\\]\n全局最优点为\\(x =(1,1,\\cdots ,1 ),f(x) =0\\)\n\nShow the code## 3、Rosenbrock 函数\nf2_Rosenbrock2 = function(x,y){\n  100*(y-x^2)^2 + (x-1)^2\n}\n\n\n\nShow the codey = x <- seq(-10, 10, 0.1)\nz <- outer(x, y, f2_Rosenbrock2)\np = plot_ly() %>% add_surface(x = ~x, y = ~y, z = ~z)\nframeWidget(p)\n\n\n\n\n\n\n\\[\nf(x) = \\sum_{i=1}^n \\left(  x_i^2 - 10cos(2\\pi x_i) +10 \\right)\n\\]\n全局最优点为\\(x =(0,0,\\cdots ,0 ),f(x) =0\\)\n\nShow the code## 4、Rastrigin\nf2_Rastrigin2 = function(x,y){\n   x^2-10*cos(2*pi*x)+10 + y^2-10*cos(2*pi*y)+10\n}\n\n\n\nShow the codey = x <- seq(-10, 10, 0.1)\nz <- outer(x, y, f2_Rastrigin2)\np = plot_ly() %>% add_surface(x = ~x, y = ~y, z = ~z)\nframeWidget(p)\n\n\n\n\n\n\n\\[\nf(x) = \\frac{1}{4000}\\sum_{i=1}^n x_i^2 -\\prod^n_{i=1}cos\\left( \\frac{x_i}{\\sqrt{i}}\\right) +1\n\\]\n全局最优点为\\(x =(0,0,\\cdots ,0 ),f(x) =0\\)\n\nShow the code## 5/Griewank 函数\nf2_Griewank = function(x,y){\n  1/4000 *(x^2+y^2)-cos(x/1)*cos(y/sqrt(2))+1\n}\n\n\n\nShow the codey = x <- seq(-10, 10, 0.1)\nz <- outer(x, y, f2_Griewank)\np = plot_ly() %>% add_surface(x = ~x, y = ~y, z = ~z)\nframeWidget(p)\n\n\n\n\n\n\n\\[\nf(x) = -20 Exp  \\left(-0.2  \\times \\sqrt{\\frac{1}{30} \\sum_{i=1}^n x_i^2 } \\right) - Exp  \\left(\\sqrt{\\frac{1}{30} \\cos(2 \\pi x_i) } \\right) +20 +e\n\\]\n全局最优点为\\(x =(0,0,\\cdots ,0 ),f(x) =0\\)\n\nShow the code## 6 Ackley 函数\nf2_Ackley2 = function(x,y){\n  -20*exp(-0.2*sqrt(1/30 * (x^2+y^2))) -exp(1/30*(cos(2*pi*x)+cos(2*pi*y)))+20+exp(1)\n}\n\n\n\nShow the codey = x <- seq(-10, 10, 0.1)\nz <- outer(x, y, f2_Ackley2)\np = plot_ly() %>% add_surface(x = ~x, y = ~y, z = ~z)\nframeWidget(p)\n\n\n\n\n\n\n\\[\nf(x) = \\sum_{i=1}^nix_i^4 + rand[0,1)\n\\]\n全局最优点为\\(x =(0,0,\\cdots ,0 ),f(x) =0\\)\n\nShow the code## 7 、Noise函数\nf2_Niose2 = function(x,y){\n  x^4+2*y^2 + rnorm(1,0,1)\n}\n\n\n\nShow the codey = x <- seq(-10, 10, 0.1)\nz <- outer(x, y, f2_Niose2)\np = plot_ly() %>% add_surface(x = ~x, y = ~y, z = ~z)\nframeWidget(p)\n\n\n\n\n\n\n\\[\nf(x) = \\frac{\\sin^2(\\sqrt{x_i^2 +x_2^2}) - 0.5 }{[1+0.001(x_1+x_2)]^2} - 0.5\n\\]\n全局最优点为\\(x =(0,0,\\cdots ,0 ),f(x) = -1\\)\n\nShow the code## 8/shaffer函数\nf2_shaffer2 = function(x,y){\n  (sin(x^2+y^2)^2 -0.5)/(1+0.001*(x^2+y^2))^2 - 0.5\n}\n\n\n\nShow the codey = x <- seq(-10, 10, 0.1)\nz <- outer(x, y, f2_shaffer2)\np = plot_ly() %>% add_surface(x = ~x, y = ~y, z = ~z)\nframeWidget(p)\n\n\n\n\n\n\nShow the codesessionInfo()\n\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.5.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] widgetframe_0.3.1 htmlwidgets_1.5.4 plotly_4.10.0     ggplot2_3.3.6    \n\nloaded via a namespace (and not attached):\n [1] pillar_1.8.1      compiler_4.2.1    tools_4.2.1       digest_0.6.29    \n [5] viridisLite_0.4.1 jsonlite_1.8.0    evaluate_0.16     lifecycle_1.0.1  \n [9] tibble_3.1.8      gtable_0.3.0      pkgconfig_2.0.3   rlang_1.0.4      \n[13] cli_3.3.0         DBI_1.1.3         rstudioapi_0.14   crosstalk_1.2.0  \n[17] yaml_2.3.5        xfun_0.32         fastmap_1.1.0     httr_1.4.4       \n[21] withr_2.5.0       stringr_1.4.1     dplyr_1.0.9       knitr_1.40       \n[25] generics_0.1.3    vctrs_0.4.1       grid_4.2.1        tidyselect_1.1.2 \n[29] data.table_1.14.2 glue_1.6.2        R6_2.5.1          fansi_1.0.3      \n[33] rmarkdown_2.16.1  farver_2.1.1      tidyr_1.2.0       purrr_0.3.4      \n[37] magrittr_2.0.3    scales_1.2.1      htmltools_0.5.3   assertthat_0.2.1 \n[41] colorspace_2.0-3  utf8_1.2.2        stringi_1.7.8     lazyeval_0.2.2   \n[45] munsell_0.5.0"
  },
  {
    "objectID": "posts/post/ellipsisParameter.html",
    "href": "posts/post/ellipsisParameter.html",
    "title": "省略号参数— 可变长参数",
    "section": "",
    "text": "​ 在R中我们查看别人的函数或者内部函数，经常用到…这种参数，...也称把可变长参数，今天就来聊一聊中方法的使用。\n\n先看一个例子：构造一个函数然后对所有的参数进行相加求和。\n\nShow the codeaddemup <- function(x, ...){\n   args <- list(...)# 推荐把省略号的内容分配给list,然后在对该list进行操作\n   for (a in args){\n                x <- x + a \n   } \n   x\n }\n\naddemup(1,1)\n#> [1] 2\naddemup(1,2,3,4,5)\n#> [1] 15\n\n\n我们还可以通过..1,..2到..9等直接引用列表…中的内容。..1表示第一项，..2表示第二项，以此类推。\n对list操作可以结合purrr包中的map, reduce, accumulate和基础函数do.call等 操作更方便。一个实际的例子，\nDGM_U = function(...){\n  #######  第一部分是对参数的检查 #####################\n  # 输入的参数为U_{k}，U_{k}代表一个完整的区间乘积互反判断矩阵。\n  n = nrow(..1)\n  m = ncol(..1)\n  args <- list(...)\n  stopifnot( length(args) >=2, all( map_lgl(args,is.matrix)),2*n ==m )\n  # 检查所有的矩阵维度是否一样\n  library(purrr)\n  t = map(args,dim) %>% do.call(rbind, .) \n  stopifnot( nrow(unique(t)) == 1)\n  \n  ####### 第二部分 对参数的操作，达到想要的目的###########\n  ## 1. 使用快捷的函数\n  k = 1 / length(args)\n  UB = reduce( map(args,function(x)fenjie(x)$B),`*`)^k\n  UD = reduce( map(args, function(x)fenjie(x)$D), `*`)^k\n  \n  ## 2. 使用循环操作 -- 对比操作\n  # UB = matrix(1,nrow = n, ncol = n)\n  # UD = matrix(1,nrow = n, ncol = n)\n  # for(xx in args){\n  #   B = fenjie(xx)$B\n  #   D = fenjie(xx)$D\n  #   for(i in 1:n){\n  #     for(j in 1:n){\n  #       UB[i,j] = UB[i,j] * B[i,j]\n  #       UD[i,j] = UD[i,j] * D[i,j]\n  #     }\n  #   }\n  # }\n  # k = 1 / length(args)\n  # UB = UB^( k)\n  # UD = UD^(k)\n  return( hecheng(UB,UD))\n}\n# 由于该函数引用了部分其他函数，故这里不能运行\nDGM_U(U_t1,U_t2,U_t3)\n\n我们知道R中的图形参数是有很多的，可以把它传递给图形参数。\n\nShow the codenicePlot = function(X,Y,...){\n  xlabel = deparse(substitute(X)) # 捕获X的输入\n  ylabel = deparse(substitute(Y)) # 捕获Y的输入\n  \n  plot(X,Y,type ='o',\n      xlab = xlabel,ylab = ylabel,main = paste(xlabel,ylabel,sep = '--'),\n      ...)\n}\n\nDate = 1:7\nSales = c(100,120,150,130,160,210,120)\nnicePlot(Date,Sales,col='red')\n\n\n\n\n其中substitute()函数捕获输入的内容(无论输入什么样的内容，则原样输出)，deparse() 函数将其转变为字符串\n\n\nShow the codev <- c(sqrt(1:100))\nf <- function(x, ...) { \n   print(x); \n   summary(...)\n  }\nf(\"Here is the summary for v.\", v, digits=2)\n#> [1] \"Here is the summary for v.\"\n#>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#>     1.0     5.1     7.1     6.7     8.7    10.0\n\n\n\n实际上，参数本身的值不是通过省略号参数传递的唯一信息。也可以使用参数的名称（如果指定），例如：\n\nShow the codef <- function(...) {\n  names(list(...))\n  \n   # 进一步的分析\n}\n\nf(some_number = 123,some_string ='abc',some_missing_value = NA)\n#> [1] \"some_number\"        \"some_string\"        \"some_missing_value\"\n\n\n\n\nShow the coderm(list = ls())\nf <- function(...) {\n  args <- list(...)\n  for( i in 1:length(args) ){ \n    assign( x = names(args)[i],value = args[[i]] )\n  }\n  ls()#显示可用的变量 #使用省略号参数作为当前变量进行进一步操作\n  \n  # 进一步的分析\n}\n\nf( some_number = 123,some_string =\"abc\")\n#> [1] \"args\"        \"i\"           \"some_number\" \"some_string\"\n\n\n\nShow the codesessionInfo()\n#> R version 4.2.1 (2022-06-23)\n#> Platform: aarch64-apple-darwin20 (64-bit)\n#> Running under: macOS Monterey 12.5.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n#> \n#> locale:\n#> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] digest_0.6.29     jsonlite_1.8.0    magrittr_2.0.3    evaluate_0.16    \n#>  [5] rlang_1.0.4       stringi_1.7.8     cli_3.3.0         rstudioapi_0.14  \n#>  [9] rmarkdown_2.16.1  tools_4.2.1       stringr_1.4.1     htmlwidgets_1.5.4\n#> [13] xfun_0.32         yaml_2.3.5        fastmap_1.1.0     compiler_4.2.1   \n#> [17] htmltools_0.5.3   knitr_1.40"
  },
  {
    "objectID": "posts/post/factor.html",
    "href": "posts/post/factor.html",
    "title": "因子数据类型处理",
    "section": "",
    "text": "类别（名义型）变量和有序类别（有序型）变量在R中称为因子（factor） ，如性别、省份、职业。\n\n类别（名义型）变量是没有顺序之分的类别变量。\n有序型变量表示一种顺序关系，代表有序量度，如打分结果，疾病严重程度等。而非数量关系。\n\n连续型变量可以呈现为某个范围内的任意值，比如年龄\n1、基础函数\n针对因子型数据，我们一般需要用到三种变化\n\n更改level标签名\n更改level顺序\n创建有序因子\n\n用factor()函数把字符型向量转换成因子，如\n\nShow the codex <- c(\"男\", \"女\", \"男\", \"男\",  \"女\")\nsex <- factor(x) #将此向量存储为(1, 2, 1, 1，2)，并在内部将其关联为1=\"男\"和2=\"女\"（具体赋值根据字母顺序而定）。\nsex\n\n[1] 男 女 男 男 女\nLevels: 女 男\n\n\n\nShow the codeattributes(sex)\n\n$levels\n[1] \"女\" \"男\"\n\n$class\n[1] \"factor\"\n\n\n因子有class属性，取值为\"factor\"， 还有一个levels(水平值)属性， 此属性可以用levels()函数访问，如\n\nShow the codelevels(sex)#查看某个因子的标签有哪些\n\n[1] \"女\" \"男\"\n\n\n因子的levels属性可以看成是一个映射， 把整数值1,2,…,映射成这些水平值， 因子在保存时会保存成整数值1,2,等与水平值对应的编号。 这样可以节省存储空间， 在建模计算的程序中也比较有利于进行数学运算。\n要表示有序型变量，需要为函数factor()指定参数ordered=TRUE。给定向量：\n\nShow the codestatus <- c(\"Poor\", \"Improved\", \"Excellent\", \"Poor\")\nstatus1 <- factor(status, ordered=TRUE)#会默认关联其值并且按关联的值排序（其实按ascii码表排序），\nstatus1  # 明显可以看出这要的排序并不是我们想要的。\n\n[1] Poor      Improved  Excellent Poor     \nLevels: Excellent < Improved < Poor\n\nShow the code#可以用选项levels自行指定各水平值, 不指定时由x的不同值来求得。\nstatus2 <- factor(status, order=TRUE,levels=c(\"Poor\", \"Improved\", \"Excellent\"))\nstatus2\n\n[1] Poor      Improved  Excellent Poor     \nLevels: Poor < Improved < Excellent\n\nShow the code#也可以将数字型变量转为因子变量 ，\nx <- c(1, 2, 1, 1, 2)\n(sex=factor(x)) #可以看出，因子水平没有任何区分,可以用labels指定标签\n\n[1] 1 2 1 1 2\nLevels: 1 2\n\nShow the codesex <- factor(x, levels=c(1, 2),labels=c(\"Male\", \"Female\")) #注意到标签的顺序必须和水平相一致\nsex\n\n[1] Male   Female Male   Male   Female\nLevels: Male Female\n\n\nfactor()函数的一般形式为\nfactor(x, levels = sort(unique(x), na.last = TRUE), labels, exclude = NA, ordered = FALSE)\n可以用选项levels自行指定各水平值, 不指定时由x的不同值来求得。 可以用选项labels指定各水平的标签, 不指定时用各水平值的对应字符串。可以用exclude选项指定要转换为缺失值(NA)的元素值集合。 如果指定了levels, 则当自变量x的某个元素等于第个水平值时输出的因子对应元素值取整数, 如果该元素值没有出现在levels中则输出的因子对应元素值取NA。 ordered取真值时表示因子水平是有次序的(按编码次序)。\n事实上，经常处理数据的时候，数据都是给定的，读入数据的时候常用 read.csv()函数的默认操作会把输入文件的字符型列自动转换成因子， 这对于性别、职业、地名这样的列是合适的， 但是对于姓名、日期、详细地址这样的列则不合适。 所以，在read.csv()调用中经常加选项stringsAsFactors=FALSE选项禁止这样的自动转换，还可以用colClasses选项逐个指定每列的类型。\n用as.numeric()可以把因子转换为纯粹的整数值，如\n\nShow the codeas.numeric(sex)\n\n[1] 1 2 1 1 2\n\n\n因为因子实际保存为整数值， 所以对因子进行一些字符型操作可能导致错误。 用as.character()可以把因子转换成原来的字符型，如\n\nShow the codeas.character(sex)\n\n[1] \"Male\"   \"Female\" \"Male\"   \"Male\"   \"Female\"\n\n\n为了对因子执行字符型操作（如取子串）， 保险的做法是先用as.character()函数强制转换为字符型。\n因为一个因子的levels属性是该因子独有的， 所以合并两个因子有可能造成错误。如\n\nShow the codeli1 <- factor(c('男', '女'))\nli2 <- factor(c('男', '男'))\nc(li1, li2)\n\n[1] 男 女 男 男\nLevels: 女 男\n\n\n结果不再是因子。 正确的做法是\n\nShow the codefactor(c(as.character(li1), as.character(li2)))#合并因子正确的方法\n\n[1] 男 女 男 男\nLevels: 女 男\n\n\n即恢复成字符型后合并， 然后再转换为因子。 在合并两个数据框时也存在这样的问题。 当然，如果在定义li1和li2 时都用了levels=c('男', '女')选项， c(li1, li2)也能给出正确结果。\n\ntable()函数\n用table()函数统计因子各水平的出现次数（称为频数或频率）。\n\nShow the codetable(sex) #返回一个特殊的有元素名的向量\n\nsex\n  Male Female \n     3      2 \n\n\n对一个变量用table函数计数的结果是一个特殊的有元素名的向量， 元素名是自变量的不同取值， 结果的元素值是对应的频数。 单个因子或单个向量的频数结果可以用向量的下标访问方法取出单个频数或若干个频数的子集。\n2、forcats包的处理因子函数\n在分类变量类数较多时，往往需要对因子水平另外排序、合并等， forcats包提供了一些针对因子的方便函数。\n其中的函数分为如下几类，未特别指明levels和标签一样\n1.修改levels顺序的函数，向量内元素不变\n\n\n\n\n\n\n函数\n功能\n\n\n\nfct_relevel(f, …, after = 0L)\n手动重新排列因子水平\n\n\nfct_inorder(f, ordered = NA)\n按照第一次出现的次序排列\n\n\nfct_infreq(f, ordered = NA)\n按照出现的频率排列\n\n\nfct_reorder(f, x, fun = median, …, .desc = FALSE)\n通过对另一个变量进行排序来重新排列因子水平\n\n\nfct_reorder2(f, x, y, fun = last2, …, .desc = TRUE)\n同上，作用不一样\n\n\nfct_shuffle(f)\n随机排列因子水平\n\n\nfct_rev(f)\n倒序\n\n\nfct_shift(f, n = 1L)\n实现前后移动，滚动变化\n\n\n\n2.变换levels名称的函数\n\n\n\n\n\n\n函数\n作用\n\n\n\nfct_anon(f,prefix=““)\nlevels用升序的数字替代，prefix参数表示在数字前面要保留的字符\n\n\nfct_collapse(f, …)\nlevels更改，主要用于levels的合并\n\n\nfct_recode(f, …)\n手动更改,把指定的标签进行更改\n\n\nfct_lump(f, n, prop, other_level = “Other”, ties.method = c(“min”,“average”, “first”, “last”, “random”, “max”))\n将最小/最常见的因子水平（levels）合并为“other”\n\n\n\n\n若n, prop的值丢失，则将出现次数比较低的标签结合在一起变为other(算法没弄懂，何为比较低)若指定n，表明保留n个最多的level，其余的变为other，指定负数，表明保留最少的若指定prop=0.1 表明保留数量超过10%的level，其余的变为other,同理可以指定负数ties.method可以指定计算方法（同时指定n），若为max,表明次数超过n的保留，低于n的改变为other指定other_level可以更改替换名称\n\n\nfct_other(f, keep, drop, other_level = “Other”)\n若指定keep,将指定的 level保留，其余变成”other”,若指定drop,将指定的 level 设置成”other”\n\n\nfct_relabel(f, fun, …)\n在原有基础上进行修改\n\n\n\n3.其他函数\n\n\n\n\n\n\n函数\n作用\n\n\n\nfct_c(f1,f2)\n将两个factor结合 或者fct_c(list(f1, f2))\n\n\nfct_count(f, sort = FALSE)\n对factor的标签进行统计计数并转化为tibble\n\n\nfct_unique(f)\n对每一个level只有一个，向量中元素按照level的顺序排列\n\n\nfct_drop(f)\n默认将没有对应level值去掉\n\n\nfct_explicit_na(f, na_level = “(Missing)”)\n使显式值缺失\n\n\n\n（下面三个更一般的函数，上面这些函数都有着特定的功能，基本上都是调用下面这三个函数实现的）\n\n\n函数\n作用\n\n\n\nlvls_reorder(f, idx, ordered = NA)\n更改level顺序\n\n\nlvls_revalue(f, new_levels)\n整体更改level名称\n\n\nlvls_expand(f, new_levels)\n增加额外的level值\n\n\n3、例子\n1.修改level顺序的函数使用\n\nShow the codelibrary(forcats)\nlibrary(ggplot2)\nf <- factor(c(\"a\", \"b\", \"c\", \"d\"))\nfct_relevel(f) # 查看f的levels\n\n[1] a b c d\nLevels: a b c d\n\nShow the codefct_relevel(f, \"c\") # 把水平c移动到第一位\n\n[1] a b c d\nLevels: c a b d\n\nShow the codefct_relevel(f, \"b\", \"a\") #把水平b a 移动到前两位\n\n[1] a b c d\nLevels: b a c d\n\nShow the codefct_relevel(f, \"a\", after = 2) # 把水平a放在第2位之后，即放在第3位\n\n[1] a b c d\nLevels: b c a d\n\nShow the codefct_relevel(f, \"a\", after = Inf) # 把水平a移动到最后\n\n[1] a b c d\nLevels: b c d a\n\nShow the code#########################################\nf <- factor(c(\"b\", \"b\", \"a\", \"c\", \"c\", \"c\"))\nfct_inorder(f) # 按照第一次出现的次序排列\n\n[1] b b a c c c\nLevels: b a c\n\nShow the codefct_infreq(f) # 按照出现的频率排列\n\n[1] b b a c c c\nLevels: c b a\n\nShow the code#######################\n# 随机排序\nf <- factor(c(\"a\", \"b\", \"c\"))\nfct_shuffle(f)\n\n[1] a b c\nLevels: a c b\n\nShow the codefct_shuffle(f)\n\n[1] a b c\nLevels: a c b\n\nShow the code########################\n# 倒序\nf <- factor(c(\"a\", \"b\", \"c\"))\nfct_rev(f)\n\n[1] a b c\nLevels: c b a\n\nShow the code#######################\nfct_shift(f) # 第一项放到最后\n\n[1] a b c\nLevels: b c a\n\nShow the codefct_shift(f, 2) # 前两项放在最后\n\n[1] a b c\nLevels: c a b\n\nShow the codefct_shift(f, -1) # 最后一项移到最前面\n\n[1] a b c\nLevels: c a b\n\n\n\nShow the code######################################################################\n##fac_reorder()可以根据不同因子水平分成的组中另一数值型变量的统计量值排序##\n######################################################################\npar(mfrow=c(1,3))\nboxplot(Sepal.Width ~ Species, data = iris,main=\"因子顺序按默认排序\")#默认的图,因子顺序按默认排序\n# 按照分组变量Sepal.Width的均值从小到大排列(默认)\nboxplot(Sepal.Width ~ fct_reorder(Species, Sepal.Width, median), data = iris,main=\"按分组变量Sepal.Width的均值升序排列\")\n# 设置.desc=T，则从大到小\nboxplot(Sepal.Width ~ fct_reorder(Species, Sepal.Width, median, .desc=T), data = iris,main=\"按分组变量Sepal.Width的均值降序排列\") \n\n\n\nShow the codepar(mfrow=c(1,1))\n# 按照分组变量time的最后一个值对应的weight的大小顺序排列（升序）\nchks <- subset(ChickWeight, as.integer(Chick) < 10)\nchks <- transform(chks, Chick = fct_shuffle(Chick))#fct_shuffle()函数随机排列因子水平\nggplot(chks, aes(Time, weight, colour = fct_reorder2(Chick, Time, weight))) +\n    geom_point()+geom_line() +labs(colour = \"Chick\")+ggtitle(\"按照分组变量time的最后一个值对应的weight的大小顺序排列(升序)\")+\n  theme(plot.title = element_text(hjust = 0.5))  #也就加上这一行标题就居中了\n\n\n\n\n2.修改level标签的函数使用\n\nShow the codef <- factor(c(\"b\", \"b\", \"a\", \"c\", \"c\", \"c\"))\nfct_anon(f)      #levels用升序的数字替代，\n\n[1] 2 2 1 3 3 3\nLevels: 1 2 3\n\nShow the codefct_anon(f, \"x\")     # prefix参数表示在数字前面要保留的字符\n\n[1] x2 x2 x1 x3 x3 x3\nLevels: x1 x2 x3\n\nShow the codefct_collapse(f, \"x\"=c(\"a\",\"b\"), \"y\"=\"c\") #把a。b标签合并成x，c标签替代为y\n\n[1] x x x y y y\nLevels: x y\n\nShow the codefct_collapse(f, \"x\"=c(\"a\",\"b\")) # 只改变一部分也可以\n\n[1] x x x c c c\nLevels: x c\n\nShow the codex <- factor(rep(LETTERS[1:9], times = c(40, 10, 5, 27, 1, 1, 1, 1, 1)))\nx %>% table() #统计标签的出现的次数\n\n.\n A  B  C  D  E  F  G  H  I \n40 10  5 27  1  1  1  1  1 \n\nShow the codex %>% fct_lump() %>% table() #把出现次数比较低值得标签保留，其余的变成other,并统计出现的次数\n\n.\n    A     D Other \n   40    27    20 \n\nShow the codex %>% fct_lump() %>% fct_inorder() %>% table()\n\n.\n    A Other     D \n   40    20    27 \n\nShow the code# 将指定的level设置成other\nx <- factor(rep(LETTERS[1:9], times = c(40, 10, 5, 27, 1, 1, 1, 1, 1)))\nfct_other(x, keep = c(\"A\", \"B\")) # 保留这两个A、B这两个标签，其余变为other\n\n [1] A     A     A     A     A     A     A     A     A     A     A     A    \n[13] A     A     A     A     A     A     A     A     A     A     A     A    \n[25] A     A     A     A     A     A     A     A     A     A     A     A    \n[37] A     A     A     A     B     B     B     B     B     B     B     B    \n[49] B     B     Other Other Other Other Other Other Other Other Other Other\n[61] Other Other Other Other Other Other Other Other Other Other Other Other\n[73] Other Other Other Other Other Other Other Other Other Other Other Other\n[85] Other Other Other\nLevels: A B Other\n\nShow the codefct_other(x, drop = c(\"A\", \"B\")) # 把A、B这个两个标签变成other\n\n [1] Other Other Other Other Other Other Other Other Other Other Other Other\n[13] Other Other Other Other Other Other Other Other Other Other Other Other\n[25] Other Other Other Other Other Other Other Other Other Other Other Other\n[37] Other Other Other Other Other Other Other Other Other Other Other Other\n[49] Other Other C     C     C     C     C     D     D     D     D     D    \n[61] D     D     D     D     D     D     D     D     D     D     D     D    \n[73] D     D     D     D     D     D     D     D     D     D     E     F    \n[85] G     H     I    \nLevels: C D E F G H I Other\n\nShow the code# 手动更改\nx <- factor(c(\"apple\", \"bear\", \"banana\", \"dear\"))\nfct_recode(x, fruit = \"apple\", \"fruit\" = \"banana\")#把标签apple替换为friut，banana也替换为friut,双引号可加可不加\n\n[1] fruit bear  fruit dear \nLevels: fruit bear dear\n\nShow the codefct_recode(x, NULL = \"apple\", fruit = \"banana\") # 移除apple标签，向量对应位置变成NA\n\n[1] <NA>  bear  fruit dear \nLevels: fruit bear dear\n\n\n3.其他函数\n\nShow the code# 对每一个level计数\nf <- factor(c(\"b\", \"b\", \"a\", \"c\", \"c\", \"c\"))\nfct_count(f)   # 对factor的标签进行统计计数并转化为tibble\n\n# A tibble: 3 × 2\n  f         n\n  <fct> <int>\n1 a         1\n2 b         2\n3 c         3\n\nShow the code# 唯一化\nunique(f)\n\n[1] b a c\nLevels: a b c\n\nShow the codefct_unique(f) # 向量中元素按照level的顺序排列\n\n[1] a b c\nLevels: a b c\n\nShow the codef <- factor(c(\"a\", \"b\"), levels = c(\"a\", \"b\", \"c\"))\nf\n\n[1] a b\nLevels: a b c\n\nShow the codefct_drop(f) # 默认将没有对应值的level去掉\n\n[1] a b\nLevels: a b\n\n\n4、forcats包因子总结\nfct_lump(f, n, prop)： 根据因子水平（levels）的值合并为“other”\nfct_collapse(f, …) : levels更改，主要用于levels的合并（主要合并现有的因子水平）\nfac_reorder() : 可以根据不同因子水平分成的组中另一数值型变量的统计量值排序。\nfct_count(f, sort = FALSE) : 对factor的标签进行统计计数并转化为tibble\n\nShow the codesessionInfo()\n\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.5.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] ggplot2_3.3.6 forcats_0.5.2\n\nloaded via a namespace (and not attached):\n [1] compiler_4.2.1    pillar_1.8.1      tools_4.2.1       digest_0.6.29    \n [5] viridisLite_0.4.1 jsonlite_1.8.0    evaluate_0.16     lifecycle_1.0.1  \n [9] tibble_3.1.8      gtable_0.3.0      pkgconfig_2.0.3   rlang_1.0.4      \n[13] DBI_1.1.3         cli_3.3.0         rstudioapi_0.14   yaml_2.3.5       \n[17] xfun_0.32         fastmap_1.1.0     withr_2.5.0       stringr_1.4.1    \n[21] dplyr_1.0.9       knitr_1.40        generics_0.1.3    htmlwidgets_1.5.4\n[25] vctrs_0.4.1       grid_4.2.1        tidyselect_1.1.2  glue_1.6.2       \n[29] R6_2.5.1          fansi_1.0.3       rmarkdown_2.16.1  farver_2.1.1     \n[33] purrr_0.3.4       magrittr_2.0.3    ellipsis_0.3.2    scales_1.2.1     \n[37] htmltools_0.5.3   assertthat_0.2.1  colorspace_2.0-3  labeling_0.4.2   \n[41] utf8_1.2.2        stringi_1.7.8     munsell_0.5.0"
  },
  {
    "objectID": "posts/post/knn算法.html",
    "href": "posts/post/knn算法.html",
    "title": "knn算法简介",
    "section": "",
    "text": "行业应用：比如文字识别、面部识别、预测某人是否喜欢推荐电影\n　　　　基因模式识别：比如用于检测某种疾病，更适合于稀有事件的分类问题（客户流失识别）\n\n应用场合：通常最近邻分类器适用特征与目标类之间的关系比较复杂的数字类型或者二者关系难以理解，但是相似类间的特征都是相似的\n\n\n特点：\n1. 简单有效，对数据分布没有假设，数据训练也很快。\n\n但是他没有模型输出，因此限制了对特征的理解。\n分类阶段比较慢。\n需要标准化(nominal)特征以及缺少数据需要预先处理\n\n\n\n优点\n缺点\n\n\n\n简单且有效\n不产生模型．在发现特彻之间关系上的能力有限\n\n\n对数据的分布没有要求\n分类阶段很慢, 需要大量的内存\n\n\n训练阶段很快\n名义变量（特征变量）和缺失数据需要额外处理\n\n\n\nk的取值：\n1. k通常在3~10之间直接取值（看分析者的心情）\n2. 可采用一般方法：k等于训练数据个数的平方根（15个数据，k可能取4）\n1. 导入数据\n\nShow the code#导入数据\n# import the CSV file\nwbcd <- read.csv(\"wisc_bc_data.csv\", stringsAsFactors = FALSE)\n\n# 查看一下数据结构，发现除了要预测的变量diagnosis是字符型变量其余全是数字型变量\nstr(wbcd)\n\n'data.frame':   569 obs. of  32 variables:\n $ id               : int  87139402 8910251 905520 868871 9012568 906539 925291 87880 862989 89827 ...\n $ diagnosis        : chr  \"B\" \"B\" \"B\" \"B\" ...\n $ radius_mean      : num  12.3 10.6 11 11.3 15.2 ...\n $ texture_mean     : num  12.4 18.9 16.8 13.4 13.2 ...\n $ perimeter_mean   : num  78.8 69.3 70.9 73 97.7 ...\n $ area_mean        : num  464 346 373 385 712 ...\n $ smoothness_mean  : num  0.1028 0.0969 0.1077 0.1164 0.0796 ...\n $ compactness_mean : num  0.0698 0.1147 0.078 0.1136 0.0693 ...\n $ concavity_mean   : num  0.0399 0.0639 0.0305 0.0464 0.0339 ...\n $ points_mean      : num  0.037 0.0264 0.0248 0.048 0.0266 ...\n $ symmetry_mean    : num  0.196 0.192 0.171 0.177 0.172 ...\n $ dimension_mean   : num  0.0595 0.0649 0.0634 0.0607 0.0554 ...\n $ radius_se        : num  0.236 0.451 0.197 0.338 0.178 ...\n $ texture_se       : num  0.666 1.197 1.387 1.343 0.412 ...\n $ perimeter_se     : num  1.67 3.43 1.34 1.85 1.34 ...\n $ area_se          : num  17.4 27.1 13.5 26.3 17.7 ...\n $ smoothness_se    : num  0.00805 0.00747 0.00516 0.01127 0.00501 ...\n $ compactness_se   : num  0.0118 0.03581 0.00936 0.03498 0.01485 ...\n $ concavity_se     : num  0.0168 0.0335 0.0106 0.0219 0.0155 ...\n $ points_se        : num  0.01241 0.01365 0.00748 0.01965 0.00915 ...\n $ symmetry_se      : num  0.0192 0.035 0.0172 0.0158 0.0165 ...\n $ dimension_se     : num  0.00225 0.00332 0.0022 0.00344 0.00177 ...\n $ radius_worst     : num  13.5 11.9 12.4 11.9 16.2 ...\n $ texture_worst    : num  15.6 22.9 26.4 15.8 15.7 ...\n $ perimeter_worst  : num  87 78.3 79.9 76.5 104.5 ...\n $ area_worst       : num  549 425 471 434 819 ...\n $ smoothness_worst : num  0.139 0.121 0.137 0.137 0.113 ...\n $ compactness_worst: num  0.127 0.252 0.148 0.182 0.174 ...\n $ concavity_worst  : num  0.1242 0.1916 0.1067 0.0867 0.1362 ...\n $ points_worst     : num  0.0939 0.0793 0.0743 0.0861 0.0818 ...\n $ symmetry_worst   : num  0.283 0.294 0.3 0.21 0.249 ...\n $ dimension_worst  : num  0.0677 0.0759 0.0788 0.0678 0.0677 ...\n\nShow the codedim(wbcd)\n\n[1] 569  32\n\n\n乳腺癌数据包括 569 例细胞活检案例， 每个案例有32 个特征。一个特征是识别号码(id变量)，一 个特征是癌症诊断结果(diagnosis变量)， 其他 30 个特征是数值型的实验室测挝结果。癌症诊断结果用编码”M”表示恶性，用编码”B”表示良性。\n2. 数据预处理————（因子变量转化为数字变量）\n\nShow the code#第一个名为ID的整形变量（作用起唯一性，不能提供有用的信息）\nwbcd <- wbcd[-1]\n\n#对目标属性重新编码为因子类型\nwbcd$diagnosis <- factor(wbcd$diagnosis, levels = c(\"B\", \"M\"),\n                         labels = c(\"良性B\", \"恶性M\"))\n\n\n# 查看变量diagnosis目标属性的结果数目\ntable(wbcd$diagnosis)\n\n\n良性B 恶性M \n  357   212 \n\nShow the code#计算变量diagnosis目标属性的占比情况\nround(prop.table(table(wbcd$diagnosis)) * 100, digits = 1)\n\n\n良性B 恶性M \n 62.7  37.3 \n\nShow the code#分析其余30个特征都是数字型变量，因此不需要进一步处理\n#但是仔细观察每个变量之间存在数量级差异，则需要标准化——数据处理\n\n\n3.数据预处理————标准化处理（max-min）和划分训练集以及测试集\n\nShow the codenormalize <- function(x) {\n  return ((x - min(x)) / (max(x) - min(x)))\n}\nwbcd_n <- as.data.frame(lapply(wbcd[2:31], normalize))\n##由于排列随机性，所以我们之间选取则可\nwbcd_train <- wbcd_n[1:469, ]\nwbcd_test <- wbcd_n[470:569, ]\n##训练数据和测试数据的目标变量（分类结果先行保留）\nwbcd_train_labels <- wbcd[1:469, 1]\nwbcd_test_labels <- wbcd[470:569, 1]\n\n\n4. knn算法实现(class包)\n创建分类器并进行预测：\np <- knn(train, test, class, k)\n            train: 一个包含数值型训练数据的数据框\n            test:   一个包含数值型测试数据的数据框\n            class :  包含训练数据每一行分类的一个因子向量\n             k:    标识最近邻数目的一个整数\n\n该函数返回一个因子向量,  该向量含有测试数据框中每一行的预测分类。\n例子：\nwbcd_test_pred <- knn(train = wbcd_train, test = wbcd_test,\n                      cl = wbcd_train_labels, k=3)\n\n建议k用奇数，这样会减少各个类别票数相等这一情况的发生\n\nShow the codelibrary(class)\nwbcd_test_pred <- knn(train = wbcd_train, test = wbcd_test,\n                      cl = wbcd_train_labels, k=21)\n\n\n5. 模型性能的评估（gmodels包）\n\nShow the codelibrary(gmodels)\n\n# 创建两个识别向量的交叉表（类似table）,prop.chisq=FALSE讲话从输出中除去不需要的卡方值\nCrossTable(x = wbcd_test_labels, y = wbcd_test_pred,\n           prop.chisq=FALSE)\n\n\n \n   Cell Contents\n|-------------------------|\n|                       N |\n|           N / Row Total |\n|           N / Col Total |\n|         N / Table Total |\n|-------------------------|\n\n \nTotal Observations in Table:  100 \n\n \n                 | wbcd_test_pred \nwbcd_test_labels |     良性B |     恶性M | Row Total | \n-----------------|-----------|-----------|-----------|\n           良性B |        61 |         0 |        61 | \n                 |     1.000 |     0.000 |     0.610 | \n                 |     0.968 |     0.000 |           | \n                 |     0.610 |     0.000 |           | \n-----------------|-----------|-----------|-----------|\n           恶性M |         2 |        37 |        39 | \n                 |     0.051 |     0.949 |     0.390 | \n                 |     0.032 |     1.000 |           | \n                 |     0.020 |     0.370 |           | \n-----------------|-----------|-----------|-----------|\n    Column Total |        63 |        37 |       100 | \n                 |     0.630 |     0.370 |           | \n-----------------|-----------|-----------|-----------|\n\n \n\nShow the codelibrary(caret)\nconfusionMatrix(wbcd_test_labels,wbcd_test_pred,positive = \"良性B\")#confusionMatrix(真实值，预测值，positive =“  ” 阳性积极的为什么，根据不同模型数据而不同\n\nConfusion Matrix and Statistics\n\n          Reference\nPrediction 良性B 恶性M\n     良性B    61     0\n     恶性M     2    37\n                                          \n               Accuracy : 0.98            \n                 95% CI : (0.9296, 0.9976)\n    No Information Rate : 0.63            \n    P-Value [Acc > NIR] : <2e-16          \n                                          \n                  Kappa : 0.9576          \n                                          \n Mcnemar's Test P-Value : 0.4795          \n                                          \n            Sensitivity : 0.9683          \n            Specificity : 1.0000          \n         Pos Pred Value : 1.0000          \n         Neg Pred Value : 0.9487          \n             Prevalence : 0.6300          \n         Detection Rate : 0.6100          \n   Detection Prevalence : 0.6100          \n      Balanced Accuracy : 0.9841          \n                                          \n       'Positive' Class : 良性B           \n                                          \n\n\n6. 改善模型的性能\n\n可尝试 用不同的标准化\n可尝试用不同的k值\n可尝试10折交叉重复验证（随机）\n。。。。。。\n7. 分析最终结果\n按上述5 来分析，只有两个分析错了，有可能是病人的原因。。。。。。。。当然原因有很多种，需要分析者对这个结果有充分的解释能力以及判断能力.\n表格中单元格的百分比表示落在4个分类里的值所占的比例。在左上角的单元格（标记为TN)中，是真阴性(True Negative)的结果。100个值中有61个值标识肿块是良性的，而kNN算法也正确地把它们标识为良性的。在右下角的单元格（标记为TP)中，显示的是真阳性(True Positive)的结果，这里表示的是分类器和临床确定的标签一致认为肿块是恶性的情形。100个预测值中有37个是真阳性(True Positive)的。\n落在另一条对角线上的单元格包含了kNN算法与真实标签不一致的案例计数。位于左下角FN单元格的2个案例是假阴性(False Negative)的结果。在这种情况下，预测的值是良性的，但肿瘤实际上是恶性的。这个方向上的错误可能会产生极其高昂的代价，因为它们可能导致一位病人认为自己没有癌症，而实际上这种疾病可能会继续蔓延。如果右上角标记为FP的单元格里有值．它包含的是假阳性(False Positive)的结果。当模型把肿块标识为恶性时而事实上它是良性时就会产生这里的值。尽管这类错误没有假阴性(False Negative)的结果那么危险，但这类错误也应该避免，因为它们可能会导致医疗系统的额外财政负担，或者病人的额外压力，毕竟这需要提供额外的检查或者治疗。\n一共有2%,即根据kNN算法，100个肿块中．有2个是被错误分类的。虽然对于仅用几行的R代码，就得到98%的准确度似乎令入印象深刻，但是我们可以尝试一些其他的模型迭代方法来看看我们是否可以提高性能并减少错误分类值的数量，特别当错误是危险的假阴性(False Negative)结果时\n8 knn实现方法\n1. class包 ---- knn\n2. caret包 ---- knn3\n3. Rweka包 ---- IBK\n\nShow the codelibrary(RWeka)\n\nRweka_knn=IBk(Species~.,data=iris)#,control=Weka_control(k=21,x=TRUE))\ntable(predict(Rweka_knn,iris[1:4]),iris$Species)#不用交叉验证，直接预测\n\n            \n             setosa versicolor virginica\n  setosa         50          0         0\n  versicolor      0         50         0\n  virginica       0          0        50\n\nShow the code#上面knn中的k好像自己选取1，那么我们需要自动选取怎么办呢？用Weka_control()调参\n#如下，自动选取1:k=20里面最合适的参数\nRweka_knns=IBk(Species~.,data=iris,control = Weka_control(K = 20,X = TRUE))#注意k、x的大小写，这里都是大写\ntable(predict(Rweka_knns,iris[1:4]),iris$Species)#不用交叉验证，直接预测\n\n            \n             setosa versicolor virginica\n  setosa         50          0         0\n  versicolor      0         49         4\n  virginica       0          1        46\n\nShow the code#Rweka_knn为分类器，evaluate_Weka_classifier()这个函数把分类器的数据平均分成10分，做10折交叉验证，查看结果\n#类似于CrossTable()函数\nevaluate_Weka_classifier(Rweka_knn,numFolds = 10)\n\n=== 10 Fold Cross Validation ===\n\n=== Summary ===\n\nCorrectly Classified Instances         143               95.3333 %\nIncorrectly Classified Instances         7                4.6667 %\nKappa statistic                          0.93  \nMean absolute error                      0.04  \nRoot mean squared error                  0.1748\nRelative absolute error                  9.0074 %\nRoot relative squared error             37.0708 %\nTotal Number of Instances              150     \n\n=== Confusion Matrix ===\n\n  a  b  c   <-- classified as\n 50  0  0 |  a = setosa\n  0 47  3 |  b = versicolor\n  0  4 46 |  c = virginica\n\nShow the codeevaluate_Weka_classifier(Rweka_knns,numFolds = 10)\n\n=== 10 Fold Cross Validation ===\n\n=== Summary ===\n\nCorrectly Classified Instances         144               96      %\nIncorrectly Classified Instances         6                4      %\nKappa statistic                          0.94  \nMean absolute error                      0.0461\nRoot mean squared error                  0.1549\nRelative absolute error                 10.3771 %\nRoot relative squared error             32.8499 %\nTotal Number of Instances              150     \n\n=== Confusion Matrix ===\n\n  a  b  c   <-- classified as\n 50  0  0 |  a = setosa\n  0 48  2 |  b = versicolor\n  0  4 46 |  c = virginica\n\n\n\nShow the codesessionInfo()\n\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.5.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] RWeka_0.4-44     caret_6.0-93     lattice_0.20-45  ggplot2_3.3.6   \n[5] gmodels_2.18.1.1 class_7.3-20    \n\nloaded via a namespace (and not attached):\n [1] Rcpp_1.0.9           lubridate_1.8.0      listenv_0.8.0       \n [4] gtools_3.9.3         assertthat_0.2.1     digest_0.6.29       \n [7] ipred_0.9-13         foreach_1.5.2        utf8_1.2.2          \n[10] parallelly_1.32.1    R6_2.5.1             plyr_1.8.7          \n[13] stats4_4.2.1         hardhat_1.2.0        e1071_1.7-11        \n[16] evaluate_0.16        pillar_1.8.1         RWekajars_3.9.3-2   \n[19] rlang_1.0.4          data.table_1.14.2    rstudioapi_0.14     \n[22] gdata_2.18.0.1       rpart_4.1.16         Matrix_1.4-1        \n[25] rmarkdown_2.16.1     splines_4.2.1        gower_1.0.0         \n[28] stringr_1.4.1        htmlwidgets_1.5.4    munsell_0.5.0       \n[31] proxy_0.4-27         compiler_4.2.1       xfun_0.32           \n[34] pkgconfig_2.0.3      globals_0.16.0       htmltools_0.5.3     \n[37] nnet_7.3-17          tidyselect_1.1.2     tibble_3.1.8        \n[40] prodlim_2019.11.13   codetools_0.2-18     fansi_1.0.3         \n[43] future_1.27.0        dplyr_1.0.9          withr_2.5.0         \n[46] ModelMetrics_1.2.2.2 MASS_7.3-58.1        recipes_1.0.1       \n[49] grid_4.2.1           nlme_3.1-159         jsonlite_1.8.0      \n[52] gtable_0.3.0         lifecycle_1.0.1      DBI_1.1.3           \n[55] magrittr_2.0.3       pROC_1.18.0          scales_1.2.1        \n[58] future.apply_1.9.0   cli_3.3.0            stringi_1.7.8       \n[61] reshape2_1.4.4       timeDate_4021.104    generics_0.1.3      \n[64] vctrs_0.4.1          lava_1.6.10          iterators_1.0.14    \n[67] tools_4.2.1          glue_1.6.2           purrr_0.3.4         \n[70] parallel_4.2.1       fastmap_1.1.0        survival_3.4-0      \n[73] yaml_2.3.5           colorspace_2.0-3     rJava_1.0-6         \n[76] knitr_1.40"
  },
  {
    "objectID": "posts/post/数据标准化方法.html",
    "href": "posts/post/数据标准化方法.html",
    "title": "R语言标准化数据处理",
    "section": "",
    "text": "##　1、标准化——数据处理"
  },
  {
    "objectID": "posts/post/数据标准化方法.html#iris实例-scale均值方差标准化",
    "href": "posts/post/数据标准化方法.html#iris实例-scale均值方差标准化",
    "title": "R语言标准化数据处理",
    "section": "2. iris实例 ———— scale（均值方差标准化）",
    "text": "2. iris实例 ———— scale（均值方差标准化）\n\n\nShow the code\nlibrary(caret)\nlibrary(dplyr)\nhead(scale(iris[,1:4]))\n\n\n     Sepal.Length Sepal.Width Petal.Length Petal.Width\n[1,]   -0.8976739  1.01560199    -1.335752   -1.311052\n[2,]   -1.1392005 -0.13153881    -1.335752   -1.311052\n[3,]   -1.3807271  0.32731751    -1.392399   -1.311052\n[4,]   -1.5014904  0.09788935    -1.279104   -1.311052\n[5,]   -1.0184372  1.24503015    -1.335752   -1.311052\n[6,]   -0.5353840  1.93331463    -1.165809   -1.048667\n\n\nShow the code\nstand_scale <- preProcess(iris)  #采用(x-mu)/std的标准化方法，与scale()函数效果一样\nhead(predict(stand_scale ,iris[,1:4]))\n\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width\n1   -0.8976739  1.01560199    -1.335752   -1.311052\n2   -1.1392005 -0.13153881    -1.335752   -1.311052\n3   -1.3807271  0.32731751    -1.392399   -1.311052\n4   -1.5014904  0.09788935    -1.279104   -1.311052\n5   -1.0184372  1.24503015    -1.335752   -1.311052\n6   -0.5353840  1.93331463    -1.165809   -1.048667\n\n\nShow the code\nall(scale(iris[,1:4])==predict(stand_scale ,iris[,1:4])) #中间存在误差，但是大多数以及相等了\n\n\n[1] FALSE"
  },
  {
    "objectID": "posts/post/数据标准化方法.html#iris实例max-min标准化",
    "href": "posts/post/数据标准化方法.html#iris实例max-min标准化",
    "title": "R语言标准化数据处理",
    "section": "3. iris实例————max-min(标准化)",
    "text": "3. iris实例————max-min(标准化)\n\n\nShow the code\nnormalize <- function(x) {\n  return ((x - min(x)) / (max(x) - min(x)))\n}\niris_max=as.data.frame(lapply(iris[1:4],normalize))\nhead(iris_max)\n\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width\n1   0.22222222   0.6250000   0.06779661  0.04166667\n2   0.16666667   0.4166667   0.06779661  0.04166667\n3   0.11111111   0.5000000   0.05084746  0.04166667\n4   0.08333333   0.4583333   0.08474576  0.04166667\n5   0.19444444   0.6666667   0.06779661  0.04166667\n6   0.30555556   0.7916667   0.11864407  0.12500000\n\n\nShow the code\nstand_range <- preProcess(iris[1:4],method = \"range\")\niris_max_prePro=predict(stand_range ,iris[1:4])\nhead(iris_max_prePro)\n\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width\n1   0.22222222   0.6250000   0.06779661  0.04166667\n2   0.16666667   0.4166667   0.06779661  0.04166667\n3   0.11111111   0.5000000   0.05084746  0.04166667\n4   0.08333333   0.4583333   0.08474576  0.04166667\n5   0.19444444   0.6666667   0.06779661  0.04166667\n6   0.30555556   0.7916667   0.11864407  0.12500000\n\n\nShow the code\nall(iris_max==iris_max_prePro)# 正常，和我们预期的一样，两个数据相等\n\n\n[1] TRUE"
  },
  {
    "objectID": "posts/post/数据标准化方法.html#还原标准化数据salce均值-方差标准化",
    "href": "posts/post/数据标准化方法.html#还原标准化数据salce均值-方差标准化",
    "title": "R语言标准化数据处理",
    "section": "4. 还原标准化数据—–salce(均值-方差标准化)",
    "text": "4. 还原标准化数据—–salce(均值-方差标准化)\n比如: 我们经常对train数据进行标准化，并且用train数据的参数去标准化test数据,R中没有内置的函数。\n还有：有些模型和数据 存在量纲差异，需要标准化后建模，并预测，预测出来的值是标准化后的数据，此时需要把预测的数据还原成真实数据，此时就需要原始数据的标准化参数了\n\n\nShow the code\nstand_scale <- preProcess(iris)  #采用(x-mu)/std的标准化方法，与scale()函数效果一样\niris_scale=predict(stand_scale,iris[,1:4])\n\n\niris_new <- t(apply(iris_scale,1,function(x){x*stand_scale$std+stand_scale$mean}))\niris_new %>% head(.,10)\n\n\n      Sepal.Length Sepal.Width Petal.Length Petal.Width\n [1,]          5.1         3.5          1.4         0.2\n [2,]          4.9         3.0          1.4         0.2\n [3,]          4.7         3.2          1.3         0.2\n [4,]          4.6         3.1          1.5         0.2\n [5,]          5.0         3.6          1.4         0.2\n [6,]          5.4         3.9          1.7         0.4\n [7,]          4.6         3.4          1.4         0.3\n [8,]          5.0         3.4          1.5         0.2\n [9,]          4.4         2.9          1.4         0.2\n[10,]          4.9         3.1          1.5         0.1\n\n\nShow the code\nhead(iris,10)\n\n\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1           5.1         3.5          1.4         0.2  setosa\n2           4.9         3.0          1.4         0.2  setosa\n3           4.7         3.2          1.3         0.2  setosa\n4           4.6         3.1          1.5         0.2  setosa\n5           5.0         3.6          1.4         0.2  setosa\n6           5.4         3.9          1.7         0.4  setosa\n7           4.6         3.4          1.4         0.3  setosa\n8           5.0         3.4          1.5         0.2  setosa\n9           4.4         2.9          1.4         0.2  setosa\n10          4.9         3.1          1.5         0.1  setosa"
  },
  {
    "objectID": "posts/post/数据标准化方法.html#还原标准化数据max-min",
    "href": "posts/post/数据标准化方法.html#还原标准化数据max-min",
    "title": "R语言标准化数据处理",
    "section": "5. 还原标准化数据—–max-min",
    "text": "5. 还原标准化数据—–max-min\n\n\nShow the code\nstand_range <- preProcess(iris[1:4],method = \"range\")\niris_max_prePro=predict(stand_range ,iris[1:4])\n\nt(apply(iris_max_prePro,1,function(x){x*(stand_range$ranges[2,]-stand_range$ranges[1,])+stand_range$ranges[1,] })) %>% head(.,10)\n\n\n      Sepal.Length Sepal.Width Petal.Length Petal.Width\n [1,]          5.1         3.5          1.4         0.2\n [2,]          4.9         3.0          1.4         0.2\n [3,]          4.7         3.2          1.3         0.2\n [4,]          4.6         3.1          1.5         0.2\n [5,]          5.0         3.6          1.4         0.2\n [6,]          5.4         3.9          1.7         0.4\n [7,]          4.6         3.4          1.4         0.3\n [8,]          5.0         3.4          1.5         0.2\n [9,]          4.4         2.9          1.4         0.2\n[10,]          4.9         3.1          1.5         0.1\n\n\nShow the code\nhead(iris,10)\n\n\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1           5.1         3.5          1.4         0.2  setosa\n2           4.9         3.0          1.4         0.2  setosa\n3           4.7         3.2          1.3         0.2  setosa\n4           4.6         3.1          1.5         0.2  setosa\n5           5.0         3.6          1.4         0.2  setosa\n6           5.4         3.9          1.7         0.4  setosa\n7           4.6         3.4          1.4         0.3  setosa\n8           5.0         3.4          1.5         0.2  setosa\n9           4.4         2.9          1.4         0.2  setosa\n10          4.9         3.1          1.5         0.1  setosa"
  },
  {
    "objectID": "posts/post/数据标准化方法.html#还原标准化数据dmwrunscale函数",
    "href": "posts/post/数据标准化方法.html#还原标准化数据dmwrunscale函数",
    "title": "R语言标准化数据处理",
    "section": "6. 还原标准化数据—DMwR::unscale()函数",
    "text": "6. 还原标准化数据—DMwR::unscale()函数\nunscale(vals, norm.data, col.ids)\n\n    vals    : 要还原标准化的数值型矩阵，或者数值型数据框  \n    norm.data    ： 以及标准化后的数据，必须是用scale()函数标准化后的数据  \n    col.ids ： 那些列可以不用标准化（默认全部列都有进行)  \n\n\nShow the code\n############ 新版本的的R好像没有这个包了\n# 我把iris数据集分为7:3\nlibrary(caret)\nlibrary(dplyr)\nlibrary(DMwR)\nlibrary(e1071)\n\n\n\n#############################################################\n########## 标准化数据\n# \ndata(algae)\nalgae[,4:12] %>% head() # 可以发现数据存在量纲的差异，我们要预测a1（因变量） ,其他为自变量\nnormData <- scale(algae[,4:12]) # 把train数据进行标准化\nt <- svm(a1 ~ .,normData[1:100,] %>% as.data.frame() ) #决策树模型\nnormPs <- predict(t,as.data.frame(normData[101:nrow(normData),])) # 可以发现预测的数据不是最终的数据，需要进行标准化还原\nnormPs %>% head() # 预测值 ,预测数据,都在0--1范围\nalgae[101:nrow(normData),\"a1\"] %>% head()# 真实值\nunscale(normPs,normData) %>% head()#于是还原预测数据\n\n\n\n\nShow the code\nsessionInfo()\n\n\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.5.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] dplyr_1.0.9     caret_6.0-93    lattice_0.20-45 ggplot2_3.3.6  \n\nloaded via a namespace (and not attached):\n [1] Rcpp_1.0.9           lubridate_1.8.0      listenv_0.8.0       \n [4] class_7.3-20         assertthat_0.2.1     digest_0.6.29       \n [7] ipred_0.9-13         foreach_1.5.2        utf8_1.2.2          \n[10] parallelly_1.32.1    R6_2.5.1             plyr_1.8.7          \n[13] stats4_4.2.1         hardhat_1.2.0        evaluate_0.16       \n[16] pillar_1.8.1         rlang_1.0.4          data.table_1.14.2   \n[19] rstudioapi_0.14      rpart_4.1.16         Matrix_1.4-1        \n[22] rmarkdown_2.16.1     splines_4.2.1        gower_1.0.0         \n[25] stringr_1.4.1        htmlwidgets_1.5.4    munsell_0.5.0       \n[28] compiler_4.2.1       xfun_0.32            pkgconfig_2.0.3     \n[31] globals_0.16.0       htmltools_0.5.3      nnet_7.3-17         \n[34] tidyselect_1.1.2     tibble_3.1.8         prodlim_2019.11.13  \n[37] codetools_0.2-18     fansi_1.0.3          future_1.27.0       \n[40] withr_2.5.0          ModelMetrics_1.2.2.2 MASS_7.3-58.1       \n[43] recipes_1.0.1        grid_4.2.1           nlme_3.1-159        \n[46] jsonlite_1.8.0       gtable_0.3.0         lifecycle_1.0.1     \n[49] DBI_1.1.3            magrittr_2.0.3       pROC_1.18.0         \n[52] scales_1.2.1         future.apply_1.9.0   cli_3.3.0           \n[55] stringi_1.7.8        reshape2_1.4.4       timeDate_4021.104   \n[58] generics_0.1.3       vctrs_0.4.1          lava_1.6.10         \n[61] iterators_1.0.14     tools_4.2.1          glue_1.6.2          \n[64] purrr_0.3.4          parallel_4.2.1       fastmap_1.1.0       \n[67] survival_3.4-0       yaml_2.3.5           colorspace_2.0-3    \n[70] knitr_1.40"
  },
  {
    "objectID": "posts/post/dplyrshizhan2.html",
    "href": "posts/post/dplyrshizhan2.html",
    "title": "dplyr – 2实战",
    "section": "",
    "text": "1.1、选择行filter()\n\n安装nycflights13包，该软件包中的飞机航班数据将用于本文中dplyr包各个函数的演示\n\nShow the codelibrary(dplyr)\nlibrary(nycflights13)\n\n\n函数tibble::as_tibble()将过长过大的数据集转换为显示更友好的tbl_df 类型:\n\nShow the codeflights <- tibble::as_tibble(flights)\nhead(flights) #有336,776 x 19\n\n# A tibble: 6 × 19\n   year month   day dep_time sched_dep…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n  <int> <int> <int>    <int>       <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n1  2013     1     1      517         515       2     830     819      11 UA     \n2  2013     1     1      533         529       4     850     830      20 UA     \n3  2013     1     1      542         540       2     923     850      33 AA     \n4  2013     1     1      544         545      -1    1004    1022     -18 B6     \n5  2013     1     1      554         600      -6     812     837     -25 DL     \n6  2013     1     1      554         558      -4     740     728      12 UA     \n# … with 9 more variables: flight <int>, tailnum <chr>, origin <chr>,\n#   dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>,\n#   time_hour <dttm>, and abbreviated variable names ¹​sched_dep_time,\n#   ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\nShow the codefilter(flights,origin == \"JFK\",month == 6L) #－ 获取六月份所有从”JFK”机场起飞的航班\n\n# A tibble: 9,472 × 19\n    year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n   <int> <int> <int>    <int>      <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n 1  2013     6     1        2       2359       3     341     350      -9 B6     \n 2  2013     6     1      538        545      -7     925     922       3 B6     \n 3  2013     6     1      539        540      -1     832     840      -8 AA     \n 4  2013     6     1      553        600      -7     700     711     -11 EV     \n 5  2013     6     1      554        600      -6     851     908     -17 UA     \n 6  2013     6     1      557        600      -3     934     942      -8 B6     \n 7  2013     6     1      559        600      -1     856     930     -34 UA     \n 8  2013     6     1      606        610      -4     847     906     -19 B6     \n 9  2013     6     1      609        615      -6     759     808      -9 US     \n10  2013     6     1      615        610       5     837     847     -10 B6     \n# … with 9,462 more rows, 9 more variables: flight <int>, tailnum <chr>,\n#   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#   minute <dbl>, time_hour <dttm>, and abbreviated variable names\n#   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\nShow the codeslice(flights,1:2) #选取前面的1:2行\n\n# A tibble: 2 × 19\n   year month   day dep_time sched_dep…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n  <int> <int> <int>    <int>       <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n1  2013     1     1      517         515       2     830     819      11 UA     \n2  2013     1     1      533         529       4     850     830      20 UA     \n# … with 9 more variables: flight <int>, tailnum <chr>, origin <chr>,\n#   dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>,\n#   time_hour <dttm>, and abbreviated variable names ¹​sched_dep_time,\n#   ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\nShow the codesample_n(flights, 4, replace = TRUE)# 随机选取4条数据记录。\n\n# A tibble: 4 × 19\n   year month   day dep_time sched_dep…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n  <int> <int> <int>    <int>       <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n1  2013     7    11     1703        1700       3    1940    2018     -38 DL     \n2  2013    10     1      822         829      -7    1007    1027     -20 DL     \n3  2013     5     5     1932        1930       2    2209    2237     -28 UA     \n4  2013     7    18     1836        1820      16    2145    2141       4 DL     \n# … with 9 more variables: flight <int>, tailnum <chr>, origin <chr>,\n#   dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>,\n#   time_hour <dttm>, and abbreviated variable names ¹​sched_dep_time,\n#   ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\nShow the codeflights %>% top_n(4,dep_time)\n\n# A tibble: 29 × 19\n    year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n   <int> <int> <int>    <int>      <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n 1  2013    10    30     2400       2359       1     327     337     -10 B6     \n 2  2013    11    27     2400       2359       1     515     445      30 B6     \n 3  2013    12     5     2400       2359       1     427     440     -13 B6     \n 4  2013    12     9     2400       2359       1     432     440      -8 B6     \n 5  2013    12     9     2400       2250      70      59    2356      63 B6     \n 6  2013    12    13     2400       2359       1     432     440      -8 B6     \n 7  2013    12    19     2400       2359       1     434     440      -6 B6     \n 8  2013    12    29     2400       1700     420     302    2025     397 AA     \n 9  2013     2     7     2400       2359       1     432     436      -4 B6     \n10  2013     2     7     2400       2359       1     443     444      -1 B6     \n# … with 19 more rows, 9 more variables: flight <int>, tailnum <chr>,\n#   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#   minute <dbl>, time_hour <dttm>, and abbreviated variable names\n#   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\n\n1.2、选择列 select()\n\n若要对选择的列进行处理用mutate函数，这里只能对列名进行处理.\n\nShow the codeans <- flights %>% select(dep_time,arr_time)\nhead(ans)\n\n# A tibble: 6 × 2\n  dep_time arr_time\n     <int>    <int>\n1      517      830\n2      533      850\n3      542      923\n4      544     1004\n5      554      812\n6      554      740\n\nShow the codeans <- flights %>% select(day:arr_delay)\nhead(ans)\n\n# A tibble: 6 × 7\n    day dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay\n  <int>    <int>          <int>     <dbl>    <int>          <int>     <dbl>\n1     1      517            515         2      830            819        11\n2     1      533            529         4      850            830        20\n3     1      542            540         2      923            850        33\n4     1      544            545        -1     1004           1022       -18\n5     1      554            600        -6      812            837       -25\n6     1      554            558        -4      740            728        12\n\n\n\nShow the code#选择整数列,若要对选择的列进行处理用mutate函数，这里只能对列名进行处理，比如\nans <- flights %>% head() %>% select(where(is.integer))\nans\n\n# A tibble: 6 × 8\n   year month   day dep_time sched_dep_time arr_time sched_arr_time flight\n  <int> <int> <int>    <int>          <int>    <int>          <int>  <int>\n1  2013     1     1      517            515      830            819   1545\n2  2013     1     1      533            529      850            830   1714\n3  2013     1     1      542            540      923            850   1141\n4  2013     1     1      544            545     1004           1022    725\n5  2013     1     1      554            600      812            837    461\n6  2013     1     1      554            558      740            728   1696\n\n\n\nShow the code#选择是字符串的列\nans <- flights %>% head() %>% select(where(function(x)is.character(x) ))\nans\n\n# A tibble: 6 × 4\n  carrier tailnum origin dest \n  <chr>   <chr>   <chr>  <chr>\n1 UA      N14228  EWR    IAH  \n2 UA      N24211  LGA    IAH  \n3 AA      N619AA  JFK    MIA  \n4 B6      N804JB  JFK    BQN  \n5 DL      N668DN  LGA    ATL  \n6 UA      N39463  EWR    ORD  \n\n\n选择数值列并且以某个字符开始的列\n\nShow the codeselect(iris,where(is.numeric)) %>% select(starts_with(\"s\")) %>% head()\n\n  Sepal.Length Sepal.Width\n1          5.1         3.5\n2          4.9         3.0\n3          4.7         3.2\n4          4.6         3.1\n5          5.0         3.6\n6          5.4         3.9\n\n\n选择非数值列\n\nShow the code# 选择非数值列\nlibrary(purrr)\niris %>% select(!where( is.numeric )) %>% head()\n\n  Species\n1  setosa\n2  setosa\n3  setosa\n4  setosa\n5  setosa\n6  setosa\n\nShow the codeiris %>% select(where(is.factor)) %>% head()\n\n  Species\n1  setosa\n2  setosa\n3  setosa\n4  setosa\n5  setosa\n6  setosa\n\n\n行同时选择——子集\n\nShow the codefilter(flights,origin == \"JFK\",month == 6L) %>%select(day:arr_delay)\n\n# A tibble: 9,472 × 7\n     day dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay\n   <int>    <int>          <int>     <dbl>    <int>          <int>     <dbl>\n 1     1        2           2359         3      341            350        -9\n 2     1      538            545        -7      925            922         3\n 3     1      539            540        -1      832            840        -8\n 4     1      553            600        -7      700            711       -11\n 5     1      554            600        -6      851            908       -17\n 6     1      557            600        -3      934            942        -8\n 7     1      559            600        -1      856            930       -34\n 8     1      606            610        -4      847            906       -19\n 9     1      609            615        -6      759            808        -9\n10     1      615            610         5      837            847       -10\n# … with 9,462 more rows\n\n\n1.3、排序arrange()\n\n\nShow the codeans <- arrange(flights,origin,desc(dest))  #对列名加 desc() 进行倒序: 与基本函数order()类似\nhead(ans)\n\n# A tibble: 6 × 19\n   year month   day dep_time sched_dep…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n  <int> <int> <int>    <int>       <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n1  2013     1     2      905         822      43    1313    1045      NA EV     \n2  2013     1     3      848         850      -2    1149    1113      36 EV     \n3  2013     1     4      901         850      11    1120    1113       7 EV     \n4  2013     1     6      843         848      -5    1053    1111     -18 EV     \n5  2013     1     7      858         850       8    1105    1113      -8 EV     \n6  2013     1     8      847         850      -3    1116    1113       3 EV     \n# … with 9 more variables: flight <int>, tailnum <chr>, origin <chr>,\n#   dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>,\n#   time_hour <dttm>, and abbreviated variable names ¹​sched_dep_time,\n#   ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\n\n1.4、添加新变量mutate\n\n\nShow the code# 添加新变量(可以多列) \nflights %>% mutate(yanwu=arr_delay + dep_delay) %>% head()\n\n# A tibble: 6 × 20\n   year month   day dep_time sched_dep…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n  <int> <int> <int>    <int>       <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n1  2013     1     1      517         515       2     830     819      11 UA     \n2  2013     1     1      533         529       4     850     830      20 UA     \n3  2013     1     1      542         540       2     923     850      33 AA     \n4  2013     1     1      544         545      -1    1004    1022     -18 B6     \n5  2013     1     1      554         600      -6     812     837     -25 DL     \n6  2013     1     1      554         558      -4     740     728      12 UA     \n# … with 10 more variables: flight <int>, tailnum <chr>, origin <chr>,\n#   dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>,\n#   time_hour <dttm>, yanwu <dbl>, and abbreviated variable names\n#   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\nShow the codeflights %>% transmute(yanwu=arr_delay + dep_delay) %>% head()\n\n# A tibble: 6 × 1\n  yanwu\n  <dbl>\n1    13\n2    24\n3    35\n4   -19\n5   -31\n6     8\n\n\n有多少航班完全没有延误\n\nShow the code#有多少航班完全没有延误\nflights %>% mutate(yanwu=arr_delay + dep_delay) %>% filter(yanwu<0) %>% head()\n\n# A tibble: 6 × 20\n   year month   day dep_time sched_dep…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n  <int> <int> <int>    <int>       <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n1  2013     1     1      544         545      -1    1004    1022     -18 B6     \n2  2013     1     1      554         600      -6     812     837     -25 DL     \n3  2013     1     1      557         600      -3     709     723     -14 EV     \n4  2013     1     1      557         600      -3     838     846      -8 B6     \n5  2013     1     1      558         600      -2     849     851      -2 B6     \n6  2013     1     1      558         600      -2     853     856      -3 B6     \n# … with 10 more variables: flight <int>, tailnum <chr>, origin <chr>,\n#   dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>,\n#   time_hour <dttm>, yanwu <dbl>, and abbreviated variable names\n#   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n\nShow the code# 可以在同一语句中对刚新增加的列进行操作:\ntransmute(flights, \n       gain = arr_delay + dep_delay, \n       gain_per_hour = gain / (arr_time / 60))\n\n# A tibble: 336,776 × 2\n    gain gain_per_hour\n   <dbl>         <dbl>\n 1    13         0.940\n 2    24         1.69 \n 3    35         2.28 \n 4   -19        -1.14 \n 5   -31        -2.29 \n 6     8         0.649\n 7    14         0.920\n 8   -17        -1.44 \n 9   -11        -0.788\n10     6         0.478\n# … with 336,766 more rows\n\n\n1.5 汇总(行): summarise()\n\n对数据框调用其它函数进行汇总操作, 返回一维的结果:先用一个简单的数据集iris\n\nShow the codeiris %>% group_by(Species) %>% summarise(m = mean(Sepal.Length,na.rm = T))\n\n# A tibble: 3 × 2\n  Species        m\n  <fct>      <dbl>\n1 setosa      5.01\n2 versicolor  5.94\n3 virginica   6.59\n\nShow the codeiris %>% group_by(Species) %>% summarise(across(where(is.numeric),list(mean=mean)))\n\n# A tibble: 3 × 5\n  Species    Sepal.Length_mean Sepal.Width_mean Petal.Length_mean Petal.Width_…¹\n  <fct>                  <dbl>            <dbl>             <dbl>          <dbl>\n1 setosa                  5.01             3.43              1.46          0.246\n2 versicolor              5.94             2.77              4.26          1.33 \n3 virginica               6.59             2.97              5.55          2.03 \n# … with abbreviated variable name ¹​Petal.Width_mean\n\nShow the codeiris %>% group_by(Species) %>% summarise(across(starts_with(\"Sepal\"), list(min = min,max = max)))\n\n# A tibble: 3 × 5\n  Species    Sepal.Length_min Sepal.Length_max Sepal.Width_min Sepal.Width_max\n  <fct>                 <dbl>            <dbl>           <dbl>           <dbl>\n1 setosa                  4.3              5.8             2.3             4.4\n2 versicolor              4.9              7               2               3.4\n3 virginica               4.9              7.9             2.2             3.8\n\n\n\nShow the codeiris %>% group_by(k = round(Sepal.Width,0) ) %>% \n  summarise(f_count=n()) %>% arrange(desc(f_count)) \n\n# A tibble: 3 × 2\n      k f_count\n  <dbl>   <int>\n1     3     106\n2     4      25\n3     2      19\n\nShow the code#上述等价 \niris %>% group_by(k = round(Sepal.Width,0)) %>% tally(sort=TRUE)\n\n# A tibble: 3 × 2\n      k     n\n  <dbl> <int>\n1     3   106\n2     4    25\n3     2    19\n\nShow the code#tally可以一步完成上述工作，group_by()以后第一次使用tally进行n()操作,再一次就是sum(n) sort=TRUE对结果排序,当等于TRUE是降序\n#再次使用tally()就是sum()\niris %>% group_by(k = round(Sepal.Width,0)) %>% tally(sort=TRUE)%>%tally()\n\n# A tibble: 1 × 1\n      n\n  <int>\n1     3\n\n\n1.6、分组动作\n以上5个函数已经很方便了, 但是当它们跟分组操作这个概念结合起来时, 那才叫真正的强大! 当对数据集通过 group_by()添加了分组信息后,filter(),select（）,mutate(), arrange() 和 summarise() 函数会自动对这些 tbl 类数据执行分组操作 (R语言泛型函数的优势).\n例如: 对飞机航班数据按飞机编号 (tailnum) 进行分组, 计算该飞机航班的次数 (count = n()), 平均飞行距离 (dist = mean(distance, na.rm = TRUE)) 和 延时 (delay = mean(arr_delay, na.rm = TRUE))\n\nShow the codeans=flights %>%\n        group_by(tailnum) %>%\n            summarise(count=n(),\n                      dist=mean(distance,na.rm = T),\n                      delay=mean(arr_delay,na.rm = T))\n\nans %>% head()\n\n# A tibble: 6 × 4\n  tailnum count  dist delay\n  <chr>   <int> <dbl> <dbl>\n1 D942DN      4  854. 31.5 \n2 N0EGMQ    371  676.  9.98\n3 N10156    153  758. 12.7 \n4 N102UW     48  536.  2.94\n5 N103US     46  535. -6.93\n6 N104UW     47  535.  1.80\n\nShow the codeans = ans %>% filter(count>20 & dist<2000 & delay >0 )\n#用 ggplot2 包作个图观察一下, 发现飞机延时不延时跟飞行距离没太大相关性:\nlibrary(ggplot2)\nggplot(ans, aes(dist, delay)) + geom_point(aes(size = count), alpha = 1/2) + geom_smooth(method = 'gam',formula = y ~ s(x, bs = \"cs\")) + scale_size_area()\n\n\n\n\n\nShow the codesessionInfo()"
  },
  {
    "objectID": "posts/post/R计算微积分.html",
    "href": "posts/post/R计算微积分.html",
    "title": "R计算微积分",
    "section": "",
    "text": "1.2 符号计算–微分\n1.2.1求一元函数导数— \\(\\sin{x}\\) 的一阶导数为： \\(\\cos{x}\\)\n\n在R里，声明表达式对象使用 expression() 函数, 计算一阶导数用D()函数,格式：D(表达式,对谁求导)\n\nShow the codefun=expression(sin(x))# 声明表达式\nD(fun,\"x\")#---方法1\n\ncos(x)\n\nShow the codederiv(fun,\"x\")#---方法2  其中.grad[, \"x\"]为求x的导数表达式\n\nexpression({\n    .value <- sin(x)\n    .grad <- array(0, c(length(.value), 1L), list(NULL, c(\"x\")))\n    .grad[, \"x\"] <- cos(x)\n    attr(.value, \"gradient\") <- .grad\n    .value\n})\n\nShow the codederiv3(fun,\"x\")#---方法3 其中.grad[, \"x\"]为求x的导数表达式\n\nexpression({\n    .expr1 <- sin(x)\n    .value <- .expr1\n    .grad <- array(0, c(length(.value), 1L), list(NULL, c(\"x\")))\n    .hessian <- array(0, c(length(.value), 1L, 1L), list(NULL, \n        c(\"x\"), c(\"x\")))\n    .grad[, \"x\"] <- cos(x)\n    .hessian[, \"x\", \"x\"] <- -.expr1\n    attr(.value, \"gradient\") <- .grad\n    attr(.value, \"hessian\") <- .hessian\n    .value\n})\n\n\n1.2.2 计算n阶导数\n\n\n计算n阶导数—方法一: 结合一阶导数写递归函数\n函数： \\(\\sin{x}+\\cos{2x}+x^2+xy+y^2+2x^3+y^3\\) 的3阶导数为：\\(12 + 8\\sin{2x} -\\cos{x}\\)\n\n\n\nShow the code   fun=expression(sin(x)+cos(2*x)+x^2+x*y+y^2+2*x^3+y^3)\n   DD <- function(expr, name, order = 1) {\n     if (order < 1)\n       stop(\"'order' must be >= 1\")\n     if (order == 1){\n       D(expr, name)\n     }else{\n       DD(D(expr, name), name, order - 1)\n     }\n   }\n   DD(fun,\"x\",3)\n\n2 * (3 * 2) - (cos(x) - sin(2 * x) * 2 * 2 * 2)\n\n\n\n计算n阶导数—方法二: Deriv 包中Simplify()化简表达式\n\n\nShow the code   library(Deriv)\n   DD(fun,\"x\",3)\n\n2 * (3 * 2) - (cos(x) - sin(2 * x) * 2 * 2 * 2)\n\nShow the code   Simplify(DD(fun, \"x\", 3))\n\n12 + 8 * sin(2 * x) - cos(x)\n\n\n1.2.3 通过函数计算导数\n有时候我们有的就是函数，这怎么计算导数呢？—还是用上面的函数\n\nShow the codef=function(x,y)sin(x)+cos(2*x)+x^2+x*y+y^2+2*x^3+y^3 #这里是函数，而不是表达式\nbody(f)\n\nsin(x) + cos(2 * x) + x^2 + x * y + y^2 + 2 * x^3 + y^3\n\nShow the codeSimplify(D(body(f), \"x\"))# 注意：函数体有花括号{}会出错\n\ncos(x) + x * (2 + 6 * x) + y - 2 * sin(2 * x)\n\n\n1.2.4 求二元函数偏导数及梯度\n\nShow the codeD(expression(x^2+x*y+y^2),\"x\")# x偏导数\n\n2 * x + y\n\nShow the codeD(expression(x^2+x*y+y^2),\"y\")# y偏导数\n\nx + 2 * y\n\n\n1.2.5 符号计算扩展包 Ryacas\n想要做更多的符号计算内容，如解方程，泰勒展开等，可以借助第三方 R 扩展包 Ryacas\n解方程: \\(\\frac{x}{1+x}=a\\) 求解\\(x=\\frac{a}{1-a}\\)\n\nShow the codelibrary(Ryacas)\nysym(\"Solve(x/(1+x) == a, x)\") \n\n{x==a/(1-a)} \n\n\n多项式展开：如\\((1+x)^3\\) 展开\n\nShow the codeysym(expression(Expand((1 + x)^3)))# 把(1+x)^3展开\n\ny: x^3+3*x^2+3*x+1\n\n\n求解常微分方程：\\(y''=4y\\)\n\nShow the codeysym(\"OdeSolve(y''== 4 * y)\")\n\ny: C105*Exp(2*x)+C109*Exp((-2)*x)\n\n\n泰勒展开：\\(\\cos{x}=1-\\frac{1}{2!}x^2+\\frac{1}{4!}x^4+o(x^4)\\)\n\nShow the codeysym(\"Taylor(x, a, 3) cos(x)\") # cos(x)函数在a点的3阶泰勒展开\n\ny: cos(a)+(Deriv(a)cos(a))*(x-a)+((x-a)^2*(Deriv(a)Deriv(a)cos(a)))/2+((x-a)^3*(Deriv(a)Deriv(a)Deriv(a)cos(a)))/6\n\n\n1.3 表达式转为函数值\n很多时候我们使用 R 目的是计算，符号计算后希望可以直接代入计算，那么只需要在 deriv 中指定 function.arg 参数为 TRUE。 \\[\n\\sin{x}+\\cos{2x}+x^2+xy+y^2对x求偏导为：\\cos{x}-2sin{2x}+2x+y\n\\]\n\nShow the codefun=expression(sin(x)+cos(2*x)+x^2+x*y+y^2)\ndx=D(fun,\"x\") #用D()函数得到符号运算结果，然后代入数值即可得到最后结果\ndx\n\ncos(x) - sin(2 * x) * 2 + 2 * x + y\n\nShow the codex=0;y=pi# 对x、y赋值\neval(dx)#求出数值解\n\n[1] 4.141593\n\nShow the codeDfun=deriv(fun,c(\"x\",\"y\"),function.arg = TRUE)# 同时对x、y求偏导--D()函数不可以同时求偏导\nDfun(x=0,y=pi/2) # 代值计算，其中attr(,\"gradient\")的值为导数值 ，另一个为原函数在该处的函数值\n\n[1] 3.467401\nattr(,\"gradient\")\n            x        y\n[1,] 2.570796 3.141593\n\nShow the code#我们可以作如下简单验证：\nfun=function(x,y){sin(x)+cos(2*x)+x^2+x*y+y^2}\nfun(x=0,y=pi/2)\n\n[1] 3.467401\n\n\n1.3、求积分—暂时只找到数值计算的–没找到符号计算的\n积分函数： integrate(fun,a,b) fun被积函数，不需要表达式，因为这是数值计算, a,b为上下限\n\nShow the codef <- function (x) sin(x)\nintegrate(f,0,pi/2)\n\n1 with absolute error < 1.1e-14\n\n\n有些时候只想要值输入 integrate(f,0,1)$value\n\nShow the codeintegrate(f,0,pi/2)$value\n\n[1] 1\n\n\n\nShow the codesessionInfo()\n\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.5.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] Ryacas_1.1.3.1 Deriv_4.1.3   \n\nloaded via a namespace (and not attached):\n [1] Rcpp_1.0.9        digest_0.6.29     jsonlite_1.8.0    magrittr_2.0.3   \n [5] evaluate_0.16     rlang_1.0.4       stringi_1.7.8     cli_3.3.0        \n [9] rstudioapi_0.14   rmarkdown_2.16.1  tools_4.2.1       stringr_1.4.1    \n[13] htmlwidgets_1.5.4 pkgload_1.3.0     xfun_0.32         yaml_2.3.5       \n[17] fastmap_1.1.0     compiler_4.2.1    htmltools_0.5.3   knitr_1.40"
  },
  {
    "objectID": "posts/post/Rplotarrows.html",
    "href": "posts/post/Rplotarrows.html",
    "title": "R画带箭头的坐标轴",
    "section": "",
    "text": "本质的方法：就是去掉原有的坐标轴，然后通过R的低等函数一步一步的画出坐标轴以及需要的曲线，以下是google到的几种方法：\n\n\nShow the code##################  画带箭头的坐标轴\n## estimate curve\nx <- seq(-1,1.5,0.1);\ny <- c(1.3,1.32,1.33,1.32,1.25,1.1,0.7,0.5,0.4,0.38,0.4,0.41,0.42,0.43,0.44,0.4,0.3,0.1,0,-0.05,-0.1,-0.15,-0.2,-0.24,-0.28,-0.3);\nf <- splinefun(x,y);\n\n## calculate precise points along estimated curve\nx <- seq(-1,1.5,0.01);\ny <- f(x);\n\n## precompute limits\nxlim <- c(min(x),max(x));\nylim <- c(min(y)-0.4,max(y)+0.2);\n\n## set global plot params\npar(xaxs='i',yaxs='i',mar=c(1,1,3,3)+0.1); ## \"internal\" axis spacing, meaning no extended range, and slightly adjust margins\n\n## draw plot\nplot(NA,xlim=xlim,ylim=ylim,axes=F,ann=F); ## set plot bounds, no default ornaments\narrows(c(0,xlim[1]),c(ylim[1],0),c(0,xlim[2]),c(ylim[2],0),0.05); ## draw custom axes\nmtext('y',3,1,at=0,las=1,cex=0.8,family='serif'); ## y label\nmtext('x',4,1,at=0,las=1,cex=0.8,family='serif'); ## x label\nlines(x,y,col='#aaaacc'); ## draw line on top\n\n\n\n\n\n\nShow the code##  Simulate your data:\nx <- seq(-1, 3, by=0.01)\ny <- 0.5*x - 0.3*x^2 + 0.4*x^3\n\n##  Plot the polynomial function, removing axis ticks and bounding box,\n##    as well as the axis labels:\nplot(x, y, \n     type=\"l\", \n     xaxt='n', yaxt='n', \n     bty='n', \n     xlab='', ylab='', \n     col=\"blue\")# 画图\n\n##  Next add in your axis arrows:\n# 适当缩小坐标轴 \nsmall = 0.9\narrows(min(x)*small, 0, max(x)*small, 0, lwd=1, length=0.15)\narrows(0, min(y)*small, 0, max(y)*small, lwd=1, length=0.15)\n\n\n\n\n\n在方法二的基础上进行进一步修改\n\nShow the code##  Simulate your data:\nx <- seq(-1, 3, by=0.01)\ny <- 0.5*x - 0.3*x^2 + 0.4*x^3\n\n##  Plot the polynomial function, removing axis ticks and bounding box,\n##    as well as the axis labels:\nplot(x, y, \n     type=\"l\", \n     xaxt='n', yaxt='n', \n     bty='n', \n     xlab='', ylab='', \n     col=\"blue\")# 画图\n\n##  Next add in your axis arrows:\n# 适当缩小坐标轴 \nsmall = 0.9\narrows(min(x)*small, 0, max(x)*small, 0, lwd=1, length=0.15)\narrows(0, min(y)*small, 0, max(y)*small, lwd=1, length=0.15)\npar(family='STKaiti')\n\ntext(max(x), (max(y) - min(y))*0.1,'X轴')\n\ntext((max(x)-min(x))*0.1, max(y),'Y轴')\n\n# 画标度---x 标度\nk1 =ceiling(range(x)[1]*small)\nk2 = floor(range(x)[2] *small )\nk = 0.5 #k为刻度\nfor (i in seq(k1,k2,k)) {\n  n=10\n  if(i == 0 ) next()\n  lines(rep(i,n),seq(0,k*0.3,length.out = n),type = \"l\")# 垂直X轴的直线长度\n  \n  text(i,-(max(x) - min(x) )*0.1,i)\n  \n}\n\n\n# 画标度---y 标度\nk1 =ceiling(range(y)[1]*small) \nk2 = floor(range(y)[2]*small)\nk = 1\nfor (i in seq(k1,k2,k)) { # 坐标轴的间隔，以1为单位,k为刻度\n  n=10\n  if(i == 0 ) next()\n  lines(seq(0,k*0.01,length.out = n),rep(i,n),type = \"l\")\n  text(-0.02*(max(x)-min(x) ),i,i)\n}\n## 画原点\ntext(-(max(x) - min(x))*0.03,-(max(y) - min(y))*0.03,\"O\",cex=1.3)"
  },
  {
    "objectID": "posts/post/Rplotarrows.html#基本函数画多折线图",
    "href": "posts/post/Rplotarrows.html#基本函数画多折线图",
    "title": "R画带箭头的坐标轴",
    "section": "基本函数画多折线图",
    "text": "基本函数画多折线图\n\nShow the codet = seq(1,10,length.out = 10000)\nmatplot(t,cbind(sin(t),cos(t)),type ='b',pch = 19,cex = 0.1)\n\n\n\n\n\nShow the codesessionInfo()\n#> R version 4.2.1 (2022-06-23)\n#> Platform: aarch64-apple-darwin20 (64-bit)\n#> Running under: macOS Monterey 12.5.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n#> \n#> locale:\n#> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] digest_0.6.29     jsonlite_1.8.0    magrittr_2.0.3    evaluate_0.16    \n#>  [5] rlang_1.0.4       stringi_1.7.8     cli_3.3.0         rstudioapi_0.14  \n#>  [9] rmarkdown_2.16.1  tools_4.2.1       stringr_1.4.1     htmlwidgets_1.5.4\n#> [13] xfun_0.32         yaml_2.3.5        fastmap_1.1.0     compiler_4.2.1   \n#> [17] htmltools_0.5.3   knitr_1.40"
  },
  {
    "objectID": "posts/post/相关图之corrplot.html",
    "href": "posts/post/相关图之corrplot.html",
    "title": "相关图之corrplot",
    "section": "",
    "text": "由于corrgram::corrgram()函数没有显示相关性的大小度量关系，于是经常用corrplot::corrplot()函数来画相关矩阵图，不过此图的缺点是title画出来不好看\ncorrplot(corr, \n  method = c(\"circle\", \"square\", \"ellipse\", \"number\", \"shade\",\"color\", \"pie\"), \n  type = c(\"full\", \"lower\", \"upper\"), add = FALSE,\n  col = NULL, bg = \"white\", title = \"\", is.corr = TRUE, diag = TRUE,\n  outline = FALSE, mar = c(0, 0, 0, 0), addgrid.col = NULL,\n  addCoef.col = NULL, addCoefasPercent = FALSE, order = c(\"original\",\n  \"AOE\", \"FPC\", \"hclust\", \"alphabet\"), hclust.method = c(\"complete\", \"ward\",\n  \"ward.D\", \"ward.D2\", \"single\", \"average\", \"mcquitty\", \"median\", \"centroid\"),\n  addrect = NULL, rect.col = \"black\", rect.lwd = 2, tl.pos = NULL,\n  tl.cex = 1, tl.col = \"red\", tl.offset = 0.4, tl.srt = 90,\n  cl.pos = NULL, cl.lim = NULL, cl.length = NULL, cl.cex = 0.8,\n  cl.ratio = 0.15, cl.align.text = \"c\", cl.offset = 0.5, number.cex = 1,\n  number.font = 2, number.digits = NULL, addshade = c(\"negative\",\n  \"positive\", \"all\"), shade.lwd = 1, shade.col = \"white\", p.mat = NULL,\n  sig.level = 0.05, insig = c(\"pch\", \"p-value\", \"blank\", \"n\", \"label_sig\"),\n  pch = 4, pch.col = \"black\", pch.cex = 3, plotCI = c(\"n\", \"square\",\n  \"circle\", \"rect\"), lowCI.mat = NULL, uppCI.mat = NULL, na.label = \"?\",\n  na.label.col = \"black\", win.asp = 1, ...)\n\n\n参数解释：\ncorr： 用于绘图的矩阵，必须是正方形矩阵(即相关系数矩阵)，如果是普通的矩阵，需要设置is.corr=FALSE \nmethod：可以是circle(圆形,默认),square(方形),ellipse(椭圆形),number(数值),shade(阴影),color(颜色),pie(饼图)。\ntype：用于设置相关矩阵图的显示区域：full(全部，默认), lower(下三角), upper(上三角)。\ncol：指定图形展示的颜色，默认以均匀的颜色展示，可以通过colorRampPalette函数向col参数赋值来设置颜色。\nbg：指定图的背景色 \ntitle：为图形添加标题\ndiag：是否展示对角线上的结果，默认为TRUE\noutline：是否绘制圆形、方形或椭圆形的轮廓，默认为FALSE\nmar：具体设置图形的四边间距\naddgrid.col：当选择的方法为颜色或阴影时，默认的网格线颜色为白色，否则为灰色\naddCoef.col：为相关系数添加颜色，默认不添加相关系数，只有方法为number时，该参数才起作用\naddCoefasPercent：为节省绘图空间，是否将相关系数转换为百分比格式，默认为FALSE\norder：指定相关系数排序的方法，一般”AOE”排序结果都比”FPC”要好\n        可以是：original(原始顺序)、AOE(特征向量角序)、FPC(第一主成分顺序)、hclust(层次聚类顺序)和alphabet(字母顺序)\n        \nhclust.method：当order为hclust时，该参数可以是层次聚类中ward法、最大距离法等7种之一\naddrect：当order为hclust时，可以为添加相关系数图添加矩形框，默认不添加框，如果想添加框时，只需为该参数指定一个整数即可\nrect.col：指定矩形框的颜色\nrect.lwd：指定矩形框的线宽\ntl.pos：指定文本标签(变量名称)的位置，字符型参数为：\"lt\", \"ld\", \"td\", \"d\" or \"n\"\n      当type=full时，默认标签位置在左边和顶部(lt)，\n    当type=lower时，默认标签在左边和对角线(ld)，\n      当type=upper时，默认标签在顶部和对角线， d表示diagonal(对角线)， n表示不添加文本标签\n\ntl.cex：指定文本标签的大小\ntl.col：指定文本标签的颜色\ncl.pos：图例（颜色条）位置，\n      当type=upper或full时，图例在右表(r)，\n      当type=lower时，图例在底部，\n      不需要图例时，只需指定该参数为n\n\naddshade：只有当method=shade时，该参数才有用，\n    参数值可以是negtive/positive和all，分表表示对负相关系数、正相关系数和所有相关系数添加阴影。\n    注意：正相关系数的阴影是45度，负相关系数的阴影是135度\n\nshade.lwd：指定阴影的线宽\nshade.col：指定阴影线的颜色\n\n参数 cl.*  用于设置图例的颜色（图例的色条），tl.* 用于设置图例的文本(标量名称)。\n对于文本标签，这两个函数 tl.col（文本标签颜色）和tl.srt（文本标签字符串旋转）用于更改文本颜色和旋转。\n\n\n代码library(corrplot)\n\nM &lt;- cor(mtcars)\nmethod = c(\"circle\", \"square\", \"ellipse\", \"number\", \"shade\",\"color\")\npar(mfrow=c(3,2))\nt = mapply(function(x){corrplot(M,method = x,order = \"AOE\",title=paste0(\"method=\",x))},method)\n\n\n\n\n\ntype = c(“full”, “lower”, “upper”)\ncorrplot.mixed() 是一个混合可视化风格的包装函数。\n\n代码M &lt;- cor(mtcars)\ntype = c(\"full\", \"lower\", \"upper\")\npar(mfrow=c(1,3))\nt = mapply(function(x){corrplot(M,order = \"hclust\",type = x,title=paste0(\"type=\",x))},type)\n\n\n\n\n\n代码par(mfrow=c(2,2))\ncorrplot.mixed(M)\ncorrplot.mixed(M, lower.col = \"black\", number.cex = .7)\ncorrplot.mixed(M, lower = \"ellipse\", upper = \"circle\")\ncorrplot.mixed(M, lower = \"square\", upper = \"circle\", tl.col = \"black\") # tl.col：指定文本标签的颜色\n\n\n\n\n\n\n代码order = c(\"original\",\"AOE\", \"FPC\", \"hclust\", \"alphabet\")\npar(mfrow=c(2,3))\nt = mapply(function(x){corrplot(M,order = x,title=paste0(\"order=\",x))},order)\n\n\n####### # 如果使用\"hclust\"，corrplot()可以根据层次聚类的结果在corrrlation矩阵图表周围绘制矩形。\npar(mfrow=c(1,2))\n\n\n\n代码corrplot(M, order = \"hclust\", addrect = 2)\ncorrplot(M, order = \"hclust\", addrect = 3)\n\n\n\n代码####### # 改变背景颜色以及图像颜色\npar(mfrow=c(1,1))\ncorrplot(M, type = \"upper\", order = \"hclust\", col = c(\"black\", \"white\"), bg = \"lightblue\")\n\n\n\n\n\n\n代码# 如上一节所示，可以定制相关图的颜色。该功能colorRampPalette()非常便于产生色谱。\n\ncol1 &lt;- colorRampPalette(c(\"#7F0000\", \"red\", \"#FF7F00\", \"yellow\", \"white\",\n                           \"cyan\", \"#007FFF\", \"blue\", \"#00007F\"))\ncol2 &lt;- colorRampPalette(c(\"#67001F\", \"#B2182B\", \"#D6604D\", \"#F4A582\",\n                           \"#FDDBC7\", \"#FFFFFF\", \"#D1E5F0\", \"#92C5DE\",\n                           \"#4393C3\", \"#2166AC\", \"#053061\"))\ncol3 &lt;- colorRampPalette(c(\"red\", \"white\", \"blue\")) \ncol4 &lt;- colorRampPalette(c(\"#7F0000\", \"red\", \"#FF7F00\", \"yellow\", \"#7FFF7F\",\n                           \"cyan\", \"#007FFF\", \"blue\", \"#00007F\"))\nwhiteblack &lt;- c(\"white\", \"black\")\n\n## using these color spectra\npar(mfrow=c(2,2))\ncorrplot(M, order = \"hclust\", addrect = 2, col = col1(100))\ncorrplot(M, order = \"hclust\", addrect = 2, col = col2(50))\ncorrplot(M, order = \"hclust\", addrect = 2, col = col3(20))\ncorrplot(M, order = \"hclust\", addrect = 2, col = col4(10))\n\n\n\n代码\n\npar(mfrow=c(1,1))\ncorrplot(M, order = \"hclust\", addrect = 2, col = whiteblack, bg = \"gold2\")\n\n\n\n代码\n\n### 使用调色板包\n# 您也可以使用标准调色板（包grDevices）\npar(mfrow=c(2,2))\ncorrplot(M, order = \"hclust\", addrect = 2, col = heat.colors(100))\ncorrplot(M, order = \"hclust\", addrect = 2, col = terrain.colors(100))\ncorrplot(M, order = \"hclust\", addrect = 2, col = cm.colors(100))\ncorrplot(M, order = \"hclust\", addrect = 2, col = gray.colors(100))\n\n\n\n代码\n\n### 使用调色板包---使用RcolorBrewer包。\n\nlibrary(RColorBrewer)\ncorrplot(M, type = \"upper\", order = \"hclust\",col = brewer.pal(n = 8, name = \"RdBu\"))\ncorrplot(M, type = \"upper\", order = \"hclust\",col = brewer.pal(n = 8, name = \"RdYlBu\"))\ncorrplot(M, type = \"upper\", order = \"hclust\",col = brewer.pal(n = 8, name = \"PuOr\"))\n\n\n\n\n\n参数 cl.* 用于设置图例的颜色，tl.* 用于设置图例的文本。\n对于文本标签，这两个函数tl.col（文本标签颜色）和tl.srt（文本标签字符串旋转）用于更改文本颜色和旋转。\n\n代码par(mfrow=c(2,2))\n\n## remove color legend and text legend 移除图例的颜色部分和文字标签部分\ncorrplot(M, order = \"AOE\", cl.pos = \"n\", tl.pos = \"n\")  \n\n## bottom  color legend, diagonal text legend, rotate text label\n## 图底图例，对角线文字图例，旋转文字标签\ncorrplot(M, order = \"AOE\", cl.pos = \"b\", tl.pos = \"d\", tl.srt = 60) \n\n## a wider color legend with numbers right aligned\ncorrplot(M, order = \"AOE\", cl.ratio = 0.2, cl.align = \"r\")\n\n## text labels rotated 45 degrees\ncorrplot(M, type = \"lower\", order = \"hclust\", tl.col = \"black\", tl.srt = 45)\n\n\n\n\n\n\n代码\npar(mfrow=c(2,2))\ncorrplot(abs(M),order = \"AOE\", col = col3(200), cl.lim = c(0, 1))\n\n## visualize a  matrix in [-100, 100]\nran &lt;- round(matrix(runif(225, -100,100), 15))\ncorrplot(ran, is.corr = FALSE, method = \"square\")\n\n## a beautiful color legend \ncorrplot(ran, is.corr = FALSE, method = \"ellipse\", cl.lim = c(-100, 100))\n\n#如果矩阵是矩形，则可以使用win.asp参数调整纵横比， 以使矩阵呈现为正方形。\nran &lt;- matrix(rnorm(70), ncol = 7)\ncorrplot(ran, is.corr = FALSE, win.asp = .7, method = \"circle\")\n\n\n\n\n\n默认情况下，corrplot将NA值呈现为”?“字符。使用na.label 参数，可以使用不同的值（最多支持两个字符）。\n\n代码M2 &lt;- M\ndiag(M2) = NA\ncorrplot(M2)\n\n\n\n代码par(mfrow=c(1,2))\ncorrplot(M2, na.label = \"o\")\ncorrplot(M2, na.label = \"NA\")\n\n\n\n\n\n从版本开始0.78，可以 在变量名中使用plotmath表达式。要激活plotmath渲染，请在标签前加上一个字符\":\"，\"=\"or \"$\"。\n\n代码M2 &lt;- M[1:5,1:5]\ncolnames(M2) &lt;- c(\"alpha\", \"beta\", \":alpha+beta\", \":a[0]\", \"=a[beta]\")\nrownames(M2) &lt;- c(\"alpha\", \"beta\", NA, \"$a[0]\", \"$ a[beta]\")\ncorrplot(M2)\n\n\n\n\n\n\n代码res1 &lt;- cor.mtest(mtcars, conf.level = .95)\nres2 &lt;- cor.mtest(mtcars, conf.level = .99)\npar(mfrow=c(1,3))\n## specialized the insignificant value according to the significant level\ncorrplot(M, p.mat = res1$p, sig.level = .2)\n\ncorrplot(M, p.mat = res1$p, sig.level = .05)\n\ncorrplot(M, p.mat = res1$p, sig.level = .01)\n\n\n\n代码\n\n\n## leave blank on no significant coefficient\ncorrplot(M, p.mat = res1$p, insig = \"blank\")\n\n## add p-values on no significant coefficient\ncorrplot(M, p.mat = res1$p, insig = \"p-value\")\n\n## add all p-values\ncorrplot(M, p.mat = res1$p, insig = \"p-value\", sig.level = -1)\n\n\n\n代码\n\n\n## add cross on no significant coefficient \npar(mfrow=c(1,1))\ncorrplot(M, p.mat = res1$p, order = \"hclust\", insig = \"pch\", addrect = 3)\n\n\n\n\n\n\n代码par(mfrow=c(3,2))\ncorrplot(M, low = res1$lowCI, upp = res1$uppCI, order = \"hclust\",\n         rect.col = \"navy\", plotC = \"rect\", cl.pos = \"n\")\n\n\n\ncorrplot(M, p.mat = res1$p, low = res1$lowCI, upp = res1$uppCI,\n         order = \"hclust\", pch.col = \"red\", sig.level = 0.01,\n         addrect = 3, rect.col = \"navy\", plotC = \"rect\", cl.pos = \"n\")\n\n\n\n\nres1 &lt;- cor.mtest(mtcars, conf.level = .95)\ncorrplot(M, p.mat = res1$p, insig = \"label_sig\",\n         sig.level = c(.001, .01, .05), pch.cex = .9, pch.col = \"white\")\n\n\n\ncorrplot(M, p.mat = res1$p, method = \"color\",\n         insig = \"label_sig\", pch.col = \"white\")\n\n\n\ncorrplot(M, p.mat = res1$p, method = \"color\", type = \"upper\",\n         sig.level = c(.001, .01, .05), pch.cex = .9,\n         insig = \"label_sig\", pch.col = \"white\", order = \"AOE\")\n\n\ncorrplot(M, p.mat = res1$p, insig = \"label_sig\", pch.col = \"white\",\n         pch = \"p&lt;.05\", pch.cex = .5, order = \"AOE\")\n\n\n\n\n\n略\n参考： https://cran.r-project.org/web/packages/corrplot/vignettes/corrplot-intro.html\n\n代码sessionInfo()\n#&gt; R version 4.2.1 (2022-06-23)\n#&gt; Platform: aarch64-apple-darwin20 (64-bit)\n#&gt; Running under: macOS Monterey 12.5.1\n#&gt; \n#&gt; Matrix products: default\n#&gt; BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n#&gt; LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n#&gt; \n#&gt; locale:\n#&gt; [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#&gt; \n#&gt; attached base packages:\n#&gt; [1] stats     graphics  grDevices utils     datasets  methods   base     \n#&gt; \n#&gt; other attached packages:\n#&gt; [1] RColorBrewer_1.1-3 corrplot_0.92     \n#&gt; \n#&gt; loaded via a namespace (and not attached):\n#&gt;  [1] digest_0.6.29     jsonlite_1.8.0    magrittr_2.0.3    evaluate_0.16    \n#&gt;  [5] rlang_1.0.4       stringi_1.7.8     cli_3.3.0         rstudioapi_0.14  \n#&gt;  [9] rmarkdown_2.16.1  tools_4.2.1       stringr_1.4.1     htmlwidgets_1.5.4\n#&gt; [13] xfun_0.32         yaml_2.3.5        fastmap_1.1.0     compiler_4.2.1   \n#&gt; [17] htmltools_0.5.3   knitr_1.40"
  },
  {
    "objectID": "posts/post/glmnet1.html",
    "href": "posts/post/glmnet1.html",
    "title": "glmnet包解读1",
    "section": "",
    "text": "glmnet 包解决了一下问题（目标函数） \\[\n\\min_{\\beta_0,\\beta} \\frac{1}{N} \\sum_{i=1}^{N} w_i l(y_i,\\beta_0+\\beta^T x_i) + \\lambda\\left[(1-\\alpha)||\\beta||_2^2/2 + \\alpha ||\\beta||_1\\right],\n\\] #### 1.1 glmnet包安装\n\nShow the codeinstall.packages(\"glmnet\", repos = \"http://cran.us.r-project.org\")"
  },
  {
    "objectID": "posts/post/glmnet1.html#快速开始",
    "href": "posts/post/glmnet1.html#快速开始",
    "title": "glmnet包解读1",
    "section": "2 快速开始",
    "text": "2 快速开始\n这节介绍glmnet包中的主要函数以及它们的一般用法，对常用函数的输入参数以及输出结果做简要的说明。\n2.1 加载glmnet包\n\nShow the codelibrary(glmnet)# 加载glmnet包\n\n\n以线性回归为例，来说明glmnet包的用法。\n2.2 准备数据\n\nShow the codedata(QuickStartExample)#x为100*20的矩阵 ,y为100 * 1的矩阵。\nx = QuickStartExample$x\ny = QuickStartExample$y\n\n\n该命令R数据存档中加载输入矩阵x和响应向量y。 x为100*20的矩阵 ,y为100 * 1的矩阵。\n2.3 拟合模型\n数据有了，我们就可以调用包中与之同名的glmnet函数来做线性回归了：\n\nShow the codefit = glmnet(x, y)\n\n\n这里生成的结果 “fit”是类的对象glmnet，包含拟合模型的所有相关信息。不鼓励用户直接提取组件（像list那样提取）。推荐使用各种方法plot，print，coef和predict提取信息，这样能够使我们更优雅执行这些任务。\n2.4 模型对象的可视化\n采用plot函数对拟合出的模型系数进行可视化：\n\nShow the code# label = T，可以显示变量的标签。\n# 参数xvar = c(\"norm\", \"lambda\", \"dev\")\n# norm（默认）:  显示系数值和L1范数之间的变化关系\n# lambda： 显示系数值和对数lambda之间的变化关系\n# dev : 显示系数值如何随解释偏差百分比（dev）之间的变化关系\nplot(fit,label = T)\n\n\n\n\n上图中，每一条曲线代表一个变量的系数。Y轴是回归系数的值，X轴是L1范数，图中上方有另一条x轴，其数值表示模型的特征数，\n2.5 模型对象信息的提取\n回到我们的拟合结果fit。作为一个 R 对象，我们可以把它当作很多函数的输入。比如说，我们可以查看详细的拟合结果：\n\nShow the codeprint(fit)\n#> \n#> Call:  glmnet(x = x, y = y) \n#> \n#>    Df  %Dev  Lambda\n#> 1   0  0.00 1.63100\n#> 2   2  5.53 1.48600\n#> 3   2 14.59 1.35400\n#> 4   2 22.11 1.23400\n#> 5   2 28.36 1.12400\n#> 6   2 33.54 1.02400\n#> 7   4 39.04 0.93320\n#> 8   5 45.60 0.85030\n#> 9   5 51.54 0.77470\n#> 10  6 57.35 0.70590\n#> 11  6 62.55 0.64320\n#> 12  6 66.87 0.58610\n#> 13  6 70.46 0.53400\n#> 14  6 73.44 0.48660\n#> 15  7 76.21 0.44330\n#> 16  7 78.57 0.40400\n#> 17  7 80.53 0.36810\n#> 18  7 82.15 0.33540\n#> 19  7 83.50 0.30560\n#> 20  7 84.62 0.27840\n#> 21  7 85.55 0.25370\n#> 22  7 86.33 0.23120\n#> 23  8 87.06 0.21060\n#> 24  8 87.69 0.19190\n#> 25  8 88.21 0.17490\n#> 26  8 88.65 0.15930\n#> 27  8 89.01 0.14520\n#> 28  8 89.31 0.13230\n#> 29  8 89.56 0.12050\n#> 30  8 89.76 0.10980\n#> 31  9 89.94 0.10010\n#> 32  9 90.10 0.09117\n#> 33  9 90.23 0.08307\n#> 34  9 90.34 0.07569\n#> 35 10 90.43 0.06897\n#> 36 11 90.53 0.06284\n#> 37 11 90.62 0.05726\n#> 38 12 90.70 0.05217\n#> 39 15 90.78 0.04754\n#> 40 16 90.86 0.04331\n#> 41 16 90.93 0.03947\n#> 42 16 90.98 0.03596\n#> 43 17 91.03 0.03277\n#> 44 17 91.07 0.02985\n#> 45 18 91.11 0.02720\n#> 46 18 91.14 0.02479\n#> 47 19 91.17 0.02258\n#> 48 19 91.20 0.02058\n#> 49 19 91.22 0.01875\n#> 50 19 91.24 0.01708\n#> 51 19 91.25 0.01557\n#> 52 19 91.26 0.01418\n#> 53 19 91.27 0.01292\n#> 54 19 91.28 0.01178\n#> 55 19 91.29 0.01073\n#> 56 19 91.29 0.00978\n#> 57 19 91.30 0.00891\n#> 58 19 91.30 0.00812\n#> 59 19 91.31 0.00739\n#> 60 19 91.31 0.00674\n#> 61 19 91.31 0.00614\n#> 62 20 91.31 0.00559\n#> 63 20 91.31 0.00510\n#> 64 20 91.31 0.00464\n#> 65 20 91.32 0.00423\n#> 66 20 91.32 0.00386\n#> 67 20 91.32 0.00351\n\n\n每一行代表了一个模型 ,它从左到右显示非零系数的个数（Df），模型所解释的偏差的百分比（%dev）和λ的值（Lambda） （注意岭回归中列Df的值是不会变的）\n通过coef来提取模型的系数：\n\nShow the code# 参数s：指定lambda的值，可以是一个向量，则提取多个模型的系数，每一列对应一个模型的系数\n# 参数complete: 逻辑值,表示是否应该返回全系数向量.\ncoef(fit,s=0.1,exact=FALSE)\n#> 21 x 1 sparse Matrix of class \"dgCMatrix\"\n#>                       s1\n#> (Intercept)  0.150928072\n#> V1           1.320597195\n#> V2           .          \n#> V3           0.675110234\n#> V4           .          \n#> V5          -0.817411518\n#> V6           0.521436671\n#> V7           0.004829335\n#> V8           0.319415917\n#> V9           .          \n#> V10          .          \n#> V11          0.142498519\n#> V12          .          \n#> V13          .          \n#> V14         -1.059978702\n#> V15          .          \n#> V16          .          \n#> V17          .          \n#> V18          .          \n#> V19          .          \n#> V20         -1.021873704\n\n\n用coef来提取模型的系数,参数采用的是s 而不是lambda,—同样在predict函数中一样的道理,eg:\n2.6 预测\n预测采用predict函数，参数newx用来设置输入数据，s用来设置\\(\\lambda\\)的值：\n\nShow the codenx = matrix(rnorm(10*20),10,20)\n#predict函数与coef函数相比多了一些参数的设置，参数newx设置待预测的输入数据集，以及tpye参数选项\npredict(fit,newx=nx,s=c(0.1,0.05))\n#>               s1         s2\n#>  [1,]  2.4510228  2.5445311\n#>  [2,]  3.7715402  3.9847592\n#>  [3,]  0.2998023  0.3619383\n#>  [4,]  0.6083807  0.5341408\n#>  [5,]  1.3505651  1.2295975\n#>  [6,] -1.4567610 -1.5414550\n#>  [7,] -1.8655189 -2.1116984\n#>  [8,]  3.2607369  3.4219932\n#>  [9,]  2.0913141  2.1585520\n#> [10,] -1.1195637 -1.1657079\n\n\n2.7 交叉验证\nglmnet提供了一系列的模型可供选择，而在大多数情况下我们需要从中挑选出一个最合适的来用就可以了。这时可以通过交叉验证的方法来筛选最优的λ值了，cv.glmnet函数实现了这一功能。 也支持绘图和预测方法。\n继续沿用之前的样本数据，调用cv.glmnet函数：\n\nShow the codecvfit = cv.glmnet(x, y)\n\n\n可以看到，cv.glmnet返回的结果是一个cv.glmnet类的对象，该对象的类型和glmnet函数返回的结果一样，它们本质上都是R中的list。 不鼓励直接提取信息，推荐使用各种函数提取.\n我们用可视化的图形来展示cv.glmnet的结果：\n\nShow the codeplot(cvfit)\n\n\n\n\n从图中可以看到MSE是如何随着lambda的不同取值而变化的。红色的散点为交叉验证的散点图，横轴为logλ，纵轴为均方误差，每个点的标准偏差上界和下界也画出来了。图的顶部字数表示非零系数的个数，第一条垂直线对应的是lambda.min的值，它是交叉验证提取出的最优值，第二条（从左往右看）是lambda.lse属性的值，它对应了距离lambda.min一个标准误差的值，并产生了一个更为正则化的模型 （lambda.1se为离最小均方误差一倍标准差的λ值。 ）\n最优的λ 值可以直接采用如下命令来提取：\n\nShow the codecvfit$lambda.min\n#> [1] 0.06896889\ncvfit$lambda.1se\n#> [1] 0.1748613\n\n\n用coef函数来提取回归模型的系数：\n\nShow the codecoef(cvfit, s = \"lambda.min\")\n#> 21 x 1 sparse Matrix of class \"dgCMatrix\"\n#>                       s1\n#> (Intercept)  0.147927056\n#> V1           1.337393911\n#> V2           .          \n#> V3           0.704086481\n#> V4           .          \n#> V5          -0.842853150\n#> V6           0.549403480\n#> V7           0.032703914\n#> V8           0.342430521\n#> V9           .          \n#> V10          0.001206608\n#> V11          0.178995989\n#> V12          .          \n#> V13          .          \n#> V14         -1.079993473\n#> V15          .          \n#> V16          .          \n#> V17          .          \n#> V18          .          \n#> V19          .          \n#> V20         -1.061382444\n\n\n可以看到回归模型的系数是采用稀疏矩阵的形式来存储的。由于计算出的模型系数经常是稀疏的，这时采用稀疏矩阵的方式来存储和计算更有效率。如果你不习惯稀疏矩阵的输出形式，可以用as.matrix()将其转化为传统的矩阵形式。\n预测同glmnet，直接采用predict泛型函数即可：\n\nShow the codepredict(cvfit, newx = x[1:5,], s = \"lambda.min\")\n#>      lambda.min\n#> [1,] -1.3626977\n#> [2,]  2.5736774\n#> [3,]  0.5767335\n#> [4,]  2.0062604\n#> [5,]  1.5410061\n\n\n自此，glmnet的入门介绍完了，你可以用来他做一些基本的回归模型了。\n接下来，我们对glmnet包进行更为深入的介绍。"
  },
  {
    "objectID": "posts/post/glmnet1.html#线性回归",
    "href": "posts/post/glmnet1.html#线性回归",
    "title": "glmnet包解读1",
    "section": "3 线性回归",
    "text": "3 线性回归\nglmnet中的线性回归主要包含两类。一定是高斯簇gaussian，还有一类是多响应高斯簇mgaussian。我们依次介绍：\n3.1 高斯簇\ngaussian 是glmnet函数中的默认函数簇，它本质上是带正则项的多元线性回归的估计问题。\n3.1.1 优化目标\n优化的目标函数如下：（高斯族采用的是平方损失函数） \\[\n\\min_{(\\beta_0, \\beta) \\in \\mathbb{R}^{p+1}}\\frac{1}{2N} \\sum_{i=1}^N (y_i -\\beta_0-x_i^T \\beta)^2+\\lambda \\left[ \\dfrac{1}{2}(1-\\alpha)||\\beta||_2^2 + \\alpha||\\beta||_1\\right],\n\\] 其中 \\(\\lambda \\geq 0\\) 是模型复杂度参数 ;\\(0 \\leq \\alpha \\leq 1\\) ，当\\(\\alpha = 0\\) 时为岭回归，当\\(\\alpha = 1\\)为lasso，在\\(0 <\\alpha < 1\\)则为两者的折中.\n3.1.2 glmnet参数设置\nglmnet提供了很多参数可以供我们选择。下面介绍一些常用的参数设置：\n\n\nalpha之前介绍过，它是弹性网的参数，取值范围是[0, 1], (且只能一个一个取，不能为向量)\n\nweights配置观测的权重。默认每个观测的权重取值均为1。\n\nnlambda默认值是100。(系统自动挑选 100 个不同的 λ 值，拟合出 100 个系数不同的模型 ）\n\nlambda一般是程序自动构建，也可以自己定义（可以是向量）。\n\nstandardize表示在拟合模型前，x变量是否需要标准化。默认standardize=TRUE。\n\n更多参数设置参考帮助文档help(glmnet)。\n我们用下面的例子来看看这些参数的用法： 还是用原来的样本数据，不同的是取α = 0.2（接近岭回归的正则项），设置观测的权重以及 λ序列的数量：\n\nShow the codefit = glmnet(x, y, alpha = 0.2, weights = c(rep(1,50),rep(2,50)), nlambda = 20)\n\n\n用print函数打印结果：\n\nShow the codeprint(fit)\n#> \n#> Call:  glmnet(x = x, y = y, weights = c(rep(1, 50), rep(2, 50)), alpha = 0.2,      nlambda = 20) \n#> \n#>    Df  %Dev Lambda\n#> 1   0  0.00 7.9390\n#> 2   4 17.89 4.8890\n#> 3   7 44.45 3.0110\n#> 4   7 65.67 1.8540\n#> 5   8 78.50 1.1420\n#> 6   9 85.39 0.7033\n#> 7  10 88.67 0.4331\n#> 8  11 90.25 0.2667\n#> 9  14 91.01 0.1643\n#> 10 17 91.38 0.1012\n#> 11 17 91.54 0.0623\n#> 12 17 91.60 0.0384\n#> 13 19 91.63 0.0236\n#> 14 20 91.64 0.0146\n#> 15 20 91.64 0.0090\n#> 16 20 91.65 0.0055\n#> 17 20 91.65 0.0034\n\n\n打印结果之前已做过说明，这里不再赘述。可以看到这里λ并没有达到预设的20。这是因为在偏差解释率达到0.999或者其变化小于10e-5时计算就会终止。而这些预设的计算终止条件可以通过glmnet.control来设置，详见help(glmnet.control)。\n注意，可以设置digits选项可用于指定打印输出中的有效数字\n3.1.3 plot参数设置\nY轴为模型的系数值。\nplot函数可以用xvar来定义X轴的度量，有三种选项：\n\n“norm” 表示系数的L1-范数(默认)，显示系数值和L1范数之间的变化关系\n“lambda” 表示对数lambda值，显示系数值和对数lambda之间的变化关系\n“dev” 表示偏差解释率，显示系数值如何随解释偏差百分比（dev）之间的变化关系\n\n在plot函数中添加参数label = TRUE可以显示变量的标签\n\nShow the codelayout(matrix(c(1,2,3),1,3))\nplot(fit, xvar = \"norm\", label = TRUE,main='nrom\\n')\nplot(fit, xvar = \"lambda\", label = TRUE,main='lambda\\n')\nplot(fit, xvar = \"dev\", label = TRUE,main='dev\\n')\n\n\n\n\n每一条曲线代表一个变量的系数。Y轴是回归系数的值，X轴是L1范数(默认)，图中上方有另一条x轴，其数值表示模型的特征数，\n3.1.4 coef参数设置\ncoef函数中最常用的两个参数为:\n\n\ns 指定λ值\n\ncomplete 表示是否应该返回全系数向量.\n\n\nShow the codeany(fit$lambda == 0.5)\n#> [1] FALSE\ncoef.exact = coef(fit, s = 0.5, complete = TRUE)\ncoef.apprx = coef(fit, s = 0.5, complete = FALSE)\ncbind2(coef.exact, coef.apprx)\n#> 21 x 2 sparse Matrix of class \"dgCMatrix\"\n#>                       s1           s1\n#> (Intercept)  0.199098747  0.199098747\n#> V1           1.174650452  1.174650452\n#> V2           .            .          \n#> V3           0.531934651  0.531934651\n#> V4           .            .          \n#> V5          -0.760959480 -0.760959480\n#> V6           0.468209413  0.468209413\n#> V7           0.061926756  0.061926756\n#> V8           0.380301491  0.380301491\n#> V9           .            .          \n#> V10          .            .          \n#> V11          0.143260991  0.143260991\n#> V12          .            .          \n#> V13          .            .          \n#> V14         -0.911207368 -0.911207368\n#> V15          .            .          \n#> V16          .            .          \n#> V17          .            .          \n#> V18          0.009196628  0.009196628\n#> V19          .            .          \n#> V20         -0.863117051 -0.863117051\n\n\n结论： 当exact选取不同的参数时，提取的系数也存在一定程度的差异，但差距不大。没有特别要求的话，使用线性插值得到的结果已经够用了。\n3.1.5 predict参数设置\npredict函数与coef函数相比多了一些参数的设置：newx是待预测的输入数据集。\ntype有多个选项可供选择：\n\n“link” 给出预测值\n“response” 对于gaussian簇，同“link”\n“coefficients” 计算给定s下的系数矩阵\n“nonzero” list对象，存储每个s下非0系数对应的下标\n\n\nShow the codepredict(fit, newx = x[1:5,], type = \"response\", s = 0.05)\n#>              s1\n#> [1,] -0.9802591\n#> [2,]  2.2992453\n#> [3,]  0.6010886\n#> [4,]  2.3572668\n#> [5,]  1.7520421\n\n\n上述命令表示在λ = 0.05时计算x头5条观测的预测值。这里的s可以是一个向量，当s是一个多数值向量时，预测值则为一个矩阵。\n3.1.6 交叉验证\n3.1.6.1 普通计算\n这小节对cv.glmnet函数的参数做简要说明：\n\n\nnfolds – 交叉验证数据集划分的份数\n\nfoldid – 自定义划分数据\n\ntype.measure – 定义交叉验证的损失函数，“deviance”和“mse”用的是平方损失，“mae”用的是平均绝对损失\n\n举一个列子：\n\nShow the code# 做20重交叉验证，采用平均绝对损失\ncvfit <- cv.glmnet(x, y, type.measure = \"mse\", nfolds = 20)\n\n\n3.1.6.2 并行计算\ncv.glmnet也支持并行计算，不过要使其工作，用户必须加载doMC并注册并行数量. 在这里给出一个简单的比较示例。 (不过很遗憾，win不能用)\n\nShow the coderequire(doMC) # win不能用,可以下载下来，但是不能平行计算。\n# install.packages(\"doMC\", repos=\"http://R-Forge.R-project.org\")\nregisterDoMC(cores=2)\nX = matrix(rnorm(1e4 * 200), 1e4, 200)\nY = rnorm(1e4)\nsystem.time(cv.glmnet(X, Y))\n#>    user  system elapsed \n#>   0.704   0.040   0.749\nsystem.time(cv.glmnet(X, Y, parallel = TRUE))\n#>    user  system elapsed \n#>   0.963   0.202   0.732\n\n\n\nShow the code# 看了一下帮助文档 可以改成doParallel 也不能用很奇怪\nlibrary(doParallel)\n# Windows 可以使用的并行包，但在这里也不能进行并行计算，时间不变\ncl<-makeCluster(6)\nregisterDoParallel(cl)\nsystem.time({cvfit = cv.glmnet(x,y,parallel=TRUE)})\n#>    user  system elapsed \n#>   0.021   0.003   0.918\nstopCluster(cl)# 时间也没有明显提高\n\n\n如上所述，并行计算可以显着加速计算过程，尤其是对于大规模问题。\n3.1.6.3 提取最优参数\n函数 coef 和 predict 处理cv.glmnet 对象和处理 glmnet 对象类似。不过处理cv.glmnet对象时，在指定\\(s\\)参数是可以用两个特殊的字符:lambda.1se和lambda.min\n\n“lambda.1se”: 为离最小均方误差MSE一倍标准差的\\(\\lambda\\)值。\n“lambda.min”: 达到最小MSE对应的\\(\\lambda\\)值（即 交叉验证提取出的最优值）\n\n\nShow the codecvfit$lambda.min\n#> [1] 0.08307327\ncoef(cvfit, s = \"lambda.min\")\n#> 21 x 1 sparse Matrix of class \"dgCMatrix\"\n#>                      s1\n#> (Intercept)  0.14936467\n#> V1           1.32975267\n#> V2           .         \n#> V3           0.69096092\n#> V4           .         \n#> V5          -0.83122558\n#> V6           0.53669611\n#> V7           0.02005438\n#> V8           0.33193760\n#> V9           .         \n#> V10          .         \n#> V11          0.16239419\n#> V12          .         \n#> V13          .         \n#> V14         -1.07081121\n#> V15          .         \n#> V16          .         \n#> V17          .         \n#> V18          .         \n#> V19          .         \n#> V20         -1.04340741\npredict(cvfit, newx = x[1:5,], s = \"lambda.min\")\n#>      lambda.min\n#> [1,] -1.3647490\n#> [2,]  2.5686013\n#> [3,]  0.5705879\n#> [4,]  1.9682289\n#> [5,]  1.4964211\n\n\n3.1.6.4 数据划分问题\n除了可以设置nfolds来寻找合适的模型外，我们还可以通过foldid设置相同的数据划分来选择最优的α值。\n\nShow the codefoldid=sample(1:10,size=length(y),replace=TRUE)\ncv1=cv.glmnet(x,y,foldid=foldid,alpha=1)\ncv.5=cv.glmnet(x,y,foldid=foldid,alpha=.5)\ncv0=cv.glmnet(x,y,foldid=foldid,alpha=0)\n\n\n进行对比\n\nShow the codepar(mfrow=c(2,2))\nplot(cv1);plot(cv.5);plot(cv0)\nplot(log(cv1$lambda),cv1$cvm,pch=19,col=\"red\",xlab=\"log(Lambda)\",ylab=cv1$name)\npoints(log(cv.5$lambda),cv.5$cvm,pch=19,col=\"grey\")\npoints(log(cv0$lambda),cv0$cvm,pch=19,col=\"blue\")\nlegend(\"topleft\",legend=c(\"alpha= 1\",\"alpha= .5\",\"alpha 0\"),pch=19,col=c(\"red\",\"grey\",\"blue\"))\n\n\n\n\n我们可以看到这里选择lasso(alpha=1)时，模型的均方误差最小。\n3.1.7 系数上限和下限\n这些是最近添加的功能，可以增强模型的范围。假设我们想要拟合我们的模型，但是要将系数限制为大于-0.7且小于0.5。这可以通过upper.limits和lower.limits参数轻松实现：\n\nShow the codetfit=glmnet(x,y,lower=-.7,upper=.5)\nplot(tfit)\n\n\n\n\n这些是相当随意的限制; 通常我们希望系数为正，所以我们只能设置lower.limit为0\n\n注意,上下限的取值范围 ：upper.limits的值不能小于0，lower.limits的值不能大于0 ,另外，如果想对每一个变量的系数对不同的限定，需要将这里的单点值即标量改为向量的形式就可以了。\n\n3.1.8 惩罚因子\n这个参数可以给每一个系数提供一个单独的惩罚因子。该惩罚因子默认是1，它也支持自定义。如果将惩罚因子全部设置成为0的话，相当于就没有惩罚项了。\n看看以下公式就一目了然了： \\[\n\\lambda \\sum_{j=1}^p \\boldsymbol{v_j} P_\\alpha(\\beta_j) = \\lambda \\sum_{j=1}^p \\boldsymbol{v_j} \\left[ (1-\\alpha)\\frac{1}{2} \\beta_j^2 + \\alpha |\\beta_j| \\right].\n\\] 这个参数设置选项很有用，假如我们知道了一些先验信息，知道了其中一些变量很重要，需要在建模正则化的同时一直保留这些变量，那么可以把这些变量对应系数的惩罚因子设置为0。\n同样用之前的数据，我们把第5、10、15个变量对应的惩罚因子设置为0：\n\nShow the codep.fac = rep(1, 20)\np.fac[c(5, 10, 15)] = 0\npfit = glmnet(x, y, penalty.factor = p.fac)\nplot(pfit, label = TRUE)\n\n\n\n\n从上图中可以看到，变量5、10、15对应的系数一直都在模型中。\n还有一些其它的有用的参数，比如，exclude参数可以用来限制指定的变量入选模型；intercept参数可以用来设定模型是否含有截距项等等。更多设置参考帮助文档help(cv.glmnet).\n3.1.9 自定义图\n有时，特别是当变量数量很少时，我们希望将变量标签添加到绘图中，而不是用变量的所在数据集中的下标。 如下：简单生成一组数据，拟合一个glmnet模型 ，并画出图\n\nShow the codeset.seed(101)\nx=matrix(rnorm(1000),100,10)\ny=rnorm(100)\nvn=paste(\"var\",1:10) \nfit=glmnet(x,y)\nplot(fit)\n\n\n\n\n然而我们想要的是用变量名称标记曲线 ，如下：\n\nShow the codepar(mar=c(4.5,4.5,1,4))\nplot(fit)\nvnat=coef(fit)\nvnat=vnat[-1,ncol(vnat)] # remove the intercept, and get the coefficients at the end of the path\naxis(4, at=vnat,line=-.5,label=vn,las=1,tick=FALSE, cex.axis=0.5)\n\n\n\n\n3.2 多响应高斯簇\n多响应高斯簇模型的估计需要在glmnet函数中设置family = \"mgaussian\"。与以上单变量响应模型类似，它只是响应变量增多了，我们通常称之为“多任务学习”问题。虽然响应变量增多了，但是建模时所选择的自变量是完全一样的，只是待估系数不同而已。\n很显然，模型的因变量不再是一个向量形式，而是一个二维矩阵，这时估计出的系数也会是一个矩阵，先看看多响应高斯簇模型解决的问题： \\[\n\\min_{(\\beta_0, \\beta) \\in \\mathbb{R}^{(p+1)\\times K}}\\frac{1}{2N} \\sum_{i=1}^N ||y_i -\\beta_0-\\beta^T x_i||^2_F+\\lambda \\left[ (1-\\alpha)||\\beta||_F^2/2 + \\alpha\\sum_{j=1}^p||\\beta_j||_2\\right].\n\\] 这里的βj是\\(p\\times K\\)维的系数矩阵\\(\\beta\\)的第j行。\n3.2.1 载入演示数据\n\nShow the codedata(MultiGaussianExample)# 产生x,y两个矩阵，x的维度100*20 ,y的维度100 * 4。\nx = MultiGaussianExample$x\ny = MultiGaussianExample$y\n\n\n3.2.2 拟合模型\n\nShow the codemfit = glmnet(x, y, family = \"mgaussian\")\n\n\n多响应高斯模型与单响应高斯模型的大部分参数设置相同，如alpha,weights,nlambda,standardize。但是mgaussian簇有一个额外的参数standardize.response，它可以用来给响应变量做标准化，默认为FALSE。\n3.2.3 查看拟合效果\n用plot函数查看系数的变化：\n\nShow the codeplot(mfit, xvar = \"lambda\", label = TRUE, type.coef = \"2norm\")\n\n\n\nShow the codeplot(mfit, xvar = \"lambda\", label = TRUE, type.coef = \"coef\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n其中xvar并且label两个参数的设置与单响应的高斯模型一样 。这里的type.coef = \"2norm\"表示每个变量的系数以二范数的形式展现。默认设置为type.coef = \"coef\"，这时每个响应变量会展示一张系数变化的图。\n3.2.4 预测\n可以通过coef函数提取系数 ，predict函数进行预测。用法和但响应的高斯模型一样，下面看看predict的用法：\n\nShow the codepredict(mfit, newx = x[1:5,], s = c(0.1, 0.01))\n#> , , 1\n#> \n#>              y1         y2         y3       y4\n#> [1,] -4.7106263 -1.1634574  0.6027634 3.740989\n#> [2,]  4.1301735 -3.0507968 -1.2122630 4.970141\n#> [3,]  3.1595229 -0.5759621  0.2607981 2.053976\n#> [4,]  0.6459242  2.1205605 -0.2252050 3.146286\n#> [5,] -1.1791890  0.1056262 -7.3352965 3.248370\n#> \n#> , , 2\n#> \n#>              y1         y2         y3       y4\n#> [1,] -4.6415158 -1.2290282  0.6118289 3.779521\n#> [2,]  4.4712843 -3.2529658 -1.2572583 5.266039\n#> [3,]  3.4735228 -0.6929231  0.4684037 2.055574\n#> [4,]  0.7353311  2.2965083 -0.2190297 2.989371\n#> [5,] -1.2759930  0.2892536 -7.8259206 3.205211\n\n\n3.2.5 交叉验证\n同样的交叉验证用cv.glmnet函数：\n\nShow the codecvmfit = cv.glmnet(x, y, family = \"mgaussian\")\n\n\n画出交叉验证的结果：\n\nShow the codeplot(cvmfit)\n\n\n\n\n想要查看最优的\\(\\lambda\\),,采用如下命令:\n\nShow the codecvmfit$lambda.min\n#> [1] 0.05193158\ncvmfit$lambda.1se\n#> [1] 0.174054\n\n\n和以前一样，第一个是达到最小均方误差的值，第二个是最正则化模型，其均方误差在最小值的一个标准误差范围内"
  },
  {
    "objectID": "posts/post/glmnet1.html#逻辑回归",
    "href": "posts/post/glmnet1.html#逻辑回归",
    "title": "glmnet包解读1",
    "section": "4 逻辑回归",
    "text": "4 逻辑回归\n逻辑回归是分类问题中最常用的模型之一。如果是一个二分类问题，一般假定响应变量服从二项分布，如果是多分类问题，则假定服从多项式分布。\n4.1 二项分布逻辑回归\n假定响应变量的取值为 \\(\\mathcal{G}=\\{1,2\\}\\).定义 \\(y_i = I(g_i=1)\\).则有\n\\[\n\\mbox{Pr}(G=2|X=x)+\\frac{e^{\\beta_0+\\beta^Tx}}{1+e^{\\beta_0+\\beta^Tx}}\n\\] 我们可以两边取对数，改写为如下形式（称为对数似然函数）：\n\\[\n\\log\\frac{\\mbox{Pr}(G=2|X=x)}{\\mbox{Pr}(G=1|X=x)}=\\beta_0+\\beta^Tx\n\\]\n这个带惩罚逻辑回归的目标函数的对数似然如下： \\[\n\\min_{(\\beta_0, \\beta) \\in \\mathbb{R}^{p+1}} -\\left[\\frac{1}{N} \\sum_{i=1}^N y_i \\cdot (\\beta_0 + x_i^T \\beta) - \\log (1+e^{(\\beta_0+x_i^T \\beta)})\\right] + \\lambda \\big[ (1-\\alpha)||\\beta||_2^2/2 + \\alpha||\\beta||_1\\big].\n\\] 当 \\(p > N\\) 时，逻辑回归常常伴随着退化的困扰 ，当\\(N\\)接近\\(p\\)时，甚至在表现出野蛮的行为 。弹性网惩罚缓解了这些问题。\n4.1.1 载入示例数据集\n\nShow the codedata(BinomialExample)# 产生名为x维度为100*30的矩阵 ,名为y长度为100的int向量（0、1向量）\nx = BinomialExample$x\ny = BinomialExample$y\n\n\n这里的输入x与其他分布簇相同，对于二项Logistic回归，响应变量y应该是具有两个级别的因子，或者是计数或比例的两列矩阵\n4.1.2 拟合模型\nglmnet二项式回归的其他可选参数与高斯族的几乎相同.仅需要把函数簇改为family = \"binomial\"即可：\n\nShow the codefit = glmnet(x, y, family = \"binomial\")\n\n\n4.1.3 查看拟合效果\n同样， 我们可以用print和plot函数去查看对象 , 用coef提取特定λ的系数，用predict可以做出预测 .\n\nShow the codeplot(fit, xvar = \"dev\", label = TRUE)\n\n\n\n\n4.1.4 预测\n逻辑回归的预测同高斯簇函数的用法有点不同，主要体现在参数type的设置上，详细概括如下：\n\n“link” 线性拟合值\n“response” 拟合的概率值\n“class” 给出计算出的最大概率对应的类的标签\n“coefficients” 计算给定s下的系数的估计值\n“nonzero” 返回一个list对象，该list包含每一个s对应非零系数的索引\n\n\n对于“二项式”模型，预测结果仅仅是针对响应变量的第二个水平(“link”, “response”, “coefficients”, “nonzero”) (可以用level函数查看第二级别的类)\n\n\nShow the codepredict(fit, newx = x[1:5,], type = \"class\", s = c(0.05, 0.01))\n#>      s1  s2 \n#> [1,] \"0\" \"0\"\n#> [2,] \"1\" \"1\"\n#> [3,] \"1\" \"1\"\n#> [4,] \"0\" \"0\"\n#> [5,] \"1\" \"1\"\n\n\n4.1.5 交叉验证\n逻辑回归的cv.glmnet的用法同高斯簇函数，nfolds, weights, lambda,parallel的设置一样，区别主要在type.measure：\n\n“mse” 用平方损失\n“deviance” 用真实偏差\n“mae” 用平均绝对误差\n“class” 用误分类率\n“auc” ROC曲线的下面积(这个选项仅针对两分类逻辑回归)。是现在最流行的综合考量模型性能的一种参数\n\n例如，用误分类率误差为标准做十折交叉验证，代码如下：\n\nShow the codecvfit = cv.glmnet(x, y, family = \"binomial\", type.measure = \"class\")\n\n\n用plot查看cv.glmnet生成的结果： .\n\nShow the codeplot(cvfit)\n\n\n\n\n\nShow the codecvfit$lambda.min #查看最优的λ值\n#> [1] 0.01116192\ncvfit$lambda.1se\n#> [1] 0.0310587\n\n\ncoef和predict与高斯簇类似：\n\nShow the codecoef(cvfit, s = \"lambda.min\") # 如前所述，此处返回的结果仅适用于响应变量的第二个水平。\n#> 31 x 1 sparse Matrix of class \"dgCMatrix\"\n#>                       s1\n#> (Intercept)  0.219571057\n#> V1           0.127143184\n#> V2           0.773438291\n#> V3          -0.622026677\n#> V4          -1.249153390\n#> V5          -0.236036348\n#> V6          -1.086126631\n#> V7           .          \n#> V8          -0.662605660\n#> V9           0.903895121\n#> V10         -1.662994099\n#> V11         -0.069429691\n#> V12         -0.109197705\n#> V13          .          \n#> V14          .          \n#> V15          .          \n#> V16          0.489302061\n#> V17          .          \n#> V18         -0.123121403\n#> V19         -0.009732698\n#> V20         -0.063913565\n#> V21          .          \n#> V22          0.237278301\n#> V23          0.413516340\n#> V24         -0.040687440\n#> V25          0.746129317\n#> V26         -0.376173275\n#> V27         -0.168082915\n#> V28          0.312045066\n#> V29         -0.254478998\n#> V30          0.157077463\n\n\nAs mentioned previously, the results returned here are only for the second level of the factor response.\n\nShow the codepredict(cvfit, newx = x[1:10,], s = \"lambda.min\", type = \"class\")\n#>       lambda.min\n#>  [1,] \"0\"       \n#>  [2,] \"1\"       \n#>  [3,] \"1\"       \n#>  [4,] \"0\"       \n#>  [5,] \"1\"       \n#>  [6,] \"0\"       \n#>  [7,] \"0\"       \n#>  [8,] \"0\"       \n#>  [9,] \"1\"       \n#> [10,] \"1\"\n\n\n4.2 多分类逻辑回归\n多分类逻辑回归假定响应变量服从多项式分布, 假定响应变量有K个水平 \\({\\cal G}=\\{1,2,\\ldots,K\\}\\)。则有\n\\[\n\\mbox{Pr}(G=k|X=x)=\\frac{e^{\\beta_{0k}+\\beta_k^Tx}}{\\sum_{\\ell=1}^Ke^{\\beta_{0\\ell}+\\beta_\\ell^Tx}}.\n\\]\n\\({Y}\\) 应该是 \\(N \\times K\\) 的响应矩阵（把离散变量进行one-hot编码即可） ,那么带弹性网惩罚项的非负对数似然函数如下： \\[\n\\ell(\\{\\beta_{0k},\\beta_{k}\\}_1^K) = -\\left[\\frac{1}{N} \\sum_{i=1}^N \\Big(\\sum_{k=1}^Ky_{il} (\\beta_{0k} + x_i^T \\beta_k)- \\log \\big(\\sum_{k=1}^K e^{\\beta_{0k}+x_i^T \\beta_k}\\big)\\Big)\\right] +\\lambda \\left[ (1-\\alpha)||\\beta||_F^2/2 + \\alpha\\sum_{j=1}^p||\\beta_j||_q\\right].\n\\] 这里β是一个\\(p\\times K\\)维的系数矩阵 \\(\\beta_k\\) 是其中的第\\(k\\)列,表示第\\(k\\)个模型对应模型的系数 , \\(\\beta_j\\) 第\\(j\\)行，表示第\\(j\\)个变量前面的系数。\n后面的惩罚项 \\(||\\beta_j||_q\\), 有两种情形 \\(q\\in \\{1,2\\}\\).当q=1时，它是一个lasso惩罚项；当q=2时，它是一个grouped-lasso惩罚项。\n4.2.1 载入示例数据集\n首先载入数据集：\n\nShow the codedata(MultinomialExample)# 产生名为x维度为100*30的矩阵 ,名为y长度为100的数字向量（水平1,2,3组成）训练是内部自动转换\nx = MultinomialExample$x\ny = MultinomialExample$y\n\n\n4.2.2 拟合模型\n多分类逻辑回归的模型拟和二分类逻辑回归类似，只是这里新增加了一个特殊的参数type.multinomial，当type.multinomial = \"grouped\"时，模型拟合时会让每个变量前面的系数全为0或者全不为零，其实就是对于每个类建立逻辑回归时所用到的变量完全相同。\n\nShow the codefit = glmnet(x, y, family = \"multinomial\", type.multinomial = \"grouped\")\n\n\n4.2.3 查看拟合效果\n用plot查看模型拟合结果：\n\nShow the codeplot(fit, xvar = \"lambda\", label = TRUE, type.coef = \"2norm\")\n\n\n\nShow the codeplot(fit, xvar = \"lambda\", label = TRUE, type.coef = \"coef\")\n\n\n\n\n\n\n\n\n\n\n这里xvar和label的使用和之前相同，但是多了一个type.coef选项，这个选项仅适用于对多分类逻辑回归以及多响应变量线性回归，若type.coef = \"coef\"会用多张图分别展示每个响应变量的系数，若type.coef = \"2norm\"则会展示系数的L2-范数。\n4.2.4 交叉验证和预测\n我们同样也可以做交叉验证：\n\nShow the codelibrary(doParallel)\n# Windows System\ncl<-makeCluster(7)\nregisterDoParallel(cl)\ncvfit=cv.glmnet(x, y, family=\"multinomial\", type.multinomial = \"grouped\", parallel = TRUE)\nstopCluster(cl)\nplot(cvfit)\n\n\n\n\n用拟合的模型来预测：\n\nShow the codepredict(cvfit, newx = x[1:10,], s = \"lambda.min\", type = \"class\")\n#>       1  \n#>  [1,] \"3\"\n#>  [2,] \"2\"\n#>  [3,] \"2\"\n#>  [4,] \"3\"\n#>  [5,] \"1\"\n#>  [6,] \"3\"\n#>  [7,] \"3\"\n#>  [8,] \"1\"\n#>  [9,] \"1\"\n#> [10,] \"2\""
  },
  {
    "objectID": "posts/post/glmnet1.html#泊松回归",
    "href": "posts/post/glmnet1.html#泊松回归",
    "title": "glmnet包解读1",
    "section": "5 泊松回归",
    "text": "5 泊松回归\n泊松回归经常会用到计数模型中，假定其误差满足泊松分布。\n经常用其均值的对数来建模：\\(\\log \\mu(x) = \\beta_0+\\beta' x\\).\n给定 \\(\\{x_i,y_i\\}_1^N\\)下的对数似然为: \\[\nl(\\beta|X, Y) = \\sum_{i=1}^N (y_i (\\beta_0+\\beta' x_i) - e^{\\beta_0+\\beta^Tx_i}.\n\\] 于是问题变成优化如下带惩罚的对数似然： \\[\n\\min_{\\beta_0,\\beta} -\\frac1N l(\\beta|X, Y)  + \\lambda \\left((1-\\alpha) \\sum_{i=1}^N \\beta_i^2/2) +\\alpha \\sum_{i=1}^N |\\beta_i|\\right).\n\\]\n5.1 加载数据集\n\nShow the codedata(PoissonExample)# 产生名为x维度为500*20的矩阵 ,名为y长度为500的数字向量,全是大于0的数字（泊松函数也是大于0的函数）\nx = PoissonExample$x\ny = PoissonExample$y\n\n\n5.2 拟合模型\n采用glmnet函数，设置family = \"poisson\"：\n\nShow the codefit = glmnet(x, y, family = \"poisson\")\n\n\n5.3 查看拟合效果\n\nShow the codeplot(fit)\n\n\n\n\n5.4 预测\n用predict做预测,在参数选项的设置中，主要是type存在一些差异，做出说明如下：\n\n“link” 给出线性拟合值\n“response” 给出拟合的均值\n“coefficients” 计算给定s下的系数，也可以直接用coef函数\n“nonzero” 返回一个list对象，该list包含每一个s对应非零系数的索引\n\n\nShow the codecoef(fit, s = 1)\n#> 21 x 1 sparse Matrix of class \"dgCMatrix\"\n#>                      s1\n#> (Intercept)  0.61123371\n#> V1           0.45819758\n#> V2          -0.77060709\n#> V3           1.34015128\n#> V4           0.04350500\n#> V5          -0.20325967\n#> V6           .         \n#> V7           .         \n#> V8           .         \n#> V9           .         \n#> V10          .         \n#> V11          .         \n#> V12          0.01816309\n#> V13          .         \n#> V14          .         \n#> V15          .         \n#> V16          .         \n#> V17          .         \n#> V18          .         \n#> V19          .         \n#> V20          .\npredict(fit, newx = x[1:5,], type = \"response\", s = c(0.1,1))\n#>              s1         s2\n#> [1,]  2.4944232  4.4263365\n#> [2,] 10.3513120 11.0586174\n#> [3,]  0.1179704  0.1781626\n#> [4,]  0.9713412  1.6828778\n#> [5,]  1.1133472  1.9934537\n\n\n我们同样也可以做交叉验证：\n\nShow the codecvfit = cv.glmnet(x, y, family = \"poisson\")\n\n\n选项与高斯族几乎相同，除了 type.measure\n\n\ncv.glmnet中type.measure的设置：\n\n“deviance” 偏差\n“mse” 均方误差\n“mae” 平均绝对误差\n\n\n\n绘制cv.glmnet对象。\n\nShow the codeplot(cvfit)\n\n\n\n\n提取最优λ对应的模型系数：\n\nShow the codeopt.lam = c(cvfit$lambda.min, cvfit$lambda.1se)\ncoef(cvfit, s = opt.lam)\n#> 21 x 2 sparse Matrix of class \"dgCMatrix\"\n#>                       s1           s2\n#> (Intercept)  0.070584044  0.200007600\n#> V1           0.609229006  0.571833738\n#> V2          -0.972486782 -0.927099773\n#> V3           1.509004735  1.466409190\n#> V4           0.225598648  0.192138902\n#> V5          -0.328715117 -0.301559295\n#> V6           .            .          \n#> V7          -0.005088443  .          \n#> V8           .            .          \n#> V9           .            .          \n#> V10          0.006071219  .          \n#> V11          .            .          \n#> V12          0.029070537  0.025801372\n#> V13         -0.014882186  .          \n#> V14          0.020864442  .          \n#> V15          .            .          \n#> V16          0.008606587  .          \n#> V17          .            .          \n#> V18          .            .          \n#> V19         -0.023621751  .          \n#> V20          0.011789503  0.009436612\n\n\n可以使用predict进行预测，方法类似，在重复"
  },
  {
    "objectID": "posts/post/glmnet1.html#cox模型",
    "href": "posts/post/glmnet1.html#cox模型",
    "title": "glmnet包解读1",
    "section": "6 Cox模型",
    "text": "6 Cox模型\n不是很了解。\nThe Cox proportional hazards model is commonly used for the study of the relationship beteween predictor variables and survival time. In the usual survival analysis framework, we have data of the form \\((y_1, x_1, \\delta_1), \\ldots, (y_n, x_n, \\delta_n)\\) where \\(y_i\\), the observed time, is a time of failure if \\(\\delta_i\\) is 1 or right-censoring if \\(\\delta_i\\) is 0. We also let \\(t_1 < t_2 < \\ldots < t_m\\) be the increasing list of unique failure times, and \\(j(i)\\) denote the index of the observation failing at time \\(t_i\\).\nThe Cox model assumes a semi-parametric form for the hazard \\[\nh_i(t) = h_0(t) e^{x_i^T \\beta},\n\\] where \\(h_i(t)\\) is the hazard for patient \\(i\\) at time \\(t\\), \\(h_0(t)\\) is a shared baseline hazard, and \\(\\beta\\) is a fixed, length \\(p\\) vector. In the classic setting \\(n \\geq p\\), inference is made via the partial likelihood \\[\nL(\\beta) = \\prod_{i=1}^m \\frac{e^{x_{j(i)}^T \\beta}}{\\sum_{j \\in R_i} e^{x_j^T \\beta}},\n\\] where \\(R_i\\) is the set of indices \\(j\\) with \\(y_j \\geq t_i\\) (those at risk at time \\(t_i\\)).\nNote there is no intercept in the Cox mode (its built into the baseline hazard, and like it, would cancel in the partial likelihood.)\nWe penalize the negative log of the partial likelihood, just like the other models, with an elastic-net penalty.\n6.1 载入数据集\n同样地，我们加载预先生成好的样本数据和响应变量，但是这里需要注意的是，这里采用了生存分析的分析框架，输入数据略有差别。首先，我们加载数据集：\n\nShow the codedata(CoxExample)# 产生名为x的矩阵，其维度为1000*30 ，名为y的矩阵，其维度为1000*2\nx = CoxExample$x\ny = CoxExample$y\ny[1:5,] # status列表示time列对应下的状态，第一列必须是数值型的时间，第二列参数是逻辑向量，0/1表示死亡与否\n#>            time status\n#> [1,] 1.76877757      1\n#> [2,] 0.54528404      1\n#> [3,] 0.04485918      0\n#> [4,] 0.85032298      0\n#> [5,] 0.61488426      1\n\n\n可以看到加载的数据还是包含自变量x以及响应变量y两部分：x是n×p维的矩阵；不同的是y，y为\\(n \\times 1\\)维的矩阵，其中名为time的列是观察时间，名为status的列为该观察时间下对应的状态，0表示生成，1表示死亡。\n6.2 拟合模型\n同样用glmnet建模:\n\nShow the codefit = glmnet(x, y, family = \"cox\")\n\n\n6.3 查看拟合效果\n\nShow the codeplot(fit)\n\n\n\n\n提取给定 \\(\\lambda\\)下对应的系数：\n\nShow the codecoef(fit, s = 0.05)\n#> 30 x 1 sparse Matrix of class \"dgCMatrix\"\n#>               1\n#> V1   0.37693638\n#> V2  -0.09547797\n#> V3  -0.13595972\n#> V4   0.09814146\n#> V5  -0.11437545\n#> V6  -0.38898545\n#> V7   0.24291400\n#> V8   0.03647596\n#> V9   0.34739813\n#> V10  0.03865115\n#> V11  .         \n#> V12  .         \n#> V13  .         \n#> V14  .         \n#> V15  .         \n#> V16  .         \n#> V17  .         \n#> V18  .         \n#> V19  .         \n#> V20  .         \n#> V21  .         \n#> V22  .         \n#> V23  .         \n#> V24  .         \n#> V25  .         \n#> V26  .         \n#> V27  .         \n#> V28  .         \n#> V29  .         \n#> V30  .\n\n\n由于Cox模型不常用于预测，所以没有给出预测的样例 。如果需要，可以参考帮助文件help(predict.glmnet)。\n6.4 交叉验证\n用cv.glmnet做K折交叉验证时，type.measure的选项仅支持“deviance”：\n\nShow the codecvfit = cv.glmnet(x, y, family = \"cox\")\n\n\n\nShow the codeplot(cvfit)\n\n\n\n\n提取最优的 \\(\\lambda\\) 值\n\nShow the codecvfit$lambda.min\n#> [1] 0.02107668\ncvfit$lambda.1se\n#> [1] 0.05343706\n\n\n提取模型系数：\n\nShow the codecoef.min = coef(cvfit, s = \"lambda.min\")\nactive.min = which(coef.min != 0)\nindex.min = coef.min[active.min]\n\n\n\nShow the codeindex.min\n#>  [1]  0.47296769 -0.16213158 -0.20518470  0.16374470 -0.17544445 -0.47500198\n#>  [7]  0.32076305  0.08339592  0.43422644  0.10423130  0.01054257 -0.01125802\n#> [13] -0.01541834\ncoef.min\n#> 30 x 1 sparse Matrix of class \"dgCMatrix\"\n#>               1\n#> V1   0.47296769\n#> V2  -0.16213158\n#> V3  -0.20518470\n#> V4   0.16374470\n#> V5  -0.17544445\n#> V6  -0.47500198\n#> V7   0.32076305\n#> V8   0.08339592\n#> V9   0.43422644\n#> V10  0.10423130\n#> V11  .         \n#> V12  .         \n#> V13  0.01054257\n#> V14  .         \n#> V15  .         \n#> V16  .         \n#> V17 -0.01125802\n#> V18  .         \n#> V19  .         \n#> V20  .         \n#> V21  .         \n#> V22  .         \n#> V23  .         \n#> V24  .         \n#> V25 -0.01541834\n#> V26  .         \n#> V27  .         \n#> V28  .         \n#> V29  .         \n#> V30  ."
  },
  {
    "objectID": "posts/post/glmnet1.html#稀疏矩阵",
    "href": "posts/post/glmnet1.html#稀疏矩阵",
    "title": "glmnet包解读1",
    "section": "7 稀疏矩阵",
    "text": "7 稀疏矩阵\n除了cox模型外，glmnet均支持稀疏矩阵作为输入，它的用法同常规矩阵的用法相同。\n我们加载一个稀疏矩阵示例：\n\nShow the codedata(SparseExample)\nx = SparseExample$x\ny = SparseExample$y\n\n\n加载的数据x为100*20的一个稀疏矩阵，y为响应变量(长度为100的向量）。\n\nShow the codeclass(x)\n#> [1] \"dgCMatrix\"\n#> attr(,\"package\")\n#> [1] \"Matrix\"\n\n\n创建稀疏矩阵有两种方式，一种方式是采用sparseMatrix生成；还有一种方式是直接采用Matrix来构建。\n当输入是稀疏矩阵时，调用glmnet的方式跟普通矩阵没有差别：\n\nShow the codefit = glmnet(x, y)\n\n\n交叉验证也一样：\n\nShow the codecvfit = cv.glmnet(x, y)\nplot(cvfit)\n\n\n\n\n稀疏矩阵除了可以用作glmnet的输入x，还可以用作predict函数的输入newx，我们来看看如下的例子：\n\nShow the codei = sample(1:5, size = 25, replace = TRUE)\nj = sample(1:20, size = 25, replace = TRUE)\nx = rnorm(25)\nnx = sparseMatrix(i = i, j = j, x = x, dims = c(5, 20))\npredict(cvfit, newx = nx, s = \"lambda.min\")\n#>      lambda.min\n#> [1,]  0.8286576\n#> [2,] -0.1938951\n#> [3,]  0.7690298\n#> [4,] -0.4358310\n#> [5,] -0.1450590\n\n\n\nShow the codesessionInfo()\n#> R version 4.2.1 (2022-06-23)\n#> Platform: aarch64-apple-darwin20 (64-bit)\n#> Running under: macOS Monterey 12.5.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n#> \n#> locale:\n#> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#> \n#> attached base packages:\n#> [1] parallel  stats     graphics  grDevices utils     datasets  methods  \n#> [8] base     \n#> \n#> other attached packages:\n#> [1] doParallel_1.0.17 doMC_1.3.8        iterators_1.0.14  foreach_1.5.2    \n#> [5] glmnet_4.1-4      Matrix_1.4-1     \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] Rcpp_1.0.9        rstudioapi_0.14   knitr_1.40        magrittr_2.0.3   \n#>  [5] splines_4.2.1     lattice_0.20-45   rlang_1.0.4       fastmap_1.1.0    \n#>  [9] stringr_1.4.1     tools_4.2.1       grid_4.2.1        xfun_0.32        \n#> [13] cli_3.3.0         htmltools_0.5.3   yaml_2.3.5        survival_3.4-0   \n#> [17] digest_0.6.29     htmlwidgets_1.5.4 codetools_0.2-18  shape_1.4.6      \n#> [21] evaluate_0.16     rmarkdown_2.16.1  stringi_1.7.8     compiler_4.2.1   \n#> [25] jsonlite_1.8.0\n\n\n参考：https://web.stanford.edu/~hastie/glmnet/glmnet_beta.html"
  },
  {
    "objectID": "posts/post/tree-model.html",
    "href": "posts/post/tree-model.html",
    "title": "回归树与模型树",
    "section": "",
    "text": "决策树可用于聚类（类别变量），也可用于数值预测,但是本节只考虑决策树用于数值预测.\n决策树用于数值预测可以分为回归树和模型树\n\n回归树: 回归树中并没用使用线性回归的方法，而是基于到达叶节点的案例的平均值做出预测\n模型树: 模型树和回归树以大致相同的方式生长，但是在每个叶节点，根据到达该节点的案例建立多元线性回归模型。根据叶节点的数目，一棵模型树可能会建立几十甚至上百个这样的模型，可能会使模型树比同等的回归树更难解释，但好处也行能提高精确度。"
  },
  {
    "objectID": "posts/post/tree-model.html#回归树与模型树的优缺点",
    "href": "posts/post/tree-model.html#回归树与模型树的优缺点",
    "title": "回归树与模型树",
    "section": "2、回归树与模型树的优缺点",
    "text": "2、回归树与模型树的优缺点\n\n\n\n\n\n\n优点\n缺点\n\n\n\n将决策树的优点对数值型数据建立模型的能力相结合\n不像线性回归那么常用\n\n\n能自动选择特征，允许该方法与大量特征一起使用\n需要大量的训练数据\n\n\n不需要使用者事先指定模型\n难以确定单个特征对于结果的总体净影响\n\n\n拟合某些类型的数据可能会比线性回归好\n可能比回归模型难以解释\n\n\n不要求用统计的知识来解释模型\n\n\n\n\n用于数值预测的决策树的建立方式与用于分类的决策树建立的方式大致相同。从根节点开始，按照特征使用分而治之的决策对数据进行划分，在进行一次分割后，将会导致结果最大化的均匀增长。\n\n\n在分类决策树中，一致性(均匀性)是有熵值度量 ，而对于数值型数据是未定义的，\n\n对于数值型决策，一致性(均匀性)可通过统计量(方差、标准差、平均绝对偏差)来度量,根据使用的决策树生长算法，度量方法可能用所不同，但基本原理相同.\n\n常见的一个分割标准成为标准偏差减少(Standard Deciation Reduction,SDR),其公式定义如下\\[SDR=sd(T)\\]"
  },
  {
    "objectID": "posts/post/tree-model.html#例子-估计葡萄酒的质量",
    "href": "posts/post/tree-model.html#例子-估计葡萄酒的质量",
    "title": "回归树与模型树",
    "section": "3、例子——-估计葡萄酒的质量",
    "text": "3、例子——-估计葡萄酒的质量\n白葡萄酒包含4898个葡萄酒案例的11种化学特征的信息，对于每种葡萄酒，实验室分析测量的特征包括酸性、含糖量、氯化物含量、硫的含量、酒精度、PH值和密度值\n3.1读入数据\n其所有特征都是数值型\n\nShow the codewine <- read.csv(\"whitewines.csv\")\n\n\n研究一下结果变量的分布,由于是离散的，可用直方图来研究葡萄酒质量的分布：\n\nShow the codehist(wine$quality)\n\n\n\n\n符合正态分布。大约以数值为6为中心(也可用summary()函数发现一些数据的异常值等等)，最后划分训练数据与测试数据(数据是随机排序),75%的训练数据，25%的测试数据\n\nShow the codewine_train <- wine[1:3750, ]\nwine_test <- wine[3751:4898, ]\n\n\n3.2基于数据训练模型—-回归树\n\nShow the codelibrary(rpart)\nm.rpart <- rpart(quality ~ ., data = wine_train)\nm.rpart# 获取该树的基本信息,#summary(m.rpart)\n\nn= 3750 \n\nnode), split, n, deviance, yval\n      * denotes terminal node\n\n 1) root 3750 2945.53200 5.870933  \n   2) alcohol< 10.85 2372 1418.86100 5.604975  \n     4) volatile.acidity>=0.2275 1611  821.30730 5.432030  \n       8) volatile.acidity>=0.3025 688  278.97670 5.255814 *\n       9) volatile.acidity< 0.3025 923  505.04230 5.563380 *\n     5) volatile.acidity< 0.2275 761  447.36400 5.971091 *\n   3) alcohol>=10.85 1378 1070.08200 6.328737  \n     6) free.sulfur.dioxide< 10.5 84   95.55952 5.369048 *\n     7) free.sulfur.dioxide>=10.5 1294  892.13600 6.391036  \n      14) alcohol< 11.76667 629  430.11130 6.173291  \n        28) volatile.acidity>=0.465 11   10.72727 4.545455 *\n        29) volatile.acidity< 0.465 618  389.71680 6.202265 *\n      15) alcohol>=11.76667 665  403.99400 6.596992 *\n\n\n对于决策树中的每个节点，到达决策点的案例数量都列出来了，例如：所有的3750个案例从根节点开始，其中\n\n(1)有2372个案例的alcohol< 10.85 2372，\n\n1378个案例的 alcohol>=10.85 。\n\n\n因为alcohol（酒精）是决策树中第一个使用的变量，所以它是葡萄酒质量中唯一最重要的指标。\n用* 表示的节点是终端或者叶节点，这意味着他们会产生预测(这里作为yavl列出来)。例如节点5有一个5.971091的yval。当该决策树用来预测时，对任意一个葡萄酒案例，如果alcohol< 10.85 2372 且volatile.acidity< 0.2275，那么它的质量值将预测为5.97\n3.3可视化决策时\n\nShow the codelibrary(rpart.plot)\n\nrpart.plot(m.rpart, digits = 3)#基本决策树图\n\n\n\nShow the coderpart.plot(m.rpart, digits = 4, fallen.leaves = TRUE, type = 3, extra = 101)#对图表的一些调整\n\n\n\n\n3.4评估模型的性能\n\nShow the codep.rpart <- predict(m.rpart, wine_test)\n#我们预测的主要统计量表明了一个潜在的问题，预测值与真实值相比落在一个更窄的范围内\nsummary(p.rpart)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  4.545   5.563   5.971   5.893   6.202   6.597 \n\nShow the codesummary(wine_test$quality)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  3.000   5.000   6.000   5.901   6.000   9.000 \n\n\n这一发现表面，该模型不能正确识别极端的情形，尤其是最好的和最差葡萄酒，反过来，另一方面，在第一四分位数和第三四分位数之间，我们可能做的不错。\n3.5用平均绝对误差度量性能\n平均绝对误差:考虑它的预测值离真实值有多远，方程如下：\\[MAE=1/n\\]\n由于误差是预测值与真实值之间的差值，所以可以简单创建一个MSE()函数，如下：\n\nShow the codeMAE <- function(actual, predicted) {\n  mean(abs(actual - predicted))  \n}\n\n# 预测值和实际值之间的平均绝对误差\nMAE(p.rpart, wine_test$quality)#MAS越小越好\n\n[1] 0.5872652\n\n\n就平均而言，这意味着模型的预测值与真实值的质量分数之间的差值大约为0.59，基于质量的尺度是从0~10，这似乎表面我们的模型做的还可以\n另一反面，大多数的葡萄酒既不是很好也不是很差，通常情况下，质量分数大约为5~6.因此根据这个指标，一个什么都没有做而是仅仅预测了均值的分类器可能同样会做的相当好（意思是直接为均值===相当于这个模型了）\n训练数据中的平均质量等级如下：（用平均值试试）\n\nShow the code# result = 5.87平均值\nmean(wine_train$quality) \n\n[1] 5.870933\n\nShow the code#如果我们对一个葡萄酒案例预测的值为5.87，那么我们将只有大约0.67的平均绝对误差\n#mean_abserror(5.87, wine_test$quality)\nmean(abs(rep(5.87,length(wine_test$quality))-wine_test$quality))#平均值的MAE为0.67\n\n[1] 0.6722474\n\n\n回归树(MSE=0.59)比估算的均值(MSE=0.67)平均更接近于真实的质量分数，但相差不大,所以模型需要改进"
  },
  {
    "objectID": "posts/post/tree-model.html#提高模型的性能-模型树改进模型",
    "href": "posts/post/tree-model.html#提高模型的性能-模型树改进模型",
    "title": "回归树与模型树",
    "section": "3.6提高模型的性能—-模型树（改进模型）",
    "text": "3.6提高模型的性能—-模型树（改进模型）\n模型树算法为M5算法—改进以后为M5’算法 M5‘算法在R中通过Rweka包和M5P()函数可以得到\n\nShow the codelibrary(RWeka)#调用的时候需要联网,还要安装该软件\n##############\n####  make_Weka_package_loader(\"lazyBayesianRules\") #加载weka相关的包\n####  list_Weka_interfaces()  #列出weka中可以调用的函数，不够的话可以下载\n####  WPM(\"list-packages\", \"installed\")\n####  WPM(\"list-packages\", \"available\")\n######################################\n# 应该是Rweka中默认没有这个函数，需要自己安装以后调用\n#好像在这里调用的时候，要安装weka\n## 调用方法cbind(d,iris[,5])\n#LBR=make_Weka_classifier(\"weka/classifiers/lazy/LBR\")\n#a=LBR(Species~., data=iris)\n#RF <-make_Weka_classifier(\"weka/classifiers/trees/RandomForest\")\n# a=RF(Species~., data=iris)\n\n###############################\n####\nM5P <- make_Weka_classifier(\"weka/classifiers/trees/M5P\")#必须调用\nm.m5p <- M5P(quality~., data = wine_train)\n\n# 画树图\nm.m5p\n\n\n这里的分割与前面的回归树很相似，然而关键的区别在于节点不是以一个数值预测终止，而是以一个线性模型终止（这里表示为LM1和LM2）\n线性模型本身显示在输出后面，例如LM1模型如下，这些值完全可以和多元模型一样解释，每一个数字都是相关特征对于预测的葡萄酒质量的净影响（效应）。对于固定酸度系数0.266意味着每增加一个单位的酸度，葡萄酒的质量预计会增加0.266\n注意的是，估计的影响只适用于到达该节点的葡萄酒案例。在这个模型树中一共建立了36个线性回归模型，每一个模型对于固定的酸度和其他10个特征的影响都有不同的估计\n对于预测数据来说：\n\nShow the code# 生成模型的预测\np.m5p <- predict(m.m5p, wine_test)\n\n# 模型树的预测返回比回归树的广\nsummary(p.m5p)\n\n\n#模型的MSE也有改善\nMAE(wine_test$quality, p.m5p)\n\n\n\nShow the codesessionInfo()\n\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.5.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] rpart.plot_3.1.1 rpart_4.1.16    \n\nloaded via a namespace (and not attached):\n [1] digest_0.6.29     jsonlite_1.8.0    magrittr_2.0.3    evaluate_0.16    \n [5] rlang_1.0.4       stringi_1.7.8     cli_3.3.0         rstudioapi_0.14  \n [9] rmarkdown_2.16.1  tools_4.2.1       stringr_1.4.1     htmlwidgets_1.5.4\n[13] xfun_0.32         yaml_2.3.5        fastmap_1.1.0     compiler_4.2.1   \n[17] htmltools_0.5.3   knitr_1.40"
  },
  {
    "objectID": "posts/post/listoperate.html",
    "href": "posts/post/listoperate.html",
    "title": "list 操作重要的函数",
    "section": "",
    "text": "以前提过可参考：(这里直接copy)\n1.捕获省略号中的内容\n​ 先看一个例子：构造一个函数然后对所有的参数进行相加求和。\n\nShow the codeaddemup <- function(x, ...){\n   args <- list(...)# 推荐把省略号的内容分配给list,然后在对该list进行操作\n   for (a in args){\n                x <- x + a \n   } \n   x\n }\n\naddemup(1,1)\n#> [1] 2\naddemup(1,2,3,4,5)\n#> [1] 15\n\n\n​ 我们还可以通过..1,..2到..9等直接引用列表…中的内容。..1表示第一项，..2表示第二项，以此类推。\n对list操作可以结合purrr包中的map, reduce, accumulate和基础函数do.call等 操作更方便。一个实际的例子，\nDGM_U = function(...){\n  #######  第一部分是对参数的检查 #####################\n  # 输入的参数为U_{k}，U_{k}代表一个完整的区间乘积互反判断矩阵。\n  n = nrow(..1)\n  m = ncol(..1)\n  args <- list(...)\n  stopifnot( length(args) >=2, all( map_lgl(args,is.matrix)),2*n ==m )\n  # 检查所有的矩阵维度是否一样\n  library(purrr)\n  t = map(args,dim) %>% do.call(rbind, .) \n  stopifnot( nrow(unique(t)) == 1)\n  \n  ####### 第二部分 对参数的操作，达到想要的目的###########\n  ## 1. 使用快捷的函数\n  k = 1 / length(args)\n  UB = reduce( map(args,function(x)fenjie(x)$B),`*`)^k\n  UD = reduce( map(args, function(x)fenjie(x)$D), `*`)^k\n  \n  ## 2. 使用循环操作\n  # UB = matrix(1,nrow = n, ncol = n)\n  # UD = matrix(1,nrow = n, ncol = n)\n  # for(xx in args){\n  #   B = fenjie(xx)$B\n  #   D = fenjie(xx)$D\n  #   for(i in 1:n){\n  #     for(j in 1:n){\n  #       UB[i,j] = UB[i,j] * B[i,j]\n  #       UD[i,j] = UD[i,j] * D[i,j]\n  #     }\n  #   }\n  # }\n  # k = 1 / length(args)\n  # UB = UB^( k)\n  # UD = UD^(k)\n  return( hecheng(UB,UD))\n}\n\nDGM_U(U_t1,U_t2,U_t3)\n2.map函数\n​ 当然R自带也提供类似的Map函数，但是我们这里只讨论purrr::map函数 ,类似的有map2() , pmap()\nmap(.x, .f, ...)\n# 该函数作用是把每一个函数应用在list中的每一个元素上，或者向量中的每一个元素上。\n# x为一个list或者向量\n# .f 提供的函数\n什么叫list中的每一个元素，比如：\n\nShow the codel = list(a = 1:3,b=matrix(1:9,nrow =3), d = list(1:9))\nl\n#> $a\n#> [1] 1 2 3\n#> \n#> $b\n#>      [,1] [,2] [,3]\n#> [1,]    1    4    7\n#> [2,]    2    5    8\n#> [3,]    3    6    9\n#> \n#> $d\n#> $d[[1]]\n#> [1] 1 2 3 4 5 6 7 8 9\n\n\n​ 该list 中只有3个元素，第一个元素是向量1:3, 第二个元素是矩阵，第三个元素是一个list。我们可以用length()函数求一个list中元素的个数。\n注意： 我们在利用函数参数...包装成list时候，一般输入的...的内容具有统一的格式.类似上面的情况。\n3.reduce 函数和accumulate 函数\n​ 这些函数都是对list中每一个元素进行操作的。无论这个元素的数据结构是什么，该元素可以是数值型向量，字符型向量、矩阵、数据框、list，这些都可以。\n4. do.call函数\n​ 操作对象也是list中的每一个元素，该函数有点类似于reduce,eg: 把list中的元素转变为matrix\nl = list(a= 1:3,b = 4:6,d = 7:9)\nreduce(l,rbind) # purrr包中的函数\ndo.call(rbind,l)\n\nreduce(l,cbind)\ndo.call(cbind,l)\n5. 把正常数据(数据框)转变为list\n​ 常常结合split函数进行使用, 首先给一个数据框，按照某种准则划分为一个list，最后利用purrr包中的函数对list中的每一个元素进行处理，\n\nShow the code## 以下分类建立一个线性回归模型\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(purrr)\n## 方法1：\nmod_fun <- function(df) lm(Sepal.Length ~ ., data = df)\nn_iris = iris %>% group_by(Species) %>% nest()\nn_iris %>% mutate(model = map(data, mod_fun))\n#> # A tibble: 3 × 3\n#> # Groups:   Species [3]\n#>   Species    data              model \n#>   <fct>      <list>            <list>\n#> 1 setosa     <tibble [50 × 4]> <lm>  \n#> 2 versicolor <tibble [50 × 4]> <lm>  \n#> 3 virginica  <tibble [50 × 4]> <lm>\n\nn_iris\n#> # A tibble: 3 × 2\n#> # Groups:   Species [3]\n#>   Species    data             \n#>   <fct>      <list>           \n#> 1 setosa     <tibble [50 × 4]>\n#> 2 versicolor <tibble [50 × 4]>\n#> 3 virginica  <tibble [50 × 4]>\n\n\n# 方法2：\nn_iris_1 = split(iris,iris$Species) \nn_iris_1 %>% map(., function(df)lm(Sepal.Length ~ ., data = df[,-5] )  )\n#> $setosa\n#> \n#> Call:\n#> lm(formula = Sepal.Length ~ ., data = df[, -5])\n#> \n#> Coefficients:\n#>  (Intercept)   Sepal.Width  Petal.Length   Petal.Width  \n#>       2.3519        0.6548        0.2376        0.2521  \n#> \n#> \n#> $versicolor\n#> \n#> Call:\n#> lm(formula = Sepal.Length ~ ., data = df[, -5])\n#> \n#> Coefficients:\n#>  (Intercept)   Sepal.Width  Petal.Length   Petal.Width  \n#>       1.8955        0.3869        0.9083       -0.6792  \n#> \n#> \n#> $virginica\n#> \n#> Call:\n#> lm(formula = Sepal.Length ~ ., data = df[, -5])\n#> \n#> Coefficients:\n#>  (Intercept)   Sepal.Width  Petal.Length   Petal.Width  \n#>       0.6999        0.3303        0.9455       -0.1698\n\n\nn_iris_1\n#> $setosa\n#>    Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1           5.1         3.5          1.4         0.2  setosa\n#> 2           4.9         3.0          1.4         0.2  setosa\n#> 3           4.7         3.2          1.3         0.2  setosa\n#> 4           4.6         3.1          1.5         0.2  setosa\n#> 5           5.0         3.6          1.4         0.2  setosa\n#> 6           5.4         3.9          1.7         0.4  setosa\n#> 7           4.6         3.4          1.4         0.3  setosa\n#> 8           5.0         3.4          1.5         0.2  setosa\n#> 9           4.4         2.9          1.4         0.2  setosa\n#> 10          4.9         3.1          1.5         0.1  setosa\n#> 11          5.4         3.7          1.5         0.2  setosa\n#> 12          4.8         3.4          1.6         0.2  setosa\n#> 13          4.8         3.0          1.4         0.1  setosa\n#> 14          4.3         3.0          1.1         0.1  setosa\n#> 15          5.8         4.0          1.2         0.2  setosa\n#> 16          5.7         4.4          1.5         0.4  setosa\n#> 17          5.4         3.9          1.3         0.4  setosa\n#> 18          5.1         3.5          1.4         0.3  setosa\n#> 19          5.7         3.8          1.7         0.3  setosa\n#> 20          5.1         3.8          1.5         0.3  setosa\n#> 21          5.4         3.4          1.7         0.2  setosa\n#> 22          5.1         3.7          1.5         0.4  setosa\n#> 23          4.6         3.6          1.0         0.2  setosa\n#> 24          5.1         3.3          1.7         0.5  setosa\n#> 25          4.8         3.4          1.9         0.2  setosa\n#> 26          5.0         3.0          1.6         0.2  setosa\n#> 27          5.0         3.4          1.6         0.4  setosa\n#> 28          5.2         3.5          1.5         0.2  setosa\n#> 29          5.2         3.4          1.4         0.2  setosa\n#> 30          4.7         3.2          1.6         0.2  setosa\n#> 31          4.8         3.1          1.6         0.2  setosa\n#> 32          5.4         3.4          1.5         0.4  setosa\n#> 33          5.2         4.1          1.5         0.1  setosa\n#> 34          5.5         4.2          1.4         0.2  setosa\n#> 35          4.9         3.1          1.5         0.2  setosa\n#> 36          5.0         3.2          1.2         0.2  setosa\n#> 37          5.5         3.5          1.3         0.2  setosa\n#> 38          4.9         3.6          1.4         0.1  setosa\n#> 39          4.4         3.0          1.3         0.2  setosa\n#> 40          5.1         3.4          1.5         0.2  setosa\n#> 41          5.0         3.5          1.3         0.3  setosa\n#> 42          4.5         2.3          1.3         0.3  setosa\n#> 43          4.4         3.2          1.3         0.2  setosa\n#> 44          5.0         3.5          1.6         0.6  setosa\n#> 45          5.1         3.8          1.9         0.4  setosa\n#> 46          4.8         3.0          1.4         0.3  setosa\n#> 47          5.1         3.8          1.6         0.2  setosa\n#> 48          4.6         3.2          1.4         0.2  setosa\n#> 49          5.3         3.7          1.5         0.2  setosa\n#> 50          5.0         3.3          1.4         0.2  setosa\n#> \n#> $versicolor\n#>     Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n#> 51           7.0         3.2          4.7         1.4 versicolor\n#> 52           6.4         3.2          4.5         1.5 versicolor\n#> 53           6.9         3.1          4.9         1.5 versicolor\n#> 54           5.5         2.3          4.0         1.3 versicolor\n#> 55           6.5         2.8          4.6         1.5 versicolor\n#> 56           5.7         2.8          4.5         1.3 versicolor\n#> 57           6.3         3.3          4.7         1.6 versicolor\n#> 58           4.9         2.4          3.3         1.0 versicolor\n#> 59           6.6         2.9          4.6         1.3 versicolor\n#> 60           5.2         2.7          3.9         1.4 versicolor\n#> 61           5.0         2.0          3.5         1.0 versicolor\n#> 62           5.9         3.0          4.2         1.5 versicolor\n#> 63           6.0         2.2          4.0         1.0 versicolor\n#> 64           6.1         2.9          4.7         1.4 versicolor\n#> 65           5.6         2.9          3.6         1.3 versicolor\n#> 66           6.7         3.1          4.4         1.4 versicolor\n#> 67           5.6         3.0          4.5         1.5 versicolor\n#> 68           5.8         2.7          4.1         1.0 versicolor\n#> 69           6.2         2.2          4.5         1.5 versicolor\n#> 70           5.6         2.5          3.9         1.1 versicolor\n#> 71           5.9         3.2          4.8         1.8 versicolor\n#> 72           6.1         2.8          4.0         1.3 versicolor\n#> 73           6.3         2.5          4.9         1.5 versicolor\n#> 74           6.1         2.8          4.7         1.2 versicolor\n#> 75           6.4         2.9          4.3         1.3 versicolor\n#> 76           6.6         3.0          4.4         1.4 versicolor\n#> 77           6.8         2.8          4.8         1.4 versicolor\n#> 78           6.7         3.0          5.0         1.7 versicolor\n#> 79           6.0         2.9          4.5         1.5 versicolor\n#> 80           5.7         2.6          3.5         1.0 versicolor\n#> 81           5.5         2.4          3.8         1.1 versicolor\n#> 82           5.5         2.4          3.7         1.0 versicolor\n#> 83           5.8         2.7          3.9         1.2 versicolor\n#> 84           6.0         2.7          5.1         1.6 versicolor\n#> 85           5.4         3.0          4.5         1.5 versicolor\n#> 86           6.0         3.4          4.5         1.6 versicolor\n#> 87           6.7         3.1          4.7         1.5 versicolor\n#> 88           6.3         2.3          4.4         1.3 versicolor\n#> 89           5.6         3.0          4.1         1.3 versicolor\n#> 90           5.5         2.5          4.0         1.3 versicolor\n#> 91           5.5         2.6          4.4         1.2 versicolor\n#> 92           6.1         3.0          4.6         1.4 versicolor\n#> 93           5.8         2.6          4.0         1.2 versicolor\n#> 94           5.0         2.3          3.3         1.0 versicolor\n#> 95           5.6         2.7          4.2         1.3 versicolor\n#> 96           5.7         3.0          4.2         1.2 versicolor\n#> 97           5.7         2.9          4.2         1.3 versicolor\n#> 98           6.2         2.9          4.3         1.3 versicolor\n#> 99           5.1         2.5          3.0         1.1 versicolor\n#> 100          5.7         2.8          4.1         1.3 versicolor\n#> \n#> $virginica\n#>     Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n#> 101          6.3         3.3          6.0         2.5 virginica\n#> 102          5.8         2.7          5.1         1.9 virginica\n#> 103          7.1         3.0          5.9         2.1 virginica\n#> 104          6.3         2.9          5.6         1.8 virginica\n#> 105          6.5         3.0          5.8         2.2 virginica\n#> 106          7.6         3.0          6.6         2.1 virginica\n#> 107          4.9         2.5          4.5         1.7 virginica\n#> 108          7.3         2.9          6.3         1.8 virginica\n#> 109          6.7         2.5          5.8         1.8 virginica\n#> 110          7.2         3.6          6.1         2.5 virginica\n#> 111          6.5         3.2          5.1         2.0 virginica\n#> 112          6.4         2.7          5.3         1.9 virginica\n#> 113          6.8         3.0          5.5         2.1 virginica\n#> 114          5.7         2.5          5.0         2.0 virginica\n#> 115          5.8         2.8          5.1         2.4 virginica\n#> 116          6.4         3.2          5.3         2.3 virginica\n#> 117          6.5         3.0          5.5         1.8 virginica\n#> 118          7.7         3.8          6.7         2.2 virginica\n#> 119          7.7         2.6          6.9         2.3 virginica\n#> 120          6.0         2.2          5.0         1.5 virginica\n#> 121          6.9         3.2          5.7         2.3 virginica\n#> 122          5.6         2.8          4.9         2.0 virginica\n#> 123          7.7         2.8          6.7         2.0 virginica\n#> 124          6.3         2.7          4.9         1.8 virginica\n#> 125          6.7         3.3          5.7         2.1 virginica\n#> 126          7.2         3.2          6.0         1.8 virginica\n#> 127          6.2         2.8          4.8         1.8 virginica\n#> 128          6.1         3.0          4.9         1.8 virginica\n#> 129          6.4         2.8          5.6         2.1 virginica\n#> 130          7.2         3.0          5.8         1.6 virginica\n#> 131          7.4         2.8          6.1         1.9 virginica\n#> 132          7.9         3.8          6.4         2.0 virginica\n#> 133          6.4         2.8          5.6         2.2 virginica\n#> 134          6.3         2.8          5.1         1.5 virginica\n#> 135          6.1         2.6          5.6         1.4 virginica\n#> 136          7.7         3.0          6.1         2.3 virginica\n#> 137          6.3         3.4          5.6         2.4 virginica\n#> 138          6.4         3.1          5.5         1.8 virginica\n#> 139          6.0         3.0          4.8         1.8 virginica\n#> 140          6.9         3.1          5.4         2.1 virginica\n#> 141          6.7         3.1          5.6         2.4 virginica\n#> 142          6.9         3.1          5.1         2.3 virginica\n#> 143          5.8         2.7          5.1         1.9 virginica\n#> 144          6.8         3.2          5.9         2.3 virginica\n#> 145          6.7         3.3          5.7         2.5 virginica\n#> 146          6.7         3.0          5.2         2.3 virginica\n#> 147          6.3         2.5          5.0         1.9 virginica\n#> 148          6.5         3.0          5.2         2.0 virginica\n#> 149          6.2         3.4          5.4         2.3 virginica\n#> 150          5.9         3.0          5.1         1.8 virginica\n\n\n\nShow the codesessionInfo()\n#> R version 4.2.1 (2022-06-23)\n#> Platform: aarch64-apple-darwin20 (64-bit)\n#> Running under: macOS Monterey 12.5.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n#> \n#> locale:\n#> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> other attached packages:\n#> [1] purrr_0.3.4 tidyr_1.2.0 dplyr_1.0.9\n#> \n#> loaded via a namespace (and not attached):\n#>  [1] rstudioapi_0.14   knitr_1.40        magrittr_2.0.3    tidyselect_1.1.2 \n#>  [5] R6_2.5.1          rlang_1.0.4       fastmap_1.1.0     fansi_1.0.3      \n#>  [9] stringr_1.4.1     tools_4.2.1       xfun_0.32         utf8_1.2.2       \n#> [13] DBI_1.1.3         cli_3.3.0         ellipsis_0.3.2    htmltools_0.5.3  \n#> [17] assertthat_0.2.1  yaml_2.3.5        digest_0.6.29     tibble_3.1.8     \n#> [21] lifecycle_1.0.1   htmlwidgets_1.5.4 vctrs_0.4.1       glue_1.6.2       \n#> [25] evaluate_0.16     rmarkdown_2.16.1  stringi_1.7.8     compiler_4.2.1   \n#> [29] pillar_1.8.1      generics_0.1.3    jsonlite_1.8.0    pkgconfig_2.0.3\n\n\n6. 更多list操作\n可以参考purrr包，并且rstudio官网上提供相应的总结表(备忘单)。"
  },
  {
    "objectID": "posts/post/dplyr3.html",
    "href": "posts/post/dplyr3.html",
    "title": "dplyr – 3合并数据",
    "section": "",
    "text": "记录是一行,字段是一列"
  },
  {
    "objectID": "posts/post/dplyr3.html#转换与合并",
    "href": "posts/post/dplyr3.html#转换与合并",
    "title": "dplyr – 3合并数据",
    "section": "1、转换与合并",
    "text": "1、转换与合并\nleft_join(a, b, by = “x1”)： 向数据集a中加入匹配的数据集b记录（行）。\nright_join(a, b, by = “x1”)： 向数据集b中加入匹配的数据集a记录。\ninner_join(a, b, by = “x1”)： 合并数据。仅保留匹配的记录。\nfull_join(a, b, by = “x1”)： 合并数据。保留所有记录，所有行。没有的用NA填充\n\nShow the codelibrary(dplyr)\na=data.frame(x1=c(\"A\",\"B\",\"C\"),x2=c(1:3))\nb=data.frame(x1=c(\"A\",\"B\",\"D\"),x3=c(\"T\",\"F\",\"T\"))\nprint(a)\n\n  x1 x2\n1  A  1\n2  B  2\n3  C  3\n\nShow the codeprint(b)\n\n  x1 x3\n1  A  T\n2  B  F\n3  D  T\n\n\n\nShow the codeleft_join(a, b, by = \"x1\")# 向数据集a中加入匹配的数据集b记录。\n\n  x1 x2   x3\n1  A  1    T\n2  B  2    F\n3  C  3 <NA>\n\nShow the coderight_join(a, b, by = \"x1\")#    向数据集b中加入匹配的数据集a记录。\n\n  x1 x2 x3\n1  A  1  T\n2  B  2  F\n3  D NA  T\n\nShow the codeinner_join(a, b, by = \"x1\")#    合并数据。仅保留匹配的记录。\n\n  x1 x2 x3\n1  A  1  T\n2  B  2  F\n\nShow the codefull_join(a, b, by = \"x1\")# 合并数据。保留所有记录，所有行，没有的用NA填充\n\n  x1 x2   x3\n1  A  1    T\n2  B  2    F\n3  C  3 <NA>\n4  D NA    T"
  },
  {
    "objectID": "posts/post/dplyr3.html#筛选与合并",
    "href": "posts/post/dplyr3.html#筛选与合并",
    "title": "dplyr – 3合并数据",
    "section": "2、筛选与合并",
    "text": "2、筛选与合并\nsemi_join(a, b, by = “x1”)： 数据集a中能与数据集b匹配的记录。\nanti_join(a, b, by = “x1”)： 数据集a中与数据集b不匹配的记录"
  },
  {
    "objectID": "posts/post/dplyr3.html#集合操作",
    "href": "posts/post/dplyr3.html#集合操作",
    "title": "dplyr – 3合并数据",
    "section": "3、集合操作",
    "text": "3、集合操作\nintersect(x, y)： 均出现在数据集x和y中的记录。xy交集\nunion(x, y)： 出现在数据集x或y中的记录。 xy并集\nsetdiff(x, y)： 仅出现在数据集x而不在y中的记录。x与y的差集\nbind_rows(x, y)： 把数据集y作为新的⾏行添加到x中。\nbind_cols(x, y)： 把数据集y作为新的列添加到x中。\n\n注意：数据按所在位置匹配。\n和rbind（） 与cbind（）不一样的是，rbind（）/cbind（）对数据合并有严格的要求\n\n\nShow the codex=data.frame(A=c(\"a\",\"b\",\"c\"),B=c(\"t\",\"u\",\"v\"),C=c(1:3))\ny=data.frame(A=c(\"a\",\"b\",\"d\"),B=c(\"t\",\"u\",\"v\"),D=c(2:4))\nprint(x)\n\n  A B C\n1 a t 1\n2 b u 2\n3 c v 3\n\nShow the codeprint(y)\n\n  A B D\n1 a t 2\n2 b u 3\n3 d v 4\n\n\n\nShow the codebind_rows(x, y) #行合并，列全部显示，没有的用NA填充 ，选择.id=\"name\"参数，多增加一列，列名name\n\n  A B  C  D\n1 a t  1 NA\n2 b u  2 NA\n3 c v  3 NA\n4 a t NA  2\n5 b u NA  3\n6 d v NA  4\n\nShow the codebind_rows(x, y, .id=\"name\")# 为了区别数据是分别来自于两个其他数据库，可以用id进行区别\n\n  name A B  C  D\n1    1 a t  1 NA\n2    1 b u  2 NA\n3    1 c v  3 NA\n4    2 a t NA  2\n5    2 b u NA  3\n6    2 d v NA  4\n\nShow the codebind_cols(x, y) #列合并，\n\n  A...1 B...2 C A...4 B...5 D\n1     a     t 1     a     t 2\n2     b     u 2     b     u 3\n3     c     v 3     d     v 4"
  },
  {
    "objectID": "posts/post/dplyr3.html#数据排序",
    "href": "posts/post/dplyr3.html#数据排序",
    "title": "dplyr – 3合并数据",
    "section": "4、数据排序",
    "text": "4、数据排序\narrange(.data, ..., .by_group = FALSE) :根据变量进行排序\n  + 默认升序，在变量前面添加desc()则变为降序\n  + .by_group = FALSE 默认忽视对组的升序排序,设置为TRUE则把组进行升序排序以后再按比变量进行排序\n\nShow the codearrange(mtcars, cyl, desc(disp))  #根据变量进行排序\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\n\nShow the codeby_cyl <- mtcars %>% group_by(cyl)\n\nby_cyl %>% arrange(desc(wt), .by_group = TRUE) #默认忽视对组的升序排序,设置为TRUE则把组进行升序排序以后再按比变量进行排序\n\n# A tibble: 32 × 11\n# Groups:   cyl [3]\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1  24.4     4 147.     62  3.69  3.19  20       1     0     4     2\n 2  22.8     4 141.     95  3.92  3.15  22.9     1     0     4     2\n 3  21.4     4 121     109  4.11  2.78  18.6     1     1     4     2\n 4  21.5     4 120.     97  3.7   2.46  20.0     1     0     3     1\n 5  22.8     4 108      93  3.85  2.32  18.6     1     1     4     1\n 6  32.4     4  78.7    66  4.08  2.2   19.5     1     1     4     1\n 7  26       4 120.     91  4.43  2.14  16.7     0     1     5     2\n 8  27.3     4  79      66  4.08  1.94  18.9     1     1     4     1\n 9  33.9     4  71.1    65  4.22  1.84  19.9     1     1     4     1\n10  30.4     4  75.7    52  4.93  1.62  18.5     1     1     4     2\n# … with 22 more rows"
  },
  {
    "objectID": "posts/post/dplyr3.html#运行环境",
    "href": "posts/post/dplyr3.html#运行环境",
    "title": "dplyr – 3合并数据",
    "section": "5、 运行环境",
    "text": "5、 运行环境\n\nShow the codesessionInfo()\n\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.5.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] dplyr_1.0.9\n\nloaded via a namespace (and not attached):\n [1] rstudioapi_0.14   knitr_1.40        magrittr_2.0.3    tidyselect_1.1.2 \n [5] R6_2.5.1          rlang_1.0.4       fastmap_1.1.0     fansi_1.0.3      \n [9] stringr_1.4.1     tools_4.2.1       xfun_0.32         utf8_1.2.2       \n[13] DBI_1.1.3         cli_3.3.0         htmltools_0.5.3   assertthat_0.2.1 \n[17] yaml_2.3.5        digest_0.6.29     tibble_3.1.8      lifecycle_1.0.1  \n[21] purrr_0.3.4       htmlwidgets_1.5.4 vctrs_0.4.1       glue_1.6.2       \n[25] evaluate_0.16     rmarkdown_2.16.1  stringi_1.7.8     compiler_4.2.1   \n[29] pillar_1.8.1      generics_0.1.3    jsonlite_1.8.0    pkgconfig_2.0.3"
  },
  {
    "objectID": "posts/post/PlotTwoAxis.html",
    "href": "posts/post/PlotTwoAxis.html",
    "title": "R语言绘制双坐标图",
    "section": "",
    "text": "Show the code#png(\"2y_1.png\")\nrm(list = ls())\nlibrary(plotrix)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nShow the codenew_iris = arrange(iris,Sepal.Length)# 按照花瓣的长度进行排序 --- 为了后面好看  \nhead(new_iris,10)\n\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1           4.3         3.0          1.1         0.1  setosa\n2           4.4         2.9          1.4         0.2  setosa\n3           4.4         3.0          1.3         0.2  setosa\n4           4.4         3.2          1.3         0.2  setosa\n5           4.5         2.3          1.3         0.3  setosa\n6           4.6         3.1          1.5         0.2  setosa\n7           4.6         3.4          1.4         0.3  setosa\n8           4.6         3.6          1.0         0.2  setosa\n9           4.6         3.2          1.4         0.2  setosa\n10          4.7         3.2          1.3         0.2  setosa\n\nShow the code# 设置数据 -\ny1 = new_iris$Sepal.Length[1:10]\nx1_axis = 1:length(y1)\n\ny2 = new_iris$Petal.Length[1:10]\nx2_axis = 1:length(y2)\n\n\npar(family='STKaiti')\ntwoord.plot(x1_axis, y1, x2_axis, y2,main = '双折线图') #  这线图\n\n\n\nShow the codepar(family='STKaiti')\ntwoord.plot(x1_axis, y1, x2_axis, y2,lylim=c(4.2,4.8),rylim=c(1,1.5),lcol=4,rcol=2,main = '折线图和条形图',\n            xlab=\"x轴\",ylab=\"y1轴\",rylab=\"y2轴\",type=c(\"bar\",\"b\"),halfwidth=0.2) # 折线图和条形图\n\n\n\nShow the code#dev.off()"
  },
  {
    "objectID": "posts/post/PlotTwoAxis.html#twoord.plot-参数解释",
    "href": "posts/post/PlotTwoAxis.html#twoord.plot-参数解释",
    "title": "R语言绘制双坐标图",
    "section": "twoord.plot() 参数解释",
    "text": "twoord.plot() 参数解释\ntwoord.plot()函数语法及参数含义：\n twoord.plot(lx,ly,rx,ry,data=NULL,main=\"\",xlim=NULL,lylim=NULL,rylim=NULL,\n        mar=c(5,4,4,4),lcol=1,rcol=2,xlab=\"\",lytickpos=NA,ylab=\"\",ylab.at=NA,\n        rytickpos=NA,rylab=\"\",rylab.at=NA,lpch=1,rpch=2,\n        type=\"b\",xtickpos=NULL,xticklab=NULL,halfwidth=0.4,axislab.cex=1,do.first=NULL,...)\n\nlx,ly,rx,ry：分别指定左坐标轴和右坐标轴的值，必须是连续的值\ndata：需要绘制双轴图形的数据框\nmain：为图形指定标题\nxlim：限制横坐标值的范围\nlylim,rylim：限制左右纵坐标值的范围\nmar：设置图形边界距，默认值为(5,4,4,4)\nlcol,rcol：设置左右坐标轴的颜色，这样可以起到图例的作用\nxlab：设置横坐标轴标签\nlytickpos：设置左坐标轴刻度标签的位置\nylab：设置左坐标轴标签\nylab.at：设置左坐标轴标签位置\nrytickpos：设置右坐标轴刻度标签的位置\nrylab：设置又坐标轴标签\nrylab.at：设置右坐标轴标签位置\nlpch,rpch：设置左右坐标轴图形的外观\ntype：指定图形类型,参考plot参数的类型\n\n\np 为 points，I for lines， b for both，“c” for the lines part alone of “b”,\n“o” for both ‘overplotted’，“h” for ‘histogram’ like (or ‘high-density’) vertical lines,\n“s” for stair steps, “S” for other steps, “n” for no plotting.\n\n\nxtickpos：设置横坐标轴刻度标签位置\nxticklab：设置横坐标轴刻度标签\nhalfwidth：设置用户给定条形图宽度的一半\naxislab.cex：设置坐标轴标签和刻度标签的大小\ndo.first：通过该参数可以往图形中添加背景色或网格线\n\n\nShow the codesessionInfo()\n\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.5.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] dplyr_1.0.9   plotrix_3.8-2\n\nloaded via a namespace (and not attached):\n [1] rstudioapi_0.14   knitr_1.40        magrittr_2.0.3    tidyselect_1.1.2 \n [5] R6_2.5.1          rlang_1.0.4       fastmap_1.1.0     fansi_1.0.3      \n [9] stringr_1.4.1     tools_4.2.1       xfun_0.32         utf8_1.2.2       \n[13] DBI_1.1.3         cli_3.3.0         htmltools_0.5.3   assertthat_0.2.1 \n[17] yaml_2.3.5        digest_0.6.29     tibble_3.1.8      lifecycle_1.0.1  \n[21] purrr_0.3.4       htmlwidgets_1.5.4 vctrs_0.4.1       glue_1.6.2       \n[25] evaluate_0.16     rmarkdown_2.16.1  stringi_1.7.8     compiler_4.2.1   \n[29] pillar_1.8.1      generics_0.1.3    jsonlite_1.8.0    pkgconfig_2.0.3"
  },
  {
    "objectID": "posts/post/OutputWidth.html",
    "href": "posts/post/OutputWidth.html",
    "title": "测试rmarkdown输出页面",
    "section": "",
    "text": "这是行内公式\\(a^2+b^2+\\sqrt{c}\\),这是行间公式 \\[x^2+y^2= z^2\\] ## 动态图\n\nShow the codelibrary(ggplot2)\nlibrary(plotly)\np <- ggplot(data = diamonds, aes(x = cut, fill = clarity)) +\n            geom_bar(position = \"dodge\")\nggplotly(p)\n\n\n\nShow the codelibrary(rbokeh)\nfigure() %>%\n  ly_points(Sepal.Length, Sepal.Width, data = iris,\n    color = Species, glyph = Species,\n    hover = list(Sepal.Length, Sepal.Width))\n\n\n\nShow the codelibrary(dygraphs)\ndygraph(nhtemp, main = \"New Haven Temperatures\") %>% \n  dyRangeSelector(dateWindow = c(\"1920-01-01\", \"1960-01-01\"))\n\n\n\n\n\nShow the codesummary(cars)\n#>      speed           dist       \n#>  Min.   : 4.0   Min.   :  2.00  \n#>  1st Qu.:12.0   1st Qu.: 26.00  \n#>  Median :15.0   Median : 36.00  \n#>  Mean   :15.4   Mean   : 42.98  \n#>  3rd Qu.:19.0   3rd Qu.: 56.00  \n#>  Max.   :25.0   Max.   :120.00\n\n\n\n\n\nShow the codesummary(iris)\n#>   Sepal.Length    Sepal.Width     Petal.Length    Petal.Width          Species  \n#>  Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.100   setosa    :50  \n#>  1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.600   1st Qu.:0.300   versicolor:50  \n#>  Median :5.800   Median :3.000   Median :4.350   Median :1.300   virginica :50  \n#>  Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199                  \n#>  3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.800                  \n#>  Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500\n\n\n\n\n\nShow the codesummary(iris)\n#>   Sepal.Length    Sepal.Width     Petal.Length    Petal.Width          Species  \n#>  Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.100   setosa    :50  \n#>  1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.600   1st Qu.:0.300   versicolor:50  \n#>  Median :5.800   Median :3.000   Median :4.350   Median :1.300   virginica :50  \n#>  Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199                  \n#>  3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.800                  \n#>  Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500\n\n\n\n\n\n\nint foo (void) {\n    int i;\n}\n\n\nint foo (void) {\n    int i;\n}\n\n\nint foo (void) {\n    int i;\n}\n\n\n\nShow the codesessionInfo()\n#> R version 4.2.1 (2022-06-23)\n#> Platform: aarch64-apple-darwin20 (64-bit)\n#> Running under: macOS Monterey 12.5.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n#> \n#> locale:\n#> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] digest_0.6.29     jsonlite_1.8.0    magrittr_2.0.3    evaluate_0.16     rlang_1.0.4       stringi_1.7.8     cli_3.3.0         rstudioapi_0.14   rmarkdown_2.16.1  tools_4.2.1       stringr_1.4.1     htmlwidgets_1.5.4 xfun_0.32         yaml_2.3.5        fastmap_1.1.0     compiler_4.2.1    htmltools_0.5.3   knitr_1.40"
  },
  {
    "objectID": "posts/post/ggfortify1jianjie.html",
    "href": "posts/post/ggfortify1jianjie.html",
    "title": "ggfortify包简介",
    "section": "",
    "text": "Show the codeknitr::opts_chunk$set(message=FALSE, warning=FALSE)\nggfortify 是一个简单易用的R软件包，它可以仅仅使用一行代码来对许多受欢迎的R软件包结果进行二维可视化，这让统计学家以及数据科学家省去了许多繁琐和重复的过程，不用对结果进行任何处理就能以 ggplot 的风格画出好看的图，大大地提高了工作的效率。\n接下来我将简单介绍一下怎么用 ggplot2 和 ggfortify 来很快地对PCA、聚类以及LFDA的结果进行可视化，然后将简单介绍用 ggfortify 来对时间序列进行快速可视化的方法。一下都是个人理解，"
  },
  {
    "objectID": "posts/post/ggfortify1jianjie.html#pca-主成分分析",
    "href": "posts/post/ggfortify1jianjie.html#pca-主成分分析",
    "title": "ggfortify包简介",
    "section": "1、PCA (主成分分析)",
    "text": "1、PCA (主成分分析)\n其实本包，大多数画图都是采用主成分（不包括因子分析）降维得到两个主成分，在进一步使其主成分为坐标，对应与每个点给出相应的颜色和类别\nggfortify 使 ggplot2 知道怎么诠释PCA对象。加载好 ggfortify 包之后, 你可以对stats::prcomp 和stats::princomp对象使用 ggplot2::autoplot。\nautoplot()函数是ggplot2中的，不过ggfortify包里面有泛函s3类的autoplot解释这个函数\nggbiplot()函数中的参数就是autoplot()函数中的参数\nautoplot(object, data = NULL, scale = 1, x = 1, y = 2, ...)\n\nobject                          :  对象\ndata                            :  对应的数据框\ncolour = 'Species'              :  若有分类因子变量，可以对不同的类别添加颜色,当为连续值时为逐渐变色\nshape = FALSE                   ： 调整点的形状，可以让所有的点消失，只留下标识（可以为具体的数字，就是形状类型）\nmain    、xlab   、ylab            ： 标题\nlabel = TRUE \n      label.size = 3            :  可以给每个点加上标识（以rownames为标准），也可以调整标识的大小.（默认为FALSE）\n      label.label               :  标识标签（默认rownames）\n      label.colour              :  文本标签的颜色\n      label.alpha               ： 透明度\n      label.angle               ： 旋转的角度\n      label.family              :  字体\n      label.fontface\n      label.lineheight\n      label.hjust\n      label.vjust\n      label.repel\n\n\nloadings = TRUE                 ： 可以很快地画出特征向量\n      loadings.colour = 'blue'  ： 特征向量的颜色\n      loadings.label = TRUE     ：  特征向量的标识(默认为特征向量的名字)\n          loadings.label.size = 3   ：  特征向量的大小\n          loadings.label.label      :\n          loadings.label.colour\n          loadings.label.alpha\n          loadings.label.angle\n          loadings.label.family\n          loadings.label.fontface\n          loadings.label.lineheight\n          loadings.label.hjust\n          loadings.label.vjust\n          loadings.label.repel\n          \n\nframe = TRUE                    ： 可以把每个类圈出来。图中没有分类则看成一类，全部圈出来（支持 stats::kmeans 和 cluster::* 等等）\n      frame.colour = 'Species'   :  对分类变量进行颜色标注，并把它们类别圈出来（类似colour = 'Species'  ）\n      frame.type = 't'          ： 选择圈的类型(默认多边形)\n      frame.level\n      frame.alpha\n\nShow the codelibrary(ggfortify)\ndf <- iris[c(1, 2, 3, 4)]\nautoplot(prcomp(df))#等价autoplot(prcomp(iris[-5]), data = iris)\n\n\n\n\n你还可以选择数据中的一列来给画出的点按类别自动分颜色。输入help(autoplot.prcomp) 可以了解到更多的其他选择。\n\nShow the codeautoplot(prcomp(df), data = iris, colour = 'Species')\n\n\n\n\n比如说给定label = TRUE 可以给每个点加上标识（以rownames为标准），也可以调整标识的大小。\n\nShow the codeautoplot(prcomp(df), data = iris, colour = 'Species', label = TRUE,label.size = 3)\n\n\n\n\n给定 shape = FALSE 可以让所有的点消失，只留下标识，这样可以让图更清晰，辨识度更大。\n\nShow the codeautoplot(prcomp(df), data = iris, colour = 'Species', shape =14,label.size = 3,label = TRUE)\n\n\n\n\n给定 loadings = TRUE 可以很快地画出特征向量。\n\nShow the codeautoplot(prcomp(df), data = iris, colour = 'Species', loadings = TRUE)\n\n\n\n\n同样的，你也可以显示特征向量的标识以及调整他们的大小，更多选择请参考帮助文件。\n\nShow the codeautoplot(prcomp(df), data = iris, colour = 'Species',\n         loadings = TRUE, loadings.colour = 'blue',\n         loadings.label = TRUE, loadings.label.size = 3)"
  },
  {
    "objectID": "posts/post/ggfortify1jianjie.html#因子分析",
    "href": "posts/post/ggfortify1jianjie.html#因子分析",
    "title": "ggfortify包简介",
    "section": "2、因子分析",
    "text": "2、因子分析\n和PCA类似，ggfortify 也支持 stats::factanal 对象。可调的选择也很广泛。以下给出了简单的例子： 注意 当你使用 factanal 来计算分数的话，你必须给定 scores 的值。 下面都是建立在因子分析模型上，但是几乎参数和主成分分析一样。。\n\nShow the code#因子分析 ，记住3个因子和2个因子画出来的图是不一样的\n\n(d.factanal <- factanal(state.x77, factors = 3, scores = 'regression'))#因子分析,\n\n\nCall:\nfactanal(x = state.x77, factors = 3, scores = \"regression\")\n\nUniquenesses:\nPopulation     Income Illiteracy   Life Exp     Murder    HS Grad      Frost \n     0.813      0.474      0.266      0.240      0.050      0.167      0.005 \n      Area \n     0.613 \n\nLoadings:\n           Factor1 Factor2 Factor3\nPopulation -0.156   0.361   0.181 \nIncome      0.316           0.651 \nIlliteracy -0.576   0.543  -0.328 \nLife Exp    0.856  -0.128   0.103 \nMurder     -0.854   0.459   0.103 \nHS Grad     0.576  -0.149   0.692 \nFrost       0.137  -0.966   0.209 \nArea       -0.184           0.593 \n\n               Factor1 Factor2 Factor3\nSS loadings      2.301   1.612   1.459\nProportion Var   0.288   0.201   0.182\nCumulative Var   0.288   0.489   0.671\n\nTest of the hypothesis that 3 factors are sufficient.\nThe chi square statistic is 20.47 on 7 degrees of freedom.\nThe p-value is 0.00464 \n\nShow the code#图的坐标应该和因子有关系，但是因子为3个的时候，图中有时怎么表达的呢？\nautoplot(d.factanal, data = state.x77, colour = 'Income')# colour为连续值(data、和colour只是纯粹的添加颜色而已)\n\n\n\nShow the codeautoplot(d.factanal, label = TRUE, label.size = 3,\n         loadings = TRUE, loadings.label = TRUE, loadings.label.size  = 3)#把特征向量画出来"
  },
  {
    "objectID": "posts/post/ggfortify1jianjie.html#聚类",
    "href": "posts/post/ggfortify1jianjie.html#聚类",
    "title": "ggfortify包简介",
    "section": "3、聚类",
    "text": "3、聚类\n3.1K-均值聚类—–若是聚类的话（自带类别，会自动画出颜色分类）\n和因子分析、主成分类似\n\nShow the codeautoplot(kmeans(iris[,-5], 3), data = iris)#坐标用的是主成分的坐标\n\n\n\nShow the codeautoplot(kmeans(iris[,-5], 3), data = iris, label = TRUE, label.size = 3)\n\n\n\n\n3.2其他聚类\nggfortify 也支持 cluster::clara, cluster::fanny, cluster::pam。\n其实本包，大多数画图都是采用主成分（不包括因子分析）降维得到两个主成分，在进一步使其主成分为坐标，对应与每个点给出相应的颜色和类别\n\nShow the codelibrary(cluster)\nautoplot(clara(iris[-5], 3))\n\n\n\nShow the codeautoplot(fanny(iris[-5], 3), frame = TRUE)#给定 frame = TRUE，可以把stats::kmeans 和 cluster::* 的每个集群圈出来。\n\n\n\nShow the codeautoplot(pam(iris[-5], 3), frame = TRUE, frame.type = 'norm')#你也可以通过 frame.type 来选择圈的类型。更多选择请参照ggplot2::stat_ellipse里面的frame.type的type关键词。\n\n\n\n\n3.3、lfda(Fisher局部判别分析)\nlfda包支持一系列的Fisher局部判别分析方法，包括半监督lfda，非线性lfda。你也可以使用ggfortify来对他们的结果进行可视化。\n\nShow the codelibrary(lfda)\n# Fisher局部判别分析 (LFDA)\nmodel <- lfda(iris[-5], iris[, 5], 4, metric=\"plain\")\nautoplot(model, data = iris, frame = TRUE, frame.colour = 'Species')#给定 frame = TRUE，可以把 stats::kmeans 和 cluster::* 中的每个类圈出来。\n\n\n\nShow the code# 半监督Fisher局部判别分析 (SELF)\nmodel <- self(iris[-5], iris[, 5], beta = 0.1, r = 3, metric=\"plain\")\nautoplot(model, data = iris, frame = TRUE, frame.colour = 'Species')"
  },
  {
    "objectID": "posts/post/ggfortify1jianjie.html#时间序列的可视化",
    "href": "posts/post/ggfortify1jianjie.html#时间序列的可视化",
    "title": "ggfortify包简介",
    "section": "4、时间序列的可视化",
    "text": "4、时间序列的可视化\n用 ggfortify 使时间序列的可视化变得及其简单。接下来我将给出一些简单的例子。\n\n\nautoplot可支持的R包有：\n\n基本stats:: ts对象\nzoo::zooreg\nxts::xts\ntimeSeries::timSeries\ntseries::irts"
  },
  {
    "objectID": "posts/post/ggfortify1jianjie.html#ts对象",
    "href": "posts/post/ggfortify1jianjie.html#ts对象",
    "title": "ggfortify包简介",
    "section": "4.1、ts对象",
    "text": "4.1、ts对象\n\nShow the codelibrary(ggfortify)\nclass(AirPassengers)#时间序列的对象为ts\n\n[1] \"ts\"\n\nShow the codeAirPassengers\n\n     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n1949 112 118 132 129 121 135 148 148 136 119 104 118\n1950 115 126 141 135 125 149 170 170 158 133 114 140\n1951 145 150 178 163 172 178 199 199 184 162 146 166\n1952 171 180 193 181 183 218 230 242 209 191 172 194\n1953 196 196 236 235 229 243 264 272 237 211 180 201\n1954 204 188 235 227 234 264 302 293 259 229 203 229\n1955 242 233 267 269 270 315 364 347 312 274 237 278\n1956 284 277 317 313 318 374 413 405 355 306 271 306\n1957 315 301 356 348 355 422 465 467 404 347 305 336\n1958 340 318 362 348 363 435 491 505 404 359 310 337\n1959 360 342 406 396 420 472 548 559 463 407 362 405\n1960 417 391 419 461 472 535 622 606 508 461 390 432\n\nShow the codeautoplot(AirPassengers)\n\n\n\nShow the code#可以使用 ts.colour 和 ts.linetype来改变线的颜色和形状。更多的选择请参考 help(autoplot.ts)。\n# 也可以像ggplot函数那样设置样式，比如\nautoplot(AirPassengers, ts.colour = 'red', ts.linetype = 'dashed',xlab = \"时间\",ylab = \"飞机乘客数量\",main= \"飞机乘客人数的变化\")\n\n\n\nShow the code#等价\nautoplot(AirPassengers, ts.colour = 'red', ts.linetype = 'dashed')+xlab(\"时间\")+ylab(\"飞机乘客数量\")+ggtitle( \"飞机乘客人数的变化\")\n\n\n\n\n4.1.1、多变量时间序列\n\nShow the codelibrary(vars)\ndata(Canada)\nclass(Canada)\n\n[1] \"mts\" \"ts\" \n\nShow the codeCanada\n\n               e     prod       rw     U\n1980 Q1 929.6105 405.3665 386.1361  7.53\n1980 Q2 929.8040 404.6398 388.1358  7.70\n1980 Q3 930.3184 403.8149 390.5401  7.47\n1980 Q4 931.4277 404.2158 393.9638  7.27\n1981 Q1 932.6620 405.0467 396.7647  7.37\n1981 Q2 933.5509 404.4167 400.0217  7.13\n1981 Q3 933.5315 402.8191 400.7515  7.40\n1981 Q4 933.0769 401.9773 405.7335  8.33\n1982 Q1 932.1238 402.0897 409.0504  8.83\n1982 Q2 930.6359 401.3067 411.3984 10.43\n1982 Q3 929.0971 401.6302 413.0194 12.20\n1982 Q4 928.5633 401.5638 415.1670 12.77\n1983 Q1 929.0694 402.8157 414.6621 12.43\n1983 Q2 930.2655 403.1421 415.7319 12.23\n1983 Q3 931.6770 403.0786 416.2315 11.70\n1983 Q4 932.1390 403.7188 418.1439 11.20\n1984 Q1 932.2767 404.8668 419.7352 11.27\n1984 Q2 932.8328 405.6362 420.4842 11.47\n1984 Q3 933.7334 405.1363 420.9309 11.30\n1984 Q4 934.1772 406.0246 422.1124 11.17\n1985 Q1 934.5928 406.4123 423.6278 11.00\n1985 Q2 935.6067 406.3009 423.9887 10.63\n1985 Q3 936.5111 406.3354 424.1902 10.27\n1985 Q4 937.4201 406.7737 426.1270 10.20\n1986 Q1 938.4159 405.1525 426.8578  9.67\n1986 Q2 938.9992 404.9298 426.7457  9.60\n1986 Q3 939.2354 404.5765 426.8858  9.60\n1986 Q4 939.6795 404.1995 428.8403  9.50\n1987 Q1 940.2497 405.9499 430.1223  9.50\n1987 Q2 941.4358 405.8221 430.2307  9.03\n1987 Q3 942.2981 406.4463 430.3930  8.70\n1987 Q4 943.5322 407.0512 432.0284  8.13\n1988 Q1 944.3490 407.9460 433.3886  7.87\n1988 Q2 944.8215 408.1796 433.9641  7.67\n1988 Q3 945.0671 408.5998 434.4844  7.80\n1988 Q4 945.8067 409.0906 436.1569  7.73\n1989 Q1 946.8697 408.7042 438.2651  7.57\n1989 Q2 946.8766 408.9803 438.7636  7.57\n1989 Q3 947.2497 408.3287 439.9498  7.33\n1989 Q4 947.6513 407.8857 441.8359  7.57\n1990 Q1 948.1840 407.2605 443.1769  7.63\n1990 Q2 948.3492 406.7752 444.3592  7.60\n1990 Q3 948.0322 406.1794 444.5236  8.17\n1990 Q4 947.1065 405.4398 446.9694  9.20\n1991 Q1 946.0796 403.2800 450.1586 10.17\n1991 Q2 946.1838 403.3649 451.5464 10.33\n1991 Q3 946.2258 403.3807 452.2984 10.40\n1991 Q4 945.9978 404.0032 453.1201 10.37\n1992 Q1 945.5183 404.4774 453.9991 10.60\n1992 Q2 945.3514 404.7868 454.9552 11.00\n1992 Q3 945.2918 405.2710 455.4824 11.40\n1992 Q4 945.4008 405.3830 456.1009 11.73\n1993 Q1 945.9058 405.1564 457.2027 11.07\n1993 Q2 945.9035 406.4700 457.3886 11.67\n1993 Q3 946.3190 406.2293 457.7799 11.47\n1993 Q4 946.5796 406.7265 457.5535 11.30\n1994 Q1 946.7800 408.5785 458.8024 10.97\n1994 Q2 947.6283 409.6767 459.0564 10.63\n1994 Q3 948.6221 410.3858 459.1578 10.10\n1994 Q4 949.3992 410.5395 459.7037  9.67\n1995 Q1 949.9481 410.4453 459.7037  9.53\n1995 Q2 949.7945 410.6256 460.0258  9.47\n1995 Q3 949.9534 410.8672 461.0257  9.50\n1995 Q4 950.2502 411.2359 461.3039  9.27\n1996 Q1 950.5380 410.6637 461.4031  9.50\n1996 Q2 950.7871 410.8085 462.9277  9.43\n1996 Q3 950.8695 412.1160 464.6888  9.70\n1996 Q4 950.9281 412.9994 465.0717  9.90\n1997 Q1 951.8457 412.9551 464.2851  9.43\n1997 Q2 952.6005 412.8241 464.0344  9.30\n1997 Q3 953.5976 413.0489 463.4535  8.87\n1997 Q4 954.1434 413.6110 465.0717  8.77\n1998 Q1 954.5426 413.6048 466.0889  8.60\n1998 Q2 955.2631 412.9684 466.6171  8.33\n1998 Q3 956.0561 412.2659 465.7478  8.17\n1998 Q4 956.7966 412.9106 465.8995  8.03\n1999 Q1 957.3865 413.8294 466.4099  7.90\n1999 Q2 958.0634 414.2242 466.9552  7.87\n1999 Q3 958.7166 415.1678 467.6281  7.53\n1999 Q4 959.4881 415.7016 467.7026  6.93\n2000 Q1 960.3625 416.8674 469.1348  6.80\n2000 Q2 960.7834 417.6104 469.3364  6.70\n2000 Q3 961.0290 418.0030 470.0117  6.93\n2000 Q4 961.7657 417.2667 469.6472  6.87\n\nShow the codeautoplot(Canada)## 需要用到的数据集，包含e、prod、rw和U四个变量，自动把全部变量添加到图中，\n\n\n\nShow the code#也可以指定相应变量，画前面3列\nautoplot(Canada[,-4])\n\n\n\nShow the code#使用 facets = FALSE 可以把所有变量画在一条轴上。\nautoplot(Canada, facets = FALSE)\n\n\n\n\n4.2 xts对象\nlibrary(xts)\nautoplot(as.xts(AirPassengers),ts.colour = 'green')#好像出问题\n4.3 timSeries对象\n\nShow the codelibrary(timeSeries)\nautoplot(as.timeSeries(AirPassengers), ts.colour = ('dodgerblue3'))"
  },
  {
    "objectID": "posts/post/ggfortify1jianjie.html#面板设计",
    "href": "posts/post/ggfortify1jianjie.html#面板设计",
    "title": "ggfortify包简介",
    "section": "5、面板设计",
    "text": "5、面板设计\n\nShow the codelibrary(purrr)\nres <- purrr::map(c(3, 4, 5), ~ kmeans(iris[-5], .))\nautoplot(res, data = iris[-5], ncol = 3)\n\n\n\n\n\nShow the codesessionInfo()\n\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.5.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] purrr_0.3.4         timeSeries_4021.104 timeDate_4021.104  \n [4] vars_1.5-6          lmtest_0.9-40       urca_1.3-0         \n [7] strucchange_1.5-3   sandwich_3.0-2      zoo_1.8-10         \n[10] MASS_7.3-58.1       lfda_1.1.3          cluster_2.1.4      \n[13] ggfortify_0.4.14    ggplot2_3.3.6      \n\nloaded via a namespace (and not attached):\n [1] tidyselect_1.1.2  xfun_0.32         lattice_0.20-45   colorspace_2.0-3 \n [5] vctrs_0.4.1       generics_0.1.3    htmltools_0.5.3   yaml_2.3.5       \n [9] utf8_1.2.2        rlang_1.0.4       pillar_1.8.1      glue_1.6.2       \n[13] withr_2.5.0       DBI_1.1.3         lifecycle_1.0.1   stringr_1.4.1    \n[17] munsell_0.5.0     gtable_0.3.0      htmlwidgets_1.5.4 evaluate_0.16    \n[21] labeling_0.4.2    knitr_1.40        fastmap_1.1.0     fansi_1.0.3      \n[25] rARPACK_0.11-0    Rcpp_1.0.9        scales_1.2.1      jsonlite_1.8.0   \n[29] farver_2.1.1      RSpectra_0.16-1   gridExtra_2.3     digest_0.6.29    \n[33] stringi_1.7.8     dplyr_1.0.9       grid_4.2.1        cli_3.3.0        \n[37] tools_4.2.1       magrittr_2.0.3    tibble_3.1.8      crayon_1.5.1     \n[41] tidyr_1.2.0       pkgconfig_2.0.3   ellipsis_0.3.2    Matrix_1.4-1     \n[45] assertthat_0.2.1  rmarkdown_2.16.1  rstudioapi_0.14   R6_2.5.1         \n[49] nlme_3.1-159      compiler_4.2.1"
  },
  {
    "objectID": "posts/post/function-arguments.html",
    "href": "posts/post/function-arguments.html",
    "title": "R函数参数的有关问题",
    "section": "",
    "text": "2. 匹配参数— match.arg()\n我们经常看见函数中有多个可选的字符串，用来做不同的模型，比如：这里的例子没有意义，但是做法值得注意。\n方法一：\n\nShow the code## 方法一：\ncenter <- function(x, type = c(\"mean\", \"median\", \"trimmed\")) {\n  type <- match.arg(type)\n  switch(type,\n         mean = mean(x),\n         median = median(x),\n         trimmed = mean(x, trim = .1))\n}\ncenter(c(1:4,100),\"mean\") # 返回向量的均值\n#> [1] 22\ncenter(c(1:4,100),\"median\") # 返回向量的中位数\n#> [1] 3\ncenter(c(1:4,100)) # 默认为第一个候选值，\n#> [1] 22\n\n\n方法二：\n\nShow the code## 方法二：\ncenter <- function(x, type) {\n  type <- match.arg(type,choices = c(\"mean\", \"median\", \"trimmed\"))\n  switch(type,\n         mean = mean(x),\n         median = median(x),\n         trimmed = mean(x, trim = .1))\n}\ncenter(c(1:4,100),\"mean\") # 返回向量的均值\n#> [1] 22\ncenter(c(1:4,100),\"median\") # 返回向量的中位数\n#> [1] 3\ntry( center(c(1:4,100)) )# 这里由于没有默认值会报错\n#> Error in match.arg(type, choices = c(\"mean\", \"median\", \"trimmed\")) : \n#>   argument \"type\" is missing, with no default\n\n\nmatch.arg()函数的功能是，根据输入来进行匹配, 比如，上面的式子，我们输入的type是”mean”，然后经过match.arg()以后通过switch可以直接调用该mean函数。\n还可以这样操作，（方法三）\n\nShow the code# 检查一个参数在函数内部是否已被初始化。\n# 对参数进行默认值处理，当然为了更方面也可以直接在函数参数处直接赋予默认值\nh = function(x,y){\n  args = as.list(match.call())\n  if(is.null(args$y)){\n    y = 10\n  }\n  x+y\n}\nh(2)\n#> [1] 12\nh(2,19)\n#> [1] 21\n\n\n类似的还有 match.call() 和match.fun()\n\nShow the code# match.call()创建一个只使用命名参数的调用， 常用于某些指定参数的更新\n# sys.call() 准确地捕获用户的输入。\n\nf <- function(abc = 1, def = 2, ghi = 3){\n  list(s = sys.call(),m = match.call())\n}\nf(d =2,2)\n#> $s\n#> f(d = 2, 2)\n#> \n#> $m\n#> f(abc = 2, def = 2)\n\n\nmatch.fun() 类似下面介绍的get()函数, 都可以把字符串变成我们想要调用的对象。\n3. 以字符串作为函数名 — get函数\n巧妙的利用get函数，把字符串变成我们想要调用的函数，因为get函数输入一个字符串，返回一个函数对象\n\nShow the code# eg： 前面的函数---可以进行对比\ncenter <- function(x, type = c(\"mean\", \"median\", \"trimmed\")) {\n  type <- match.arg(type)\n  f = get(type)\n  f(x)\n}\ncenter(c(1:4,100),\"mean\")\n#> [1] 22\ncenter(c(1:4,100),\"median\")\n#> [1] 3\ncenter(c(1:4,100))\n#> [1] 22\n\n\n\n# eg： 用match.fun  来替代get()\ncenter2 <- function(x, type = c(\"mean\", \"median\", \"trimmed\")) {\n  type <- match.arg(type)\n  f = match.fun(type)\n  f(x)\n}\ncenter2(c(1:4,100),\"mean\")\n#> [1] 22\ncenter2(c(1:4,100),\"median\")\n#> [1] 3\ncenter2(c(1:4,100))\n#> [1] 22\n\n\n两者的区别是get还可以返回某个对象，比如数据框、向量等，而match.fun 只能返回函数类型\n\nShow the codev = 1:10\n# match.fun('v') # 这里会报错\nget('v')\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n\n\nouter <- 1:5\ntry(match.fun(outer, descend = FALSE)) #-> Error:  not a function\n#> function (X, Y, FUN = \"*\", ...) \n#> {\n#>     if (is.array(X)) {\n#>         dX <- dim(X)\n#>         nx <- dimnames(X)\n#>         no.nx <- is.null(nx)\n#>     }\n#>     else {\n#>         dX <- length(X)\n#>         no.nx <- is.null(names(X))\n#>         if (!no.nx) \n#>             nx <- list(names(X))\n#>     }\n#>     if (is.array(Y)) {\n#>         dY <- dim(Y)\n#>         ny <- dimnames(Y)\n#>         no.ny <- is.null(ny)\n#>     }\n#>     else {\n#>         dY <- length(Y)\n#>         no.ny <- is.null(names(Y))\n#>         if (!no.ny) \n#>             ny <- list(names(Y))\n#>     }\n#>     robj <- if (is.character(FUN) && FUN == \"*\") {\n#>         if (!missing(...)) \n#>             stop(\"using ... with FUN = \\\"*\\\" is an error\")\n#>         tcrossprod(as.vector(X), as.vector(Y))\n#>     }\n#>     else {\n#>         FUN <- match.fun(FUN)\n#>         Y <- rep(Y, rep.int(length(X), length(Y)))\n#>         if (length(X)) \n#>             X <- rep(X, times = ceiling(length(Y)/length(X)))\n#>         FUN(X, Y, ...)\n#>     }\n#>     dim(robj) <- c(dX, dY)\n#>     if (!(no.nx && no.ny)) {\n#>         if (no.nx) \n#>             nx <- vector(\"list\", length(dX))\n#>         else if (no.ny) \n#>             ny <- vector(\"list\", length(dY))\n#>         dimnames(robj) <- c(nx, ny)\n#>     }\n#>     robj\n#> }\n#> <bytecode: 0x13ec60550>\n#> <environment: namespace:base>\nmatch.fun(outer) # finds it anyway，由于outer是R内部的函数，只不过现在被覆盖了，但是还是能找到\n#> function (X, Y, FUN = \"*\", ...) \n#> {\n#>     if (is.array(X)) {\n#>         dX <- dim(X)\n#>         nx <- dimnames(X)\n#>         no.nx <- is.null(nx)\n#>     }\n#>     else {\n#>         dX <- length(X)\n#>         no.nx <- is.null(names(X))\n#>         if (!no.nx) \n#>             nx <- list(names(X))\n#>     }\n#>     if (is.array(Y)) {\n#>         dY <- dim(Y)\n#>         ny <- dimnames(Y)\n#>         no.ny <- is.null(ny)\n#>     }\n#>     else {\n#>         dY <- length(Y)\n#>         no.ny <- is.null(names(Y))\n#>         if (!no.ny) \n#>             ny <- list(names(Y))\n#>     }\n#>     robj <- if (is.character(FUN) && FUN == \"*\") {\n#>         if (!missing(...)) \n#>             stop(\"using ... with FUN = \\\"*\\\" is an error\")\n#>         tcrossprod(as.vector(X), as.vector(Y))\n#>     }\n#>     else {\n#>         FUN <- match.fun(FUN)\n#>         Y <- rep(Y, rep.int(length(X), length(Y)))\n#>         if (length(X)) \n#>             X <- rep(X, times = ceiling(length(Y)/length(X)))\n#>         FUN(X, Y, ...)\n#>     }\n#>     dim(robj) <- c(dX, dY)\n#>     if (!(no.nx && no.ny)) {\n#>         if (no.nx) \n#>             nx <- vector(\"list\", length(dX))\n#>         else if (no.ny) \n#>             ny <- vector(\"list\", length(dY))\n#>         dimnames(robj) <- c(nx, ny)\n#>     }\n#>     robj\n#> }\n#> <bytecode: 0x13ec60550>\n#> <environment: namespace:base>\nmatch.fun(\"outer\")\n#> function (X, Y, FUN = \"*\", ...) \n#> {\n#>     if (is.array(X)) {\n#>         dX <- dim(X)\n#>         nx <- dimnames(X)\n#>         no.nx <- is.null(nx)\n#>     }\n#>     else {\n#>         dX <- length(X)\n#>         no.nx <- is.null(names(X))\n#>         if (!no.nx) \n#>             nx <- list(names(X))\n#>     }\n#>     if (is.array(Y)) {\n#>         dY <- dim(Y)\n#>         ny <- dimnames(Y)\n#>         no.ny <- is.null(ny)\n#>     }\n#>     else {\n#>         dY <- length(Y)\n#>         no.ny <- is.null(names(Y))\n#>         if (!no.ny) \n#>             ny <- list(names(Y))\n#>     }\n#>     robj <- if (is.character(FUN) && FUN == \"*\") {\n#>         if (!missing(...)) \n#>             stop(\"using ... with FUN = \\\"*\\\" is an error\")\n#>         tcrossprod(as.vector(X), as.vector(Y))\n#>     }\n#>     else {\n#>         FUN <- match.fun(FUN)\n#>         Y <- rep(Y, rep.int(length(X), length(Y)))\n#>         if (length(X)) \n#>             X <- rep(X, times = ceiling(length(Y)/length(X)))\n#>         FUN(X, Y, ...)\n#>     }\n#>     dim(robj) <- c(dX, dY)\n#>     if (!(no.nx && no.ny)) {\n#>         if (no.nx) \n#>             nx <- vector(\"list\", length(dX))\n#>         else if (no.ny) \n#>             ny <- vector(\"list\", length(dY))\n#>         dimnames(robj) <- c(nx, ny)\n#>     }\n#>     robj\n#> }\n#> <bytecode: 0x13ec60550>\n#> <environment: namespace:base>\n\n\n4. 以字符串作为函数名 — call()函数\ncall函数，可以直接通过字符串的形式调用某个函数(只要环境空间中存在)，\n\nShow the codeget(\"rnorm\")(5,mean = 300)\n#> [1] 298.8218 299.9723 299.8310 299.4821 300.4309\n\neval( call('rnorm',5,mean=300) ) # 执行函数调用，本质上call是创建一个函数调用，最后通过eval进行执行\n#> [1] 299.6504 299.7716 298.8720 301.2693 302.0457\n\ncall_1 = quote(rnorm(5,mean = 3))\ncall_2 = call(\"rnorm\",5,mean = 3)\ncall_3 = as.call( list(quote(rnorm),5,mean = 3) )\n# 这里call_1,call_2,call_3 完全等价，是一个表达式。需要进一步执行表达式需要利用eval来执行。\n\n\n5. 把函数参数(不带字符串参数)转变为字符串\ndeparse(substitute(函数参数))\n\nShow the codenicePlot = function(X,Y,...){\n  xlabel = deparse(substitute(X)) # 捕获X的输入\n  ylabel = deparse(substitute(Y)) # 捕获Y的输入\n  \n  plot(X,Y,type ='o',xlab = xlabel,ylab = ylabel,main = paste(xlabel,ylabel,sep = '--'), ...)\n}\n\nDate = 1:7\nSales = c(100,120,150,130,160,210,120)\nnicePlot(Date,Sales,col='red')\n\n\n\n\n\nShow the codesessionInfo()\n#> R version 4.2.1 (2022-06-23)\n#> Platform: aarch64-apple-darwin20 (64-bit)\n#> Running under: macOS Monterey 12.5.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n#> \n#> locale:\n#> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] digest_0.6.29     jsonlite_1.8.0    magrittr_2.0.3    evaluate_0.16    \n#>  [5] rlang_1.0.4       stringi_1.7.8     cli_3.3.0         rstudioapi_0.14  \n#>  [9] rmarkdown_2.16.1  tools_4.2.1       stringr_1.4.1     htmlwidgets_1.5.4\n#> [13] xfun_0.32         yaml_2.3.5        fastmap_1.1.0     compiler_4.2.1   \n#> [17] htmltools_0.5.3   knitr_1.40"
  },
  {
    "objectID": "posts/post/R金融分析与VaR.html",
    "href": "posts/post/R金融分析与VaR.html",
    "title": "R金融分析以及VaR",
    "section": "",
    "text": "这是一份很久以前一份作业报告."
  },
  {
    "objectID": "posts/post/R金融分析与VaR.html#第一题",
    "href": "posts/post/R金融分析与VaR.html#第一题",
    "title": "R金融分析以及VaR",
    "section": "第一题",
    "text": "第一题\n加载工具包\n\nShow the code#加载工具包\nlibrary(plyr)\nlibrary(quantmod)\nlibrary(TTR)\nlibrary(ggplot2)\nlibrary(scales)\nlibrary(stringr)\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(dygraphs)\nlibrary(RColorBrewer)\nlibrary(ggfortify)\nlibrary(dplyr)\n\n\n输入要研究的股票数据代码\n\nShow the code\n#######################################\n####输入要研究的股票数据代码#####\n######################################\n## 中国银行 601988.SS\n##  中国建设银行 601939.SS\n##  农行   601288.SS\n## 浦发银行 600000.SS\n## 民生银行  600016.SS\n#下载数据\ntitle<-\"浦发银行\" #股票名字作为图片标题 ,\nstock<- \"600000.SS\"  # 股票的代码 \nsDate<-\"2015-1-1\" #开始日期\neDate<-\"2018-10-01\" #结束日期\n\n\n下载数据并保存到本地\n\nShow the code\n## 上面的参数 eval=FALSE 代码这代码块不执行\ndownload<-function(stock,from=sDate,to=eDate){\n      df<-getSymbols(stock,from=from,to=to,env=environment(),auto.assign=FALSE)  #下载数据\n      names(df)<-c(\"Open\",\"High\",\"Low\",\"Close\",\"Volume\",\"Adjusted\")\n      write.zoo(df,file=paste(stock,\".csv\",sep=\"\"),sep=\",\",quote=FALSE) #保存到本地\n}\n\n\n\ndownload(stock) # 这个是从网上下载数据，如果只研究一只股票，建议运行第一次以后，进行注释改代码\n\n\n读取本地股票数据\n\nShow the code#本地读数据\nread<-function(stock){\n  as.xts(read.csv.zoo(file=paste(stock,\".csv\",sep=\"\"),header = TRUE,sep=\",\", format=\"%Y-%m-%d\"))\n}\n\n\ndata <- read(stock)\ncdata = data$Close\n\n\n删除该文件\n\nShow the code file.remove(paste0(stock,\".csv\")) # 删除存储的文件\n\n\n计算日、月、年、收益率（按收盘价） 并保存数据\n\nShow the codedaily_return=dailyReturn(cdata) # 日收益率\nmonthly_return = monthlyReturn(cdata) # 月收益率\nyearly_return = yearlyReturn(cdata)  # 年收益率\n\n# #保存股票的日收益率\n# write.zoo(daily_return,paste0(stock,\"_daily_return.csv\"),\n#           quote = FALSE, sep = \",\") \n\n# #保存股票的月收益率\n# write.zoo(monthly_return,paste0(stock,\"_monthly_return.csv\"),\n#           quote = FALSE, sep = \",\")    \n\n\n# #保存股票的日收益率\n# write.zoo(yearly_return,paste0(stock,\"_yearly_return.csv\"),\n#           quote = FALSE, sep = \",\")    \n\n      \n\n\n计算 日收益率的均值 和波动率\n\nShow the code\nsprintf(paste(stock,\"日收益率的均值: %f\"),mean(daily_return)) # 日收益率的均值\n#> [1] \"600000.SS 日收益率的均值: 0.000085\"\n\nsprintf(paste(stock,\"日收益率的波动率: %f\"),sd(daily_return)) #   # 日收益率的波动率  \n#> [1] \"600000.SS 日收益率的波动率: 0.017104\"\n\n\n计算移动平均值(5,10,20,60期移动平均值) 并保存数据\n\nShow the code#移动平均\nma<-function(cdata,mas=c(5,10,20,60)){ \n     ldata<-cdata\n     for(m in mas){\n         ldata<-merge(ldata,SMA(cdata,m))\n     }\n    #      ldata<-na.locf(ldata, fromLast=TRUE) #是否把NA进行均值填充\n     names(ldata)<-c('Value',paste('ma',mas,sep=''))\n     return(ldata)\n }\n\nldata = ma(cdata , c(5,10,20,30,60))  # 股票的 5 ，10 ，20 ，60 期移动平均值\n\n# # 保存股票的 5 ，10 ，20 ，60 期移动平均值\n# write.zoo(ldata,paste0(stock,\"_\",title,\"_ma.csv\"),quote = FALSE, sep = \",\")\n\n\n画出收盘价与5 期 30 期移动平均线\n\nShow the code\nldata = ma(cdata, c(5,30)) \ndygraph(ldata)%>%   dyOptions(colors = c(\"red\",\"blue\", \"green\")) %>% \n  dySeries(names(ldata)[2], strokeWidth = 2, strokePattern = \"dashed\") %>% \n    dySeries(names(ldata)[3], strokeWidth = 2, strokePattern = \"dashed\") %>% \n      dyRangeSelector()\n\n\n\n\n\n寻找金叉死叉，即买卖点\n\nShow the codema_lag_data=function(ldata){\n    SMA5 = embed (ldata[,2],2)  # 5期均线\n    colnames(SMA5)= c(\"sam5\",\"lagsma5\")\n    \n    SMA30 = embed (ldata[,3],2) # 30期均线\n    colnames(SMA30) = c(\"sma30\",\"lagsma30\")\n    # 合并长期短期的sma\n    smaLS=cbind(SMA5,SMA30)\n    \n    ## 转换为时间序列格式\n    smaLS = xts(smaLS,order.by = index(ldata[,2][-1]))\n    smaLS = na.omit(smaLS)\n    return(smaLS)\n}\n\nsmaLS = ma_lag_data(ldata)\n\n\n保存买卖点\n\nShow the code\n## 构造捕捉向上突破点函数\nUpcross<-function(x){\n  ifelse(x[2]<x[4] & x[1]>x[3], 1, 0)\n}\n\n## 构造捕捉向下突破点函数\nDowncross<-function(x){\n  ifelse(x[2]>x[4] & x[1]<x[3], -1, 0)\n}\n\n\n# 捕捉短线 向上突破长线日期\nUpsig<-apply(smaLS,1,Upcross)\nUpsig<-xts(Upsig,order.by=index(smaLS))\nnames(Upsig)<-\"Upsig\"\n\n# 捕捉短线 向上突破长线，释放买入信号，进行买入操作\nUpBuy = lag.xts(Upsig) # 判断成功以后 要过后1期进行购买\n\n## 查看所有买入点\nUpBuy[UpBuy==1]\n#>            Upsig\n#> 2015-03-16     1\n#> 2015-05-27     1\n#> 2015-06-05     1\n#> 2015-09-09     1\n#> 2015-12-23     1\n#> 2016-02-16     1\n#> 2016-04-07     1\n#> 2016-04-20     1\n#> 2016-05-31     1\n#> 2016-07-28     1\n#> 2016-08-01     1\n#> 2016-11-10     1\n#> 2017-01-23     1\n#> 2017-05-25     1\n#> 2017-07-13     1\n#> 2017-09-07     1\n#> 2017-11-23     1\n#> 2018-01-12     1\n#> 2018-07-25     1\n\n## 捕捉短线向下突破 长线日期\n\nDownsig<-apply(smaLS,1,Downcross)\nDownsig<-xts(Downsig,order.by=index(smaLS))\nnames(Downsig)<-\"Downsig\"\n\n## 短线向上突破 长线，释放卖出信号，进行卖出操作\nDownSell<-lag.xts(Downsig) # 判断成功以后 要过后1期进行购买\n## 查看所有卖出点\nDownSell[DownSell==-1]\n#>            Downsig\n#> 2015-05-11      -1\n#> 2015-06-04      -1\n#> 2015-06-24      -1\n#> 2015-12-18      -1\n#> 2015-12-31      -1\n#> 2016-03-15      -1\n#> 2016-04-08      -1\n#> 2016-05-11      -1\n#> 2016-06-27      -1\n#> 2016-07-29      -1\n#> 2016-10-18      -1\n#> 2016-12-20      -1\n#> 2017-03-02      -1\n#> 2017-07-07      -1\n#> 2017-08-09      -1\n#> 2017-10-27      -1\n#> 2017-12-15      -1\n#> 2018-02-14      -1\ndim(DownSell)\n#> [1] 885   1\ndim(UpBuy)\n#> [1] 885   1\n\n\n## 买卖数据点 1为买入，-1 为卖出  0 持有点\nBSdata=DownSell+UpBuy\nnames(BSdata)=\"BS\"\n\n# 保存买卖数据点 \n# write.zoo(BSdata,paste0(stock,\"_\",title,\"_买卖点.csv\"),quote = FALSE, sep = \",\")\n\n\n在图上画出买卖点，并表示标签，买入(B),卖出(S),\n\nShow the codeUpBuy1 = UpBuy[UpBuy==1]  # ## 查看所有买入点\nDownSell1 = DownSell[DownSell==-1]## 查看所有卖出点\n\ndrow_plot_2ma = function(ldata,upbuytime,upbuylabel=\"B\",downselltime,downselllabel=\"S\",ptitle=title){\n  ### ldata字段包含\"Value\"(收盘价) \"ma5\"(移动平均)   \"ma20\" \n         plot1= dygraph(ldata,main = ptitle)%>%  \n           dyOptions(colors = c(\"red\",\"blue\", \"green\"),gridLineColor = \"lightblue\") %>% \n            dyAxis(\"x\", drawGrid = FALSE) %>%\n              dyAxis(\"y\", label = \"price(价格)\") %>% \n                  dySeries(names(ldata)[2], strokeWidth = 2, strokePattern = \"dashed\") %>%  \n                        dySeries(names(ldata)[3], strokeWidth = 2, strokePattern = \"dashed\") %>% \n                        dyRangeSelector()\n         \n         \n           for(i in upbuytime){\n             plot1 = plot1 %>%  dyAnnotation(i, text = upbuylabel, tooltip = \"Korea\")\n           }\n         \n           for(j in downselltime){\n             plot1 = plot1 %>%  dyAnnotation(j, text = downselllabel, tooltip = \"Vietnam\")\n           }\n\n  plot1\n}\n\n\ndrow_plot_2ma(ldata = ldata,\n              upbuytime = as.character(index(UpBuy1)),\n              downselltime = as.character(index(DownSell1))\n              )\n\n\n\n\n\n画出所用的均线5,10,30,60 图 以及 收盘价 以及 2均线形成（5,30）的金叉死叉\n\nShow the codeldata = ma(cdata, c(5,10,30,60)) \n\ndrow_plot_ma = function(ldata,upbuytime,upbuylabel=\"B\",downselltime,downselllabel=\"S\",ptitle=title){\n  ### ldata字段包含\"Value\"(收盘价) \"ma5\"(移动平均)   \"ma20\" \n         plot1= dygraph(ldata,main = ptitle)%>%  \n                    dyOptions(colors = RColorBrewer::brewer.pal( length(names(ldata)), \"Set2\")) %>% \n                      dySeries(names(ldata)[1], strokeWidth = 2) %>% \n                       dyAxis(\"x\", drawGrid = FALSE) %>%\n                         dyAxis(\"y\", label = \"price(价格)\") %>% \n                            dyRangeSelector()\n         \n         for( i in names(ldata)[2:length(names(ldata))]){\n              plot1 = plot1 %>% dySeries(i, strokeWidth = 1, strokePattern = \"dashed\")\n         }\n         \n           for(i in upbuytime){\n             plot1 = plot1 %>%  dyAnnotation(i, text = upbuylabel, tooltip = \"Korea\")\n           }\n         \n           for(j in downselltime){\n             plot1 = plot1 %>%  dyAnnotation(j, text = downselllabel, tooltip = \"Vietnam\")\n           }\n\n  plot1\n}\n\n\ndrow_plot_ma(ldata = ldata,upbuytime = as.character(index(UpBuy1)),downselltime = as.character(index(DownSell1)))\n\n\n\n\n\n\nShow the code\nlibrary(ggplot2)\n## 用ggplot2 画线图 首先对ldata数据进行整合\nlibrary(ggfortify)\n\n\n\n## 快速画图\n\n\n\nldata = ma(cdata, c(5,30)) \n\n\ndrow_ggplot2_ma=function(ldata,upbuytime,upbuylabel=\"B\",downselltime,downselllabel=\"S\",ptitle=title){\n          plot2 = autoplot.zoo(ldata,facet = NULL) + labs(title=title, x=\"time\", y=\"price\")+theme(plot.title = element_text(hjust = 0.5))\n           for(i in upbuytime){\n             plot2 =plot2+ annotate(\"text\", x=as.Date(i), y=as.numeric(ldata[i]$Value), label=upbuylabel)\n           }\n         \n           for(j in downselltime){\n             plot2=plot2+ annotate(\"text\", x=as.Date(j), y=as.numeric(ldata[j]$Value), label=downselllabel)\n           }\n   plot2\n}\n\ndrow_ggplot2_ma(ldata = ldata,upbuytime = as.character(index(UpBuy1)),downselltime = as.character(index(DownSell1)))\n\n\n\nShow the code\n\n\nldata = ma(cdata, c(5,10,30,60)) \ndrow_ggplot2_ma(ldata = ldata,upbuytime = as.character(index(UpBuy1)),downselltime = as.character(index(DownSell1)))"
  },
  {
    "objectID": "posts/post/R金融分析与VaR.html#第二题-var",
    "href": "posts/post/R金融分析与VaR.html#第二题-var",
    "title": "R金融分析以及VaR",
    "section": "第二题 –VaR",
    "text": "第二题 –VaR\n\nShow the code#加载工具包\nrm(list = ls())\nlibrary(plyr)\nlibrary(quantmod)\nlibrary(TTR)\nlibrary(ggplot2)\nlibrary(scales)\nlibrary(stringr)\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(dygraphs)\nlibrary(RColorBrewer)\nlibrary(PerformanceAnalytics)\n\n\n输入要研究的股票数据代码\n\nShow the code\n#######################################\n####输入要研究的股票数据代码#####\n######################################\n## 中国银行 601988.SS\n##  中国建设银行 601939.SS\n##  农行   601288.SS\n## 浦发银行 600000.SS\n## 民生银行  600016.SS\n#下载数据\ntitle<-\"浦发银行\" #图片标题\nstock<-\"600000.SS\"  # 中国银行的代码 \nsDate<-\"2015-1-1\" #开始日期\neDate<-\"2017-12-31\" #结束日期\n\n\n下载数据并保存到本地\n\nShow the code\n## 上面的参数 eval=FALSE 代码这代码块不执行\ndownload<-function(stock,from=sDate,to=eDate){\n      df<-getSymbols(stock,from=from,to=to,env=environment(),auto.assign=FALSE)  #下载数据\n      names(df)<-c(\"Open\",\"High\",\"Low\",\"Close\",\"Volume\",\"Adjusted\")\n      write.zoo(df,file=paste(stock,\".csv\",sep=\"\"),sep=\",\",quote=FALSE) #保存到本地\n}\n\n\ndownload(stock) # 这个是从网上下载数据，如果只研究一只股票，建议运行第一次以后，进行注释改代码\n\n\n读入数据\n\nShow the code\n\nread<-function(stock){as.xts(read.zoo(file=paste(stock,\".csv\",sep=\"\"),header = TRUE,sep=\",\", format=\"%Y-%m-%d\"))}\n\ndata <- read(stock)\ncdata = data$Close\n\n\n删除该文件\n\nShow the code file.remove(paste0(stock,\".csv\")) # 删除存储的文件\n\n\n计算VaR–历史模拟法\n\nShow the code\n\ndaily_return=dailyReturn(cdata)[-1] #cdata为收盘价，计算日收益率\ndaily_return_VaR =apply(embed(daily_return,90), 1, function(x)VaR(x,p=0.95,method = \"historical\")) %>% xts(.,order.by = index(daily_return[-c(1:89)]))\n\nvardata = cbind(daily_return,daily_return_VaR)\nnames(vardata) =c(\"dreturn\",\"d.re.var\")\n### 画出VaR时序图\ndygraph(vardata,main = \"日收益率与VaR\") %>% dyRangeSelector() %>%  dyAxis(\"y\", label = \"日收益率\") %>% dyAxis(\"x\", label = \"时间\")\n\n\n\n\nShow the codevardata1= na.omit(vardata)\n\n\n### 计算每只股票最近3年内跌幅超过VaR预测阈值的次数\nVaR_count=(vardata1[,1]<vardata1[,2]) %>% sum()\nsprintf(\"收益率超过VaR阈值的次数: %d,3年一共有%d有效天,占%f\",VaR_count, dim(vardata1)[1],VaR_count/dim(vardata1)[1])\n#> [1] \"收益率超过VaR阈值的次数: 44,3年一共有825有效天,占0.053333\"\n\n\n计算VaR–韦伯法\n\nShow the codelibrary(quantmod)\n\nddd=xdata=getSymbols('600000.SS',auto.assign = F)\ncdata<-data.frame(coredata(xdata))\n\nnames(cdata)<-c('open','high','low','close','volume','adjprice')\ncdata$date<-as.Date(.indexDate(xdata))\nn<-nrow(cdata)\ncdata$re=NA\ncdata$re[2:n]<-(cdata$close[2:n]-cdata$close[1:(n-1)])/cdata$close[1:(n-1)]## 计算日收益率\n\ncdata=dplyr::filter(cdata,is.na(cdata$re)==F) #去除na值\nn<-nrow(cdata) #提取\n\nm<-sum(cdata$date>\"2015-01-01\") # 大于某个日期的天数\n\nxdate<-cdata$date[cdata$date>\"2015-01-01\"] # 提前大于某个日期的天数 \nVaR<-rep(NA,m)\nqVaR<-rep(NA,m)\nzVaR<-rep(NA,m)\nwVaR<-rep(NA,m)\nd1=0\nd2=0\nd3=0\nd4=0\nalpha=0.05\nfor(i in 1:m){\n  RE<-cdata$re[(n-m-252+i):(n-m+i-1)]\n  SRE<-sort(RE)\n  VaR[i]<--(SRE[trunc(252*alpha)]+SRE[trunc(252*alpha)+1])/2\n  qVaR[i]<--quantile(RE,0.05)\n  zVaR[i]<--qnorm(alpha,mean(RE),sd(RE))\n  ERE<-exp(RE)\n  fn<-function(par0){\n    k<-par0[1]\n    lambda<-par0[2]\n    kk=0\n    for(j in 1:252){\n      x=ERE[j]\n      kk=kk+\n        log((k/lambda)*((x/lambda)^(k-1))*exp(-(x/lambda)^k))  \n    }\n    return(kk)\n  }\n  xml <- optim(c(1,1),fn,method='BFGS',control=list(fnscale=-1))\n  k   <- xml$par[1]\n  lambda <- xml$par[2]\n  wVaR[i] <- -log(qweibull(alpha,k,lambda))\n  dre = cdata$re[n-m+i]\n  \n  if(dre < -VaR[i]){d1=d1+1}\n  if(dre < -qVaR[i]){d2=d2+1}\n  if(dre < -zVaR[i]){d3=d3+1}\n  if(dre < -wVaR[i]){d4=d4+1}\n}\nctv<-qbinom(0.05,m,alpha)\nVR=data.frame(xdate,VaR,qVaR,zVaR,wVaR)\n# plot(xdate,zVaR,type='l',col='blue')\n# lines(xdate,VaR)\n\nrequire(ggplot2)\nVR1=data.frame(date=xdate,VAR=VaR,gr=rep('HIS',m))\nVR2=data.frame(date=xdate,VAR=qVaR,gr=rep('qHIS',m))\nVR3=data.frame(date=xdate,VAR=zVaR,gr=rep('Norm',m))\nVR4=data.frame(date=xdate,VAR=wVaR,gr=rep('Weibull',m))\n\n# xaa=rbind(VR1,VR2,VR3,VR4)\n# \n# ggplot(xaa,aes(x=date,y=VAR,group=gr,color=gr))+geom_line(size=0.8)\n# \n\n\n\nShow the code\n\n\nVR44 = cbind(VR4,re=cdata[cdata$date>\"2015-01-01\",]$re)\nggplot(VR44,aes(x=date,y=re,color=\"red\"))+geom_line(size=0.8)+\n  geom_line(aes(x=date,y=-VAR,color=\"blue\")) #VaR应该是损失，把日收益率引入\n\n\n\nShow the code\n### 计算每只股票最近3年内跌幅超过VaR预测阈值的次数\nVaR_count=(VR44$re<(-VR44$VAR)) %>% sum()\nsprintf(\"收益率超过VaR阈值的次数: %d,\",VaR_count)\n#> [1] \"收益率超过VaR阈值的次数: 12,\"\n\n\n\nShow the codesessionInfo()\n#> R version 4.2.1 (2022-06-23)\n#> Platform: aarch64-apple-darwin20 (64-bit)\n#> Running under: macOS Monterey 12.5.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n#> \n#> locale:\n#> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> other attached packages:\n#>  [1] PerformanceAnalytics_2.0.4 ggfortify_0.4.14          \n#>  [3] RColorBrewer_1.1-3         dygraphs_1.1.1.6          \n#>  [5] lubridate_1.8.0            dplyr_1.0.9               \n#>  [7] stringr_1.4.1              scales_1.2.1              \n#>  [9] ggplot2_3.3.6              quantmod_0.4.20           \n#> [11] TTR_0.24.3                 xts_0.12.1                \n#> [13] zoo_1.8-10                 plyr_1.8.7                \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] tidyselect_1.1.2  xfun_0.32         purrr_0.3.4       lattice_0.20-45  \n#>  [5] colorspace_2.0-3  vctrs_0.4.1       generics_0.1.3    htmltools_0.5.3  \n#>  [9] yaml_2.3.5        utf8_1.2.2        rlang_1.0.4       pillar_1.8.1     \n#> [13] glue_1.6.2        withr_2.5.0       DBI_1.1.3         lifecycle_1.0.1  \n#> [17] munsell_0.5.0     gtable_0.3.0      htmlwidgets_1.5.4 evaluate_0.16    \n#> [21] labeling_0.4.2    knitr_1.40        fastmap_1.1.0     curl_4.3.2       \n#> [25] fansi_1.0.3       Rcpp_1.0.9        jsonlite_1.8.0    farver_2.1.1     \n#> [29] gridExtra_2.3     digest_0.6.29     stringi_1.7.8     grid_4.2.1       \n#> [33] quadprog_1.5-8    cli_3.3.0         tools_4.2.1       magrittr_2.0.3   \n#> [37] tibble_3.1.8      crayon_1.5.1      tidyr_1.2.0       pkgconfig_2.0.3  \n#> [41] assertthat_0.2.1  rmarkdown_2.16.1  rstudioapi_0.14   R6_2.5.1         \n#> [45] compiler_4.2.1"
  },
  {
    "objectID": "posts/post/相关图之ggplot扩展.html",
    "href": "posts/post/相关图之ggplot扩展.html",
    "title": "相关图之ggplot系列扩展1",
    "section": "",
    "text": "由于corrplot包画图存在一些问题，比如图像不美观，以及title显示不出，等等\n于是有了ggplot2 的扩展系列\nggcorrplot包 专门画相关系数矩阵图： https://github.com/kassambara/ggcorrplot\nGGally 包： 对ggplot2进行了更多的扩展，其中包括相关系数图： http://ggobi.github.io/ggally/index.html#alterations"
  },
  {
    "objectID": "posts/post/相关图之ggplot扩展.html#ggcorrplot包",
    "href": "posts/post/相关图之ggplot扩展.html#ggcorrplot包",
    "title": "相关图之ggplot系列扩展1",
    "section": "ggcorrplot包",
    "text": "ggcorrplot包\n\nShow the codelibrary(ggcorrplot)\nlibrary(purrr)\ndata(mtcars)\ncorr <- round(cor(mtcars), 1)# 相关系数矩阵\ncorr %>% head()\n\n# Compute a matrix of correlation p-values\np.mat <- cor_pmat(mtcars) # 计算矩阵之间的相关性p—值\np.mat %>% head()\n\n## 相关矩阵可视化\n#ggcorrplot(corr)# #method默认为square\nggcorrplot(corr, method = \"circle\")\n\n\n\n## 重新排序相关矩阵\n#### 使用分层聚类\nggcorrplot(corr, hc.order = TRUE, outline.col = \"white\")\n\n## 相关图布局的类型\nggcorrplot(corr, hc.order = TRUE, type = \"lower\",outline.col = \"white\")#下三角矩阵图\nggcorrplot(corr, hc.order = TRUE, type = \"upper\",outline.col = \"white\")#上三角矩阵图\n\n## 更改颜色以及主题\n####  colors参数\nggcorrplot(corr, hc.order = TRUE, type = \"lower\",\n   outline.col = \"white\",\n   ggtheme = ggplot2::theme_gray,\n   colors = c(\"#6D9EC1\", \"white\", \"#E46726\"))\n\n## 添加相关系数\n#### 设置参数lab = TRUE\nggcorrplot(corr, hc.order = TRUE, type = \"lower\",lab = TRUE)#添加相关系数, 设置参数lab = TRUE\n\n## 增加显著性水平，不显著的话就不添加了\n#### 设置参数p.mat\nggcorrplot(corr, hc.order = TRUE,type = \"lower\", p.mat = p.mat) # 增加显著性水平,设置参数p.mat\nggcorrplot(corr, p.mat = p.mat, hc.order=TRUE, type = \"lower\", insig = \"blank\")# 将不显著的色块设置成空白\n\n## 可以添加标题，像ggplot2那样添加标题， 这样好看一些\nggcorrplot(corr)+ggtitle(\"mtcars的相关矩阵图\")+ theme(plot.title = element_text(hjust = 0.5))"
  },
  {
    "objectID": "posts/post/相关图之ggplot扩展.html#ggally包",
    "href": "posts/post/相关图之ggplot扩展.html#ggally包",
    "title": "相关图之ggplot系列扩展1",
    "section": "GGally包",
    "text": "GGally包\n介绍\n该包的ggcorr函数是一个可视化函数，用于将相关矩阵绘制为ggplot2对象。它的灵感来自Stack Overflow问题。\n解释\n相关矩阵显示了相对大量的连续变量之间的相关系数。然而，虽然R提供了一种通过cor函数创建这种矩阵的简单方法，但它没有为该函数创建的矩阵提供绘图方法。\n该ggcorr功能提供了这样的绘图方法，使用ggplot2包中实现的“图形语法” 来渲染绘图。在实践中，其结果在图形上接近corrplot功能的结果，这是优秀arm包装的一部分。\n安装\ninstall.packages(\"GGally\")\n# 或者\nsource(\"https://raw.githubusercontent.com/briatte/ggcorr/master/ggcorr.R\")\n依赖\n主要的包依赖ggcorr是ggplot2用于绘图构造的包。\n\nShow the codelibrary(ggplot2)\n\n\n该ggplot2软件包可以从被安装CRAN通过install.packages。这样做也将安装reshape2包，内部ggcorr用于数据操作。\n\nShow the codelibrary(GGally)\nggcorr(mtcars)\n\n\n\nShow the codeggcorr(iris) # ggcorr会自动挑选数值型变量进行画图,它还产生一个警告，指示数据集的一列不包含数字数据，因此从相关矩阵中删除。从传递给的数据集中删除列可以避免警告， eg: ggcorr(iris[,-5])\n#> Warning in ggcorr(iris): data in column(s) 'Species' are not numeric and were\n#> ignored\n\n\n\n\n注意：当与连续色标一起使用时，ggcorr当前也会产生与色彩插值相关的警告。这是一个无害的警告，应该在未来的更新ggplot2和scales包中消失。此警告隐藏在此小插图的其余部分中。\n\nShow the codeggcorr(mtcars)# 默认接受数据框，矩阵\n\n\n\n\n\nShow the code##  可接受相关系数矩阵\n## ggcorr支持cor函数提供的所有相关方法。参考cor()函数:\n## cor(x, y = NULL, use = \"everything\",method = c(\"pearson\", \"kendall\", \"spearman\"))\nggcorr(data = NULL, cor_matrix = cor(mtcars, use = \"everything\"))\n\n\n\n\n控制图例的颜色块\n默认图例颜色是连续的，\n若要把图例颜色分类(离散),则添加nbreaks=n参数,把相关系数从-1到+1分为nbreaks=nn等分，如下：\n\nShow the code## ggplot独立图像的分面 --devtools::install_github(\"thomasp85/patchwork\")\nlibrary(patchwork)\np1 = ggcorr(mtcars, nbreaks = 5)\n\n\n## 对色阶(图例)的控制, name控制图例的标题,legend.size控制图例文本大小,legend.position控制图例显示位置\n## 后面两个参数是ggplot2中的参数，由于绘图是一个ggplot2对象，所有其他相关theme和guides方法也适用\np2 = ggcorr(mtcars, name = expression(rho), legend.position = \"bottom\", legend.size = 12) +\n        guides(fill = guide_colorbar(barwidth = 18, title.vjust = 0.75)) +\n            theme(legend.title = element_text(size = 14))\np1 + p2\n\n\n\n\n控制调色板\nggcorr默认颜色从亮红色到浅灰色到亮蓝色.可以通过被修改low,mid和high参数,其类似于那些的scale_gradient2\n\nShow the codep1 = ggcorr(mtcars)\np2 = ggcorr(mtcars, low = \"steelblue\", mid = \"white\", high = \"darkred\")\n\np1 + p2\n\n\n\n\n控制图像的形状\n默认情况下，ggcorr使用颜色方块来表示相关系数的强度，与热图表示观察计数的方式类似。\nggcorr也可以用圆圈表示相关性的大小。设置geom=\"circle\"即可\n\nShow the codeggcorr(mtcars, geom = \"circle\", nbreaks = 5)# 可以通过min_size和max_size参数设置圆的大小\n\n\n\n\n控制系数标签\nggcorr通过设置label=TRUE，可以在相关矩阵之上显示相关系数：\n\nShow the codep1 = ggcorr(mtcars, label = TRUE) \n\np2 = ggcorr(mtcars, nbreaks = 4, palette = \"RdGy\", label = TRUE, label_size = 3, label_color = \"white\",label_round=1)# 在label_color和label_size参数允许样式系数标签，label_round设置系数标签中显示的位数，label_alpha=TRUE 设置标签的透明度，则透明度水平将像相关系数一样变化\n\np3 = ggcorr(mtcars, label = TRUE, label_size = 3, label_round = 2, label_alpha = TRUE)\n\np1 + p2 + p3  # patchwork包能把独立的两个图形画在一张面板上\n\n\n\n\n控制变量标签（即变量名称的显示问题）\n在上面的几个例子中，变量标签的渲染（在相关矩阵的对角线上示出）不一定是最佳的。要修改这些标签的方面，用户所要做的就是将所有支持的参数geom_text直接传递给ggcorr。下面的示例显示了如何在将标签向左移动并更改颜色时减小标签的大小：\n相关矩阵中的变量标签可能出现的一个问题是它们太长而无法在图的左下方完整显示。下面通过使用MIN变量启动相关矩阵来说明此问题，该变量似乎在图的最左下角略微修剪：\n\nShow the codeggcorr(mtcars, hjust = 0.75, size = 5, color = \"grey50\")\n\n\n\n\n要解决此问题，ggcorr可以通过layout.exp参数向绘图的水平轴添加一些空白。将任何数值传递给此参数将在图的左侧添加一个或多个“不可见的图块”，这可以帮助显示具有长名称的变量：\n\nShow the codeggcorr(mtcars, hjust = 0.75, size = 5, color = \"grey50\", layout.exp = 1)"
  },
  {
    "objectID": "posts/post/相关图之ggplot扩展.html#其他控制",
    "href": "posts/post/相关图之ggplot扩展.html#其他控制",
    "title": "相关图之ggplot系列扩展1",
    "section": "其他控制",
    "text": "其他控制\n剪切相关比例\n设置相关系数的样式\n如果设置geom=\"text\"，则它将相关系数表示为它们的（有色）值：\n\nShow the codeggcorr(mtcars, geom = \"text\", nbreaks = 5, palette = \"RdYlBu\", hjust = 1)\n\n\n\n\n控制内部值\n由于ggcorr生成ggplot2对象，因此了解如何构造对象以从中获取更具体的图可能很有用。每个ggcorr对象都包含以下data对象：\n\nShow the codehead(ggcorr(mtcars)$data, 5)\n#>      x   y coefficient label\n#> 2  cyl mpg  -0.8521620  -0.9\n#> 3 disp mpg  -0.8475514  -0.8\n#> 4   hp mpg  -0.7761684  -0.8\n#> 5 drat mpg   0.6811719   0.7\n#> 6   wt mpg  -0.8676594  -0.9\n\n\n于是可以使用不同颜色来区分负系数和正系数：\n\nShow the codeggcorr(mtcars, geom = \"blank\", label = TRUE, hjust = 0.75) +\n  geom_point(size = 10, aes(color = coefficient > 0, alpha = abs(coefficient) > 0.5)) +\n  scale_alpha_manual(values = c(\"TRUE\" = 0.25, \"FALSE\" = 0)) +\n  guides(color = \"none\", alpha = \"none\")"
  },
  {
    "objectID": "posts/post/相关图之ggplot扩展.html#参考",
    "href": "posts/post/相关图之ggplot扩展.html#参考",
    "title": "相关图之ggplot系列扩展1",
    "section": "参考",
    "text": "参考\n参考： https://briatte.github.io/ggcorr/\n\nShow the codesessionInfo()\n#> R version 4.2.1 (2022-06-23)\n#> Platform: aarch64-apple-darwin20 (64-bit)\n#> Running under: macOS Monterey 12.5.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n#> \n#> locale:\n#> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> other attached packages:\n#> [1] patchwork_1.1.2 GGally_2.1.2    ggplot2_3.3.6  \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] Rcpp_1.0.9         plyr_1.8.7         RColorBrewer_1.1-3 pillar_1.8.1      \n#>  [5] compiler_4.2.1     tools_4.2.1        digest_0.6.29      jsonlite_1.8.0    \n#>  [9] evaluate_0.16      lifecycle_1.0.1    tibble_3.1.8       gtable_0.3.0      \n#> [13] pkgconfig_2.0.3    rlang_1.0.4        cli_3.3.0          DBI_1.1.3         \n#> [17] rstudioapi_0.14    yaml_2.3.5         xfun_0.32          fastmap_1.1.0     \n#> [21] withr_2.5.0        stringr_1.4.1      dplyr_1.0.9        knitr_1.40        \n#> [25] generics_0.1.3     htmlwidgets_1.5.4  vctrs_0.4.1        grid_4.2.1        \n#> [29] tidyselect_1.1.2   reshape_0.8.9      glue_1.6.2         R6_2.5.1          \n#> [33] fansi_1.0.3        rmarkdown_2.16.1   farver_2.1.1       purrr_0.3.4       \n#> [37] magrittr_2.0.3     scales_1.2.1       htmltools_0.5.3    assertthat_0.2.1  \n#> [41] colorspace_2.0-3   labeling_0.4.2     utf8_1.2.2         stringi_1.7.8     \n#> [45] munsell_0.5.0"
  },
  {
    "objectID": "posts/uncertain/2019-02-26-4-1基于可能度的多属性决策方法.html",
    "href": "posts/uncertain/2019-02-26-4-1基于可能度的多属性决策方法.html",
    "title": "4.1 基于可能度的多属性决策方法",
    "section": "",
    "text": "Show the code#####  第四章--属性权重为实数且属性值为区间数的多属性决策方法及应用\n## 4.1 基于可能度的多属性决策方法---徐泽水《不确定多属性决策方法与应用》109页 \n## 4.1.4 实例分析\n\n#####  第一步： 求出规范化矩阵\nA = c(0.214,0.220,0.166,0.178,0.184,0.190,\n      0.206,0.225,0.220,0.229,0.182,0.191,\n      0.195,0.204,0.192,0.198,0.220,0.231,\n      0.181,0.190,0.195,0.205,0.185,0.195,\n      0.175,0.184,0.193,0.201,0.201,0.211) \nR = matrix(A,nrow = 5,byrow = T) # R为规范化后的决策矩阵\nR # 矩阵R的奇数列代表属性的下界 ，偶数列代表属性的上界\n#>       [,1]  [,2]  [,3]  [,4]  [,5]  [,6]\n#> [1,] 0.214 0.220 0.166 0.178 0.184 0.190\n#> [2,] 0.206 0.225 0.220 0.229 0.182 0.191\n#> [3,] 0.195 0.204 0.192 0.198 0.220 0.231\n#> [4,] 0.181 0.190 0.195 0.205 0.185 0.195\n#> [5,] 0.175 0.184 0.193 0.201 0.201 0.211\n\n#####  第二步：通过规范化的决策矩阵和指定的权重（利用WAA算子）求出个方案的综合属性值\nzongheshuxin_z = function(R,w){\n  # zongheshuxin_z 函数，输入参数为规范化后的决策矩阵R，以及属性权重值w向量，\n  # 返回一个n*2的矩阵，代表输出各个方案的综合属性值得区间数，第一列为下界，第二列为上界，行代表个方案\n  stopifnot( length(w) == (ncol(R)/2) ) #检验输入的权重长度与决策矩阵的属性个数是否相等\n  col_L = seq(1, ncol(R)-1, by = 2) # 属性的下界\n  col_U = seq(2, ncol(R), by = 2)# 属性的上界  \n  z_L = apply(R[,col_L],1,function(x)sum(x*w))\n  z_U = apply(R[,col_U],1,function(x)sum(x*w))\n  z = matrix(c(z_L,z_U), ncol= 2 )\n  return(z)\n}\nw = c(0.4,0.4, 0.2) # 指定属性的权重\nZ = zongheshuxin_z(R,w) # 返回一个n*2的矩阵，每一行代表输出各个方案的综合属性值得区间数\n \n##### 第三步，利用区间数两两比较，得出可能度矩阵\nprobability_matrix = function(Z){\n  #probability_matrix函数输入一个n*2的矩阵，每一行代表输出各个方案的综合属性值得区间数\n  # 此函数输出各方案两两比较的可能度矩阵。\n  \n  #degree_probability函数求两个区间数的可能度，\n  # a，b代表输入的区间数，输入这两个 \n  degree_probability = function(a,b){\n    stopifnot(length(a) == length(b) ,length(b)==2)\n    stopifnot(a[1] <= a[2], b[1] <= b[2])\n    l_a = a[2] - a[1];l_b = b[2]- b[1];\n    p = min(l_a + l_b, max(a[2]-b[1],0) ) / (l_a + l_b)\n    return(p)\n  } \n  \n  P = matrix(0, ncol = nrow(Z),nrow = nrow(Z))\n  for (i in 1:nrow(Z)) {\n    for(j in 1:nrow(Z)){\n      P[i,j] = degree_probability(Z[i,],Z[j,])\n    }\n  }\n  return(P)\n}\nP = probability_matrix(Z)\n\n##### 第四步。根据可能度矩阵，利用4.6式求出可能度矩阵的排序向量,值越大越好\nprobability_matrix_oder_v = function(P){\n  v = rep(0,nrow(P))\n  n = nrow(P)\n  for(i in 1:nrow(P)){\n    v[i] =  ( 1 / (n*(n-1)) ) * ( sum(P[i,]) + n/2 -1)\n  }\n  return(v)\n}\n\nprobability_matrix_oder_v(P)\n#> [1] 0.1557106 0.2995283 0.2504717 0.1488647 0.1454247\nlibrary(magrittr)\nprobability_matrix_oder_v(P) %>% rank() %>% order(.,decreasing = T)\n#> [1] 2 3 1 4 5\n# 故方案2综合评估结果最好"
  },
  {
    "objectID": "posts/uncertain/2019-02-26-1-6基于信息熵的多属性决策方法.html",
    "href": "posts/uncertain/2019-02-26-1-6基于信息熵的多属性决策方法.html",
    "title": "1.6 基于信息熵的多属性决策方法",
    "section": "",
    "text": "代码##  1.6 基于信息熵的多属性决策方法---徐泽水《不确定多属性决策方法与应用》26页 --1.62 实例分析\n\nlibrary(data.table)\nlibrary(dplyr)\nA = c(2,1.5,2,5.5,5,9,\n      2.5,2.7,1.8,6.5,3,5,\n      1.8,2,2.1,4.5,7,7,\n      2.2,1.8,2,5,5,5)\nA= matrix(A,nrow = 4,ncol = 6,byrow = T) %&gt;% data.table()\nA # 原始决策矩阵\n#&gt;     V1  V2  V3  V4 V5 V6\n#&gt; 1: 2.0 1.5 2.0 5.5  5  9\n#&gt; 2: 2.5 2.7 1.8 6.5  3  5\n#&gt; 3: 1.8 2.0 2.1 4.5  7  7\n#&gt; 4: 2.2 1.8 2.0 5.0  5  5\n\n\n\n代码#######################################################\n##### 第一步把原始决策矩阵A 利用适当的方法进行规范化为R，R为归一化后的矩阵\n##########################################################\n### norm_matrix()函数，根据书中收益型属性（按公式1.2）与成本型属性(按公式1.4)分别进行归一化\n# 参数A表示决策矩阵,shouyi参数代表收益型属性，输入收益型属性在决策矩阵中第几列，若有多列，用数值型向量即可，\n# chengben参数代表成本型属性，与收益型属性类型。\n# 该参数可任选其一输入，也可同时指定。\nnorm_matrix = function(A,shouyi=NULL,chengben=NULL){\n  if(is.matrix(A))A = data.table(A)\n  stopifnot(!is.null(shouyi) | !is.null(chengben))\n  m = ncol(A)\n  if(is.null(chengben)) chengben =setdiff(1:m,shouyi) \n  if(is.null(shouyi)) shouyi = setdiff(1:m,chengben)\n  stopifnot(length(intersect(shouyi,chengben))==0,setequal(union(shouyi,chengben),1:m))\n  #对决策矩阵进行重命名\n  names(A)=paste0('V',1:m)\n  shouyi = paste0(\"V\",shouyi)\n  chengben = paste0(\"V\",chengben)\n  R = A\n  R[,':='(c(shouyi),lapply(.SD, function(x)x/max(x))),.SDcols =shouyi] # 收益型属性归一化 （书中1.2式）\n  R[,':='(c(chengben),lapply(.SD,function(x)min(x)/x)),.SDcol = chengben]# 成本型属性归一化 （书中1.3式）\n  R = as.data.frame(R)\n  return(R)\n}\n\nR = norm_matrix(A,chengben = 4)\nround(R,3)\n#&gt;     V1    V2    V3    V4    V5    V6\n#&gt; 1 0.80 0.556 0.952 0.818 0.714 1.000\n#&gt; 2 1.00 1.000 0.857 0.692 0.429 0.556\n#&gt; 3 0.72 0.741 1.000 1.000 1.000 0.778\n#&gt; 4 0.88 0.667 0.952 0.900 0.714 0.556\n\n\n\n代码#########################################################\n##### 第二步 计算矩阵R，得到列归一化矩阵R'\n#################################################\nR_t = sapply(R, function(x)x/sum(x))\nround(R_t,3)\n#&gt;         V1    V2    V3    V4   V5    V6\n#&gt; [1,] 0.235 0.188 0.253 0.240 0.25 0.346\n#&gt; [2,] 0.294 0.338 0.228 0.203 0.15 0.192\n#&gt; [3,] 0.212 0.250 0.266 0.293 0.35 0.269\n#&gt; [4,] 0.259 0.225 0.253 0.264 0.25 0.192\n#########################################################\n##### 第三步 根据R_t计算属性u_j的信息熵\n#################################################\nentropy = function(R_t){\n  if(!is.data.frame(R_t)) R_t = as.data.frame(R_t)\n  n = nrow(R_t)\n  E = sapply(R_t, function(x) (-1/log(n)) * sum( ifelse(x == 0 , 0 , x*log(x) ) ) )\n  return(E)\n}\nE = entropy(R_t)\nE\n#&gt;        V1        V2        V3        V4        V5        V6 \n#&gt; 0.9946889 0.9829482 0.9988876 0.9936177 0.9703227 0.9771412\n#########################################################\n##### 第四步 根据信息熵计算权重向量\n#################################################\nw = (1-E)/sum(1-E)\nround(w,3)\n#&gt;    V1    V2    V3    V4    V5    V6 \n#&gt; 0.064 0.207 0.014 0.077 0.360 0.277\n#########################################################\n##### 第五步 根据权重向量按照1.12式计算每一个方案的综合属性值Z\n#################################################\nz = t(as.matrix(R) %*% as.matrix(w,ncol=1)) %&gt;% as.data.frame() # 计算综合属性值\nround(z,4)\n#&gt;       V1     V2     V3     V4\n#&gt; 1 0.7775 0.6451 0.8666 0.6887\n#########################################################\n##### 第六步 根据综合属性值Z对方案进行排序\n#################################################\n#rank(z) #输出排序\nsort(rank(z),decreasing = T)\n#&gt; V3 V1 V4 V2 \n#&gt;  4  3  2  1"
  },
  {
    "objectID": "posts/uncertain/2019-02-26-1-5基于离差最大化.html",
    "href": "posts/uncertain/2019-02-26-1-5基于离差最大化.html",
    "title": "1.5.2离差最大化的多属性决策方法",
    "section": "",
    "text": "Show the code#####  1.5.2离差最大化的多属性决策方法---徐泽水《不确定多属性决策方法与应用》24页 --1.52 实例分析\nlibrary(data.table)\nlibrary(dplyr)\nA= c(12,11.5,780,175,22,2.43,\n     12,14.6,898,165,33.5,2.83,\n     10.3,13.5,741,181,22.7,3,\n     12,15.24,1038,204,47.3,4,\n     11.4,12.19,833.4,180,19,5.9,\n     9,12.8,667,170,19.8,3.8,\n     12.2,13.37,991,170,59,3.3,\n     12,14.3,1048,230,37.2,1.9,\n     9,6.25,287,105,5,3.6,\n     10.33,15,927,167,52.6,3.14)\nA= matrix(A,nrow = 10,ncol = 6,byrow = T) %>% data.table()\nA # 原始决策矩阵 ， 也称决策矩阵\n#>        V1    V2     V3  V4   V5   V6\n#>  1: 12.00 11.50  780.0 175 22.0 2.43\n#>  2: 12.00 14.60  898.0 165 33.5 2.83\n#>  3: 10.30 13.50  741.0 181 22.7 3.00\n#>  4: 12.00 15.24 1038.0 204 47.3 4.00\n#>  5: 11.40 12.19  833.4 180 19.0 5.90\n#>  6:  9.00 12.80  667.0 170 19.8 3.80\n#>  7: 12.20 13.37  991.0 170 59.0 3.30\n#>  8: 12.00 14.30 1048.0 230 37.2 1.90\n#>  9:  9.00  6.25  287.0 105  5.0 3.60\n#> 10: 10.33 15.00  927.0 167 52.6 3.14\n\n\n\nShow the code#######################################################\n##### 第一步把原始决策矩阵A 利用适当的方法进行规范化为R，R为归一化后的矩阵\n##########################################################\n### norm_matrix()函数，根据书中收益型属性（按公式1.2）与成本型属性(按公式1.4)分别进行归一化\n# 参数A表示决策矩阵,shouyi参数代表收益型属性，输入收益型属性在决策矩阵中第几列，若有多列，用数值型向量即可，\n# chengben参数代表成本型属性，与收益型属性类型。\n# 该参数可任选其一输入，也可同时指定。\nnorm_matrix = function(A,shouyi=NULL,chengben=NULL){\n  if(is.matrix(A))A = data.table(A)\n  stopifnot(!is.null(shouyi) | !is.null(chengben))\n  m = ncol(A)\n  if(is.null(chengben)) chengben =setdiff(1:m,shouyi) \n  if(is.null(shouyi)) shouyi = setdiff(1:m,chengben)\n  stopifnot(length(intersect(shouyi,chengben))==0,setequal(union(shouyi,chengben),1:m))\n  #对决策矩阵进行重命名\n  names(A)=paste0('V',1:m)\n  shouyi = paste0(\"V\",shouyi)\n  chengben = paste0(\"V\",chengben)\n  R = A\n  R[,':='(c(shouyi),lapply(.SD, function(x)x/max(x))),.SDcols =shouyi] # 收益型属性归一化 （书中1.2式）\n  R[,':='(c(chengben),lapply(.SD,function(x)min(x)/x)),.SDcols = chengben]# 成本型属性归一化 （书中1.3式）\n  R = as.data.frame(R)\n  return(R)\n}\n\nR = norm_matrix(A,chengben = 4)\nround(R,3)\n#>       V1    V2    V3    V4    V5    V6\n#> 1  0.984 0.755 0.744 0.600 0.373 0.412\n#> 2  0.984 0.958 0.857 0.636 0.568 0.480\n#> 3  0.844 0.886 0.707 0.580 0.385 0.508\n#> 4  0.984 1.000 0.990 0.515 0.802 0.678\n#> 5  0.934 0.800 0.795 0.583 0.322 1.000\n#> 6  0.738 0.840 0.636 0.618 0.336 0.644\n#> 7  1.000 0.877 0.946 0.618 1.000 0.559\n#> 8  0.984 0.938 1.000 0.457 0.631 0.322\n#> 9  0.738 0.410 0.274 1.000 0.085 0.610\n#> 10 0.847 0.984 0.885 0.629 0.892 0.532\n\n\n\nShow the code#########################################################\n##### 第二步 根据1.13式计算最优权重向量\n#################################################\n# max_licha此函数输入规范化矩阵，通过离差最大化计算方法，输出最优权重向量\nmax_licha= function(R){\n  if(is.data.table(R))R = setDF(R)\n  V=matrix(0,nrow = nrow(R),ncol = ncol(R))\n  for(i in 1:nrow(R)){\n    for(j in 1:ncol(R)){\n      V[i,j] = sum(abs(R[i,j] - R[,j] )) \n    }\n  }\n  w = colSums(V)/sum(colSums(V))# 最优权重向量\n  return(w)\n}\n\nw = max_licha(R)\nround(w,3)\n#> [1] 0.096 0.147 0.195 0.112 0.284 0.167\n\n\n\nShow the code#########################################################\n##### 第三步 根据权重向量按照1.12式计算每一个方案的综合属性值Z\n#################################################\nz = t(as.matrix(R) %*% as.matrix(w,ncol=1)) %>% as.data.frame() # 计算综合属性值\nround(z,4)\n#>       V1     V2     V3     V4     V5     V6     V7     V8     V9    V10\n#> 1 0.5918 0.7143 0.6077 0.8324 0.6855 0.5898 0.8552 0.7108 0.4218 0.8102\n#########################################################\n##### 第四步 根据综合属性值Z对方案进行排序\n#################################################\n#rank(z) #输出排序\nsort(rank(z),decreasing = T)\n#>  V7  V4 V10  V2  V8  V5  V3  V1  V6  V9 \n#>  10   9   8   7   6   5   4   3   2   1"
  },
  {
    "objectID": "posts/uncertain/2019-02-26-3-2基于方案满意度的多属性决策方法.html",
    "href": "posts/uncertain/2019-02-26-3-2基于方案满意度的多属性决策方法.html",
    "title": "3.2 基于方案满意度的多属性决策方法",
    "section": "",
    "text": "Show the code##  3.2 基于方案满意度的多属性决策方法---徐泽水《不确定多属性决策方法与应用》81页 --3.2.2 实例分析\nlibrary(data.table)\nlibrary(dplyr)\nA = c(47177, 16.61, 8.89, 31.05, 15.77,\n      43323, 9.08, 3.65, 29.80, 8.44,\n      59023, 13.84, 6.06, 26.55, 12.87,\n      46821, 10.59, 3.51, 22.46, 7.41,\n      41646, 13.24, 4.64, 24.33, 9.33,\n      26446, 10.16, 2.38, 26.80, 9.85,\n      38381, 11.97, 4.79, 26.45, 10.64,\n      57808, 10.29, 4.54, 23.00, 9.23,\n      28869, 7.68, 2.12, 31.08, 9.05,\n      38812, 8.92, 3.38, 25.68, 8.73,\n      30721, 10.87, 4.15, 30.36, 11.44,\n      24848, 10.77,2.42, 30.71, 11.37,\n      26925, 9.34, 3.06, 30.11, 10.84,\n      23269, 8.25, 2.58, 32.57, 8.62,\n      28267, 8.13, 3.17, 29.25, 9.17,\n      21583, 7.14, 4.66, 35.35, 11.27)\n\nA= matrix(A,nrow = 16,ncol = 5,byrow = T) %>% data.table()\nA # 原始决策矩阵\n#>        V1    V2   V3    V4    V5\n#>  1: 47177 16.61 8.89 31.05 15.77\n#>  2: 43323  9.08 3.65 29.80  8.44\n#>  3: 59023 13.84 6.06 26.55 12.87\n#>  4: 46821 10.59 3.51 22.46  7.41\n#>  5: 41646 13.24 4.64 24.33  9.33\n#>  6: 26446 10.16 2.38 26.80  9.85\n#>  7: 38381 11.97 4.79 26.45 10.64\n#>  8: 57808 10.29 4.54 23.00  9.23\n#>  9: 28869  7.68 2.12 31.08  9.05\n#> 10: 38812  8.92 3.38 25.68  8.73\n#> 11: 30721 10.87 4.15 30.36 11.44\n#> 12: 24848 10.77 2.42 30.71 11.37\n#> 13: 26925  9.34 3.06 30.11 10.84\n#> 14: 23269  8.25 2.58 32.57  8.62\n#> 15: 28267  8.13 3.17 29.25  9.17\n#> 16: 21583  7.14 4.66 35.35 11.27\n\n\n\n\nShow the code#### 第一步: 把原始决策矩阵A 利用适当的方法进行规范化为R，R为归一化后的矩阵\n### norm_matrix()函数，根据书中收益型属性（按公式1.2）与成本型属性(按公式1.4)分别进行归一化\n#####  注意这个与前面的norm_matrix函数(即下面norm_matrix2)结果相同，只是代码显得更少了,保证了列名不变\nnorm_matrix = function(A, shouyi = NULL, chengben = NULL) {\n  stopifnot(!is.null(shouyi) | !is.null(chengben))\n  if (is.matrix(A)) A = data.table(A)\n  m = ncol(A)\n  if (is.null(chengben)) chengben = setdiff(1:m, shouyi)\n  if (is.null(shouyi)) shouyi = setdiff(1:m, chengben)\n  # 如果输入的shouyi与chengben向量交集不为空，且并集不是全集，则算法出错\n  stopifnot(length(intersect(shouyi, chengben)) == 0, setequal(union(shouyi, chengben), 1:m))\n  R =copy(A) # 重新赋值\n  if (length(chengben) == 0) {\n    R[, colnames(R)[shouyi] := lapply(.SD, function(x) x / max(x)), .SDcols = shouyi] # 收益型属性归一化 （书中1.2式）\n  } else if (length(shouyi) == 0) {\n    R[, colnames(R)[chengben] := lapply(.SD, function(x) min(x) / x  ), .SDcols = chengben]# 成本型属性归一化 （书中1.3式）\n  } else{\n    R[, colnames(R)[shouyi] := lapply(.SD, function(x) x / max(x)), .SDcols = shouyi] # 收益型属性归一化 （书中1.2式）\n    R[, colnames(R)[chengben] := lapply(.SD, function(x) min(x) / x  ), .SDcols = chengben]# 成本型属性归一化 （书中1.3式）\n  }\n  return(setDF(R))\n}\n\n\n\nShow the codenorm_matrix2 = function(A,shouyi=NULL,chengben=NULL){\n  if(is.matrix(A))A = data.table(A)\n  stopifnot(!is.null(shouyi) | !is.null(chengben))\n  m = ncol(A)\n  if(is.null(chengben)) chengben =setdiff(1:m,shouyi) \n  if(is.null(shouyi)) shouyi = setdiff(1:m,chengben)\n  stopifnot(length(intersect(shouyi,chengben))==0,setequal(union(shouyi,chengben),1:m))\n  \n  if( length(chengben) == 0 ){\n    # 对决策矩阵进行重命名\n    colnames(A)=paste0('V',1:m)\n    shouyi = paste0(\"V\",shouyi)\n    R = A    \n    # 归一化\n    R[,':='(c(shouyi),lapply(.SD, function(x)x/max(x))),.SDcols =shouyi] # 收益型属性归一化 （书中1.2式）\n  }else if( length(shouyi) == 0 ){\n    #对决策矩阵进行重命名\n    names(A)=paste0('V',1:m)\n    chengben = paste0(\"V\",chengben)\n    R = A\n    # 归一化\n    R[,':='(c(chengben),lapply(.SD,function(x)min(x)/x)),.SDcol = chengben]# 成本型属性归一化 （书中1.3式）\n  }else{\n    #对决策矩阵进行重命名\n    names(A)=paste0('V',1:m)\n    shouyi = paste0(\"V\",shouyi)\n    chengben = paste0(\"V\",chengben)\n    R = A\n    # 归一化\n    R[,':='(c(shouyi),lapply(.SD, function(x)x/max(x))),.SDcols =shouyi] # 收益型属性归一化 （书中1.2式）\n    R[,':='(c(chengben),lapply(.SD,function(x)min(x)/x)),.SDcol = chengben]# 成本型属性归一化 （书中1.3式）    \n  }\n  R = as.data.frame(R)\n  return(R)\n}\n\n\n\nShow the codeR = norm_matrix(A, chengben = 4)\nround(R,3)\n#>       V1    V2    V3    V4    V5\n#> 1  0.799 1.000 1.000 0.723 1.000\n#> 2  0.734 0.547 0.411 0.754 0.535\n#> 3  1.000 0.833 0.682 0.846 0.816\n#> 4  0.793 0.638 0.395 1.000 0.470\n#> 5  0.706 0.797 0.522 0.923 0.592\n#> 6  0.448 0.612 0.268 0.838 0.625\n#> 7  0.650 0.721 0.539 0.849 0.675\n#> 8  0.979 0.620 0.511 0.977 0.585\n#> 9  0.489 0.462 0.238 0.723 0.574\n#> 10 0.658 0.537 0.380 0.875 0.554\n#> 11 0.520 0.654 0.467 0.740 0.725\n#> 12 0.421 0.648 0.272 0.731 0.721\n#> 13 0.456 0.562 0.344 0.746 0.687\n#> 14 0.394 0.497 0.290 0.690 0.547\n#> 15 0.479 0.489 0.357 0.768 0.581\n#> 16 0.366 0.430 0.524 0.635 0.715\n\n\n\n\nShow the code###### 第二步 ： 求出综合属性正理想值z_max,以及综合属性负理想值z_min\nM_zonghe_position = function(R,lower_c,upper_c){\n   #综合属性正理想值z_max\n    library(Rglpk)\n    n = nrow(R)\n    m = ncol(R)\n    ## 约束条件，权和向量为1 \n    mat = matrix(rep(1,m),nrow = 1) \n    dir = c(\"==\")\n    rhs = c(1)\n    ## \n    types = c(\"C\") # 表示解为实数\n    bounds <- list(lower = list(ind = 1L:m, val = lower_c),\n                   upper = list(ind = 1L:m, val = upper_c))\n    ###  下面 max_obj 函数中的xx为R矩阵的某一行\n    max_obj = function(xx) Rglpk_solve_LP(xx, mat, dir, rhs, bounds, types,max = TRUE)$optimum\n    return(apply(R, 1, max_obj))\n}\nz_max = M_zonghe_position(R,lower_c = c(0.22,0.18,0.15,0.23,0.16),upper_c = c(0.24,0.20,0.17,0.26,0.17))\nround(z_max,3)\n#>  [1] 0.890 0.623 0.851 0.706 0.735 0.585 0.703 0.777 0.522 0.633 0.631 0.576\n#> [13] 0.575 0.502 0.555 0.534\n\n\n## 求出综合属性负理想值\nM_zonghe_negative = function(R,lower_c,upper_c){\n  #综合属性负理想值z_min\n  if(is.data.table(R)) R = as.data.frame(R)\n  library(Rglpk)\n  n = nrow(R)\n  m = ncol(R)\n  ## 约束条件，权和向量为1 \n  mat = matrix(rep(1,m),nrow = 1) \n  dir = c(\"==\")\n  rhs = c(1)\n  ## \n  types = c(\"C\") # 表示解为实数\n  bounds <- list(lower = list(ind = 1L:m, val = lower_c),\n                 upper = list(ind = 1L:m, val = upper_c))\n  ###  下面 max_obj 函数中的xx为R矩阵的某一行\n  min_obj = function(xx) Rglpk_solve_LP(xx, mat, dir, rhs, bounds, types)$optimum\n  return(apply(R, 1, min_obj))\n}\nz_min = M_zonghe_negative(R,lower_c = c(0.22,0.18,0.15,0.23,0.16),upper_c = c(0.24,0.20,0.17,0.26,0.17))\nz_min\n#>  [1] 0.8799025 0.6122816 0.8442960 0.6869648 0.7224206 0.5680731 0.6945892\n#>  [8] 0.7600534 0.5084315 0.6185512 0.6213819 0.5605654 0.5620055 0.4893540\n#> [15] 0.5430971 0.5233214\n\n\n\n\nShow the code#####  第三步： 求出各方按的满意度，PW 矩阵的每一行为对应方案的满意度矩阵，\n# 把满意度矩阵的每一行乘以对应属性的权重，则为该方案的满意度，但此时属性权重未知\n# 通过建立线性目标函数，求解出属性权重\nPW = matrix(0,ncol = ncol(R),nrow = nrow(R))\nfor(i in 1:nrow(R)){\n  for(j in 1:ncol(R)){\n    PW[i,j] = (R[i,j] - z_min[i])/(z_max[i] - z_min[i])\n  }\n}\nPW\n#>             [,1]        [,2]         [,3]        [,4]       [,5]\n#>  [1,]  -7.820666 11.65256149  11.65256149 -15.1896961  11.652561\n#>  [2,]  11.145778 -6.00900673 -18.47012741  12.9486991  -7.058863\n#>  [3,]  22.923509 -1.62874601 -23.94335797   0.2436666  -4.150187\n#>  [4,]   5.606157 -2.60510136 -15.40681623  16.5088261 -11.448630\n#>  [5,]  -1.373481  6.09491123 -16.36028397  16.3793613 -10.672955\n#>  [6,]  -7.029567  2.55423994 -17.59326739  15.8143586   3.311256\n#>  [7,]  -4.979815  2.92839875 -17.50474858  17.3674915  -2.235035\n#>  [8,]  13.013027 -8.33758206 -14.79304717  12.8414038 -10.367462\n#>  [9,]  -1.441419 -3.43690273 -20.14420736  15.9848337   4.883279\n#> [10,]   2.696916 -5.63428706 -16.47249835  17.6965044  -4.490027\n#> [11,] -10.399110  3.40588154 -15.93163587  12.2046922  10.724431\n#> [12,]  -9.130713  5.74617525 -18.86296457  11.1727327  10.494447\n#> [13,]  -7.990561  0.02312869 -16.44500376  13.8874395   9.466552\n#> [14,]  -7.630903  0.58843249 -15.97617926  16.0642115   4.593201\n#> [15,]  -5.286466 -4.41756470 -15.36276214  18.5132509   3.161791\n#> [16,] -15.310838 -9.07672150   0.08382542  10.8811429  18.581452\n\n### 通过满意度矩阵，求出属性权重\nM_w = function(R,lower_c,upper_c){\n  library(Rglpk)\n  n = nrow(R)\n  m = ncol(R)\n  obj = c(apply(R, 2, sum)) # 设置目标函数\n  mat = matrix(rep(1,m),nrow = 1) # 约束条件，权和向量为1 \n  dir = c(\"==\")\n  rhs = c(1)\n  types = c(\"C\")\n  bounds <- list(lower = list(ind = 1L:m, val = lower_c),\n                 upper = list(ind = 1L:m, val = upper_c))\n  return(Rglpk_solve_LP(obj, mat, dir, rhs, bounds, types,max =TRUE )$solution)\n}\nw = M_w(PW,lower_c = c(0.22,0.18,0.15,0.23,0.16),upper_c = c(0.24,0.20,0.17,0.26,0.17))\nw # 权重\n#> [1] 0.22 0.20 0.15 0.26 0.17\n### 通过权重确定方案综合指标值\nz = apply(R, 1, function(x)sum(x*w))\nz\n#>  [1] 0.8839165 0.6193408 0.8475817 0.7011357 0.7335354 0.5851453 0.7034886\n#>  [8] 0.7693701 0.5212981 0.6306097 0.6310837 0.5758520 0.5752496 0.5018189\n#> [15] 0.5552379 0.5317315\n\n\n##第四步，#按降序排列，最大的为方案最优\n\nShow the code#########第四步，#按降序排列，最大的为方案最优\n\nround(z,4)%>% rank %>% order(.,decreasing=T)#按降序排列，最大的为最优\n#>  [1]  1  3  8  5  7  4 11 10  2  6 12 13 15 16  9 14"
  },
  {
    "objectID": "posts/uncertain/2019-02-25不确定多属性方法徐泽水pdf.html",
    "href": "posts/uncertain/2019-02-25不确定多属性方法徐泽水pdf.html",
    "title": "不确定多属性决策方法徐泽水pdf",
    "section": "",
    "text": "https://cdn.jsdelivr.net/gh/zscmmm/imgs2208save@master/img/xuzeshui不确定多属性决策方法及应用_徐泽水.pdf"
  },
  {
    "objectID": "posts/uncertain/2019-02-26-3-1基于理想点的多属性决策方法.html",
    "href": "posts/uncertain/2019-02-26-3-1基于理想点的多属性决策方法.html",
    "title": "3.1 基于理想点的多属性决策方法",
    "section": "",
    "text": "Show the code##  3.1 基于理想点的多属性决策方法---徐泽水《不确定多属性决策方法与应用》78页 --3.1.2 实例分析\n\nlibrary(data.table)\nlibrary(dplyr)\nA = c(0.37,1800,2,19,90,\n      0.58,2800,5,28,105,\n      0.52,3500,5,32,130,\n      0.43,1900,3,27,98)\n      \nA= matrix(A,nrow = 4,ncol = 5,byrow = T) %>% data.table()\nA # 原始决策矩阵\n#>      V1   V2 V3 V4  V5\n#> 1: 0.37 1800  2 19  90\n#> 2: 0.58 2800  5 28 105\n#> 3: 0.52 3500  5 32 130\n#> 4: 0.43 1900  3 27  98\n\n####################################################### ##############################\n##################  正理想点偏差 -----  且 决策者不能提供任何权重信息  ###############\n####################################################### ##############################\n#### 第一步把原始决策矩阵A 利用适当的方法进行规范化为R，R为归一化后的矩阵\n### norm_matrix()函数，根据书中收益型属性（按公式1.2）与成本型属性(按公式1.4)分别进行归一化\nnorm_matrix = function(A,shouyi=NULL,chengben=NULL){\n  if(is.matrix(A))A = data.table(A)\n  stopifnot(!is.null(shouyi) | !is.null(chengben))\n  m = ncol(A)\n  if(is.null(chengben)) chengben =setdiff(1L:m,shouyi) \n  if(is.null(shouyi)) shouyi = setdiff(1:m,chengben)\n  stopifnot(length(intersect(shouyi,chengben))==0,setequal(union(shouyi,chengben),1:m))\n\n  if( length(chengben) == 0 ){\n    # 对决策矩阵进行重命名\n    names(A)=paste0('V',1:m)\n    shouyi = paste0(\"V\",shouyi)\n    R = A    \n    # 归一化\n    R[,':='(c(shouyi),lapply(.SD, function(x)x/max(x))),.SDcols =shouyi] # 收益型属性归一化 （书中1.2式）\n  }else if( length(shouyi) == 0 ){\n    #对决策矩阵进行重命名\n    names(A)=paste0('V',1:m)\n    chengben = paste0(\"V\",chengben)\n    R = A\n    # 归一化\n    R[,':='(c(chengben),lapply(.SD,function(x)min(x)/x)),.SDcols = chengben]# 成本型属性归一化 （书中1.3式）\n  }else{\n    #对决策矩阵进行重命名\n    names(A)=paste0('V',1:m)\n    shouyi = paste0(\"V\",shouyi)\n    chengben = paste0(\"V\",chengben)\n    R = A\n    # 归一化\n    R[,':='(c(shouyi),lapply(.SD, function(x)x/max(x))),.SDcols =shouyi] # 收益型属性归一化 （书中1.2式）\n    R[,':='(c(chengben),lapply(.SD,function(x)min(x)/x)),.SDcols = chengben]# 成本型属性归一化 （书中1.3式）    \n  }\n  R = as.data.frame(R)\n  return(R)\n}\nR = norm_matrix(A,shouyi = c(1:5))\nR\n#>          V1        V2  V3      V4        V5\n#> 1 0.6379310 0.5142857 0.4 0.59375 0.6923077\n#> 2 1.0000000 0.8000000 1.0 0.87500 0.8076923\n#> 3 0.8965517 1.0000000 1.0 1.00000 1.0000000\n#> 4 0.7413793 0.5428571 0.6 0.84375 0.7538462\n#### 第二步  最小化方案与正理想点之间的偏差，得出属性权重向量\nM_position = function(R){ # 输入归一化后的决策矩阵。\n  m =  ncol(R)\n  n = nrow(R)\n  # ## 程序 1 \n   temp = apply(R, 2, FUN = function(x)1/(n-sum(x)) )\n   w = temp/sum(temp) \n   return(w)\n  # ## 程序 2 \n  # w = rep(0,m)\n  # s = 0\n  # for(j in 1:m){\n  #   s = s + 1/(n - sum(R[,j]))\n  # }\n  # for(j in 1:m){\n  #   w[j] = (1/(n - sum(R[,j])))/s \n  # }\n  # return(w)\n}\nw = M_position(R)\nw\n#>        V1        V2        V3        V4        V5 \n#> 0.2282300 0.1446113 0.1652700 0.2403928 0.2214959\n#### 第三步  计算出的权重向量，带入目标函数，并对目标函数值升序排序，排序结果，即为方案的优劣结果\nf_obj = apply(R, 1, function(x){ sum( (1-x)*w*w ) })\nround(f_obj,4) # 按升序排列，则最优结果为: x3 > x2 > x4 > x1\n#> [1] 0.0840 0.0208 0.0054 0.0551\n\n\n####################################################### ##############################\n##################  负（或正）理想点偏差 -----  且 决策者提供权重信息  ########## \n######################   （本质求解线性规划问题） 书中77页M3.3 和 M-3.6###############################\n####################################################### ##############################\n########  方法一： 正理想点偏差\n# 第一步： 归一化决策矩阵\n# 第二步： 得出属性权重向量\n# M_position_tigong_w 输入决策矩阵(为规范化后的决策矩阵)，以及提供权重信息,以向量形式给出\n# 该函数输入结果为： 得出属性权重向量\n\nM_position_tigong_w = function(R,lower_c,upper_c){\n  library(Rglpk)\n  n = nrow(R)\n  m = ncol(R)\n  obj = n - c(apply(R, 2, sum)) # 设置目标函数\n  mat = matrix(rep(1,m),nrow = 1) # 约束条件，权和向量为1 \n  dir = c(\"==\")\n  rhs = c(1)\n  types = c(\"C\")\n  bounds <- list(lower = list(ind = 1L:m, val = lower_c),\n                 upper = list(ind = 1L:m, val = upper_c))\n  return(Rglpk_solve_LP(obj, mat, dir, rhs, bounds, types)$solution)\n}\n\n\nw = M_position_tigong_w(R,lower_c = c(0.15,0.13,0.15,0.20,0.20),\n                    upper_c = c(0.25,0.15,0.20,0.25,0.23))\nw\n#> [1] 0.25 0.13 0.15 0.25 0.22\nround(w,2)\n#> [1] 0.25 0.13 0.15 0.25 0.22\n####  第三步： 把计算出的权重向量，带入目标函数，并对目标函数值升序排序，排序结果，即为方案的优劣结果\napply(R, 1, function(x) sum( (1-x)*w ) )\n#> [1] 0.41291491 0.09955769 0.02586207 0.27730009\napply(R, 1, function(x) sum( (1-x)*w ) ) %>% rank %>% order()# 按升序排列，则最优结果为: x3 > x2 > x4 > x1\n#> [1] 3 2 4 1\n\n\n\n########  方法二： 负理想点偏差\n# 第一步： 归一化决策矩阵\n# 第二步： 得出属性权重向量\n# M_negative_w 输入决策矩阵(为规范化后的决策矩阵)，以及提供权重信息,以向量形式给出\n# 该函数输入结果为： 得出属性权重向量\nM_negative_w = function(R,lower_c,upper_c){\n  library(Rglpk)\n  n = nrow(R)\n  m = ncol(R)\n  obj = c(apply(R, 2, sum)) # 设置目标函数\n  mat = matrix(rep(1,m),nrow = 1) # 约束条件，权和向量为1 \n  dir = c(\"==\")\n  rhs = c(1)\n  types = c(\"C\")\n  bounds <- list(lower = list(ind = 1L:m, val = lower_c),\n                 upper = list(ind = 1L:m, val = upper_c))\n  return(Rglpk_solve_LP(obj, mat, dir, rhs, bounds, types,max =TRUE )$solution)\n}\nw = M_position_tigong_w(R,lower_c = c(0.15,0.13,0.15,0.20,0.20),\n                        upper_c = c(0.25,0.15,0.20,0.25,0.23))\nw\n#> [1] 0.25 0.13 0.15 0.25 0.22\nround(w,2)\n#> [1] 0.25 0.13 0.15 0.25 0.22\n####  第三步： 把计算出的权重向量，带入目标函数，并对目标函数值升序排序，排序结果，即为方案的优劣结果\napply(R, 1, function(x) sum( (1-x)*w ) )\n#> [1] 0.41291491 0.09955769 0.02586207 0.27730009\napply(R, 1, function(x) sum( (1-x)*w ) ) %>% rank %>% order()# 按升序排列，则最优结果为: x3 > x2 > x4 > x1\n#> [1] 3 2 4 1"
  },
  {
    "objectID": "posts/uncertain/2019-02-26-2-1模糊互补判断矩阵的排序方法.html",
    "href": "posts/uncertain/2019-02-26-2-1模糊互补判断矩阵的排序方法.html",
    "title": "2.1 模糊互补判断矩阵的排序方法",
    "section": "",
    "text": "Show the code###  2.1 模糊互补判断矩阵的排序方法---徐泽水《不确定多属性决策方法与应用》59页 --2.1.6 实例分析\n# 以及55页 例 2.1\nB = c(0.5,0.7,0.6,0.8,\n      0.3,0.5,0.4,0.6,\n      0.4,0.6,0.5,0.7,\n      0.2,0.4,0.3,0.5) \nB = matrix(B, nrow = 4,ncol = 4,byrow = T)\n######## MTM 排序法---模糊互补判断矩阵的中转法\n# MTM 函数直接输入模糊互补判断矩阵B，直接即可求出对应案例（即行，决策矩阵行代表案例，列代表属性）的权重向量w.\nMTM = function(B){\n  w = 0\n  n = nrow(B)\n  m = ncol(B)\n  stopifnot(n==m)\n  for(i in 1:n){\n    w[i] =( sum(B[i,]) + n/2 -1) /(n*(n-1))\n  }\n  return(w)\n}\nMTM(B)\n#> [1] 0.3000000 0.2333333 0.2666667 0.2000000\n\n########## LVM 排序---- 模糊互补判断矩阵排序的最小方差法\n# LVM函数直接输入模糊互补判断矩阵B，直接即可求出对应案例（即行，决策矩阵行代表案例，列代表属性）的权重向量w.\nLVM = function(x){\n  w =0\n  n = nrow(B)\n  m = ncol(B)\n  stopifnot(n==m)\n  for(i in 1:n){\n    w[i] =( sum(B[i,]) + 1 - n/2 )/n \n  }\n  return(w)\n}\nLVM(B)\n#> [1] 0.4 0.2 0.3 0.1\n### LDM 排序 -------模糊互补判断矩阵排序的最小偏差法\n# LDM 函数 --本质是求解一个线性规划问题。\nLDM = function(B){\n  n = nrow(B)\n  m =  ncol(B)\n  stopifnot(n == m)\n  w = matrix(runif(n, min = 0.1, max = 0.9),nrow = 1,byrow = T)# 随机初始化正向量w\n  e = 0.0001 # 迭代精度，要求权向量的每一个分量都小于此精度，则迭代结束。\n  k = 0 # 迭代次数\n  repeat{\n    eta = rep(0,n) # 初始化中间变量\n    for(i in 1:n){\n      for(j in 1:n){\n        eta[i] = eta[i] + (B[i, j]/B[j, i]) * (w[j]/w[i]) - (B[j, i]/B[i, j]) * (w[i]/w[j])\n      }\n    }\n    v = 0; w1 = rep(0,n);v_fenzi = 0; v_fenmu = 0 # 初始化中间变量\n    if( all( abs(eta) < e) ) {\n      break\n    }else{\n      l = which.max(abs(eta))\n      for(j in 1:n){\n        if(j != l) {\n          v_fenzi = v_fenzi + B[l,j]/B[j,l] * w[j]/w[l]\n          v_fenmu = v_fenmu + B[j,l]/B[l,j] * w[l]/w[j]\n        }\n      }\n      v =  sqrt(v_fenzi/v_fenmu)\n      for(i in 1:n){\n        if(i != l){\n          w1[i] = w[i]\n        }else{\n          w1[i] = v * w[l]\n        }\n      }\n      k = k+1\n      w = w1/sum(w1)\n    }\n  }\n  return(w)  \n}\nLDM(B)\n#> [1] 0.4302060 0.1799470 0.2748736 0.1149734\n\n##### CEM -- 模糊互补判断矩阵排序的特征向量法\n# CEM函数\nCEM = function(B){\n  # 第一步 ---通过转换公式，得出转换矩阵H\n  n = nrow(B)\n  H = matrix(0, ncol = n, nrow = n)\n  for( i in 1:n){\n    for(j in 1:n){\n      H[i,j] = B[i,j]/B[j,i]\n    }\n  }\n  # 第二步 -- 求转换矩阵H的最大特征值对应的特征向量,此特征向量即模糊互补判断矩阵的排序向量\n  #### 直接调用系统函数求矩阵的特征值以及特征向量\n  # w = Re(eigen(H)$vectors[,1] / sum(eigen(H)$vectors[,1]))\n  # return(w)\n  ####  数值方法求矩阵H的最大特征值对应的特征向量,\n  max_eigen_w =  function(M) {\n    n = nrow(M)\n    m =  ncol(M)\n    stopifnot(n == m)\n    w = matrix(runif(n, min = 0.1, max = 0.9),nrow = 1,byrow = T)# 随机初始化正向量w\n    q = max(w)\n    w = w / q # 并初始化权向量\n    # 进行迭代\n    repeat{\n      w = M %*% t(w)\n      w = t(w)\n      q1 = max(w)\n      w = w/q1\n      e = q1 - q # 迭代的精度\n      if(abs(e) < 0.000001) {\n        break\n      }\n      q = q1\n    }\n    return(w)\n  }\n  w = max_eigen_w(H)\n  # 第三步 ---- 并对特征向量进行归一化处理\n  w = w / sum(w)\n  return(w)\n}\n\nCEM(B)\n#>           [,1]      [,2]      [,3]      [,4]\n#> [1,] 0.4303074 0.1798951 0.2747969 0.1150005\n\n\n##### 检验模糊互补判断矩阵一致性\n# 直接输入模糊互补判断矩阵可得CR指标，CR<0.1 ,一般检验通过\nCEM_CR_test =  function(B, w = CEM(B)){\n  # 第一步 -- 先要先求出权重向量w -- 即模糊互补矩阵对应的最大特征值的特征向量 ,直接进行默认参数设置。\n  # 注意调用此函数之前，要调用CEM函数\n  \n  n = nrow(B)\n  CI = 0\n  for(i in 1:n) {\n    for (j in 1:n) {\n      if (i < j) {\n        CI = CI + (B[i, j] / B[j, i]) * (w[j] / w[i]) + (B[j, i] / B[i, j]) * (w[i] / w[j]) -2\n      }\n    }\n  }\n  CI = CI /(n*(n-1))  \n  RI = c(0,0,0.52,0.89,1.12,1.26,1.36,1.41,1.46,1.49,1.52,1.56,1.58,1.59)\n  return( CI/RI[n]) \n}\n\nCEM_CR_test(B)\n#> [1] 0.0008969988\n\n\n######  55 页 -----例2.1 \nB = c(0.5,0.6,0.4,0.3,\n      0.4,0.5,0.6,0.6,\n      0.6,0.4,0.5,0.7,\n      0.7,0.4,0.3,0.5) \nB = matrix(B, nrow = 4,ncol = 4,byrow = T)\nCEM(B)\n#>           [,1]      [,2]     [,3]      [,4]\n#> [1,] 0.2043336 0.2697384 0.297326 0.2286019\nCEM_CR_test(B)\n#> [1] 0.1609257"
  },
  {
    "objectID": "posts/uncertain/2019-05-05-incomplete-interval-GDM.html",
    "href": "posts/uncertain/2019-05-05-incomplete-interval-GDM.html",
    "title": "残缺区间群体决策模型（GDM Liu 2012)",
    "section": "",
    "text": "徐泽水： A consistency improving method in the analytic hierarchy process 1999年\n刘芳：Acceptable consistency analysis of interval reciprocal comparison matrices 2009年\n刘芳： A goal programming model for incomplete interval multiplicative preference relations and its application in group decision-making 2012年\n\n\n先把残缺区间矩阵\\(U_k\\)通过某种方法(LOP2)或者利用粒子群算法)进行补全成\\(U_k^{’}\\)，\n检查补全以后的矩阵\\(U_{k}^{'}\\)是否具有一致性(\\(U_{k}^{'}\\)具有一致性 的充要条件 是 \\(U_{k}^{'}\\) 分解成单个的正互反判断矩阵B 和D，矩阵B和D的CR <= 0.1)，不具有则调整（按照徐泽水1999年提出的论文进行调整)\n若\\(U_{k}^{'}\\)具有一致性，则进行群体决策模型构建，生成最终的区间判断矩阵U\n通过最终的区间判断矩阵U生成区间权重，注意生成区间权重并没有归一化权重，根据区间权重生成可能度矩阵P.\n\n\nconsistency(A): 求正互反判断矩阵的一致性指标，返回一个list\nem_get_w(A) : 特征值求权重 —— 没有归一化权重\ngm_get_w(A)： 几何平均求权重 — — 没有归一化权重\nget_w(B,D): 分别获取B，D的权重（可以指定几何平均或者特征值求权重），然后组成区间权重向量（即小的在前，大的在后），这里返回的是一个矩阵，把每一个区间数看做矩阵的一行。\nfenjie(U ): 把区间矩阵U分解成正互反判断矩阵B和D\nadjust_w(A,lambda) : 利用论文的方法进行调整，返回调整后符合一致性条件的一致性矩阵。\ndegree_probability(a,b) 函数计算两个区间数的可能度\nprobability_matrix(w) 给一个n*2 的区间数，求其可能度矩阵\n\n介绍几个函数—-这几个函数都是利用粒子群算法把\\(U_{k}\\)变成\\(U_{k}^{'}\\)\n以下是补全区间的关键元素。\n\nindex_matrix():此函数可以查找到区间正互反判断矩阵中那些元素是缺失的（缺失用0表示)，并生成一个矩阵，每一列都有其相关含义。\nhecheng(B,D): 对应fenjie的逆向操作，把两个正互反矩阵进行合并成一个区间判断矩阵。`\njianyan_yuesu(U):检验输入的区间判断矩阵U是否满足要求，即有没有输入上的出错。\nset_x(x,U):函数把x向量赋值给U中缺失的元素\nobj_fun(Ut):求补全好的区间矩阵的目标函数值\n\n随机初始化残缺元素\n\n\nU_to_UU() 函数是把区间矩阵U 重塑成(n * n ) 2形式的矩阵，以两列为单位，因为每两列是一个区间，第一列代表区间的下界，第二列代表区间的上界，故 形成2列矩阵，每一行代表一个区间数，\n\nUU_to_U() 函数是通过找出UU中的缺失元素，然后赋予缺失元素一个随机值（ 该随机值保证了在1/9 ~ 9之间，且保证了UU中的下界与上界的关系，若某行只缺失一个数据，也能得到相应的保证），并把赋予好的完整矩阵变成区间判断矩阵的形式。\n\nU_runif()是U_to_UU() 和UU_to_U() 函数的融合，先利用U_to_UU()变成我们需要的格式，然后利用UU_to_U()产生随机值进行填充最后返回我们随机填充好的区间判断矩阵\n\ninit_x() 通过随机初始化U，找出解\n\n\nGDM_PSO()主要的函数，通过利用粒子群算法把\\(U_{k}\\)变成\\(U_{k}^{'}\\)\nDGM_U()群体决策，把若干个完整的区间判断矩阵合并成一个区间判断矩阵。\n\n\nShow the coderm(list = ls())\n# 0。 一致性指标的求解\nconsistency = function(A){\n  lambda = Re(eigen(A)$values[1]) # 矩阵A的最大特征值\n  n  = nrow(A)\n  RI = c(0,0,0.58,0.90,1.12,1.24,1.32,1.41,1.45);\n  CI = (lambda-n) / (n-1);\n  CR = CI / RI[n];\n  eig_w = eigen(A)$vectors[,1] / sum( eigen(A)$vectors[,1]);\n  return(list(\"eig_value\"=lambda,\"CI\"=CI,\"RI\"=RI[n],\"CR\"=CR,'eig_w'=Re( eig_w )))\n}\n\n\n# 1. 特征值求权重\nem_get_w = function(A){\n  n = nrow(A)\n  stopifnot(nrow(A) ==  ncol(A))\n  \n  lambda = Re(eigen(A)$values[1]) # 矩阵A的最大特征值\n  n = nrow(A)\n  RI = c(0,0,0.58,0.90,1.12,1.24,1.32,1.41,1.45);\n  CI=(lambda-n)/(n-1);\n  CR=CI/RI[n];\n  eig_origin = eigen(A)$vectors[,1]\n  eig_w = eigen(A)$vectors[,1] # /sum(eigen(A)$vectors[,1]);\n  eig_w = Re(eig_w)\n  return(eig_w)\n}\n# 2. 几何平均求权重\ngm_get_w =function(A){\n  n = nrow(A)\n  stopifnot(nrow(A) ==  ncol(A))\n  temp = apply(A, 1, function(x) prod(x)^(1/n) )\n  w = temp # /sum(temp)\n  return(w)\n}\n# 3. 合并权重\nget_w = function(B,D,method = c('gm_get_w','em_get_w') ){\n  n = nrow(B)\n  stopifnot(n == nrow(D))\n  method <- match.arg(method)\n  f = get(method)\n  w_B = f(B)\n  w_D = f(D)\n  w_L = rep(0,length(w_B))\n  w_U = rep(0,length(w_B))\n  for(i in 1:length(w_B)){\n    w_L[i] = min(w_B[i],w_D[i])\n    w_U[i] = max(w_B[i],w_D[i])\n  }\n  w = matrix(c(w_L,w_U), ncol= 2 )\n  return(w)\n}\n\n\n\n# 4. 通过U进行分解，分解出B，D矩阵，\nfenjie = function(U){\n  n = nrow(U)\n  stopifnot(ncol(U) == 2*n)\n  \n  B = matrix(0,nrow = n,ncol = n)\n  D = matrix(0,nrow = n,ncol = n)\n  \n  for(i in 1:n){\n    for(j in 1:n){\n      if(i<j){\n        B[i,j] = U[i,j*2]\n        D[i,j] = U[i,2*j-1]\n      }else if(i>j){\n        B[i,j] = U[i,2*j-1]\n        D[i,j] = U[i,j*2]\n      }else{\n        B[i,j] = U[i,2*j]\n        D[i,j] =U[i,2*j]\n      }\n    }\n  }\n  return(list('B'=B,'D'=D))\n}\n\n\n# 5. 徐泽水(1999年)的文章方法进行调整，直到满足一致性条件为准(CR <=0.1).\nadjust_w <- function(A, lambda) {\n  k <- 0\n  n = nrow(A)\n  m = ncol(A)\n  stopifnot(n == m)\n  temp_CR <- consistency(A)$CR\n  temp_w <- consistency(A)$eig_w\n  while (temp_CR >= 0.1 && k < 1000) {\n    for (i in 1:n) {\n      for (j in 1:n) {\n          A[i, j] <- (A[i, j]^lambda) * (temp_w[i] / temp_w[j])^(1 - lambda)\n      }\n    }\n    temp_CR <- consistency(A)$CR\n    temp_w <- consistency(A)$eig_w\n    k <- k + 1\n  }\n  return(A)\n}\n\n\n\n# 6. degree_probability 函数计算两个区间数的可能度\ndegree_probability <- function(a, b) {\n  # 输入的a,b代表一个区间，即是一个二维向量，且小的在前面，大的元素在后面\n  stopifnot(length(a) == length(b), length(a) == 2, a[1] <= a[2], b[1] <= b[2])\n  temp <- 0\n  if (a[1] == a[2] && b[1] == b[2]) {\n    if (a[1] > b[1]) {\n      temp <- 1\n    } else if (a[1] == b[1]) {\n      temp <- 0.5\n    } else {\n      temp <- 0\n    }\n  } else if (a[1] == a[2] && b[1] != b[2]) {\n    if (a[1] > b[2]) {\n      temp <- 1\n    } else if (b[1] <= a[1] & a[1] <= b[2]) {\n      temp <- (a[1] - b[1]) / (b[2] - b[1])\n    } else {\n      temp <- 0\n    }\n  } else if (a[1] != a[2] && b[1] == b[2]) {\n    if (a[1] > b[1]) {\n      temp <- 1\n    } else if (a[1] <= b[1] & b[1] <= a[2]) {\n      temp <- (a[2] - b[1]) / (a[2] - a[1])\n    } else {\n      temp <- 0\n    }\n  } else if (a[1] != a[2] && b[1] != b[2]) {\n    if (a[1] < a[2] && a[2] <= b[1] && b[1] < b[2]) {\n      temp <- 0\n    } else if (a[1] <= b[1] && b[1] < a[2] && a[2] <= b[2]) {\n      s_t <- (a[2] - b[1]) * (a[2] - b[1]) * 0.5\n      s <- (b[2] - b[1]) * (a[2] - a[1])\n      temp <- s_t / s\n    } else if (a[1] <= b[1] && b[1] <= b[2] && b[2] <= a[2]) {\n      s_t <- ((a[2] - b[2]) + (a[2] - b[1])) * (b[2] - b[1]) * 0.5\n      s <- (b[2] - b[1]) * (a[2] - a[1])\n      temp <- s_t / s\n    } else if (b[1] < a[1] && a[1] < a[2] && a[2] < b[2]) { \n      # 可写等号b[1] <= a[1] && a[1]<a[2] &&a[2]<=b[2]\n      s_t <- ((a[1] - b[1]) + (a[2] - b[1])) * (a[2] - a[1]) * 0.5\n      s <- (b[2] - b[1]) * (a[2] - a[1])\n      temp <- s_t / s\n    } else if (b[1] < a[1] && a[1] < b[2] && b[2] < a[2]) {\n      s_tt <- (b[2] - a[1]) * (b[2] - a[1]) * 0.5\n      s <- (b[2] - b[1]) * (a[2] - a[1])\n      s_t <- s - s_tt\n      temp <- s_t / s\n    } else if (b[1] < b[2] && b[2] <= a[1] && a[1] < a[2]) {\n      temp <- 1\n    } else {\n    stop(\"运行出错,请检查\")\n    }\n  } else {\n    stop(\"运行出错,请检查\")\n  }\n  return(temp)\n}\n\n# 7. probability_matrix 给一个n*2 的区间数，求其可能度矩阵\nprobability_matrix <- function(Z) {\n  # probability_matrix函数输入一个n*2的矩阵，每一行代表输出各个方案的综合属性值得区间数\n  # 此函数输出各方案两两比较的可能度矩阵。\n  # degree_probability函数求两个区间数的可能度，\n  # a，b代表输入的区间数，输入这两个\n  P <- matrix(0, ncol = nrow(Z), nrow = nrow(Z))\n  for (i in 1:nrow(Z)) {\n    for (j in 1:nrow(Z)) {\n      P[i, j] <- degree_probability(Z[i, ], Z[j, ])\n    }\n  }\n  return(P)\n}\n\n\n# 8. index_matrix此函数可以查找到区间正互反判断矩阵中那些元素是缺失的（缺失用0表示)\nindex_matrix <- function(U) {\n  nnn <- which(U == 0, arr.ind = T)[, 1] # 行\n  mmm <- which(U == 0, arr.ind = T)[, 2] # 列\n  index <- matrix(0, nrow = length(nnn), ncol = 8)\n  # 矩阵index 每一行相当于一个变量\n  # 第一列代表 X索引，即变量X1,X2,...Xn\n  # 第二三列 代表变量Xi 所在U中的位置，用行和列表示\n  # 第四列，第五列，根据变量Xi在U的位置，\n  # 第6 列，判断Xi与Xj 是否为同一个位置，\n  index[, 1] <- 1:length(nnn)\n  index[, 2] <- nnn #\n  index[, 3] <- mmm\n  index\n  for (i in 1:nrow(index)) {\n    if (index[i, 3] %% 2 == 0) {\n      # 第3列的数字是偶数,检查U矩阵向前一列是否为0\n      if (U[index[i, 2], index[i, 3] - 1] == 0) {\n        index[i, 4] <- 0\n        index[i, 5] <- 0\n      } else {\n        index[i, 4] <- U[index[i, 2], index[i, 3] - 1]\n        index[i, 5] <- 0\n      }\n    } else {\n      if (U[index[i, 2], index[i, 3] + 1] == 0) {\n        index[i, 4] <- 0\n        index[i, 5] <- 0\n      } else {\n        index[i, 4] <- 0\n        index[i, 5] <- U[index[i, 2], index[i, 3] + 1]\n      }\n    }\n  }\n  \n  for (i in 1:nrow(index)) {\n    if (index[i, 4] != 0 & index[i, 5] == 0) {\n      index[i, 5] <- 9\n    }\n  }\n  for (i in 1:nrow(index)) {\n    if (index[i, 5] != 0 & index[i, 4] == 0) {\n      index[i, 4] <- 1 / 9\n    }\n  }\n  index[, 6] <- ifelse((index[, 4] == index[, 5] & index[, 4] == 0), 1, 0)\n  jinjibiao <- c()\n  for (i in 1:nrow(index)) {\n    for (j in 1:nrow(index)) {\n      if (index[i, 6] == 1 & index[j, 6] == 1 & j != i) {\n        if (index[i, 2] == index[j, 2] & abs(index[i, 3] - index[j, 3]) == 1) {\n          if (!(index[i, 7] %in% jinjibiao)) {\n            jinjibiao <- c(jinjibiao, j)\n            index[i, 7] <- index[i, 1]\n            index[i, 8] <- index[j, 1]\n          }\n        }\n      }\n    }\n  }\n  for (i in 1:nrow(index)) {\n    if (index[i, 7] > index[i, 8]) {\n      t <- index[i, 8]\n      index[i, 8] <- index[i, 7]\n      index[i, 7] <- t\n    }\n  }\n  \n  return(index)\n}\n\n\n# 9. 合成\nhecheng <- function(B, D) {\n  n = nrow(B)\n  m = ncol(B)\n  stopifnot(n == m, n == nrow(D) )\n  UU <- matrix(0, nrow = n, ncol = n * 2)\n  \n  for (i in 1:n) {\n    for (j in 1:(2*n) ) {\n      k <- (j + 1) %/% 2\n      if (i > k) {\n        if (j %% 2 == 0) {\n          UU[i, j] <- D[i, k]\n        } else {\n          UU[i, j] <- B[i, k]\n        }\n      } else if (i < k) {\n        if (j %% 2 == 0) {\n          UU[i, j] <- B[i, k]\n        } else {\n          UU[i, j] <- D[i, k]\n        }\n      } else {\n        UU[i, j] <- 1\n      }\n    }\n  }\n  return(UU)\n}\n\n\n####################################################################################\n######################## 构建 目标函数 补全区间残缺矩阵 ################## \n# 10. 检验U矩阵是否符合条件 \njianyan_yuesu <- function(U) {\n  if (!all(U >= 1 / 9 & U <= 9)) {\n    stop(\"U矩阵不满足约束条件\")\n  }\n  B <- fenjie(U)$B # 先对U进行分解，分解成B，D约束条件\n  D <- fenjie(U)$D\n  R <- matrix(0, nrow = nrow(D), ncol = ncol(D)) # 存储C与D比较的结果\n  for (i in 1:nrow(B)) {\n    for (j in 1:ncol(B)) {\n      if (i < j) {\n        R[i, j] <- (B[i, j] >= D[i, j])\n      } else if (i > j) {\n        R[i, j] <- (B[i, j] <= D[i, j])\n      } else {\n        R[i, j] <- all(B[i, j] == D[i, j], B[i, j] == 1)\n      }\n    }\n  }\n  if (!all(R == 1)) {\n    stop(\"U矩阵分解后的B,D矩阵不满足约束条件\")\n  }\n  return(1) # 返回结果为1 即满足约束\n}\n\n\n# 11. 把x的值赋予U中的残缺元素\nset_x <- function(x, U) {\n  U[which(U == 0)] <- x\n  return(U)\n}\n\n# 12，U补全后的矩阵记为Ut，计算补全后的目标函数值\nobj_fun <- function(Ut) {\n  s_sum <- 0\n  B_sum <- 0\n  D_sum <- 0\n  B <- fenjie(Ut)$B\n  D <- fenjie(Ut)$D\n  n <- nrow(B)\n  if (jianyan_yuesu(Ut)) {\n    for (i in 1:n) {\n      for (j in 1:n) {\n        for (k in 1:n) {\n          B_sum <- B_sum + (log(B[i, j], 9) - log(B[i, k], 9) - log(B[k, j], 9))^2\n          D_sum <- D_sum + (log(D[i, j], 9) - log(D[i, k], 9) - log(D[k, j], 9))^2\n        }\n      }\n    }\n    s_sum <- s_sum + B_sum + D_sum\n    return(s_sum)\n  } else {\n    stop(\"!!!输入的矩阵不符合约束条件\")\n  }\n}\n\n\n\n#########################################################\n#######################################################\n######################## 13. 初始化x #######\n######### U_runif 通过U产生 符合要求的随机矩阵U2\n# 13.1 重塑U ---把U变成UU（即(n*n )*2)形式的矩阵）\nU_to_UU <- function(U) {\n  n <- nrow(U)\n  m <- ncol(U) / 2\n  stopifnot(m >= 4, m == nrow(U))\n  # 先重塑U,U的每两列进行列合并成UU，通过UU产生0所在位置的随机数，并返回0所在的行下标，\n  # 即矩阵B，D为0的下标\n  UU <- U[, 1:2]\n  for (j in 2:(ncol(U) / 2)) {\n    temp1 <- U[, c(2 * j - 1, 2 * j)]\n    UU <- rbind(UU, temp1)\n  }\n  return(UU)\n}\n\n# 13.2 UU 转变成U的形式，并赋予随机值\nUU_to_U <- function(UU) {\n  n <- sqrt(nrow(UU))\n  if (!as.integer(n)) stop(\"n不是整数\")\n  BD_index2 <- t(apply(UU, 1, function(x) {\n    temp <- c(0, 0)\n    if (x[1] == 0 && x[2] != 0) {\n      temp[1] <- runif(1, 1 / 9, x[2])\n      temp[2] <- x[2]\n    } else if (x[1] != 0 && x[2] == 0) {\n      temp[1] <- x[1]\n      temp[2] <- runif(1, x[1], 9)\n    } else if (x[1] == 0 && x[2] == 0) {\n      temp <- sort(runif(2, 1 / 9, 9))\n    } else {\n      temp <- x\n    }\n    return(temp)\n  }))\n  # 把BD_index2 转变为 U的形式\n  stopifnot(nrow(BD_index2) %% n == 0)\n  U2 <- BD_index2[1:n, ]\n  for (j in 2:(nrow(BD_index2) / n)) {\n    temp2 <- BD_index2[(n * j - n + 1):(n * j), ]\n    U2 <- cbind(U2, temp2)\n  }\n  return(U2)\n}\n\n# 13.3 直接通过U随机初始化U\nU_runif <- function(U) {\n  UU <- U_to_UU(U)\n  # 对UU的每一行进行判断，产生出符合要求的随机数，并使BD_index2的形式与UU的形式一样，都为 (n*m) * 2矩阵\n  U2 <- UU_to_U(UU)\n  return(U2)\n}\n\n# 13.4 通过随机初始化U，找出解\ninit_x <- function(U) {\n  U2 <- U_runif(U)\n  return(U2[which(U == 0)])\n}\n\n\n###############################################################\n## 14。通过粒子群算法求目标函数最小值，来补全残缺区间矩阵的元素\nGDM_PSO <- function(U) {\n  Popsize <- 100 # 种群的大小\n  Dim <- sum(U == 0) # 粒子的维度\n  c1 <- 2 # 学习因子\n  c2 <- 2 # 学习因子\n  LB <- 1 / 9 # 下限\n  UB <- 9 # 上限\n  w_start <- 0.9\n  w_end <- 0.4\n  Vmax <- 5\n  Vmin <- -Vmax\n  MaxIter <- 3000\n  \n  \n  index <- index_matrix(U)\n  \n  # 初始化粒子位置和速度\n  X <- matrix(0, nrow = Popsize, ncol = Dim)\n  for (i in 1:Popsize) {\n    X[i, ] <- init_x(U)\n  }\n  V <- matrix(runif(Popsize * Dim), nrow = Popsize, ncol = Dim)\n  \n  # 设置当前位置为粒子的最好位置，并记录其最好值\n  PBest <- X\n  FPBest <- apply(X, 1, function(xx) obj_fun(set_x(xx, U)))\n  # FPBest\n  \n  if (anyNA(FPBest)) {\n    stop(\"适应度函数出现NA 或NaN，请检查\")\n  }\n  # 找出初始微粒群体的最好微粒\n  Best <- PBest[which.min(FPBest), ] # 最好的微粒\n  FGBest <- min(FPBest) # 以及最好的微粒对应的适应度值\n  \n  FX <- c(FGBest, rep(0, MaxIter - 1)) # 用来记录每一代的最粒子对应的适应度值\n  iter <- 0 # 初始迭代次数\n  \n  while (iter < MaxIter) {\n    # if(iter%%100 == 0) print(iter) # 显示循环进度条\n    iter <- iter + 1\n    # 更新权重的值\n    w_now <- (w_start - (w_start - w_end) / MaxIter * iter)\n    A <- matrix(rep(Best, each = Popsize), nrow = Popsize, ncol = Dim)\n    # 生成随机数\n    R1 <- matrix(runif(Popsize * Dim), nrow = Popsize, ncol = Dim)\n    R2 <- matrix(runif(Popsize * Dim), nrow = Popsize, ncol = Dim)\n    \n    # 速度更新\n    V <- w_now * V + c1 * R1 * (PBest - X) + c2 * R2 * (A - X)\n    \n    # 对进化后速度大于最大素的的微粒进行处理\n    changes <- V > Vmax\n    V[changes] <- Vmax\n    changes <- V < Vmin\n    V[changes] <- Vmin\n    \n    # 微粒位置进行更新\n    X <- X + 1.0 * V\n    # 对进化后微粒位置 大于搜索空间的的微粒进行处理\n    changes <- X > UB\n    X[changes] <- UB\n    changes <- X < LB\n    X[changes] <- LB\n    # 并再次检验是否满足约束，如果不满足约束，则进行调整\n    \n    for (ii in 1:nrow(index)) {\n      if (index[ii, 6] == 0) {\n        X[which(X[, ii] < index[ii, 4]), ii ] <- index[ii, 4]\n        X[which(X[, ii] > index[ii, 5]), ii] <- index[ii, 5]\n      } else {\n        X[which(X[, ii] < 1 / 9), ii ] <- 1 / 9\n        X[which(X[, ii] > 9), ii] <- 9\n        # 交换值 ，\n        if (ii %in% index[, 7] & index[ii, 7] != 0) {\n          kkkk <- ii\n          jjjj <- index[ii, 8]\n          \n          Low <- ifelse(X[, kkkk] > X[, jjjj], X[, jjjj], X[, kkkk])\n          UP <- ifelse(X[, kkkk] > X[, jjjj], X[, kkkk], X[, jjjj])\n          X[, kkkk] <- Low\n          X[, jjjj] <- UP\n        }\n      }\n    }\n    \n    \n    # 重新计算新位置的适应度值\n    \n    FPBest2 <- apply(X, 1, function(xx) obj_fun(set_x(xx, U)))\n    \n    # 更新每个微粒最好的位置\n    P <- (FPBest2 < FPBest)\n    FPBest[P] <- FPBest2[P] # 适应度值更换\n    PBest[P, ] <- X[P, ] # 粒子位置更换\n    \n    # 保存最好的粒子和适应度值\n    Best <- PBest[which.min(FPBest), ]\n    FGBest <- min(FPBest)\n    FX[iter] <- FGBest\n  }\n  # Best 为找到的最优解，把最优解赋值给区间型矩阵\n  Ut = set_x(Best,U) # Ut 即补全后的区间型矩阵\n  obj = obj_fun(Ut ) # 最优区间矩阵对于的目标函数值\n  return(list(\"best\" = Best, \"FGBest\" = FGBest,\"Ut\" = Ut,\"obj\"= obj))\n}\n\n## 15. DGM_U()群体决策，把若干个完整的区间判断矩阵合并成一个区间判断矩阵。\nDGM_U = function(...){\n  #######  第一部分是对参数的检查 #####################\n  # 输入的参数为U_{k}，U_{k}代表一个完整的区间乘积互反判断矩阵。\n  n = nrow(..1)\n  m = ncol(..1)\n  args <- list(...)\n  stopifnot( length(args) >=2, all( map_lgl(args,is.matrix)),2*n ==m )\n  # 检查所有的矩阵维度是否一样\n  library(purrr)\n  t = map(args,dim) %>% do.call(rbind, .) \n  stopifnot( nrow(unique(t)) == 1)\n  \n  ####### 第二部分 对参数的操作，达到想要的目的###########\n  ## 1. 使用快捷的函数\n  k = 1 / length(args)\n  UB = reduce( map(args,function(x)fenjie(x)$B),`*`)^k\n  UD = reduce( map(args, function(x)fenjie(x)$D), `*`)^k\n  \n  return( hecheng(UB,UD))\n}\n\n\n\n\n先利用一个区间残缺矩阵进行补全操作，然后计算其可能度矩阵P。\n\nShow the codeU = matrix(c(1,1,1,2,0,2,2,3,\n             1/2,1,1,1,0,0,2,5,\n             1/2,0,0,0,1,1,3,0,\n             1/3,1/2,1/5,1/2,0,1/3,1,1),nrow = 4,byrow = T)\nU\n#>           [,1] [,2] [,3] [,4] [,5]      [,6] [,7] [,8]\n#> [1,] 1.0000000  1.0  1.0  2.0    0 2.0000000    2    3\n#> [2,] 0.5000000  1.0  1.0  1.0    0 0.0000000    2    5\n#> [3,] 0.5000000  0.0  0.0  0.0    1 1.0000000    3    0\n#> [4,] 0.3333333  0.5  0.2  0.5    0 0.3333333    1    1\nbest_U = GDM_PSO(U)\nbest_U\n#> $best\n#> [1] 1.5000000 0.7745967 1.5000000 0.6666667 0.6666667 0.3333333 1.2909944 3.0000000\n#> \n#> $FGBest\n#> [1] 2.560765\n#> \n#> $Ut\n#>           [,1] [,2]      [,3] [,4]      [,5]      [,6] [,7] [,8]\n#> [1,] 1.0000000  1.0 1.0000000  2.0 0.6666667 2.0000000    2    3\n#> [2,] 0.5000000  1.0 1.0000000  1.0 0.6666667 1.2909944    2    5\n#> [3,] 0.5000000  1.5 0.7745967  1.5 1.0000000 1.0000000    3    3\n#> [4,] 0.3333333  0.5 0.2000000  0.5 0.3333333 0.3333333    1    1\n#> \n#> $obj\n#> [1] 2.560765\n\nlibrary(magrittr)\nlibrary(purrr)\n## # 矩阵U进行分解成B，D，并检验B，D的CR值\nbest_U$Ut %>%fenjie() %>%  map(.,function(x)consistency(x)$CR)\n#> $B\n#> [1] 0.04881706\n#> \n#> $D\n#> [1] 7.949838e-10\n\n# 直接求出区间权重，以及根据权重求出区间可能度矩阵\n( w = get_w(B= fenjie(best_U$Ut)$B ,D = fenjie(best_U$Ut)$D) ) #每一行对应第i个方案的区间权重\n#>           [,1]     [,2]\n#> [1,] 1.0745699 1.861210\n#> [2,] 1.0745699 1.340343\n#> [3,] 1.0382256 1.611855\n#> [4,] 0.3860974 0.537285\n( P = probability_matrix(w) ) # 可能度矩阵P\n#>           [,1]      [,2]      [,3] [,4]\n#> [1,] 0.5000000 0.8310704 0.6801310  1.0\n#> [2,] 0.1689296 0.5000000 0.2950182  1.0\n#> [3,] 0.3198690 0.7049818 0.5000000  1.0\n#> [4,] 0.0000000 0.0000000 0.0000000  0.5\n\n\n\n多个区间矩阵的操作\n\nShow the codeU1 = matrix(c(1,1,2,4,0,0,0,0,\n              1/4,1/2,1,1,1,3,0,0,\n              0,0,1/3,1,1,1,1/2,1,\n              0,0,0,0,1,2,1,1),nrow = 4,byrow = T)\nU2 = matrix(c(1,1,1,3,2,5,3,6,\n              1/3,1,1,1,3,0,1/2,4,\n              1/5,1/2,0,1/3,1,1,0,0,\n              1/6,1/3,1/4,2,0,0,1,1),nrow = 4,byrow = T)\nU3 = matrix(c(1,1,0,0,1/3,2,2,4,\n              0,0,1,1,0,0,1/3,2,\n              1/2,3,0,0,1,1,1/2,3,\n              1/4,1/2,1/2,3,1/3,2,1,1),nrow = 4,byrow = T)\n\n#########################################################################\n############### 对U1进行操作 ###########\nbest_U1 = GDM_PSO(U1) \nbest_U1\n#> $best\n#>  [1] 0.1111111 0.1111111 0.5000000 1.0000000 0.3849002 2.0000000 2.0000000 9.0000000 1.0000000 0.5000000 9.0000000 2.5980762\n#> \n#> $FGBest\n#> [1] 0.1542834\n#> \n#> $Ut\n#>           [,1] [,2]      [,3] [,4] [,5] [,6] [,7]     [,8]\n#> [1,] 1.0000000  1.0 2.0000000    4    2    9  1.0 9.000000\n#> [2,] 0.2500000  0.5 1.0000000    1    1    3  0.5 2.598076\n#> [3,] 0.1111111  0.5 0.3333333    1    1    1  0.5 1.000000\n#> [4,] 0.1111111  1.0 0.3849002    2    1    2  1.0 1.000000\n#> \n#> $obj\n#> [1] 0.1542834\n### 矩阵U进行分解成B，D，并检验B，D的CR值\nbest_U1$Ut %>%fenjie() %>%  map(.,function(x)consistency(x)$CR)\n#> $B\n#> [1] 0.002877359\n#> \n#> $D\n#> [1] -4.504035e-11\n\n\n\nShow the code#########################################################################\n############### 对U2进行操作 ###########\nbest_U2 = GDM_PSO(U2)\nbest_U2\n#> $best\n#> [1] 0.3333333 0.7905694 3.0000000 2.0000000 0.5000000 1.2649111\n#> \n#> $FGBest\n#> [1] 8.227604\n#> \n#> $Ut\n#>           [,1]      [,2]      [,3]      [,4]      [,5] [,6] [,7]     [,8]\n#> [1,] 1.0000000 1.0000000 1.0000000 3.0000000 2.0000000    5  3.0 6.000000\n#> [2,] 0.3333333 1.0000000 1.0000000 1.0000000 3.0000000    3  0.5 4.000000\n#> [3,] 0.2000000 0.5000000 0.3333333 0.3333333 1.0000000    1  0.5 1.264911\n#> [4,] 0.1666667 0.3333333 0.2500000 2.0000000 0.7905694    2  1.0 1.000000\n#> \n#> $obj\n#> [1] 8.227604\n## # 矩阵U进行分解成B，D，并检验B，D的CR值\nbest_U2$Ut %>%fenjie() %>%  map(.,function(x)consistency(x)$CR)\n#> $B\n#> [1] 0.01941419\n#> \n#> $D\n#> [1] 0.1401432\n\n\n\nShow the code#########################################################################\n############### 对U3进行操作 ###########\nbest_U3 = GDM_PSO(U3)\nbest_U3\n#> $best\n#> [1] 0.4030941 0.4048632 2.4678983 1.3926094 2.4679007 3.3078502 0.2999835 0.7129858\n#> \n#> $FGBest\n#> [1] 10.52412\n#> \n#> $Ut\n#>           [,1]      [,2]     [,3]     [,4]      [,5]      [,6]      [,7] [,8]\n#> [1,] 1.0000000 1.0000000 2.467898 2.467901 0.3333333 2.0000000 2.0000000    4\n#> [2,] 0.4030941 0.4048632 1.000000 1.000000 0.2999835 0.7129858 0.3333333    2\n#> [3,] 0.5000000 3.0000000 1.392609 3.307850 1.0000000 1.0000000 0.5000000    3\n#> [4,] 0.2500000 0.5000000 0.500000 3.000000 0.3333333 2.0000000 1.0000000    1\n#> \n#> $obj\n#> [1] 10.52412\n## # 矩阵U进行分解成B，D，并检验B，D的CR值\nbest_U3$Ut %>%fenjie() %>%  map(.,function(x)consistency(x)$CR)\n#> $B\n#> [1] 0.004191067\n#> \n#> $D\n#> [1] 0.2094884\n\n\n发现U2 和U3 填充后没有满足一致性条件，于是需要调整\n\nShow the code## U2调整后的矩阵\ntemp2 = best_U2$Ut %>% fenjie() %>% map2(.,list(0.6,0.88),adjust_w) \nhecheng(temp2$B,temp2$D)\n#>           [,1]      [,2]      [,3]      [,4]      [,5]     [,6]      [,7]     [,8]\n#> [1,] 1.0000000 1.0000000 1.0902384 3.0000000 2.2142197 5.000000 2.5464288 6.000000\n#> [2,] 0.3333333 0.9172306 1.0000000 1.0000000 2.7801250 3.000000 0.5831896 4.000000\n#> [3,] 0.2000000 0.4516264 0.3333333 0.3596961 1.0000000 1.000000 0.4911658 1.264911\n#> [4,] 0.1666667 0.3927068 0.2500000 1.7147083 0.7905694 2.035972 1.0000000 1.000000\n\n## U3调整后的矩阵\ntemp3 = best_U3$Ut %>% fenjie() %>% map2(.,list(0.6,0.88),adjust_w) \nhecheng(temp3$B,temp3$D)\n#>           [,1]      [,2]     [,3]     [,4]      [,5]      [,6]      [,7] [,8]\n#> [1,] 1.0000000 1.0000000 2.614291 2.467901 0.4338405 2.0000000 1.5314546    4\n#> [2,] 0.4030941 0.3822943 1.000000 1.000000 0.2858496 0.7129858 0.3197585    2\n#> [3,] 0.5000000 2.3049946 1.392609 3.479965 1.0000000 1.0000000 0.6491458    3\n#> [4,] 0.2500000 0.6529740 0.500000 3.127361 0.3333333 1.5404860 1.0000000    1\n\n\n​ 如果分解后的B和D没有达到一致性，则进行调整，由于这里用的是PSO算法进行残缺元素的填充，因此带有一定的随机值。于是我们用以下三个矩阵代代替补全后的矩阵(论文中给出的)\n\nShow the codeU_t1 = matrix(c(1,1,2,4,2,9,1,9,\n                1/4,1/2,1,1,1,3,0.5,2.25,\n                1/9,1/2,1/3,1,1,1,1/2,1,\n                1/9,1,0.4444,2,1,2,1,1),nrow = 4,byrow = T)\n\nU_t2 = matrix(c(1,1,1.0815,3,2.0609,5,2.5209,6,\n                 1/3,0.9246,1,1,2.5515,3,0.6414,4,\n                 1/5,0.4852,1/3,0.3919,1,1,1.1237,1.3333,\n                 1/6,0.3967,1/4,1.5587,0.75,0.8899,1,1),nrow = 4,byrow = T)\n\n\nU_t3 = matrix(c(1,1,0.7256,2.1183,0.4837,2,1.2234,4,\n                 0.4721,1.3782,1,1,0.6666,0.8008,0.4299,2,\n                 1/2,2.0675,1.2488,1.5001,1,1,0.6449,3,\n                 1/4,0.8174,1/2,2.3262,1/3,1.5507,1,1),nrow = 4,byrow = T)\n( U = DGM_U(U_t1,U_t2,U_t3) ) # 多个区间矩阵融合为一个综合的区间矩阵\n#>           [,1]      [,2]      [,3]      [,4]      [,5]     [,6]      [,7]     [,8]\n#> [1,] 1.0000000 1.0000000 1.1621208 2.9402860 1.2585998 4.481405 1.4555977 6.000000\n#> [2,] 0.3401086 0.8604891 1.0000000 1.0000000 1.1936774 1.931622 0.5166013 2.620741\n#> [3,] 0.2231443 0.7945333 0.5177063 0.8377192 1.0000000 1.000000 0.7129147 1.587388\n#> [4,] 0.1666667 0.6870140 0.3815587 1.9355892 0.6299605 1.402705 1.0000000 1.000000\n( w = get_w(fenjie(U)$B,fenjie(U)$D) )# 对综合区间矩阵进行求权重--注意：权重没归一化\n#>           [,1]      [,2]\n#> [1,] 1.2079392 2.9818703\n#> [2,] 0.8534871 1.1454892\n#> [3,] 0.6543922 0.8299693\n#> [4,] 0.4473844 1.1686549\nprobability_matrix(w)#可能度矩阵\n#>      [,1]    [,2]      [,3]      [,4]\n#> [1,]  0.5 1.00000 1.0000000 1.0000000\n#> [2,]  0.0 0.50000 1.0000000 0.7654600\n#> [3,]  0.0 0.00000 0.5000000 0.4087181\n#> [4,]  0.0 0.23454 0.5912819 0.5000000\n\n\n\n如果区间矩阵是残缺的，那么用以下函数去补全：\nU = matrix(c(1,1,1,2,0,2,2,3,\n             1/2,1,1,1,0,0,2,5,\n             1/2,0,0,0,1,1,3,0,\n             1/3,1/2,1/5,1/2,0,1/3,1,1),nrow = 4,byrow = T)\nU\nbest_U = GDM_PSO(U)\nbest_U\n\n## 补全以后要进行一致性检验：\nbest_U$Ut %>%fenjie() %>%  map(.,function(x)consistency(x)$CR\n\n## 一致性检验没通过，则用下面的方法进行调整\ntemp = best_U$Ut %>% fenjie() %>% map2(.,list(0.6,0.88),adjust_w) \nU1 = hecheng(temp$B,temp$D) # 一定是一致性检验通过的区间判断矩阵\n若是多个完整的区间矩阵，要综合成一个矩阵，则可以直接用下面的方法：\n# U_t1 ,U_t2,... ,是完整的区间判断矩阵，且符合一致性检验条件\n( U = DGM_U(U_t1,U_t2,U_t3) ) # 多个区间矩阵融合为一个综合的区间矩阵，\n( w = get_w(fenjie(U)$B,fenjie(U)$D) )# 对综合区间矩阵进行求权重--注意：权重没归一化\nprobability_matrix(w)#可能度矩阵"
  },
  {
    "objectID": "posts/uncertain/2019-05-04-interval-of-possibility-degree.html",
    "href": "posts/uncertain/2019-05-04-interval-of-possibility-degree.html",
    "title": "求区间可能度矩阵的算法(Liu 2009)",
    "section": "",
    "text": "徐泽水： A consistency improving method in the analytic hierarchy process 1999年\n刘芳：Acceptable consistency analysis of interval reciprocal comparison matrices 2009年\n\n\n把区间乘性互反矩阵U拆成两个正互反判断矩阵B和D,B，D都是正的互反判断矩阵。其中B的下三角元素大于D矩阵的下三角元素，B的上三角小于D的上三角元素 ，简称B的下三角大，上三角小\n一致性检验，若拆分后的B，D矩阵一致性不满足条件(即\\(CR<= 0.1\\)) ，则用徐泽水(1999年)的文章方法进行调整，直到满足一致性条件为准(\\(CR <=0.1\\)).\n然后分别计算矩阵\\(B，D\\)的权重向量\\(w(B),w(D)\\) ,注意这里的权重没有归一化处理.\n通过公式\\(w_i = [min(w_i(B),w_i(D)),max(w_i(B),w_i(D))]\\),把两个权重向量组合成一个区间向量。\n通过区间向量\\(w\\)计算出区间向量的可能度矩阵\\(P\\)。\n\n\nconsistency(A): 求正互反判断矩阵的一致性指标，返回一个list\nem_get_w(A) : 特征值求权重 —— 没有归一化权重\ngm_get_w(A)： 几何平均求权重 — — 没有归一化权重\nget_w(B,D): 分别获取B，D的权重（可以指定几何平均或者特征值求权重），然后组成区间权重向量（即小的在前，大的在后），这里返回的是一个矩阵，把每一个区间数看做矩阵的一行。\nfenjie(U ): 把区间矩阵U分解成正互反判断矩阵B和D\nadjust_w(A,lambda) : 利用论文的方法进行调整，返回调整后符合一致性条件的一致性矩阵。\ndegree_probability(a,b) 函数计算两个区间数的可能度\nprobability_matrix(w) 给一个n*2 的区间数，求其可能度矩阵\n\n\nShow the code\nrm(list = ls())\n# 0。 一致性指标的求解\nconsistency = function(A){\n  lambda = Re(eigen(A)$values[1]) # 矩阵A的最大特征值\n  n  = nrow(A)\n  RI = c(0,0,0.58,0.90,1.12,1.24,1.32,1.41,1.45);\n  CI = (lambda-n) / (n-1);\n  CR = CI / RI[n];\n  eig_w = eigen(A)$vectors[,1] / sum( eigen(A)$vectors[,1]);\n  return(list(\"eig_value\"=lambda,\"CI\"=CI,\"RI\"=RI[n],\"CR\"=CR,'eig_w'=Re( eig_w )))\n}\n\n\n\n# 1. 特征值求权重\nem_get_w = function(A){\n  n = nrow(A)\n  stopifnot(nrow(A) ==  ncol(A))\n  \n  lambda = Re(eigen(A)$values[1]) # 矩阵A的最大特征值\n  n = nrow(A)\n  RI = c(0,0,0.58,0.90,1.12,1.24,1.32,1.41,1.45);\n  CI=(lambda-n)/(n-1);\n  CR=CI/RI[n];\n  eig_origin = eigen(A)$vectors[,1]\n  eig_w = eigen(A)$vectors[,1] # /sum(eigen(A)$vectors[,1]);\n  eig_w = Re(eig_w)\n  return(eig_w)\n}\n# 2. 几何平均求权重 -- \ngm_get_w =function(A){\n  n = nrow(A)\n  stopifnot(nrow(A) ==  ncol(A))\n  temp = apply(A, 1, function(x) prod(x)^(1/n) )\n  w = temp # /sum(temp) \n  return(w)\n}\n# 3. 合并权重\nget_w = function(B,D,method = c('gm_get_w','em_get_w') ){\n  n = nrow(B)\n  stopifnot(n == nrow(D))\n  method <- match.arg(method)\n  f = get(method)\n  w_B = f(B)\n  w_D = f(D)\n  w_L = rep(0,length(w_B))\n  w_U = rep(0,length(w_B))\n  for(i in 1:length(w_B)){\n    w_L[i] = min(w_B[i],w_D[i])\n    w_U[i] = max(w_B[i],w_D[i])\n  }\n  w = matrix(c(w_L,w_U), ncol= 2 )\n  return(w)\n}\n\n\n\n# 4. 通过U进行分解，分解出B，D矩阵，\nfenjie = function(U){\n  n = nrow(U)\n  stopifnot(ncol(U) == 2*n)\n  \n  B = matrix(0,nrow = n,ncol = n)\n  D = matrix(0,nrow = n,ncol = n)\n  \n  for(i in 1:n){\n    for(j in 1:n){\n      if(i<j){\n        B[i,j] = U[i,j*2]\n        D[i,j] = U[i,2*j-1]\n      }else if(i>j){\n        B[i,j] = U[i,2*j-1]\n        D[i,j] = U[i,j*2]\n      }else{\n        B[i,j] = U[i,2*j]\n        D[i,j] =U[i,2*j]\n      }\n    }\n  }\n  return(list('B'=B,'D'=D))\n}\n\n\n# 5. 徐泽水(1999年)的文章方法进行调整，直到满足一致性条件为准(CR <=0.1).\nadjust_w <- function(A, lambda) {\n  k <- 0\n  n = nrow(A)\n  m = ncol(A)\n  stopifnot(n == m)\n  temp_CR <- consistency(A)$CR\n  temp_w <- consistency(A)$eig_w\n  while (temp_CR >= 0.1 && k < 1000) {\n    for (i in 1:n) {\n      for (j in 1:n) {\n          A[i, j] <- (A[i, j]^lambda) * (temp_w[i] / temp_w[j])^(1 - lambda)\n      }\n    }\n    temp_CR <- consistency(A)$CR\n    temp_w <- consistency(A)$eig_w\n    k <- k + 1\n  }\n  return(A)\n}\n\n\n\n# 6. degree_probability 函数计算两个区间数的可能度\ndegree_probability <- function(a, b) {\n  # 输入的a,b代表一个区间，即是一个二维向量，且小的在前面，大的元素在后面\n  stopifnot(length(a) == length(b), length(a) == 2, a[1] <= a[2], b[1] <= b[2])\n  temp <- 0\n  if (a[1] == a[2] && b[1] == b[2]) {\n    if (a[1] > b[1]) {\n      temp <- 1\n    } else if (a[1] == b[1]) {\n      temp <- 0.5\n    } else {\n      temp <- 0\n    }\n  } else if (a[1] == a[2] && b[1] != b[2]) {\n    if (a[1] > b[2]) {\n      temp <- 1\n    } else if (b[1] <= a[1] & a[1] <= b[2]) {\n      temp <- (a[1] - b[1]) / (b[2] - b[1])\n    } else {\n      temp <- 0\n    }\n  } else if (a[1] != a[2] && b[1] == b[2]) {\n    if (a[1] > b[1]) {\n      temp <- 1\n    } else if (a[1] <= b[1] & b[1] <= a[2]) {\n      temp <- (a[2] - b[1]) / (a[2] - a[1])\n    } else {\n      temp <- 0\n    }\n  } else if (a[1] != a[2] && b[1] != b[2]) {\n    if (a[1] < a[2] && a[2] <= b[1] && b[1] < b[2]) {\n      temp <- 0\n    } else if (a[1] <= b[1] && b[1] < a[2] && a[2] <= b[2]) {\n      s_t <- (a[2] - b[1]) * (a[2] - b[1]) * 0.5\n      s <- (b[2] - b[1]) * (a[2] - a[1])\n      temp <- s_t / s\n    } else if (a[1] <= b[1] && b[1] <= b[2] && b[2] <= a[2]) {\n      s_t <- ((a[2] - b[2]) + (a[2] - b[1])) * (b[2] - b[1]) * 0.5\n      s <- (b[2] - b[1]) * (a[2] - a[1])\n      temp <- s_t / s\n    } else if (b[1] < a[1] && a[1] < a[2] && a[2] < b[2]) { \n      # 可写等号b[1] <= a[1] && a[1]<a[2] &&a[2]<=b[2]\n      s_t <- ((a[1] - b[1]) + (a[2] - b[1])) * (a[2] - a[1]) * 0.5\n      s <- (b[2] - b[1]) * (a[2] - a[1])\n      temp <- s_t / s\n    } else if (b[1] < a[1] && a[1] < b[2] && b[2] < a[2]) {\n      s_tt <- (b[2] - a[1]) * (b[2] - a[1]) * 0.5\n      s <- (b[2] - b[1]) * (a[2] - a[1])\n      s_t <- s - s_tt\n      temp <- s_t / s\n    } else if (b[1] < b[2] && b[2] <= a[1] && a[1] < a[2]) {\n      temp <- 1\n    } else {\n      stop(\"运行出错\")\n    }\n  } else {\n    stop(\"运行出错,请检查\")\n  }\n  return(temp)\n}\n\n# 7. probability_matrix 给一个n*2 的区间数，求其可能度矩阵\nprobability_matrix <- function(Z) {\n  # probability_matrix函数输入一个n*2的矩阵，每一行代表输出各个方案的综合属性值得区间数\n  # 此函数输出各方案两两比较的可能度矩阵。\n  # degree_probability函数求两个区间数的可能度，\n  # a，b代表输入的区间数，输入这两个\n  P <- matrix(0, ncol = nrow(Z), nrow = nrow(Z))\n  for (i in 1:nrow(Z)) {\n    for (j in 1:nrow(Z)) {\n      P[i, j] <- degree_probability(Z[i, ], Z[j, ])\n    }\n  }\n  return(P)\n}\n\n\n总结: 只需给出一个区间判断矩阵，返回最终的权重(前提是B和D要满足一致性条件\\(CR<=0.1\\))\n\n\n\nShow the code\nU = matrix(c(1,1,2,5,2,4,1,3,\n             1/5,1/2,1,1,1,3,1,2,\n             1/4,1/2,1/3,1,1,1,1/2,1,\n             1/3,1,1/2,1,1,2,1,1),nrow = 4,byrow = T)\nfenjie(U) \n#> $B\n#>           [,1]      [,2] [,3] [,4]\n#> [1,] 1.0000000 5.0000000    4    3\n#> [2,] 0.2000000 1.0000000    3    2\n#> [3,] 0.2500000 0.3333333    1    1\n#> [4,] 0.3333333 0.5000000    1    1\n#> \n#> $D\n#>      [,1] [,2] [,3] [,4]\n#> [1,]  1.0    2    2  1.0\n#> [2,]  0.5    1    1  1.0\n#> [3,]  0.5    1    1  0.5\n#> [4,]  1.0    1    2  1.0\n\n## 一致性检验\nlibrary(purrr)\nfenjie(U) %>% map(function(x)consistency(x)$CR) # 求解矩阵B，D的一致性指标\n#> $B\n#> [1] 0.08209909\n#> \n#> $D\n#> [1] 0.02246186\n\n# 直接求出区间权重，以及根据权重求出区间可能度矩阵\n( w = get_w(B= fenjie(U)$B ,D = fenjie(U)$D) ) #每一行对应第i个方案的区间权重\n#>           [,1]      [,2]\n#> [1,] 1.4142136 2.7831577\n#> [2,] 0.8408964 1.0466351\n#> [3,] 0.5372850 0.7071068\n#> [4,] 0.6389431 1.1892071\n\n( P = probability_matrix(w) ) # 可能度矩阵P\n#>      [,1]      [,2]      [,3]       [,4]\n#> [1,]  0.5 1.0000000 1.0000000 1.00000000\n#> [2,]  0.0 0.5000000 1.0000000 0.55395713\n#> [3,]  0.0 0.0000000 0.5000000 0.02486059\n#> [4,]  0.0 0.4460429 0.9751394 0.50000000\n\n\n\n\nShow the code\nU  = matrix(c(1,1,1,2,1,2,2,3,\n              1/2,1,1,1,3,5,4,5,\n              1/2,1,1/5,1/3,1,1,6,8,\n              1/3,1/2,1/5,1/4,1/8,1/6,1,1),nrow = 4,byrow = T)\nfenjie(U)\n#> $B\n#>           [,1] [,2]  [,3] [,4]\n#> [1,] 1.0000000  2.0 2.000    3\n#> [2,] 0.5000000  1.0 5.000    5\n#> [3,] 0.5000000  0.2 1.000    8\n#> [4,] 0.3333333  0.2 0.125    1\n#> \n#> $D\n#>      [,1]      [,2]      [,3] [,4]\n#> [1,]  1.0 1.0000000 1.0000000    2\n#> [2,]  1.0 1.0000000 3.0000000    4\n#> [3,]  1.0 0.3333333 1.0000000    6\n#> [4,]  0.5 0.2500000 0.1666667    1\nfenjie(U) %>% map(function(x)consistency(x)$CR) # 可以发现B和D的一致性不满足条件\n#> $B\n#> [1] 0.2752221\n#> \n#> $D\n#> [1] 0.1232627\n\n## 方法一： 进行调整\nadjust_w(fenjie(U)$B,lambda = 0.6) %>% round(4)\n#>        [,1]   [,2]   [,3]   [,4]\n#> [1,] 1.0000 1.4696 1.9339 3.9751\n#> [2,] 0.6805 1.0000 3.4564 5.5703\n#> [3,] 0.5171 0.2893 1.0000 5.6119\n#> [4,] 0.2516 0.1795 0.1782 1.0000\nadjust_w(fenjie(U)$D,lambda = 0.88) %>% round(4)\n#>        [,1]   [,2]   [,3]   [,4]\n#> [1,] 1.0000 0.9428 0.9943 2.1061\n#> [2,] 1.0607 1.0000 2.7732 4.1112\n#> [3,] 1.0057 0.3606 1.0000 5.5695\n#> [4,] 0.4748 0.2432 0.1795 1.0000\n\n## 方法二:进行调整 --  多参数映射\ntemp = fenjie(U) %>% map2(.,list(0.6,0.88),function(x,y)round( adjust_w(x,y),4) )\ntemp\n#> $B\n#>        [,1]   [,2]   [,3]   [,4]\n#> [1,] 1.0000 1.4696 1.9339 3.9751\n#> [2,] 0.6805 1.0000 3.4564 5.5703\n#> [3,] 0.5171 0.2893 1.0000 5.6119\n#> [4,] 0.2516 0.1795 0.1782 1.0000\n#> \n#> $D\n#>        [,1]   [,2]   [,3]   [,4]\n#> [1,] 1.0000 0.9428 0.9943 2.1061\n#> [2,] 1.0607 1.0000 2.7732 4.1112\n#> [3,] 1.0057 0.3606 1.0000 5.5695\n#> [4,] 0.4748 0.2432 0.1795 1.0000\ntemp %>% map(function(x)consistency(x)$CR)#检验权重情况\n#> $B\n#> [1] 0.09525181\n#> \n#> $D\n#> [1] 0.09474896\n\n\n# 求出调整后的B和D的权重\n( w = get_w(B= temp$B ,D = temp$D) ) #每一行对应第i个方案的区间权重\n#>           [,1]      [,2]\n#> [1,] 1.1853702 1.8333497\n#> [2,] 1.8648143 1.9025351\n#> [3,] 0.9572122 1.1921409\n#> [4,] 0.2995165 0.3794326\n( P = probability_matrix(w) ) # 可能度矩阵P\n#>              [,1] [,2]      [,3] [,4]\n#> [1,] 0.5000000000  0.0 0.9998494  1.0\n#> [2,] 1.0000000000  0.5 1.0000000  1.0\n#> [3,] 0.0001505719  0.0 0.5000000  1.0\n#> [4,] 0.0000000000  0.0 0.0000000  0.5\n\n\n\n无论什么样的区间矩阵(一致性是否满足)，都可以用步骤\n# list(0.6,0.88)中的0.6和0.88 为调整adjust_w()函数参数中的lambda值对应\ntemp = fenjie(U) %>% map2(., list(0.6,0.88),function(x,y)round( adjust_w(x,y),4) )\nw = get_w(B= temp$B ,D = temp$D)#每一行对应第i个方案的区间权重\nw\n\nP = probability_matrix(w)\nP"
  },
  {
    "objectID": "posts/uncertain/2019-02-26-4-2基于投影的多属性决策方法.html",
    "href": "posts/uncertain/2019-02-26-4-2基于投影的多属性决策方法.html",
    "title": "4.2基于投影的多属性决策方法(含4.3区间归一化)",
    "section": "",
    "text": "Show the code#####  第四章--属性权重为实数且属性值为区间数的多属性决策方法及应用\n## 4.2 基于投影的多属性决策方法---徐泽水《不确定多属性决策方法与应用》112页 \n## 4.2.2 实例分析\n\n#####  第一步： 求出规范化矩阵\nA = c(58.9,59,200,250,1.9,2.1,0.990,0.991,0.907,0.909,\n      58.5,58.7,340,350,3.4,3.5,0.990,0.992,0.910,0.912,\n      58.0,58.5,290,310,2.0,2.2,0.992,0.993,0.914,0.917) \nA = matrix(A,nrow = 3,byrow = T) # A为决策矩阵\nA # 矩阵A的奇数列代表属性的下界 ，偶数列代表属性的上界\n#>      [,1] [,2] [,3] [,4] [,5] [,6]  [,7]  [,8]  [,9] [,10]\n#> [1,] 58.9 59.0  200  250  1.9  2.1 0.990 0.991 0.907 0.909\n#> [2,] 58.5 58.7  340  350  3.4  3.5 0.990 0.992 0.910 0.912\n#> [3,] 58.0 58.5  290  310  2.0  2.2 0.992 0.993 0.914 0.917\n\n\nnorm_matrix = function(A, shouyi = NULL, chengben = NULL) {\n  m = ncol(A)/2\n  n = nrow(A)\n  #chengben = c(1,2,4,5);shouyi = NULL\n  stopifnot( ncol(A)%%2 == 0 ) #检验输入的决策矩阵的列数是否为偶数\n  stopifnot(!is.null(shouyi) | !is.null(chengben))\n  if (is.null(chengben)) chengben = setdiff(1:m, shouyi)\n  if (is.null(shouyi)) shouyi = setdiff(1:m, chengben)\n  # 如果输入的shouyi与chengben向量交集不为空，且并集不是全集，则算法出错\n  stopifnot(length(intersect(shouyi, chengben)) == 0, setequal(union(shouyi, chengben), 1:m))\n  \n  R = matrix(0, nrow = nrow(A),ncol = ncol(A))\n  for(i in 1:n){\n    for(j in 1:ncol(A) ){\n      k = (j+1) %/% 2\n      if( k %in% shouyi){\n        if( (j%%2) == 0 ){# 第j列为收益类型 且为偶数\n          R[i,j] = A[i,j] / sqrt(sum(A[,j-1]^2))\n        }else{\n          R[i,j] = A[i,j] / sqrt(sum(A[,j+1]^2))\n        }\n      }\n      if(k %in% chengben){\n        if( (j%%2) == 0 ){\n          R[i,j] = (1/A[i,j-1]) / sqrt(sum((1/A[,j])^2))\n        }else{\n          R[i,j] = (1/A[i,j+1]) / sqrt(sum((1/A[,j])^2))\n        }\n      }\n    }\n  }\n\n  return(R)\n}\nlibrary(dplyr)\nR = norm_matrix(A,chengben = c(1,3))\nR\n#>           [,1]      [,2]      [,3]      [,4]      [,5]      [,6]      [,7]\n#> [1,] 0.5720972 0.5757060 0.3772242 0.5106296 0.6079511 0.7334020 0.5761861\n#> [2,] 0.5750210 0.5796425 0.6412812 0.7148814 0.3647707 0.4098423 0.5761861\n#> [3,] 0.5769869 0.5846394 0.5469751 0.6331807 0.5803170 0.6967319 0.5773501\n#>           [,8]      [,9]     [,10]\n#> [1,] 0.5775443 0.5737618 0.5765018\n#> [2,] 0.5781271 0.5756596 0.5784044\n#> [3,] 0.5787098 0.5781900 0.5815755\nR %>% round(.,4)\n#>        [,1]   [,2]   [,3]   [,4]   [,5]   [,6]   [,7]   [,8]   [,9]  [,10]\n#> [1,] 0.5721 0.5757 0.3772 0.5106 0.6080 0.7334 0.5762 0.5775 0.5738 0.5765\n#> [2,] 0.5750 0.5796 0.6413 0.7149 0.3648 0.4098 0.5762 0.5781 0.5757 0.5784\n#> [3,] 0.5770 0.5846 0.5470 0.6332 0.5803 0.6967 0.5774 0.5787 0.5782 0.5816\n\nw = c(0.2189,0.2182,0.1725,0.2143,0.1761)\nY = t(apply(R, 1 , function(x){x* rep(w,each = 2)})) %>% round(.,4)\nY\n#>        [,1]   [,2]   [,3]   [,4]   [,5]   [,6]   [,7]   [,8]   [,9]  [,10]\n#> [1,] 0.1252 0.1260 0.0823 0.1114 0.1049 0.1265 0.1235 0.1238 0.1010 0.1015\n#> [2,] 0.1259 0.1269 0.1399 0.1560 0.0629 0.0707 0.1235 0.1239 0.1014 0.1019\n#> [3,] 0.1263 0.1280 0.1193 0.1382 0.1001 0.1202 0.1237 0.1240 0.1018 0.1024\n\nposition_y = apply(Y, 2, function(x)max(x))\nposition_y\n#>  [1] 0.1263 0.1280 0.1399 0.1560 0.1049 0.1265 0.1237 0.1240 0.1018 0.1024\napply(Y, 1,function(x)sum(x*position_y))/sqrt(sum(position_y^2))\n#> [1] 0.3536778 0.3634614 0.3757275\n\n\n4.3 区间归一化\n** 注：书中的归一化有问题 **\n\nShow the coderm(list = ls() )\n#####  第一步： 求出规范化矩阵\nA = c(1.5,1.9,9,9.5,8,9,10,12,12,13,8,9,2,3,1.2,1.3,\n      2.7,3.1,5,6,9,9.5,4,5,4,5,7,8,9,10,1.1,1.2,\n      1.8,2,8.5,9.1,7,8,8,9,9,10,8.5,9,5,6,1,1.3,\n      2.5,2.8,5,6,9,10,6,7,6,8,7,7.5,8,9,0.8,0.9,\n      2,2.5,4,5,8,9,5,6,5,7,8,9,5,6,0.6,0.7) \nA = matrix(A,nrow = 5,byrow = T) # A为决策矩阵\nA # 矩阵A的奇数列代表属性的下界 ，偶数列代表属性的上界\n#>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]\n#> [1,]  1.5  1.9  9.0  9.5    8  9.0   10   12   12    13   8.0   9.0     2     3\n#> [2,]  2.7  3.1  5.0  6.0    9  9.5    4    5    4     5   7.0   8.0     9    10\n#> [3,]  1.8  2.0  8.5  9.1    7  8.0    8    9    9    10   8.5   9.0     5     6\n#> [4,]  2.5  2.8  5.0  6.0    9 10.0    6    7    6     8   7.0   7.5     8     9\n#> [5,]  2.0  2.5  4.0  5.0    8  9.0    5    6    5     7   8.0   9.0     5     6\n#>      [,15] [,16]\n#> [1,]   1.2   1.3\n#> [2,]   1.1   1.2\n#> [3,]   1.0   1.3\n#> [4,]   0.8   0.9\n#> [5,]   0.6   0.7\n\nnorm_matrix = function(A, shouyi = NULL, chengben = NULL) {\n  m = ncol(A)/2\n  n = nrow(A)\n  #chengben = c(1,2,4,5);shouyi = NULL\n  stopifnot( ncol(A)%%2 == 0 ) #检验输入的决策矩阵的列数是否为偶数\n  stopifnot(!is.null(shouyi) | !is.null(chengben))\n  if (is.null(chengben)) chengben = setdiff(1:m, shouyi)\n  if (is.null(shouyi)) shouyi = setdiff(1:m, chengben)\n  # 如果输入的shouyi与chengben向量交集不为空，且并集不是全集，则算法出错\n  stopifnot(length(intersect(shouyi, chengben)) == 0, setequal(union(shouyi, chengben), 1:m))\n  \n  R = matrix(0, nrow = nrow(A),ncol = ncol(A))\n  for(i in 1:n){\n    for(j in 1:ncol(A) ){\n      k = (j+1) %/% 2\n      if( k %in% shouyi){\n        if( (j%%2) == 0 ){# 第j列为收益类型 且为偶数\n          R[i,j] = A[i,j] / sqrt(sum(A[,j-1]^2))\n        }else{\n          R[i,j] = A[i,j] / sqrt(sum(A[,j+1]^2))\n        }\n      }\n      if(k %in% chengben){\n        if( (j%%2) == 0 ){\n          R[i,j] = (1/A[i,j-1]) / sqrt(sum((1/A[,j])^2))\n        }else{\n          R[i,j] = (1/A[i,j+1]) / sqrt(sum((1/A[,j])^2))\n        }\n      }\n    }\n  }\n\n  return(R)\n}\n\nR = norm_matrix(A,chengben = c(1,2,4,5)) %>% round(.,2)\nR \n#>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]\n#> [1,] 0.46 0.70 0.26 0.32 0.39 0.49 0.21 0.31 0.20  0.27  0.42  0.52  0.12  0.21\n#> [2,] 0.28 0.39 0.41 0.58 0.44 0.52 0.51 0.76 0.52  0.82  0.37  0.46  0.56  0.71\n#> [3,] 0.44 0.58 0.27 0.34 0.34 0.43 0.28 0.38 0.26  0.37  0.45  0.52  0.31  0.43\n#> [4,] 0.31 0.42 0.41 0.58 0.44 0.54 0.36 0.51 0.32  0.55  0.37  0.43  0.49  0.64\n#> [5,] 0.35 0.52 0.49 0.73 0.39 0.49 0.42 0.61 0.37  0.66  0.42  0.52  0.31  0.43\n#>      [,15] [,16]\n#> [1,]  0.49  0.60\n#> [2,]  0.44  0.56\n#> [3,]  0.40  0.60\n#> [4,]  0.32  0.42\n#> [5,]  0.24  0.32\nR %>% round(.,2)\n#>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]\n#> [1,] 0.46 0.70 0.26 0.32 0.39 0.49 0.21 0.31 0.20  0.27  0.42  0.52  0.12  0.21\n#> [2,] 0.28 0.39 0.41 0.58 0.44 0.52 0.51 0.76 0.52  0.82  0.37  0.46  0.56  0.71\n#> [3,] 0.44 0.58 0.27 0.34 0.34 0.43 0.28 0.38 0.26  0.37  0.45  0.52  0.31  0.43\n#> [4,] 0.31 0.42 0.41 0.58 0.44 0.54 0.36 0.51 0.32  0.55  0.37  0.43  0.49  0.64\n#> [5,] 0.35 0.52 0.49 0.73 0.39 0.49 0.42 0.61 0.37  0.66  0.42  0.52  0.31  0.43\n#>      [,15] [,16]\n#> [1,]  0.49  0.60\n#> [2,]  0.44  0.56\n#> [3,]  0.40  0.60\n#> [4,]  0.32  0.42\n#> [5,]  0.24  0.32\n\n\nw = c(0.1,0.12,0.15,0.13,0.17,0.11,0.12,0.1)\nY = t(apply(R, 1 , function(x){x* rep(w,each = 2)})) %>% round(.,3)\nY\n#>       [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9] [,10] [,11] [,12]\n#> [1,] 0.046 0.070 0.031 0.038 0.058 0.074 0.027 0.040 0.034 0.046 0.046 0.057\n#> [2,] 0.028 0.039 0.049 0.070 0.066 0.078 0.066 0.099 0.088 0.139 0.041 0.051\n#> [3,] 0.044 0.058 0.032 0.041 0.051 0.064 0.036 0.049 0.044 0.063 0.050 0.057\n#> [4,] 0.031 0.042 0.049 0.070 0.066 0.081 0.047 0.066 0.054 0.094 0.041 0.047\n#> [5,] 0.035 0.052 0.059 0.088 0.058 0.074 0.055 0.079 0.063 0.112 0.046 0.057\n#>      [,13] [,14] [,15] [,16]\n#> [1,] 0.014 0.025 0.049 0.060\n#> [2,] 0.067 0.085 0.044 0.056\n#> [3,] 0.037 0.052 0.040 0.060\n#> [4,] 0.059 0.077 0.032 0.042\n#> [5,] 0.037 0.052 0.024 0.032\n\nnorm_matrix(A,shouyi = c(3,6,7,8)) %>% round(.,2)\n#>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]\n#> [1,] 0.46 0.70 0.26 0.32 0.39 0.49 0.21 0.31 0.20  0.27  0.42  0.52  0.12  0.21\n#> [2,] 0.28 0.39 0.41 0.58 0.44 0.52 0.51 0.76 0.52  0.82  0.37  0.46  0.56  0.71\n#> [3,] 0.44 0.58 0.27 0.34 0.34 0.43 0.28 0.38 0.26  0.37  0.45  0.52  0.31  0.43\n#> [4,] 0.31 0.42 0.41 0.58 0.44 0.54 0.36 0.51 0.32  0.55  0.37  0.43  0.49  0.64\n#> [5,] 0.35 0.52 0.49 0.73 0.39 0.49 0.42 0.61 0.37  0.66  0.42  0.52  0.31  0.43\n#>      [,15] [,16]\n#> [1,]  0.49  0.60\n#> [2,]  0.44  0.56\n#> [3,]  0.40  0.60\n#> [4,]  0.32  0.42\n#> [5,]  0.24  0.32"
  },
  {
    "objectID": "posts/uncertain/2019-02-26-1-7方案有偏好信息的多属性决策方法.html",
    "href": "posts/uncertain/2019-02-26-1-7方案有偏好信息的多属性决策方法.html",
    "title": "1.7方案有偏好信息的多属性决策方法",
    "section": "",
    "text": "代码## 1 对方案的偏好信息为互反判断矩阵的情形\nlibrary(data.table)\nlibrary(dplyr)\nA = c(3.0,100,10,7,\n      2.5,80,8,5,\n      1.8,50,20,11,\n      2.2,70,12,9)\nA= matrix(A,nrow = 4,ncol = 4,byrow = T) %&gt;% data.table()\nA # 原始决策矩阵\n#&gt;     V1  V2 V3 V4\n#&gt; 1: 3.0 100 10  7\n#&gt; 2: 2.5  80  8  5\n#&gt; 3: 1.8  50 20 11\n#&gt; 4: 2.2  70 12  9\n\n#######################################################\n##### 第一步把原始决策矩阵A 利用适当的方法进行规范化为R，R为归一化后的矩阵\n##########################################################\n### norm_matrix()函数，根据书中收益型属性（按公式1.2）与成本型属性(按公式1.4)分别进行归一化\n# 参数A表示决策矩阵,shouyi参数代表收益型属性，输入收益型属性在决策矩阵中第几列，若有多列，用数值型向量即可，\n# chengben参数代表成本型属性，与收益型属性类型。\n# 该参数可任选其一输入，也可同时指定。\nnorm_matrix = function(A,shouyi=NULL,chengben=NULL){\n  if(is.matrix(A))A = data.table(A)\n  stopifnot(!is.null(shouyi) | !is.null(chengben))\n  m = ncol(A)\n  if(is.null(chengben)) chengben =setdiff(1:m,shouyi) \n  if(is.null(shouyi)) shouyi = setdiff(1:m,chengben)\n  stopifnot(length(intersect(shouyi,chengben))==0,setequal(union(shouyi,chengben),1:m))\n  #对决策矩阵进行重命名\n  names(A)=paste0('V',1:m)\n  shouyi = paste0(\"V\",shouyi)\n  chengben = paste0(\"V\",chengben)\n  R = A\n  R[,':='(c(shouyi),lapply(.SD, function(x)x/max(x))),.SDcols =shouyi] # 收益型属性归一化 （书中1.2式）\n  R[,':='(c(chengben),lapply(.SD,function(x)min(x)/x)),.SDcol = chengben]# 成本型属性归一化 （书中1.3式）\n  R = as.data.frame(R)\n  return(R)\n}\n\nR = norm_matrix(A,chengben = c(1,3))\nround(R,3)\n#&gt;      V1  V2    V3    V4\n#&gt; 1 0.600 1.0 0.800 0.636\n#&gt; 2 0.720 0.8 1.000 0.455\n#&gt; 3 1.000 0.5 0.400 1.000\n#&gt; 4 0.818 0.7 0.667 0.818\n#########################################################\n##### 第二步 根据决策方案(即决策矩阵的行)进行成对比较，构造出判断矩阵\n#################################################\n# 假设如下判断矩阵\nH = c(1,2,1/4,1/5,\n      1/2,1,1/2,1/3,\n      4,2,1,1/2,\n      5,3,2,1)\nH = matrix(H, nrow = 4, ncol = 4, byrow = T)\nH\n#&gt;      [,1] [,2] [,3]      [,4]\n#&gt; [1,]  1.0    2 0.25 0.2000000\n#&gt; [2,]  0.5    1 0.50 0.3333333\n#&gt; [3,]  4.0    2 1.00 0.5000000\n#&gt; [4,]  5.0    3 2.00 1.0000000\nQ = matrix(0,nrow = 4,ncol = 4)\nfor(k in 1:4) {\n  for (l in 1:4) {\n    for (i in 1:4) {\n      for (j in 1:4) {\n        Q[k, l] = Q[k, l] + (H[i, j] * R[i, k] - R[i, k]) * ((H[i, j] * R[i, l] - R[i, l]))\n      }\n    }\n  }\n}\nQ\n#&gt;          [,1]     [,2]     [,3]     [,4]\n#&gt; [1,] 25.59035 19.01777 17.29175 25.45790\n#&gt; [2,] 19.01777 15.65944 14.36756 18.89730\n#&gt; [3,] 17.29175 14.36756 13.32738 17.10511\n#&gt; [4,] 25.45790 18.89730 17.10511 25.39491\ne_m = matrix(rep(1,4),nrow = 1)\nt(e_m)\n#&gt;      [,1]\n#&gt; [1,]    1\n#&gt; [2,]    1\n#&gt; [3,]    1\n#&gt; [4,]    1\n\n\n\n代码\n(solve(Q) %*% t(e_m) )/as.vector(e_m %*% solve(Q) %*% t(e_m))\n#&gt;           [,1]\n#&gt; [1,] -8.823475\n#&gt; [2,] -6.429099\n#&gt; [3,]  7.436625\n#&gt; [4,]  8.815949\n(solve(Q) %*% t(e_m) ) /0.2014189\n#&gt;           [,1]\n#&gt; [1,] -8.823476\n#&gt; [2,] -6.429100\n#&gt; [3,]  7.436626\n#&gt; [4,]  8.815950\n\n\n\n（待完善）\n\n（待完善）"
  },
  {
    "objectID": "posts/matlab/plotMathfun.html",
    "href": "posts/matlab/plotMathfun.html",
    "title": "MATLAB集合",
    "section": "",
    "text": "画数学坐标系_函数图像"
  },
  {
    "objectID": "posts/matlab/matlab-question.html#输入可变长参数以及输出可变长参数",
    "href": "posts/matlab/matlab-question.html#输入可变长参数以及输出可变长参数",
    "title": "matlab 问题集合基础",
    "section": "2、 输入可变长参数,以及输出可变长参数",
    "text": "2、 输入可变长参数,以及输出可变长参数"
  },
  {
    "objectID": "posts/matlab/matlab-question.html#nargin-捕获输入参数的个数-nargout-捕获输出参数的个数.",
    "href": "posts/matlab/matlab-question.html#nargin-捕获输入参数的个数-nargout-捕获输出参数的个数.",
    "title": "matlab 问题集合基础",
    "section": "3、 nargin 捕获输入参数的个数, nargout 捕获输出参数的个数.",
    "text": "3、 nargin 捕获输入参数的个数, nargout 捕获输出参数的个数.\nfunction varargout = foo(varargin)\n%输入可变长参数,以及输出可变长参数,都是放在一个细胞中存储, \n%而inputname 存变量名的方式,用的是字符数组矩阵的形式\nif nargin == 2\n  varargout{1} = a1; varargout{2} = a2;\nelse nargin == 3\n  varargout{1} = a1; varargout{2} = a2; varargout{3} = a3;\nend\n\n\nfunction varargout = combin_index(varargin)\nvariable_name = cell(1,nargin); % 创建一个 1* nargin 大小的 cell,\nfor i = 1:nargin\n    T = f(varargin{i});  % 获取的新参数 传递给另一个函数\n    variable_name{i} = inputname(i); % 由于变量名是字符,所以用细胞来存储\nend\n% variable_name 这个 cell 存储了变量名"
  },
  {
    "objectID": "posts/matlab/matlab-question.html#table-类型的变量如何进行转置对于表格您可以使用table2cell和cell2table的组合",
    "href": "posts/matlab/matlab-question.html#table-类型的变量如何进行转置对于表格您可以使用table2cell和cell2table的组合",
    "title": "matlab 问题集合基础",
    "section": "4、 table 类型的变量如何进行转置,对于表格，您可以使用’table2cell’和’cell2table’的组合：",
    "text": "4、 table 类型的变量如何进行转置,对于表格，您可以使用’table2cell’和’cell2table’的组合：\nXc = table2cell(X) % 这里 X 为要转置的表,Xt 为转置后的表\nXt = cell2table(Xc','RowNames',X.Properties.VariableNames,'VariableNames',X.Properties.RowNames)\n如果用的是 matlab2018 可以使用rows2vars函数,参考https://www.mathworks.com/help/matlab/ref/rows2vars.html"
  },
  {
    "objectID": "posts/matlab/matlab-question.html#matlab字符串以及-cell-之间-的操作可以看薛山的-matlab-基础教程",
    "href": "posts/matlab/matlab-question.html#matlab字符串以及-cell-之间-的操作可以看薛山的-matlab-基础教程",
    "title": "matlab 问题集合基础",
    "section": "5、 matlab字符串以及 cell 之间 的操作可以看薛山的 MATLAB 基础教程",
    "text": "5、 matlab字符串以及 cell 之间 的操作可以看薛山的 MATLAB 基础教程"
  },
  {
    "objectID": "posts/matlab/matlab-question.html#区分repmat-以及repelem",
    "href": "posts/matlab/matlab-question.html#区分repmat-以及repelem",
    "title": "matlab 问题集合基础",
    "section": "6、 区分repmat 以及repelem ,",
    "text": "6、 区分repmat 以及repelem ,\n\nrepmat 把复制的对象看做一个整体\nrepelem 复制对象中的元素,最终结果不改变原对象的数据类型"
  },
  {
    "objectID": "posts/matlab/matlab-question.html#matlab-中-矩阵-点除-一个向量的问题.",
    "href": "posts/matlab/matlab-question.html#matlab-中-矩阵-点除-一个向量的问题.",
    "title": "matlab 问题集合基础",
    "section": "7、MATLAB 中 矩阵 点除 一个向量的问题(./),",
    "text": "7、MATLAB 中 矩阵 点除 一个向量的问题(./),\n点除保证矩阵维度和向量长度相同,且 w为行向量,A为方阵,A 可以不是方阵,\nMATLAB:\n\nA ./ w w 为行向量时, 结果是把矩阵 A 的每一列对应的行向量元素相除\nA ./ w' w’ 为列向量时, 结果是把矩阵 A 的每一行对应的列向量元素相除\n\nR : 由于 R 中默认把向量都变为行向量, 所以想对列操作需要进行转变\n\nA / w w 为行向量时, 结果是把矩阵 A 的每一列对应的行向量元素相除\nt(t(A)/w) 其中w为行向量时, 结果是把矩阵 A 的每一行对应的行向量元素相除\n\n %% 实例\n >> A1 = magic(3)\nA1 =\n     8     1     6\n     3     5     7\n     4     9     2\n>> d = [1:3]\nd =\n     1     2     3\n>> A1 ./ d\nans =\n    8.0000    0.5000    2.0000\n    3.0000    2.5000    2.3333\n    4.0000    4.5000    0.6667\n>> A1 ./ d'\nans =\n    8.0000    1.0000    6.0000\n    1.5000    2.5000    3.5000\n    1.3333    3.0000    0.6667\n%% 于是可以进行 按列单位化 :  A5 ./ sqrt(sum(A5.^2,1))\n%%  按行单位化: A5 ./ sqrt(sum(A5.^2,2))\n# R 中, 矩阵除以向量  直接是矩阵行除向量对应的元素. \n> A = matlab::magic(3)\n> A\n     [,1] [,2] [,3]\n[1,]    8    1    6\n[2,]    3    5    7\n[3,]    4    9    2\n> d = c(1:3)\n> A / d\n         [,1] [,2]      [,3]\n[1,] 8.000000  1.0 6.0000000\n[2,] 1.500000  2.5 3.5000000\n[3,] 1.333333  3.0 0.6666667\n> t(t(A)/d)  # 类似 MATLAB 矩阵列除以向量对应的元素\n     [,1] [,2]      [,3]\n[1,]    8  0.5 2.0000000\n[2,]    3  2.5 2.3333333\n[3,]    4  4.5 0.6666667\n\n## 还可以利用 sweep 函数,-- \n#矩阵的某个方向(列或行) 对一个向量中的元素进行一一对应运算\n> sweep(A, 1, d, FUN = '/')   # 1 代表对矩阵行方向进行运算,等价于: A / d\n         [,1] [,2]      [,3]\n[1,] 8.000000  1.0 6.0000000\n[2,] 1.500000  2.5 3.5000000\n[3,] 1.333333  3.0 0.6666667\n> sweep(A, 2, d, FUN = '/')  # 2 代表对矩阵列方向进行运算,等价于: t(t(A)/d)\n     [,1] [,2]      [,3]\n[1,]    8  0.5 2.0000000\n[2,]    3  2.5 2.3333333\n[3,]    4  4.5 0.6666667\n\n\nsweep(x, MARGIN, STATS, FUN=\"-\", ...)对矩阵进行运算。MARGIN为1，表示行的方向上进行运算，为2表示列的方向上运算。STATS是运算的参数。FUN为运算函数，默认是减法。下面利用sweep对矩阵x进行极差标准化变换。\n\n注意:\n\nR 中 1 代表对行方向上进行运算, 2 代表对列的方向上进行运算,\nMATLAB 中 1 代表对列方向上进行计算, 2 代表对行方向上进行计算"
  },
  {
    "objectID": "posts/matlab/matlab-question.html#矩阵对向量运算的理解",
    "href": "posts/matlab/matlab-question.html#矩阵对向量运算的理解",
    "title": "matlab 问题集合基础",
    "section": "8 、矩阵对向量运算的理解",
    "text": "8 、矩阵对向量运算的理解\n由于 R 中不存在列向量与行向量, 其实 R 中的向量在内存中都是以列的方式存储,所以 R 中的向量全是列向量, 这就可以和 MATLAB 的运算对应起来, 于是 MATLAB 和 R 的矩阵对向量运算可以解释为一下情况, 假设 A 代表矩阵,d 代表向量,&代表运算规则\n\nA & d\n\n1, 列向量d自动扩充复制成一个大小和矩阵A 一模一样的矩阵,然后再按照矩阵点除(这里这的是矩阵对应位置元素做运算)的方法进行运算(即列向量按照行进行扩充)\nd = c(1:3) #列向量按照行进行扩充复制\n[1 1 1\n 2 2 2 \n 3 3 3]\n\nd = [1,2,3] # 行向量按照列进行扩充\n[1 2 3\n 1 2 3\n 1 2 3]\n2 由于 MATLAB 支持行向量,所以 行向量是按照列的方式进行复制扩充的. 然后在进行矩阵运算(行向量按照列进行扩充)"
  },
  {
    "objectID": "posts/matlab/matlab-question.html#两个向量之间的点除.",
    "href": "posts/matlab/matlab-question.html#两个向量之间的点除.",
    "title": "matlab 问题集合基础",
    "section": "9 、两个向量之间的点除./ ,",
    "text": "9 、两个向量之间的点除./ ,\n\n行向量点除列向量 , 行作为分子,列作为分母,交叉构建成一个矩阵\n列向量点除行向量,列作为分子, 行作为分母,交叉构建成一个矩阵\n若\\(w = (w_1,w_2,\\dots,w_n)\\)是一个向量,\n\n数学中的\\(\\dfrac{w_i}{w_j}\\) , 对应的是 w ./ w'矩阵中的第j,i 元素\n数学中的\\(\\dfrac{w_j}{w_i}\\) , 对应的是 w ./ w'矩阵中的第i,j 元素, 分母的索引在前面\nmatlab中log(A).^2 等价(log(A)).^2\n\n\n>> format rat\nw1 = [1,3,5];\n>> w2 = [7,9,11];\n>> w1 ./ w2'\nans =\n       1/7            3/7            5/7     \n       1/9            1/3            5/9     \n       1/11           3/11           5/11    \n>> w1' ./ w2\nans =\n       1/7            1/9            1/11    \n       3/7            1/3            3/11    \n       5/7            5/9            5/11"
  },
  {
    "objectID": "posts/matlab/matlab-question.html#sum-prodmean-涉及维度的函数这和-r-中不一样默认都是对列进行操作",
    "href": "posts/matlab/matlab-question.html#sum-prodmean-涉及维度的函数这和-r-中不一样默认都是对列进行操作",
    "title": "matlab 问题集合基础",
    "section": "10、 sum, prod,mean ,… 涉及维度的函数,这和 R 中不一样,默认都是对列进行操作",
    "text": "10、 sum, prod,mean ,… 涉及维度的函数,这和 R 中不一样,默认都是对列进行操作\n\nR 中 一般是 1 代表对行进行操作,apply(A,1,sum)\nMATLAB 一般 1 代表是对列进行操作. sum(A,1)\n\n% matlab\n>> A2 = [1,1/5,1/3,1/9;\n      5,1,4,1/8;\n      3,1/4,1,1/9;\n      9,8,9,1];\n>> sum(A2,1)\nans =\n   18.0000    9.4500   14.3333    1.3472\n>> sum(A2,2)\nans =\n    1.6444\n   10.1250\n    4.3611\n   27.0000\n>> sum(A2)\nans =\n   18.0000    9.4500   14.3333    1.3472\n#  R语言\n> A = matrix(c(1,1/5,1/3,1/9,\n+       5,1,4,1/8,\n+       3,1/4,1,1/9,\n+       9,8,9,1),ncol =4,nrow =4,byrow = T)\n> \n> apply(A,1, sum)\n[1]  1.644444 10.125000  4.361111 27.000000\n> apply(A,2, sum)\n[1] 18.000000  9.450000 14.333333  1.347222\n>"
  },
  {
    "objectID": "posts/matlab/matlab-question.html#matlab归一化问题",
    "href": "posts/matlab/matlab-question.html#matlab归一化问题",
    "title": "matlab 问题集合基础",
    "section": "11、 matlab归一化问题",
    "text": "11、 matlab归一化问题\n均值-方差归一化\n%自带函数 -- MATLAB 默认的方差是 n-1 的\nzscore(A1)\nmapstd(A1)\n% 矩阵方法 -- 其中 std(A1,0,1) : 0 方差是 n-1,\n(A1 - mean(A1,1) ) ./ std(A1,0,1)\n\n% 循环方法\n n = size(A1,1)\n B = zeros(size(A1))\n for i = 1:n\n     B(:,i) =( A1(:,i) - mean(A1(:,i)) ) ./ std(A1(:,i),0,1);\n end\n B\nMax-min 均值化\nmapminmax"
  },
  {
    "objectID": "posts/matlab/matlab-question.html#统计重复出现的此次即频率",
    "href": "posts/matlab/matlab-question.html#统计重复出现的此次即频率",
    "title": "matlab 问题集合基础",
    "section": "12、 —统计重复出现的此次,即频率",
    "text": "12、 —统计重复出现的此次,即频率\ntabulate"
  },
  {
    "objectID": "posts/matlab/matlab-question.html#matlab-保存图片问题",
    "href": "posts/matlab/matlab-question.html#matlab-保存图片问题",
    "title": "matlab 问题集合基础",
    "section": "13、 Matlab 保存图片问题",
    "text": "13、 Matlab 保存图片问题\n保存图片 saveas 图片丢失颜色 —加参数 epsc 即可\nsaveas(gca,'Density.eps','epsc')\nsaveas 指定目录保存\nsaveas(gcf,['D://give/your/path/here/',''filename',bmp);"
  },
  {
    "objectID": "posts/matlab/matlab-question.html#matlab-对缺失值-nan-的处理",
    "href": "posts/matlab/matlab-question.html#matlab-对缺失值-nan-的处理",
    "title": "matlab 问题集合基础",
    "section": "14、matlab 对缺失值 nan 的处理",
    "text": "14、matlab 对缺失值 nan 的处理\nR = rmmissing(A) 从数组或表中删除缺失的条目\nrmmissing(B,1) % nan 所在的行被删除,返回剩余完整的行 (默认)\nrmmissing(B,2) % nan 所在的列被删除,返回剩余完整的列\nB(all(~isnan(B), 2),:)   %同理删除矩阵中缺失的条目\n% 其中 all(A,2) 的意思是如果A的某行没有非零值，那么该行返回值为1，"
  },
  {
    "objectID": "posts/matlab/matlab-R-rank.html",
    "href": "posts/matlab/matlab-R-rank.html",
    "title": "MATLAB 与 R 在排序上的区别",
    "section": "",
    "text": "R语言排序有几个基本函数： sort()；rank()；order()\nsort（）是对向量进行从小到大的排序\nrank（）返回的是对向量中每个数值对应的秩\norder（）返回的值表示位置，依次对应的是向量的最小值、次小值、第三小值......最大值\n> data=c(5,6,8,2,4,9)\n> sort(data)\n[1] 2 4 5 6 8 9\n> rank(data) % 秩,即排序后的位置,比如 data 中的第一个元素 5,在升序排序中是占第 3 个位置,所以返回 3. \n[1] 3 4 5 1 2 6\n> order(data)\n[1] 4 5 1 2 3 6\n\n\n\n[y , index]  = sort(x);\ny 把 x 排列升序后的结果 % 类似 R 中的 sort\nindex 为 x 的秩   % 类似 R 中的 order\n tiedrank(data)  % 类似 R 中的 rank, 返回平均秩,\nans =\n     3     4     5     1     2     6\n>> data=[5,6,8,2,4,9];\n[y, index] =sort(data)\ny =\n     2     4     5     6     8     9\nindex =\n     4     5     1     2     3     6\n 有 y ==  data(index)\n >> tiedrank(data)\nans =\n     3     4     5     1     2     6\n tiedrank([10 20 30 40 20]) % 返回平均秩\n ans =\n    1   2.5    4    5    2\nsortrow(A,2)\n把矩阵 A 按照第 2 列进行升序排序, 默认为第一列,类似 excel 中的表排序"
  },
  {
    "objectID": "posts/matlab/MATLAB_Rcpp_c.html",
    "href": "posts/matlab/MATLAB_Rcpp_c.html",
    "title": "Armadillo + Rcpp VS MATLAB/octave",
    "section": "",
    "text": "http://arma.sourceforge.net/docs.html\n\n\n\n\n\n\n\n\n\n\n\nMatlab/Octave\nArmadillo\nNotes\n\n\n\n\nA,B,C代表矩阵a,b,c 代表向量\nvec x(10);vec y = zeros(10);rowvec x(10); rowvec y = zeros(10); rowvec a = {1,2,3,4};vec b = {1,2,3,4};mat A = randu(10,10);\nC++中要声明向量类型(这里都是 double 类型)vec 默认 colvec(等价),是列向量\n\n\nA(1,1)\nA(0,0)\nC++ 索引从 0 开始\n\n\nA(k,k)\nA(k-1,k-1)\n\n\n\n\n\n\n\n\nsize(A,1)\nA.n_rows\nC++ 中直接利用对象的属性\n\n\nsize(A,2)\nA.n_cols\n\n\n\nsize(Q,3)\nQ.n_slices\n这里 Q 是一个三维数组\n\n\nnumel(A)length(A(:))\nA.n_elem\n矩阵 A 中所有元素的个数,行数\\(\\times\\) 列数\n\n\n\n\n\n\n\nA(:, k)\nA.col(k)\n注意这里的索引问题,为了方便 这里不做转换\n\n\nA(k, :)\nA.row(k)\n\n\n\nA(:, p:q)\nA.cols(p,q)\n\n\n\nA(p:q, :)\nA.rows(p,q)\n\n\n\nA(p:q, r:s)\nA( span(p,q), span(r,s) ) A.submat(p, r, q, s)\n\n\n\n\n\n\n\n\nQ(:, :, k)\nQ.slice(k)\nQ 是一个三维数组\n\n\nQ(:, :, t:u)\nQ.slices(t, u)\n\n\n\nQ(p:q, r:s, t:u)\nQ( span(p,q), span(r,s), span(t,u) )\n\n\n\n\n\n\n\n\nA’\nA.t() trans(A)\n\n\n\nA^(-1)\ninv(A)\n求 A 的逆R 中是: solve(A)\n\n\n\n\n\n\n\nA = zeros(size(A))\nA.zeros()\n把矩阵 A复制为 0 矩阵\n\n\nA = ones(size(A))\nA.ones()\n\n\n\nA = zeros(k)\nA = zeros(k,k)\n创建一个\\(k \\times k\\) 的 0 矩阵,并赋值给 A\n\n\nA = ones(k)\nA = ones(k,k)\n\n\n\n\n\n\n\n\nA + B\nA + B\n\n\n\nA - B\nA - B\n\n\n\nA .* B\nA % B\n\n\n\nA ./ B\nA / B\n\n\n\nA*B\nA*B\n\n\n\nA  B\nsolve(A,B)inv(A)*B\n\n\n\nA / B\n无A*inv(B)\n\n\n\n\n\n\n\n\nA ./ a\nA.each_row() / a\na为行向量 ,C++中不能是列除以行注意和 MATLAB 的区别\n\n\nA ./ b\nA.each_col() /b\nb为列向量,\n\n\nA .* a\nA.each_row() % a\na 为行向量\n\n\nA .* b\nA.each_col % b\nb为列向量\n\n\n\n\n\n\n\nsqrt(A)\nsqrt(A)\n求数组元素的开方\n\n\nA .^ p\npow(A,p)\n求数组元素的次方\n\n\nexp(A)\nexp(A)\n以自然常数为底数的指数\n\n\nlog(A)\nlog(A)\n\n\n\nlog2(A)\nlog2(A)\n这里都是以数组形式运算\n\n\nlog10(A)\nlog10(A)\n\n\n\nsign(A)\nsign(A)\n符号函数\n\n\n\n向量的^ 也可以用 pow计算\n注意,Rcpp 并不提供^运算, 支持向量的 + - * / 以及 == ! = < > > = <=\n\n\n\n\n\n\n\nx = A(:)\nvec x = vectorise(A)\n把矩阵转变为列向量(即按内存排序), C++ 中不能是行向量\n\n\nX = [ A B ]\nX = join_horiz(A,B)\n矩阵的拼接\n\n\nX = [ A; B ]\nX = join_vert(A,B)\n\n\n\n\n\n\n\n\nA = randn(2,4);\nmat A = randn(2,4);\n产生维度为 2*4 的标准正太分布数据\n\n\nA = randi(2,4)\nmat A = randi(2,4)mat A = randi(2,4,distr_param(3,8))\n以$2 $的随机整数,0 到正无穷产生 \\(2 \\times 4\\) 的随机矩阵,范围 [3,8]之间的整数\n\n\nA = randu(2,4)\nmat A = randu(2,4)\n产生维度为 2*4 的标准均匀分布数据\n\n\n\n\n\n\n\na * b\na % b A.row(i)%A.row(i)A.col(i) %A.col(i)\na ,b 为列向量 , 向量对应元素相乘\n\n\n\n\n\n\n\nsum(A,1)sum(A)\nrowvec a = sum(A, 0)rowvec a = sum(A)\nC++. 中 0 代表列 ,1 代表行\n\n\nsum(A,2)\ncolvec a = sum(A,1)\nMATLAB 中 1 代表列, 2 代表行\n\n\nsum(A(:))\ndouble y = aucc(A)\n\n\n\nmean(A)\nmean(A)\n与 sum 函数类似\n\n\nmax(A)max(A,1)max(A,2)\nrowvec a = max(M);rowvec b = max(M,0);colvec c = max(M,1);\n与 sum 函数类似(还有 min 之类的)\n\n\nmin(A)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nValue\nR vector\nRcpp vector\nRcpp matrix\nRcpp scalar\nC++ scalar\n\n\n\n\nLogical\nlogical\nLogicalVector\nLogicalMatrix\n-\nbool\n\n\nInteger\ninteger\nIntegerVector\nIntegerMatrix\n-\nint\n\n\nReal\nnumeric\nNumericVector\nNumericMatrix\n-\ndouble\n\n\nComplex\ncomplex\nComplexVector\nComplexMatrix\nRcomplex\ncomplex\n\n\nString\ncharacter\nCharacterVector(StringVector)\nCharacterMatrix(StringMatrix)\nString\nstring\n\n\nDate\nDate\nDateVector\n-\nDate\n-\n\n\nDatetime\nPOSIXct\nDatetimeVector\n-\nDatetime\ntime_t\n\n\n\n\n\n\nR\nRcpp\n\n\n\n\ndata.frame\nDataFrame\n\n\nlist\nList\n\n\nS3 class\nList\n\n\nS4 class\nS4\n\n\n\n\n\n\n即 Rcpp 中提供了基础 R 中的的一些基本函数,几乎和 基础 R 一样,支持向量运算.\nhttps://teuder.github.io/rcpp4everyone_en/\nhttp://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/rcpp-sugar.html\n\n\n\n\n\n\n\n\n\nRcpp\nC++\nMatlab\nNote\n\n\n\n\nRcout\nstd::cout\n\n\n\n\nRcerr\nstd::cerr\n\n注意这里的四个函数都只能打印一些信息并输出到屏幕,并不能中止程序\n\n\nRprintf( format, variables)\nstd::printf()\n\n\n\n\nREprintf()\n\n\n\n\n\n\n\n\n\n\n\nstop(“范围提示信息”)\n\nerror(‘信息’)\n这要遇到这种情况,后面的程序不再运行直接打印错误信息\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRCPP 提供的迭代器\nNumericVector::iterator\nIntegerVector::iterator\nLogicalVector::iterator\nCharacterVector::iterator\nDataFrame::iterator\nList::iterator\n// [[Rcpp::export]]\ndouble rcpp_sum(NumericVector x) {\n  double total = 0;\n  for(NumericVector::iterator i = x.begin(); i != x.end(); ++i) {\n    total += *i;\n  }\n  return total;\n}\n\ni = v.begin() : 迭代器 i指向v的第一个元素\n++i : Updates i to the state pointing to the next element.\n--i : Updates i to the state pointing to the previous element.\ni + 1 : Represents an iterator pointing to the element 1 elements behind of i.\ni - 1 : Represents an iterator pointing to the element 1 elements ahead of i.\n*i : 表示指针i 指向的元素的值\nv.end() : 表示v的最后一个元素\n*(v.begin()+k) : Represents the value of the k-th element of v ( 即 v[k]).\nv[k] = *(v.begin() + k)"
  },
  {
    "objectID": "posts/matlab/MATLAB-fun-arg.html",
    "href": "posts/matlab/MATLAB-fun-arg.html",
    "title": "MATLAB函数中参数的问题",
    "section": "",
    "text": "函数功能: 返回函数参数数量(一般在函数内部使用)\n　　在函数内部使用时,nargin 和 nargout分别表明有输入和输出参数数量。若在函数外部使用, nargin 和nargout对给定的函数，表明输入和输出参数数量。如果一个函数有可变数量的参数，参数数量为负值。\n\nnargin：返回函数输入参数的数量。\nnargin(fun)：返回函数 fun输入参数数量。如果函数参数数量可变，nargin 返回一个负值。fun 可以是函数名或映射函数的函数句柄。\nnargout：返回函数输出参数的数量。\nnargout(fun)：返回函数fun的输出参数数量。fun可以使函数名或映射函数的函数句柄。"
  },
  {
    "objectID": "posts/matlab/MATLAB-fun-arg.html#inputname-获取函数参数名称返回一个字符串",
    "href": "posts/matlab/MATLAB-fun-arg.html#inputname-获取函数参数名称返回一个字符串",
    "title": "MATLAB函数中参数的问题",
    "section": "2. inputname — 获取函数参数名称,返回一个字符串",
    "text": "2. inputname — 获取函数参数名称,返回一个字符串\n　　函数功能: 返回函数指定输入参数的名称字符串(只能在函数内部使用).\n​ inputname(argnum) : 注意: 这里的 argnum是一个数字,表示第几个参数,返回的是第argnum个参数的名称字符串。如果输入参数没有名称（例如它是一个表达式，而不是一个变量），这时会返回空字符串(’’)。 这个常常和varargin参数一起使用."
  },
  {
    "objectID": "posts/matlab/MATLAB-fun-arg.html#varargin-varargout-可变长输入输出参数",
    "href": "posts/matlab/MATLAB-fun-arg.html#varargin-varargout-可变长输入输出参数",
    "title": "MATLAB函数中参数的问题",
    "section": "3. varargin / varargout — —可变长输入/输出参数",
    "text": "3. varargin / varargout — —可变长输入/输出参数\n函数功能: 在一个函数中，用于表示输入参数不确定的情况(只能在函数内部使用)\n本质上 是一个 cell 数组(大小 1* size(varargin,2)), 它包含了用户输入的参数.\n用 varargin{i} 调用第 i 个参数, 用varargin{:}调用所有的参量;\nfunction varargout = combin_index(varargin)\n%输入可变长参数,以及输出可变长参数,都是放在一个细胞中存储, \n%而inputname 存变量名的方式,用的是cell字符数组矩阵的形式\n% 由于 nargin 参数已经计算了输入参数的总个数. size(varargin,2) 等价(某些情况下)\nvariable_name = cell(1,nargin); % 创建一个 1* nargin 大小的 cell,\nfor i = 1:nargin\n    T = foo(varargin{i});  % 获取的新参数 传递给另一个函数\n    variable_name{i} = inputname(i);  % 由于变量名是字符,所以用细胞来存储\nend\n% variable_name 这个 cell 存储了变量名\n这个varargout一般用的较少…….基本 和 varargin 类似"
  },
  {
    "objectID": "posts/md/latex-bib-csl.html",
    "href": "posts/md/latex-bib-csl.html",
    "title": "latex + bib + csl",
    "section": "",
    "text": "利用 latex 写学术论文, 总爱遇到一个问题, 参考文献的样式问题, 由于 latex 的原因,不能使用 csl 参考样式文件, 因此本应用孕育而生.\n1, 只需要上传对应的 tex 源文件, 以及 bbl 文件和 csl 参考文献, 就能导出格式文件,\n2, 为什么要写这个,不用bst 模板文件 + bbl?\n\n我们导师只需要一个 tex 源文件,其余不相关的文件统统要柔和到一个文件里面,就这么简单.\n\n3, 由于本人能力有限,如有问题,希望批评指正."
  },
  {
    "objectID": "posts/md/添加谷歌分析.html",
    "href": "posts/md/添加谷歌分析.html",
    "title": "添加谷歌网站分析",
    "section": "",
    "text": "直接在config.toml中的googleAnalytics = “” 把自己的Id写进去即可完成."
  },
  {
    "objectID": "posts/md/计算各种距离matlab.html",
    "href": "posts/md/计算各种距离matlab.html",
    "title": "计算各种距离 （matlab）",
    "section": "",
    "text": "观测值对之间的成对距离\nmatlab中自带的计算距离矩阵的函数有两个pdist和pdist2。前者计算一个向量自身的距离矩阵，后者计算两个向量之间的距离矩阵。基本调用形式如下：\n输入： 一个矩阵\n计算方法: 案例计算各自的距离\nD = pdist(X)\nD = pdist(X,Distance)\nD = pdist(X,Distance,DistParameter)\npdist2 — 计算向量之间的距离"
  },
  {
    "objectID": "posts/md/datatable3.html",
    "href": "posts/md/datatable3.html",
    "title": "data.table – 3常见操作",
    "section": "",
    "text": "knitr::opts_chunk$set(message = F,warning = F,comment = \"#&gt;\",collapse = TRUE)\n数据准备"
  },
  {
    "objectID": "posts/md/datatable3.html#两个data.table行合并",
    "href": "posts/md/datatable3.html#两个data.table行合并",
    "title": "data.table – 3常见操作",
    "section": "1. 两个data.table行合并",
    "text": "1. 两个data.table行合并\n##### --- 两个data.table行合并 --两个数据的列数应该相等 ##### \n#### --- 方法一 --纯粹的合并\nrbind(iris_1,iris_2)\n\n### -- 方法2  --- \nl = list(iris_1,iris_2)\nrbindlist(l, use.names=TRUE, fill=TRUE) %&gt;% head()"
  },
  {
    "objectID": "posts/md/datatable3.html#两个data.table列合并",
    "href": "posts/md/datatable3.html#两个data.table列合并",
    "title": "data.table – 3常见操作",
    "section": "2. 两个data.table列合并",
    "text": "2. 两个data.table列合并\n##### --- 两个data.table列合并 --两个数据的行数应该相等\n## --方法一  纯粹的合并\ncbind(iris_1[,1:2],iris_2[,5])\n## --方法2  --- 类似 dplyr包中的链接\n# merge(iris_1[,1:2], iris_2[,5], all=TRUE,sort=F) \n\n## --方法3  --- 类似 dplyr包中的链接\n# dt_a[dt_b,on=.(b = y)]\n多个data.table 合并– 按照自己想要的方式合并\n# Merge multiple data.tables \ndt_list    &lt;- list(dt1, dt2, dt3)\nmerge_func &lt;- function(...) merge(..., all = TRUE, by='carname')\ndt_merged  &lt;- Reduce(merge_func, dt_list)"
  },
  {
    "objectID": "posts/md/datatable3.html#把list类型转变为data.table类型",
    "href": "posts/md/datatable3.html#把list类型转变为data.table类型",
    "title": "data.table – 3常见操作",
    "section": "3. 把list类型转变为data.table类型",
    "text": "3. 把list类型转变为data.table类型\n####  把list类型转变为data.table类型\naa = lapply(1:5, function(x) list('CR' = x,'CSI' = x^2))\naa\nrbindlist(aa)"
  },
  {
    "objectID": "posts/md/datatable3.html#对列进行批量操作",
    "href": "posts/md/datatable3.html#对列进行批量操作",
    "title": "data.table – 3常见操作",
    "section": "4.对列进行批量操作",
    "text": "4.对列进行批量操作\n\n4. 1对列进行操作\n## 对每一列都进行某个操作\niris_1[,lapply(.SD, function(x)length(x))]\n\n## 也可以指定列进行计算\niris_1[,lapply(.SD, function(x){sum(x)/.N}),.SDcol = 1:3]\n# 指定的列，可以使用数字列，也可以使用字符列\n\niris_1[,lapply(.SD, function(x){sum(x)/.N}),.SDcol = c(\"Sepal.Length\",\"Sepal.Width\")]\n\n\n\n\n\n#### 排除列进行操作,  排除列可以用！ 也可用 - \n# eg： 排除某些列，然后对剩下的列进行操作\niris_1 = data.table(iris[1:50,])\niris_1[1:5, lapply(.SD, function(x)x*100 ),.SDcols = !(5)] # 排除第5列，对其余列进行操作\niris_1[1:5, lapply(.SD, function(x)x*100 ),.SDcols = !(4:5)]# \n\niris_1[1:5, lapply(.SD, function(x)x*100 ),.SDcols = -(c(1,5))] \niris_1[1:5, lapply(.SD, function(x)x*100 ),.SDcols = !(c(\"Sepal.Length\",\"Species\"))]\n\n\n\n4.2 对列进行有匹配的筛选\n只用data.table 包\niris_dt = data.table(iris[1:5,])\n# 筛选列名中包含\"Sep\"字符串的列,这类似于shell中的grep命令,或者基本R中的grepl命令\niris_dt[,names(iris_dt) %like% \"Sep\", with=FALSE]\n\n# 筛选列名中包含\"Length\"字符串的列\niris_dt[,names(iris_dt) %like% \"Length\", with=FALSE]\n也可以引进dplyr包进行结合使用，\nlibrary(data.table)\niris_1 = data.table(iris[1:5,])\nlibrary(dplyr)\niris_1[,select(.SD,contains(\"S\"))] # 从列中筛选出列名包含\"S\"的列，这列contains函数不区分大小写\niris_1[,select(.SD,contains(\"s\"))] \n\niris_1[,select(.SD,starts_with(\"Sep\"))]  # 列名是\"Sep\"字符串开始的\niris_1[,select(.SD,ends_with(\"th\"))] # 列名是\"th\"字符串结束的\n\n\niris_1[,select_if(.SD,is.numeric)] # 为数值型属性的列\niris_1[,select_if(.SD,is.factor)] \n\n\n\n\n4. 3 对列进行批量重命名\n\n4.3.1 更新部分列\n** 记住.SD只能用于:=的右边 ，不能用于左边，左边应该是字符、数值格式**\niris_1[,colnames(iris_1[,1:4]) := lapply(.SD[,1:4],function(x) x*100)]\niris_1\n\n# iris_1[,colnames(.SD[,1:4]) := lapply(.SD[,1:4],function(x) x*100)] # 出错\n\n\n4.3.2左边利用数值进行更新列\n# 左边利用数值进行更新列\niris_1 = data.table(iris[1:5,])\niris_1[1:5, (c(2,3,4)):=lapply(.SD, function(x)x*100 ),.SDcols = !(c(1,5))]\niris_1[1:5,]\n\n\niris_1 = data.table(iris[1:5,])\n## 如果左边用数字并打上() 代表第几列，指定第几列的操作\niris_1[,(2:3):=Species] # 把第2：3列的值进行更新，即第2:3列都为Species列\niris_1\n\n\n4.3.3 左边利用字符串更新列\n# 左边利用字符串更新列\n## 对指定的列进行计算 --- 并修改原有的列\niris_1 = data.table(iris[1:5,])\ncol_names = c(\"Sepal.Length\",\"Sepal.Width\")\niris_1[, (col_names) := lapply(.SD, function(x)x*10 ),.SDcols = col_names]\niris_1"
  },
  {
    "objectID": "posts/md/datatable3.html#data.table-数据的重组与拆分",
    "href": "posts/md/datatable3.html#data.table-数据的重组与拆分",
    "title": "data.table – 3常见操作",
    "section": "5.data.table 数据的重组与拆分",
    "text": "5.data.table 数据的重组与拆分\n这里的melt 和cast 针对data.table 进行了优化\n\nmelt — — 把宽格式数据转化成长格式。\ndcast — — 把长格式数据转化成宽格式。参考前面的,这里只讲data.frame, data.table类似\n\n如果不是data.table数据格式，推荐使用tidyr包进行数据的重组与拆分\nmelt(data, id.vars = c(\"\"),#保留的列 ，可以省略(表示不保留列)\n         measure.vars= c(\"\",\"\"), # 指定列进行融合，不指定时表示全部融合，可以使用正则表达式\n         variable.name='variable',value.name = 'value')# 融合后的名字与值\n参见下图：\n\n\n\nmelt"
  },
  {
    "objectID": "posts/md/datatable3.html#实现dplyr中的join_left操作",
    "href": "posts/md/datatable3.html#实现dplyr中的join_left操作",
    "title": "data.table – 3常见操作",
    "section": "6. 实现dplyr中的join_left操作",
    "text": "6. 实现dplyr中的join_left操作\n\n\n\n类型\n语法1\n语法2(推荐)\n\n\n\n\nInner\nX[Y,nomatch=0] 或者Y[X,nomatch=0]\nmerge(X,Y,all=F)\n\n\nLeft\nY[X]\nmerge(X,Y,all.x=T)\n\n\nRight\nX[Y]\nmerge(X,Y,all.y=T)\n\n\nFull\n-\nmerge(X,Y,all=T)\n\n\n\n\n\n\n\n\nmerge(x, y, by = NULL, by.x = NULL, by.y = NULL, all = FALSE,\nall.x = all, all.y = all, sort = TRUE, suffixes = c(\".x\", \".y\"), no.dups = TRUE,\nallow.cartesian=getOption(\"datatable.allow.cartesian\"),  # default FALSE\n...)\n\n参数解释\n    x, y : 需要合并的数据集\n    by : 用于连接两个数据集的列,当两个数据集公共列名相同,可以写成 by = \"公共列名\"\n    by.x, by.y: 用于指定依据那个列合并,常用与当两个数据集公共列名不一样的时候\n    all, all.x, all.y 指定对于的合并类型"
  },
  {
    "objectID": "posts/md/datatable3.html#按照a列分组后找出b列的最大值",
    "href": "posts/md/datatable3.html#按照a列分组后找出b列的最大值",
    "title": "data.table – 3常见操作",
    "section": "7. 按照A列分组后,找出B列的最大值",
    "text": "7. 按照A列分组后,找出B列的最大值\n即选择每组中某列对应最大值的行,\n分组有一个功能,即提取所有的值都是唯一的.\nunique()函数提供的唯一性, 有一定缺陷\n\n作用于向量, 返回唯一的向量, 有重复项默认前面的值作为返回对象\n作用于数据框,返回数据框的每一行都唯一\n不能到达数据框A列保持唯一,若A列有重复项,选择B列中最大的那个值作为返回对象.\n\nID    &lt;- c(1,1,1,2,2,2,2,3,3)\nValue &lt;- c(2,3,5,2,5,8,17,3,5)\nEvent &lt;- c(1,1,2,1,2,1,2,2,2)\ngroup &lt;- data.frame(Subject=ID, pt=Value, Event=Event)\nrequire(data.table) \ngroup &lt;- as.data.table(group)\ngroup\n# 所有最大值\ngroup[group[, .I[pt == max(pt)], by=Subject]$V1,]\n\n# 只想要第一个最大值\ngroup[group[, .I[which.max(pt)], by=Subject]$V1,]# 方法一: 很快\ngroup[, .SD[which.max(pt)], by=Subject]# 方法二: 较慢\n\nhttps://stackoverflow.com/questions/24558328/how-to-select-the-row-with-the-maximum-value-in-each-group"
  },
  {
    "objectID": "posts/md/datatable3.html#按照a列分组后找出b列的第2大的值",
    "href": "posts/md/datatable3.html#按照a列分组后找出b列的第2大的值",
    "title": "data.table – 3常见操作",
    "section": "8. 按照A列分组后,找出B列的第2大的值",
    "text": "8. 按照A列分组后,找出B列的第2大的值\n\ngroup[group[,.I[order(-pt)[2]],by=.(Subject)]$V1,]\n\n\ngroup[,.SD[order(-pt)[2]], by = Subject]\n  ## 方法一:\n  dtf_t = dt[dt[, .I[order(-count_dot,abbr_len)[1]], by=journal_lower]$V1,]\n\n  ## 方法二:\n  dtf = dt[dt[, .I[{\n    temp = which(count_dot == max(count_dot))\n    ifelse(length(temp) == 1, temp, which.min(abbr_len))\n  }], by = journal_lower]$V1,]"
  },
  {
    "objectID": "posts/md/seq函数族.html",
    "href": "posts/md/seq函数族.html",
    "title": "seq*函数族",
    "section": "",
    "text": "主要介绍seq_along(along.with)和seq_len(length.out)函数，应用于循环中\n比如:\n# 要循环某个向量长度的次数,比如向量a，其长度未知\nfor(i in seq_along(a)){...}  代替 for(i in 1:length(a)){...}   ## 经常犯这样的错误，不美观\n\n# 循环中，循环1:10可以用一下方法\nfor(i in seq_len(10)){...}  代替 for(i in 1:10){...} \nhead(x,5) : 取向量的前5个元素，向量 ，数据框 ，list都适用\ntail(x,5): 取向量的后5个元素，等价 x[-(1:(length(x)-5))] 等价 x[(length(n-4):length(n)]"
  },
  {
    "objectID": "posts/md/遗传算法.html",
    "href": "posts/md/遗传算法.html",
    "title": "遗传算法（待完善）",
    "section": "",
    "text": "遗传算法是模仿自然界生物进化机制发展起来的随机全局搜索和优化方法，本质是一种高效、并行、全局搜索的方法。\n\n\n\n\n假设一个具体的问题的解为 \\(X = (x_1,x_2, \\cdots, x_n )\\) ，并且每个变量都有取值范围\\(x_j \\in [a_j,b_j]，j=1,2,\\cdots,n\\).\n\n\n\n\n\n\n\n\n编码方式\n编码\n解码\n\n\n\n\n二进制编码\n第\\(j\\) 个变量用长度为 \\(k_j\\)的二进制编码符号来表示，二进制串编码符号长度与问题所要求的求解进度有关，假设分量\\(x_j\\) 的精度是小数点后4位，则\\(k_j\\)的计算公式如下: \\[ \\log_2^{(b_j-a_j) \\cdot 10^4+1} \\le k_j < \\log_2^{(b_j-a_j) \\cdot 10^4}+1\\]一般地，\\(k_j\\)都取同一个整数​\\(k=max\\{k_j,\\}\\)\n即把二进制串转变为十进制数 假设\\(x_j\\)的编码为\\(c_kc_{k-1}c_{k-2} \\cdots c_2c_1\\),长度为k,则对应解码公式为: \\[x_j = a_j+(\\sum_{i=1}^{k}b_i\\cdot 2^{i-1} )\\cdot  \\frac{b_j-a_j}{2^{k}-1}\\\\ \\]\n\n\n格雷码编码\n类似二进制编码\n类似二进制解码\n\n\n实数编码（也称浮点数编码）\n个体的每个基因值用一定范围的一个实数表示，此时染色体长度等于变量个数。\n一般不需要解码\n\n\n整数编码\n用于特殊的问题（TSP问题）或者其他问题。\n一般不需要解码\n\n\n其他编码方式\n\n\n\n\n\n符号编码： 二进制编码和格雷码编码 统称符号编码。即单个基因无实际意义。有时候整数编码也叫符号编码。\n序号编码： 实数编码和整数编码。\n以下概念都按照二进制编码给出，其余编码几乎都类似。\n\n\n\n染色体：又称个体或者解（即对应问题的解），解\\(X\\)中所有分量按二进制编码并依次排列的二进制串称为染色体。\n\n\n\n基因：染色体上的每一个二进制位都称为一个基因.\n\n\n\n群体： 选定的一组解，其中解的个数为群体的规模。\n\n\n\n选择（又称复制或者选择算子）: 根据各个个体的适应度值，按照一定的规则或者方法从上一代群体中选择出一些优良的个体遗传到下一代群体中。体现了群体中的个体进行优胜劣汰操作。\n一般地，选择的优良个体数目 = 种群数目，是从种群中直接选择与种群数目相等的个体生成新种群。若有重复选取的个体则保留。\n\n\n\n\n\n\n\n\n\n\n名称\n方法\n特点\n\n\n\n\n轮盘赌选择(比例选择)常用\n每一个个体进入下一代的概率等于它的适应值与整个种群适应度值和的比例。具体操作：1.计算出每个个体的概率，并求出累计分布概率，2. 产生随机数，3.若随机数落入对应的累计分布概率的区间中，则选择该个体。\n选择误差较大\n\n\n随机竞争选择\n1. 利用轮盘赌选择方法， 每次选择两个个体，2. 再从两者中选择适应度高的一个个体。\n比轮盘赌选择好\n\n\n最佳保留选择\n1. 利用轮盘赌选择方法选出（种群数目-1）个个体，2. 再从上一代群体中选择适应度最高的那个个体。\n保证迭代终止结果为历代最高适应度个体\n\n\n\n\n\n\n\n交叉：又称交叉算子，将群体内的各个个体随机搭配成对，对每一对个体，以某个概率（称为交叉概率，预先给定）交换他们之间的部分染色体。\n一般地，交叉次数 = 种群数目 \\(\\times\\) 交叉概率。 交叉时直接更新种群，直至达到交叉次数则停止交叉。\n\n\n\n\n\n\n\n\n\n\n\n名称\n具体做法\n特点\n适用编码\n\n\n\n\n单点交叉（符号编码常用）\n\n标准遗传算法\n符号编码\n\n\n两点(三点)交叉\n\n使用较多\n符号编码\n\n\n均匀交叉\n\n无\n符号编码\n\n\n算术交叉 实数编码常用\n算术交叉是指由两个个体的线性组合而产生出两个新的个体。具体交叉公式如下： \\[  \\begin{cases} X_A^{t+1} = \\alpha X_B^{t}+(1-\\alpha ) X_{A}^{t} \\\\X_B^{t+1} = \\alpha X_A^{t}+(1-\\alpha ) X_{B}^{t} \\end{cases}\\]其中\\(X_A^{t},X_B^{t} \\) 第t次进化时要交叉的个体，\\(X_A^{t+1},X_B^{t+1}\\)为交叉产生的新个体， $$ 为一个参数，可以指定为常数，也可以随机产生(常用),也可以根据进化代数所决定。\n无\n序号编码\n\n\n\n\n\n\n\n\n\n\n\n\n\n变异：又称变异算子，对群体中的每一个个体，以某一概率(称为变异概率，预先给定)改变染色体上的一个或者多个基因。\n\n\n\n\n\n\n\n\n\n\n\n名称\n具体做法\n特点\n使用编码\n\n\n\n\n基本位变异（符号编码常用）\n在二进制编码中,1. 对每一个个体，产生一个随机数，2. 若随机数小于变异概率，则此个体准备变异3. 该变异个体随机选取一个基因位，由0变1，或1变0\n标准遗传算法\n符号编码\n\n\n均匀变异\n在实数编码中,1. 对每一个个体，产生一个随机数，2. 若随机数小于变异概率，则此个体准备变异3. 用符合某一范围内均匀分布的随机数来替换该基因\n\n序号编码\n\n\n非均匀变异\n对比与均匀变异，不用均匀分布\n\n序号编码\n\n\n高斯变异（实数编码中常用）\n在实数编码中,1. 对每一个个体，产生一个随机数，2. 若随机数小于变异概率，则此个体准备变异3. 用正太分布的随机数来替换该基因具体法则：3.1 先产生一个随机数\\(p\\)用来决定该基因是加还是减一个数.3.2. 如果随机数\\(p<0.5\\),则\\[该基因  +该基因距离该变量上边界的长度 \\times[1-p^{ \\delta}]\\].3.3如果随机数\\(p>=0.5\\),则 \\[该基因  -该基因距离该变量下边界的长度 \\times[1-p^{ \\delta}]\\] 其中\\(\\delta = (\\dfrac{1-当前种群迭代次数 }{最大迭代次数})^2\\)3.4 具体该加该减视情况而定。\n\n序号编码\n\n\n\n\n\n\n\n1.根据不同问题选择不同的编码方式，选择、交叉、变异对应的算子一般也是不同的。\n2. 编码时初始种群时应该检查每个染色体是否符合解的要求（取值范围或者约束条件），\n3.种群进行交叉（变异）操作一定要检查交叉（变异）后的染色体是否符合解的要求，若不满足，应该重新进行交叉（变异），直到交叉（变异）成功为止.\n\n\n\n\n\n根据实际问题确认参数集\n\n(2)根据参数集进行编码，并且生成初始种群P(1)\n\n通过种群解码得到对应的参数值，并带入目标函数得到适应值。\n群体经过选择、交叉、变异运算后得到下一代群体。\n\n(5)终止条件判断：若达到迭代次数则停止算法，输出群体中的最有解，否则转到(3)\n\n\n\n群体大小，一般取20~100\n终止进化代数, 一般取100~500\n交叉概率, 一般取0.4~0.99\n变异概率,一般取0.0001~0.1\n\n\n\n利用遗传算法求以下问题，并精度为小数点后4位。 \\[\n\\begin{aligned}\n\\max  f(x_1,x_2) & = 21.5 +x_1sin(4\\pi x_1)+x_2sin(20\\pi x_2)  \\\\\ns.t.  &\\begin{cases}\n\\quad & -3.0 \\leq x_1 \\leq 12.1 \\\\\n& 4.1\\leq x_2 \\leq 5.8\n\\end{cases}\n\\end{aligned}\n\\] 具体步骤：\n假设种群大小为10 ，终止进化代数为100，交叉概率为0.4，变异概率为0.1\n\n根据实际问题确认参数集，\n\n​ 该问题的参数集为 \\(X=(x_1,x_2)\\)\n(2)根据参数集进行编码，并且生成初始种群P(1),\n​ 根据其精度要求，利用公式计算出，\\(x_1，x_2\\)分别编码成18位、15位二进制串，并生成10个初始种群P(1).\n​ 具体算法 :\n\\[\n\\begin{aligned}\nx_1: & 17.2042 = \\log_2^{(12.1-(-3.0))\\cdot10^4+1} \\leq 15 < \\log_2^{(12.1-(-3.0))\\cdot10^4}+1 =18.2042 \\text{, 故取18} \\\\\nx_2: & 14.0533=\\log_2^{(5.8-4.1)\\cdot10^4+1} \\leq x_2 < \\log_2^{(5.8-4.1)\\cdot10^4}+1 = 15.0532 \\text{,故取15，}\n\\end{aligned}\n\\]\n所以该问题的染色体长度为33，即所有变量的二进制长度之和。\n但为了方便一般变量\\(x_2\\)的长度也为18，故染色体长度为 \\(36=18 \\times 变量个数\\).\n\n通过种群解码得到对应的参数值，并带入目标函数得到适应值。\n\n​ 若染色体二进制为111101001110101010'000000010101101010 可解码为\\(X=(11.446273,4.171908)\\) .然后在带入目标函数得到适应值，\n记住：有10个染色体，对应10个适应度值\n\n群体经过选择、交叉、变异运算后得到下一代群体。\n\n选择（轮盘赌选择方法）： 把适应度值进行求和归一化当做概率，用累计概率把区间[0,1]划分成10份，然后产生10个随机数，若随机数落入对应的区间内，则选择该染色体，作为下一代种群（有重复的染色体，不用删除，每个染色体独立）。\n交叉（单点交叉）：基于选择产生的染色体，也产生10个随机数，如对应的随机数低于交叉概率，则选择用来交叉，交叉点的位置也是随机的。\n变异（基本位变异）： 基于交叉产生的染色体，也产生10个随机数，如对应的随机数低于变异概率，则用来变异，变异点的位置也是随机的。\n于是新的一代种群产生了。\n(5)终止条件判断：若达到迭代次数则停止算法，输出群体中的最有解，否则转到(3)\n\n\n\n需要用到遗传算法工具箱，需要自己配置\n%% 清空所有\nclc\nclear all\nclose all\n%% 定义目标函数值--用向量的形式定义方便以后调用\n%ObjFun = @(x,y)21.5+x.*sin(4*pi.*x)+y.*sin(20*pi.*y);\nObjFun = @(X)-(21.5+X(:,1).*sin(4*pi.*X(:,1))+X(:,2).*sin(20*pi.*X(:,2)));\n\n%% 定义遗传算法初始参数\nNIND = 100;  % 个体数目，或者种群大小（Number of individual）\nMAXGEN = 500 ;  %最大遗传代数 （Maximum number of generation）\nNVAR = 2; % 变量的数目，此处为x1 x2两个变量，所以染色体长度为NVAR * PRECI\nPRECI = 18; % 变量的二进制位数（Precision of variable ）若当某个变量长度不一样时，取所有变量中编码最长的那个, \nGGAP = 0.9; % 代沟(Generation gap )，\npx = 0.7; % 交叉概率\npm =0.01; % 变异概率\n\n%% 建立区域描述器(Build field descriptor),一种特殊矩阵结构。\n% 区域描述器结构FieldD =  [len;lb;ub;code;scale;lbin;ubin]\n%  其中 len 表示染色体长度；\n%  lb、ub 分别指每个变量使用的下界和上界\n% code 指明该二进制串是用的什么编码（0代表格雷编码，1代表二进制编码）,常用二进制编码\n% scale是否使用对数刻度（为0表示算术刻度，1代表对数刻度），常用算术刻度\n% lbin和ubin 表示是否包含变量的上下边界,0表示不包含，1表示包含 ，\n%其中rep函数重复某个元素(or矩阵)扩充为指定维度\nFieldD = [rep([PRECI],[1,NVAR]);[-3.0 4];[12.1 5.8];[1,1];[0 0];[1 1];[1 1]];\n\n% 也可以简化为 \n%FieldD = [rep([PRECI],[1,NVAR]);rep([-10,15],[1,NVAR]);rep([1;0;1;1]),[1,NVAR]];\n% rep([PRECI],[1,NVAR])表示为染色体长度 ---对应参数len；\n% rep([-10,15],[1,NVAR]) 所有变量的上下界 ---- 对应参数lb和ub;\n% rep([1;0;1;1]),[1,NVAR] 基本的参数\n\nChrom = crtbp(NIND,NVAR * PRECI);% 随机创建初始种群，行代表一个染色体（即个体），NVAR * PRECI 代表染色体长度，每一个变量的长度为PRECI。\n\n%% 遗传算法优化\ngen = 0 ; % 迭代计数器\nX = bs2rv(Chrom,FieldD);%初始种群转变为十进制数,即解空间\nObjV = ObjFun(X);%计算初始种群的目标函数值\n% 优结果的初始跟踪\n%trace = zeros(3,MAXGEN) ;% 由于本题巧好是两个变量，方便画图，可用此种方法代替，3代表比变量数目多1，每一列代表每一代种群的最有解和对应的适应度值（最后一个）,\ntrace = zeros(2,MAXGEN);%通用方法\nwhile gen <MAXGEN \n    FitnV = ranking(ObjV);  %分配适应度 (Assign fitness values),这里求最小值\n    SelCh = select('sus',Chrom,FitnV,GGAP);%选择\n    SelCh = recombin('xovsp',SelCh,px);% 交叉\n    SelCh = mut(SelCh,pm); %变异\n    X = bs2rv(SelCh,FieldD);% 子代个体转变为十进制数\n    ObjVSel = ObjFun(X); %子代个体的适应度值计算\n    [Chrom,ObjV]=reins(Chrom,SelCh,1,1,ObjV,ObjVSel);%重插入子代到父代，得到新种群\n    gen = gen+1;  % 迭代计数器更新\n    [Y,I] = min(ObjV);% 获取每代的最有解以及其序号，Y为最优解，I为最有解的个体序号（即种群中所在的行数）\n    % 对应设置trace = zeros(3,MAXGEN) ;\n    %trace(1:2,gen) = X(I,:); % 记下每一代的最有解，因为有两个变量,gen控 制trace矩阵的列,\n    %trace(3,gen) = Y;%记下每一代的最有解对应的适应度值\n    trace(1,gen)= Y;%记下每一代的最有解对应的适应度值\n    trace(2,gen)= sum(ObjV)/length(ObjV);\nend\n% 求出最有解\n[Y,I] = min(ObjV);\nX(I,:)  % 最有解\nY       %对应的最优适应度值\n\n% 画出寻优结果轨迹图\nfigure(1);\nplot(trace(1,:));hold on;\nplot(trace(2,:),'-.');grid;\nlegend('种群均值的变化','解的变化');\n\n%% 画出函数图\nfigure(2);\nlbx = -3.0 ; lux = 12.1;\nlby = 4.1 ; luy= 5.8;\nezmesh('21.5+x*sin(4*pi*x)+y*sin(20*pi*y)',[lbx,lux,lby,luy],1000)\nhold on;\n    \n\n\n\n手写\n主函数如下:\n%%%%% 不用遗传算法工具箱，手写\n%% 清空所有\nclc\nclear all\nclose all\n%% 定义目标函数值--用向量的形式定义方便以后调用\nObjFun = @(X)-(21.5+X(:,1).*sin(4*pi.*X(:,1))+X(:,2).*sin(20*pi.*X(:,2)));\n%% GA \npopsize =100; % 种群规模\nlenchrom =3  ;% 变量字符串长度\npc = 0.7;  % 交叉概率\npm = 0.3;% 变异概率\nmaxgen = 100; %进化次数\n% 变量的取值范围\npopmax =12;\npopmin =-5;\nbound = [popmin popmax;popmin popmax;popmin popmax];\n%% 产生初始种群\nfor i = 1:popsize\n    GApop(i,:) = Code(lenchrom,bound);%随机产生一个染色体--采用实数编码\n    fitness(i) = ObjFun(GApop(i,:));% 计算该染色体的适应度\nend\n% 找到初始种群中最好的染色体和对应的适应度值，并且设置当前的最好染色体和适应度值为全局最好\ngbest = GApop;  %当前种群所有的染色体为个体最佳\nfitnessgbest=fitness;% 当前种群中所有染色体的适应度值为个体最佳适应度\n[bestfitness,bestindex] = min(fitness);\nzbest =GApop(bestindex,:);% 当前最好的染色体为全局最佳染色体\nfitnesszbest=bestfitness;% 当前最好的染色体对应的适应度值为全局最佳染色体适应度值\nyy(1) = fitnesszbest;  % 存储每一代的最优适应度值\n%% 迭代寻优\nfor i = 1:maxgen\n    GApop = Select(GApop,fitness,popsize);% 选择\n    GApop=Cross(pc,lenchrom,GApop,popsize,bound);% 交叉操作 GA \n    GApop=Mutation(pm,lenchrom,GApop,popsize,[i maxgen],bound);% 变异操作 GA\n    pop=GApop;\n    for j = 1:popsize\n        fitness(j)= ObjFun(pop(j,:));\n        % 个体最有值更新\n        if fitness(j)<fitnessgbest(j)\n            gbest(j,:) = pop(j,:);\n            fitnessgbest(j) = fitness(j);\n        end\n        % 群体最有值更新\n        if fitness(j) <fitnesszbest\n            zbest= pop(j,:);\n            fitnesszbest = fitness(j);\n        end\n    end\n    yy(i+1) = fitnesszbest;\nend\n \n%% 输出结果\ndisp('最优值：')\nzbest\ndisp('最优适应度：')\nfitnesszbest\n\n%% 画图 -- 进化次数与适应度之间的关系图（折线图）\nfigure(1)\nplot(yy,'linewidth',2);\ntitle(['适应度曲线' ,'终止代数=',num2str(maxgen)]);\nxlabel('进化代数');ylabel('适应度');\ngrid on ;\n染色体编码如下：\nfunction ret = Code(lenchrom,bound)\n% 本函数将变量编码成染色体，用于随机初始化一个种群\n% lenchrom  input : 染色体长度\n% bound     input ： 变量的取值范围\n% ret       output : 染色体的编码值\nflag = 0 ;\nwhile flag ==0\n    pick = rand(1,lenchrom);\n    ret = bound(:,1)'+(bound(:,2)-bound(:,1))'.*pick;%线性插值,bound(:,1)表示变量的下界。\n    flag = test(lenchrom,bound,ret);%染色体可行性检查\nend\n染色体可行性检查(若有多的约束自己加，也可以加到目标函数中)\nfunction flag = test(lenchrom,bound,code)\n% lenchrom input : 染色体长度\n% bound    input : 变量的取值范围\n% code  output: 染色体的编码值\n% 初始变量 \nflag =1;\n[n,m] = size(code);\nfor i = 1:n\n    if code(i)<bound(i,1) || code(i)>bound(i,2)\n        flag =0;\n    end\nend\n选择算子如下：\nfunction ret=Select(individuals,fitness,sizepop)\n% 本函数对每一代种群中的染色体进行选择，以进行后面的交叉和变异 \n% individuals input : 种群信息\n% fitness input : 适应度\n% sizepop input : 种群规模\n% ret   output : 经过选择后的种群\n\nsumf = cumsum(fitness./sum(fitness));%累计概率\nindex = [];\nfor i = 1:sizepop\n    pick = rand ; % 产生随机数\n    for j = 1:sizepop\n        if pick <= sumf(j)\n            index =[index j];\n            break;\n        end\n    end\nend\n\nindividuals = individuals(index,:);\nfitness=fitness(index);\nret = individuals;\n交叉算子如下：\nfunction ret=Cross(pcross,lenchrom,chrom,sizepop,bound)\n%本函数完成交叉操作\n% pcorss                input  : 交叉概率\n% lenchrom              input  : 染色体的长度\n% chrom                 input  : 染色体群\n% sizepop               input  : 种群规模\n% ret                   output : 交叉后的染色体\n\nfor i=1:sizepop \n    \n    % 随机选择两个染色体进行交叉\n    pick=rand(1,2);\n    while prod(pick)==0 %检查产生的两个随机数是否存在0 \n        pick=rand(1,2);\n    end\n    index=ceil(pick.*sizepop);% ceil  向上取整\n    % 交叉概率决定是否进行交叉\n    pick=rand;\n    while pick==0\n        pick=rand;\n    end\n    if pick>pcross\n        continue;\n    end\n    flag=0;\n    while flag==0\n        % 随机选择交叉位置\n        pick=rand;\n        while pick==0\n            pick=rand;\n        end\n        pos=ceil(pick.*sum(lenchrom)); %随机选择进行交叉的位置，即选择第几个变量进行交叉，\n                                       % 注意：两个染色体交叉的位置相同\n        pick=rand; %交叉开始\n        v1=chrom(index(1),pos); \n        v2=chrom(index(2),pos);\n        chrom(index(1),pos)=pick*v2+(1-pick)*v1;\n        chrom(index(2),pos)=pick*v1+(1-pick)*v2; %交叉结束\n        flag1=test(lenchrom,bound,chrom(index(1),:));  %检验染色体1的可行性\n        flag2=test(lenchrom,bound,chrom(index(2),:));  %检验染色体2的可行性\n        if   flag1*flag2==0\n            flag=0;\n        else flag=1;\n        end    %如果两个染色体不是都可行，则重新交叉\n    end\nend\nret=chrom;\n变异算子如下：\nfunction ret=Mutation(pmutation,lenchrom,chrom,sizepop,pop,bound)\n% 本函数完成变异操作\n% pcorss                input  : 变异概率\n% lenchrom              input  : 染色体长度\n% chrom                 input  : 染色体群\n% sizepop               input  : 种群规模\n% pop                   input  : 当前种群的进化代数和最大的进化代数信息\n% ret                   output : 变异后的染色体\n%pm,l       enchrom,GApop,popsize,[i maxgen],bound\n%pmutation,lenchrom,chrom,sizepop,pop,      bound\n%pmutation = pm,lenchrom = lenchrom,chrom= GApop,sizepop=popsize,pop=[1 maxgen]\nfor i=1:sizepop  \n    % 随机选择一个染色体进行变异\n    pick=rand;\n    while pick==0\n        pick=rand;\n    end\n    index=ceil(pick*sizepop);\n    % 变异概率决定该轮循环是否进行变异\n    pick=rand;\n    if pick>pmutation\n        continue;\n    end\n    flag=0;\n    while flag==0\n        % 变异位置\n        pick=rand;\n        while pick==0\n            pick=rand;\n        end\n        pos=ceil(pick*sum(lenchrom));  %随机选择了染色体变异的位置，即选择了第pos个变量进行变异\n        v=chrom(i,pos); %选择第i个染色体的第pos位置的基因（即第pos个变量）\n        v1=v-bound(pos,1); % 计算该基因距离所处变量下界的长度\n        v2=bound(pos,2)-v;% 计算该基因距离所处变量上界的长度\n        pick=rand; %变异开始-- 应该用的是高斯变异\n        if pick>0.5\n            delta=v2*(1-pick^((1-pop(1)/pop(2))^2));\n            chrom(i,pos)=v+delta;\n        else\n            delta=v1*(1-pick^((1-pop(1)/pop(2))^2));\n            chrom(i,pos)=v-delta;\n        end   %变异结束\n        flag=test(lenchrom,bound,chrom(i,:));     %检验染色体的可行性\n    end\nend\nret=chrom;\n算法程序链接（二进制与实数编码）：遗传算法"
  },
  {
    "objectID": "posts/md/environment.html",
    "href": "posts/md/environment.html",
    "title": "环境",
    "section": "",
    "text": "详细的解释可以查看书《高级R语言编程指南》,这里总结一份与环境有关的函数总结：(参考R语言核心技术手册第二版)\n\n\n\n\n\n\n\n\n函数\n描述\n\n\n\n\n\nassign\n在envir环境中将名称x赋给value对象\n\n\n\nget\n在envir环境中获得与名称x关联的对象\n\n\n\nexists\n判断在环境envir是是否定义了名称x\n\n\n\nobjects\n以向量的形式返回envir环境中定义的所有(对象)名称\n\n\n\nremove\n从envir环境中将参数中罗列的对象删除(列表不适合作为参数的名称，尤其当参数是向量时)\n\n\n\nsearch\n以向量的形式列出全局环境的所有父环境，也称为搜索路径\n\n\n\nsearchpaths\n以向量的形式返回全局环境的所有父环境的路径\n\n\n\nattach\n将列表、数据框或数据文件中的对象添加到当前的搜索路径中\n\n\n\ndetach\n将列表、数据框或数据文件中的对象从当前的搜索路径中删除\n\n\n\nemptyenv\n空环境对象，它是所有环境的祖先，也是唯一一个没有父环境的的环境\n\n\n\nparent.env\n查看envir环境的父环境\n\n\n\nbaseenv\n基础环境，它是R基础软件包的环境，它的父环境是空环境\n\n\n\nglobalenv(或.GlobalEnv)\n用户的工作环境，也叫全局环境，通常情况下我们就是在这个环境中工作的，全局环境的父环境是由library() 或require()添加的最后一个添加包\n\n\n\nenvironment\n它是当前环境，(默认情况下，当前环境等于全局环境)\n\n\n\nnew.env\n手动创建一个新的环境对象\n\n\n\nparent.frame\n返回函数被调用的环境 ,即可以访问调用环境的父环境，常常作为参数使用，需要搭配其他函数eg:eval\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n调用栈的操作\n\n\n\n\n\n\n\n函数\n描述\n\n\n\n\nsys.call\n返回一个包含当前函数调用(包括参数)的语言对象\n\n\nsys.frame\n返回调用环境\n\n\nsys.nframe\n返回当前帧的编号(即在调用堆栈中的位置)，如果在R控制台中调用该函数，返回值为0,\n\n\nsys.function\n返回当前计算的函数\n\n\nsys.parent\n返回父环境的编号\n\n\nsys.calls\n返回栈中所有帧的调用\n\n\nsys.frames\n返回栈中所有的环境\n\n\nsys.parents\n返回栈中每个帧的父帧\n\n\nsys.on.exit\n返回当前on.exit所使用的表达式\n\n\nsys.status\n返回一个列表\n\n\nparent.frame\n返回sys.frame(sys.parent(n)) ,即返回函数被调用的父环境，即允许访问调用父环境.常常作为参数使用，需要搭配其他函数eg:eval\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n《R语言核心编程技巧第二版》"
  },
  {
    "objectID": "posts/md/datatable2.html",
    "href": "posts/md/datatable2.html",
    "title": "data.table – 2基本概念",
    "section": "",
    "text": "set* 函数族 会改变原有的数据，没有返回值，在data.table里，操作符\":=\"和所有的以set开头函数（比如setkey,setorder,setname等）一样，它们都会更新输入的原数据。\nlibrary(data.table)\niris_dt = data.table(iris)\n# setnames(DT,oldnames,newnames) # 改变DT的列名oldnames,newnames为向量即变量\n\n#改变列的顺序\ncol_names = colnames(iris_dt)\nsetcolorder(iris_dt,col_names[5:1])\n\n# 更改某行某列的值,即更新元素的值\nset(iris_dt,1,1,NA)# 更改1行1列的值为NA\n\n\n\ndata.table从来不使用行名。data.table类似有行名的形式为1:，2: , ...\n主键会对筛选的列进行重排序\n我们把data.table数据中的行名叫做键（或主键），他类似于python的字典，使用键值对类型查找数据，键要求唯一，每一行有且只有一个键。但是R中的键可以用多个甚至可以重复，键就相当于索引，通过键进行数据的查找\nsetkey() 和 setkeyv()可以直接更新输入的data.table，就和上一讲中的操作符”:=“一样。它们没有返回值。\n这个主键和其它语言不一样，例如python的键，唯一，在r中任意列都能使用setkey()来设置主键\n\nlibrary(data.table)\nmtcars_dt &lt;- data.table(mtcars)  # 可以看出mtcars数据集中的行名没有了，替而代之为1: ，2:\n\n# 若想保留行名，设置keep.rownames = T，当keep.rowname＝\"new\"时，列名改为new即可\nmtcars_dt &lt;- data.table(mtcars,keep.rownames = T)#默认创建一个叫做 rn的列，并且将行名赋值给这一列。\nmtcars_dt\n\n\n怎么将数据中的某一列设置为主键呢？—setkey()函数\n\nsetkey(DT, key)将DT中的key列设置为主键，但是类行名 1:，2:,…,不会发生改变,\n上面等价setkeyv(DT, \"key\") ，也将DT中的key列设置为主键\n一旦将某一列设置成data.table的主键，就可以在参数i里指定 .()来subset那些主键了(就可以进行行筛选了)。我们还是用mtcars数据集，我们增加一个新列new\n\nmtcars_dt &lt;- data.table(mtcars)\nmtcars_dt[,new:=Sys.Date()+1:32] #增加一列new，内容为时间\nsetkey(mtcars_dt,new)\nmtcars_dt   # 类似行名并没有发生改变，\nmtcars_dt[.(Sys.Date()+1)]\nkey(mtcars_dt)    #查询设置主键的列名\n\n\n# 也可以在r中任意列都能使用setkey()来设置主键\nsetkey(mtcars_dt,cyl,vs)    #会把先前设置的new主键给覆盖掉\nmtcars_dt[.(4,1)]   #如果主键是字符型的列，那么可以省略 .()\nkey(mtcars_dt)  #查询设置主键的列名\n\nhaskey(mtcars_dt) # 返回TF值，检查是否有Key\n\n\n\n\n二级索引和data.table的主键类似（二级索引不重排序，主键会重排序），但有以下两点不同：\n\n它不会再内存里将整个data.table重新排序（setkey会）。它只会计算某列的顺序，将这个顺序向量保存在一个额外的，叫做index的属性里面。\n一个data.table可以有多个二级索引，我们把主键与二级索引提取行方法进行对比\n\n# 设置主键的过程\nmtcars_dt &lt;- data.table(mtcars)\nmtcars_dt[,new:=Sys.Date()+1:32] #增加一列new，内容为时间\nsetkey(mtcars_dt,cyl,vs)    #设置主键\nmtcars_dt[.(4,1)]   #提取cyl==4,vs==1的所有行\n#  设置二级索引的过程--方法1\nmtcars_dt &lt;- data.table(mtcars)\nmtcars_dt[,new:=Sys.Date()+1:32] #增加一列new，内容为时间\nsetindex(mtcars_dt,cyl,vs)# 把cyl,vs两列都设置二级索引的过程--方法1\nmtcars_dt   # 等价 setindexv(mtcars_dt,\"cyl\",\"vs\")\n\n#注意mtcars_dt实际上没有按照cyl列的升序重新排列。还记得吗？setkey()会重新排序！\n# setindex(mtcars_dt,NULL)  会删除所有的二级索引。\nindices(mtcars_dt,vectors = FALSE)#  获取数据的二级索引,  默认为FALSE\nsetindex(mtcars_dt,new) #再次建立一个二级索引\nindices(mtcars_dt)# 查看二级索引，可以发现在原有的二级索引上追加了新的索引，不会覆盖，还记得setkey(mtcars_dt,cyl,vs)会把先前设置的new主键给覆盖掉\n\n参数on能自动创建并重用二级索引－－等价setindex() 函数\n通过创建索引进行subset。每次都能节省setindex()的时间。\n通过检查属性，可以简单地重用已经存在的二级索引。\n语法简单。\n在参数i里面指定取值，在参数on里面指定列名。参数on必须是一个字符型的向量。\n注意参数on也可以用来指定主键。事实上，为了更佳的可读性，我们鼓励在参数on里面指定主键。\n\n#  设置二级索引的过程--方法2\nmtcars_dt &lt;- data.table(mtcars)\nmtcars_dt[,new:=Sys.Date()+1:32] #增加一列new，内容为时间\nmtcars_dt[.(6),on=\"cyl\"]#当为字符时，可以省略.()\nmtcars_dt[.(6,3),on=c(\"cyl\",\"gear\")]#同时满足cyl=6,gear=3的行\n主键与索引用来提取行，对参数i处理的一个变形，可以结合j，by参数进行处理\n\n\n\n\n\n对于每次查询指定所有符合条件的行都被返回，若只返回第一行／最后一行设置为“first”或“last”。\n\n\n\n指定在没有找到符合条件的数据的情况下，是返回NA。设置 nomatch = 0L 跳过哪些不存在的数据\nlibrary(data.table)\nlibrary(magrittr)\niris_dt = data.table(iris) \niris_dt[.(5.1), on='Sepal.Length'] %&gt;% head(3)\niris_dt[.(100), on='Sepal.Length'] # 没有找到Sepal.Length==100 的行,则返回NA\niris_dt[.(100), on='Sepal.Length', nomatch = 0]\n\n\n\n\n\n\nmelt(data, id.vars, measure.vars, \n    variable.name = \"variable\", value.name = \"value\", \n    ..., na.rm = FALSE, variable.factor = TRUE, \n    value.factor = FALSE, \n    verbose = getOption(\"datatable.verbose\"))\n\n参数 measure.vars 指定了想要拆分（或合并）的列。我们也可以指定索引而不是列名。\n默认variable列是 factor类型的。如果你想返回一个字符型的向量，可以将参数 variable.factor 设为 FALSE。参数 variable.factor 是data.table的函数melt() 里独有的，增强包reshape2 里面没有这个参数。\nvariable.name = “variable”, value.name = “value”, 会把转化后的列被自动命名为 variable 和 value（默认值）。\n在结果里，函数melt() 保持了原来列的属性。\n\n\n\n\ndcast(data, formula, fun.aggregate = NULL, sep = \"_\", \n    ..., margins = NULL, subset = NULL, fill = NULL, \n    drop = TRUE, value.var = guess(data),\n    verbose = getOption(\"datatable.verbose\"))\n\n函数 dcast() 使用了操作符“~”，左边是作为 id.vars 的列，右边是作为 measure.vars 的列。\n参数 value.var 指定了需要被分拆扩张的列。\n函数 dcast() 也会在结果中尽量保持原来的属性\n可以给参数 fun.aggregate 传递一个函数。当操作符“~”不方便指定列名的时候，这个功能特别有用。\n\n\n\n\n\n\nrleid —- 计算某向量的游程数（游程数：每次连续作为一组）（可以结合by参数使用）\n\nDT = data.table(grp=rep(c(\"A\", \"B\", \"C\", \"A\", \"B\"), c(2,2,3,1,2)), value=1:10)\nDT\nrleid(DT$grp) # 获取DT$grp的游程数，返回一个和原向量等长的向量\nrleidv(DT, \"grp\") # 与上面等价\n\nrleid(DT$grp, prefix=\"grp\") # 在游程数前面加\"grp\"\n\n# 也可以按游程数进行分组，并计算其游程数的个数等操作\nDT[, .N, by=.(rleid(grp))]\n\nrowid —–某个值在向量中出现的次数，出现第几次就显示为几\n\n\nDT = data.table(x=c(20,10,10,30,30,20), y=c(\"a\", \"a\", \"a\", \"b\", \"b\", \"b\"), z=1:6)\nDT\nrowid(DT$x) # 1,1,2,1,2,2\nrowidv(DT, cols=\"x\") # 和上面等价\n\nrowid(DT$x, prefix=\"group\") # 数字前面加\"group\"\n\n# 多列组合,看每一行的所有元素是否相同，相同则计数+1\nrowid(DT$x, DT$y)#等价rowidv(DT, cols=c(\"x\",\"y\")) \n\nDT[, .(N=seq_len(.N)), by=.(x,y)]$N # 上面相当于做了这样的事\n# 应用\ndcast(DT, x ~ rowid(x, prefix=\"group\"), value.var=\"z\") #\n\ntstrsplit —字符串拆分函数，类似strsplit函数,只不过结果和strsplit进行了转置\n\nname &lt;- 1:3\ndates &lt;- c(\"2016-3-4\",\"2016-3-14\",\"2016-3-24\")\nnd &lt;- data.table(name,dates)\nnd\nstrsplit(dates,\"-\")\ntstrsplit(dates,\"-\") \nnd[,c(\"year\",\"month\",\"day\"):=tstrsplit(dates,\"-\")] # 实现拆分\nnd\n\n\n\n\n\n\n\n\n\n\n函数\n功能\n\n\n\n\n%between%\n快速查找某一区间：mtcars_dt[disp %between% c(150,200)]# 150&lt;= disp &lt;= 200之间DT[c %between% list(a,b)]#a列 &lt;= c &lt;=b 列之间(向量版本)\n\n\n%chin%\n快速匹配 （%in% 的加速版）： x %chin% table\n\n\n%inrange%\n快速查找某一区间： dft[V1 %inrange% c(50,60)] 即选择50 &lt;= V1 &lt;=60所有的行dft[V1 %inrange% list(V2,V3)] 即选择 V2 &lt;= V1 &lt;= V3的所有行\n\n\nA %like% B\n匹配字符串A中含有B的字符\n\n\n.I\n表示（分组后）每一行在原数据框中是第几行 dft[,.I[2],by=accept].I是一个整数向量，等于seq_len(nrow(x)), While grouping, it holds for each item in the group, its row location in x. This is useful to subset in j; e.g.DT[, .I[which.max(somecol)], by=grp]. 结合by,提取子集时,非常有用\n\n\n.N\n.N 代表行的数量，用by参数分组时则是每一组的行数量\n\n\n.SD\n是经过i 和by 处理之后剩下的那部分数据集,本质是一个data.table\n\n\n.SDcols\n.SDcols 指定.SD 代表的数据框包括哪些列\n\n\nsetDF(DT)\n将data.table转化为data.frame\n\n\nsetDT(df)\n将data.frame转化为data.table\n\n\nsetnames(DT,old,new)\n修改列名 也可以通过重新赋值操作 colnames(DT)\n\n\nfsort\n排序\n\n\nfrank\n求秩, 类似rank\n\n\nfintersect(x, y, all = FALSE)\nx与y的交集,相比于基础函数(默认为FALSE)， 增加了all参数，控制重复值\n\n\nfsetdiff(x, y, all = FALSE)\nx与y的差集，即x-y\n\n\nfunion(x, y, all = FALSE)\nx与y的并集\n\n\nfsetequal(x, y)\n检验x与y二者是否完全相等,返回逻辑值\n\n\nshift(x,n=1L,...)\n把向量x向前移动或者向后移动n个数字\n\n\n\n\n\n两者都是选择某列的值在一个范围内的所有行,即 \\(a \\leq c \\leq b\\)\nDT[c %between% list(a,b)] 这里的a,b 一定是DT自身的列名\nDT[c %inrange% list(a,b)] 这里的a,b 不是DT自身的列名,可以是外部的变量\n\n\n\nDT &lt;- data.table(A=1:5)\nDT[ , X := shift(A, 1, type=\"lag\")]\nDT[ , Y := shift(A, 1, type=\"lead\")]\nDT[ , Y1 := shift(A, 2, type=\"lead\")]\nDT\n\n\n\n由于data.table 没有行号,因此.I()一般不单独使用\nmtcars_dt &lt;- data.table(mtcars) \nmtcars_dt[, .I[cyl==6]] # 返回 cyl ==6 所在的行号\n## 等价于\nmtcars_dt[, which(cyl==6)]\n\n\n\n.SD代表行经过i 筛选后, 列除了by参数指定的列以外的所有列组成的新的data.table, 是原数据的子集\nlibrary(data.table)\nmtcars_dt = data.table::as.data.table(mtcars)\nmtcars_dt[, .SD, by=cyl]\noutput &lt;- mtcars_dt[, lapply(.SD[, 1:10, with=F], mean), by=cyl]\noutput\n\n\n\n\nset(x, i = NULL, j, value)\n作用: 将value 值快速分配给i行j列元素, i , j 使用整数10L 而不是10, j参数不能省\nm = matrix(1,nrow=3,ncol=4)\nDT = as.data.table(m)    \nset(DT,3L,1L,10)# 第3行第1列元素改为10\nset(DT,,2L,20) # 第2列的所有元素都改为20\nDT\n\n\nm = matrix(1,nrow=100000,ncol=100)\nDF = as.data.frame(m)\nDT = as.data.table(m)  \nDT2 = copy(DT)\nsystem.time(for (i in 1:10000) DF[i,1] &lt;- i)\nsystem.time(for (i in 1:10000) DT[i,V1:=i])\nsystem.time(for (i in 1:10000) set(DT2,i,1L,i*10))\n\n\n\n在控制台中输入options()会打印出一个list，这是当前的options设置值，比如显示保留几位小数等。加载data.table包之后，这里新增了一些data.table专用的参数，可以用下面的命令查看\nops &lt;- options() # ops就是一个list，参数和值的一一对应\n# 由于data.table专用参数都是以datatable为前缀，使用我们输入时可以这样\nops$datatable.print.nrows # 返回100，设置打印的最大行数，超过了则简单打印\ngetOption(\"datatable.print.topn\") #返回5，简单打印设置，前后各5行，其余行省略"
  },
  {
    "objectID": "posts/md/hugo---分类标签添加.html",
    "href": "posts/md/hugo---分类标签添加.html",
    "title": "hugo–分类标签添加",
    "section": "",
    "text": "2、也可以在导航栏添加一个分类汇总页面\n    [[menu.main]]\n    name = \"Tag\"\n    url = \"/tags/\"\n把terms.html文件拷贝到 _default下\n<meta charset=\"utf-8\"> {{ partial \"header.html\" . }}\n<main class=\"content\" role=\"main\">\n     <article class=\"article\">\n    <div class=\"tags0\">\n        <h1 class=\"tags1\">分类标签有{{ len .Data.Terms }}个</h1>\n\n        {{ $data := .Data }} {{ range .Data.Terms.ByCount }} {{ $termLink := printf \"/%s/%s/\" $data.Plural .Term | urlize }}\n        <h2 class=\"tags2\">\n            <a href=\"{{ $termLink }}\">{{ .Term }}</a> 有{{ .Count }}篇\n        </h2>\n        <div class=\"tags3\">\n            <ul>\n            {{ range .Pages | first 5 }}\n            <li><a href=\"{{ .Permalink }}\" class=\"tags4\">{{ .Title }}</a></li>\n            {{ end }} {{ if gt (len .Pages) 5 }}\n            <li><a href=\"{{ $termLink }}\" class=\"tags4\">……</a></li>\n            {{ end }}\n             </ul>\n        </div>\n\n        {{ end }}\n    </div>\n      </article>\n</main>\n<link rel=\"stylesheet\" href=\"{{ \"css/fonts.css\" | relURL }}\" media=\"all\">\n<link rel=\"stylesheet\" href=\"{{ \"css/main.css\" | relURL }}\" media=\"all\">\n<link rel=\"stylesheet\" href=\"{{ \"css/font-awesome.min.css\" | relURL }}\" media=\"all\">\n{{ partial \"footer.html\" . }}\n\n然后设置自己想要的css样式即可"
  },
  {
    "objectID": "posts/md/dongtaikeshihua.html",
    "href": "posts/md/dongtaikeshihua.html",
    "title": "动态可视化如此简单",
    "section": "",
    "text": "不用任何代码，只需要知道你画什么图，需要什么数据格式，就可以画出漂亮的动态图了，并且有每种可视化都有相应数据案例，很方面。\n由于是国外的网站，可能有点慢。\n网站： https://app.flourish.studio/templates\n可以参考这篇微信文章： https://mp.weixin.qq.com/s/aQfpyVtmjDp8kmzce3k11w\n这个非常方便的可以嵌入到网页上去，\n直接复制粘贴到markdown即可\n\n\n\n\n如果要进行数据分析可视化 也可以使用IBM Watson Analystics，这个画热力地图非常方面"
  },
  {
    "objectID": "posts/md/RSelenium应用京东商品.html",
    "href": "posts/md/RSelenium应用京东商品.html",
    "title": "RSelenium应用–京东商品",
    "section": "",
    "text": "url=\"https://www.baidu.com/\"\nremDr$navigate(url)  # navigate方法打开网页，url一定要完整\n## remDr$getCurrentUrl() # 获取当前页面的url\n\n###########################进行搜索关键词\n#####  按属性--属性值搜索 ,可以是css,xpath ,id ,属性等 对应值\nwebElem <- remDr$findElement(using = 'css', \"#kw\") # 找到这个元素--进行搜索关键词\nwebElem$sendKeysToElement(list(\"京东\",key=\"enter\"))\n#### 获取当前页面的所有标题，每个链接的标题都包含在<h3 class = \"t\">标签中。我们将h3首先访问标题\n#### 注意 findElements和 findElement方法是获取一个或者多个的区别\nwebElems <- remDr$findElements(using = 'css', \"h3.t\")\nresHeaders <- unlist(lapply(webElems, function(x){x$getElementText()})) #\nresHeaders\n\n######################## 鼠标点击事件\nwebElem<-remDr$findElement(using = \"css\",\"#w-f80518 > div > h2 > a.rujtl6l-header-title\")# 找到相应元素，直接点击\nwebElem$clickElement()\n##### 方法二： \n### webElem=webElems[[min(which(resHeaders ==resHeaders[1]))]]# 根据返回的标题标签去重以后，找到相应位置点击\n### webElem$clickElement() \n\n\n######################### 在京东首页进行关键词搜索\n###########窗口页面跳转\nremDr$getCurrentUrl()# 可以看出当前页面还是百度的页面，并没有跳转到京东页面\nremDr$getCurrentWindowHandle()# 查看当前属于哪个窗口页面\nremDr$getTitle()# 当前窗口页面的标题\nremDr$getWindowHandles() # 获取当前浏览器所有的窗口页面\n## 现在进行页面跳转\ncurrWin <- remDr$getCurrentWindowHandle() # 当前窗口\nallWins <- unlist(remDr$getWindowHandles()) # 所有窗口，这里只有两个\notherWindow <- allWins[!allWins %in% currWin[[1]]] # 排除当前窗口，获取其他窗口\nremDr$switchToWindow(otherWindow)# 窗口跳转函数，若其他窗口有多个，需要指定一个\nremDr$getCurrentUrl()\nremDr$getTitle()# 跳转成功\n###########跳转成功后，进行京东关键词搜索\nwebElem <- remDr$findElement(using = 'id', \"key\")\nwebElem$sendKeysToElement(list(\"笔记本电脑\",key=\"enter\"))\n\n################### 选电脑有很多条件--现对条件进行限制\n# #### 电脑贵重，选择京东自营\n## 方法一：---选择元素\nwebElem <- remDr$findElement(using = 'css', \"#J_feature > ul > li:nth-child(1) > a\")#找到这个京东自营元素--点击即可\nwebElem$clickElement()# 点击这元素\n## 方法二： 效果同上，---JavaScript脚本\n# 可以看见 \"京东自营\"这个html元素标签里面有onclick=\"searchlog(1,0,0,43)\"属性,<a data-field=\"wtype\" data-val=\"1\" class=\"selected\" href=\"javascript:;\" onclick=\"searchlog(1,0,0,43)\"><i></i>京东物流</a>，对JavaScript不熟悉，操作不成功。\n# remDr$executeScript(script = \"searchlog(1,0,0,43)\",args = list(\"dummy\"))\n\n# #### 选择其他条件---同上\n\n\n######################## 页面拉到最下面 --JavaScript脚本, 因为在爬取数据的时候，当页面拉到最下面的时候，才有新数据产生\nscripts <- \"window.scrollTo(0,document.body.scrollHeight)\" # 页面拉到最下面,\n# document.body.scrollHeight是表示body标签最大可以滚动到的坐标,window.scrollTo(x,y),里面为坐标\nremDr$executeScript(script = scripts,args = list(\"dummy\"))\nSys.sleep(3)\n\n# ####################### # 页面拉到最上面---JavaScript\n# scripts <- \"window.scrollTo(0,0)\" # 页面拉到最上面\n# remDr$executeScript(script = scripts,args = list(\"dummy\"))\n# Sys.sleep(3)\n######################## 页面拉到指定元素位置---javascript----这里可以循环两次\n## 参考:http://www.w3school.com.cn/jsref/dom_obj_document.asp\n# scripts <- 'window.scrollTo(0,document.getElementById(\"J_goodsList\").scrollHeight)'\n# remDr$executeScript(script = scripts,args = list(\"dummy\"))\n# Sys.sleep(3)\n\n\n#####################  模拟点击下一页---css\n# nextBtn <- remDr$findElement(using=\"css\",value = \"#J_bottomPage > span.p-num > a:nth-child(7)\")\n# nextBtn$clickElement()\n#################### 模拟点击下一页  --JavaScript\nnextpage=str_c(\"SEARCH.page(\",i, \",true)\") ##  可用str_c()字符串拼接而成\nremDr$executeScript(nextpage,args = list(\"dummy\"))\n\n\n\n############################ 此时可以获取当前页面的源代码，并提取相应的标题\nremDr$maxWindowSize()# 窗口最大化--有时要\n# webpage=remDr$getPageSource()[[1]][1] #获取当前页面的源代码\n### 保存为本地文件\n# con=file(\"test1.html\",encoding = \"utf-8\")\n# writeLines(webpage1,con)\n# close(con)\n\n###\n\n\n######################### 结合rvest包操作提取 商品信息\nlibrary(rvest)\nlibrary(stringr)\nxinxi_page=function(){\n# 提取当前页面的源代码\nwebpage=read_html(remDr$getPageSource()[[1]][1])\n# 提取商品价格\nprice <-  webpage %>% html_nodes(\"#J_goodsList .p-price\") %>% html_text() %>% str_trim()\n# 提取商品的简介信息 ，若class属性有多个值时，只用一个即可\nxinxi <- webpage %>% html_nodes(\"#J_goodsList .p-name\") %>% html_text() %>% str_trim() \n# 提取商品的商店信息\nshop <-  webpage %>% html_nodes(\"#J_goodsList .p-shop\") %>% html_text() %>% str_trim()\nif(identical(length(price),length(xinxi),length(shop))){\n  df=data.frame(xinxi,price,shop)\n}else {\n  print(\"这一页提取有问题：\")\n  print(remDr$getCurrentUrl()[[1]])\n}\n}\nremDr$close()# 关闭浏览\n## 只需循环页面 提取信息，保存数据即可\n完整代码\nrm(list = ls())\ngc()\nlibrary(RSelenium)\nlibrary(stringr)\nsetwd(\"E:\\\\rwork\\\\Rselenium\")\n\n######## 初始化浏览器####\nremDr <- remoteDriver(\n  browserName = \"chrome\",  # 浏览器可以自己设置firefox、chrome、phantomjs（要配置）\n  remoteServerAddr = \"localhost\",\n  port = 4444L) # 默认情况下，Selenium Server侦听端口为4444\n\nremDr$open() # 打开浏览器 \n\nurl=\"https://www.jd.com/?cu=true&utm_source=haosou-pinzhuan&utm_medium=cpc&utm_campaign=t_288551095_haosoupinzhuan&utm_term=0a875d61c5fe47d8bc48679132932d23_0_8f7391a4de7c48dc92723934bc4fd73d\"\nremDr$navigate(url) #直接打开京东\nSys.sleep(3)\nremDr$maxWindowSize()\nSys.sleep(3)\n关键词搜索以及选择筛选条件\n###########跳转成功后，进行京东关键词搜索\nwebElem <- remDr$findElement(using = 'id', \"key\")\nwebElem$sendKeysToElement(list(\"笔记本电脑\",key=\"enter\"))\nSys.sleep(3)\n################### 选电脑有很多条件--现对条件进行限制\n# #### 电脑贵重，选择京东自营\n## 方法一：---选择元素\nwebElem <- remDr$findElement(using = 'css', \"#J_feature > ul > li:nth-child(1) > a\")#找到这个京东自营元素--点击即可\nwebElem$clickElement()# 点击这元素\nSys.sleep(3)\n提取信息\nlibrary(rvest)\nlibrary(stringr)\nlibrary(data.table)\nlibrary(readr)\n\nxinxi_page=function(){\n# 提取当前页面的源代码\nwebpage=read_html(remDr$getPageSource()[[1]][1])\n# 提取商品价格\nprice <-  webpage %>% html_nodes(\"#J_goodsList .p-price\") %>% html_text() %>% str_trim()\n# 提取商品的简介信息 ，若class属性有多个值时，只用一个即可\nxinxi <- webpage %>% html_nodes(\"#J_goodsList .p-name\") %>% html_text() %>% str_trim() \n# 提取商品的商店信息\nshop <-  webpage %>% html_nodes(\"#J_goodsList .p-shop\") %>% html_text() %>% str_trim()\n\nlink <-  webpage %>% html_nodes(\"#J_goodsList .p-name a\") %>% html_attr(\"href\")\nlink_finally=str_c(\"https:\",link)\n\nif(identical(length(price),length(xinxi),length(shop),length(link))){\n  df=data.frame(xinxi,price,shop,link,link_finally)\n  return(df)\n}else {\n  print(\"这一页提取有问题：\")\n  print(remDr$getCurrentUrl()[[1]])\n  return(NULL)\n}\n}\n\n\n\npage_operation=function(n,file=\"tiannao.csv\"){# n代表页数\nfor(i in 1:n) {\n########页面拉到最下面 --JavaScript脚本\nscripts <- \"window.scrollTo(0,document.body.scrollHeight)\" # 页面拉到最下面,\n# document.body.scrollHeight是表示body标签最大可以滚动到的坐标,window.scrollTo(x,y),里面为坐标\nremDr$executeScript(script = scripts,args = list(\"dummy\"))\nSys.sleep(3)\n\n############  提取商品信息\ndff=data.frame()\ndff=xinxi_page()\nwrite_excel_csv(dff,file,append = TRUE)# 使用过fwrite(),和系统自带的write.csv()以及readr包的write_csv()都乱码\nSys.sleep(3)\n#################### 模拟点击下一页  --JavaScript\nii=2*i+1\nnextpage=str_c(\"SEARCH.page(\",ii, \",true)\") ##  \nremDr$executeScript(nextpage,args = list(\"dummy\"))\nSys.sleep(3)\nSys.sleep(3)\n\n}\n}\n\n提取多少页\npage_operation(20,\"diannao2.csv\")\nremDr$close()# 关闭浏览\n\n\n\n20180407diannao"
  },
  {
    "objectID": "posts/md/RandC.html",
    "href": "posts/md/RandC.html",
    "title": "R结合C++",
    "section": "",
    "text": "首先要配置好R和C++的环境，在R官网中分别有不同操作系统的环境配置条件，按照下载R软件的步骤，在下载R软件页面有相应的配置说明。如果是mac系统也可以参考这篇文章：macOS\n基本的用法可以参考：\n\nhttp://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/rcpp.html\n个人建议要写c++代码给R软件使用，建议不要混合编程，我只是简单的实验过，这样会降低代码运行的效率，甚至，可能比R本身的运算还慢。\n基本的c++ 大概能写一些简单的循环运算，但要涉及比较复杂的矩阵运算此时需要额外的库，不过不怕麻烦你自己也可以用c++写，这里推荐使用Armadillo 库，语法和MATLAB很相似，上手很快。\n由于查资料发现，Armadillo 被RcppArmadillo包给封装了，但基本没有对其做任何更改，所以你只需要简单的引入相应的Rcpp环境，就能简单的写c++了，再次说明，c++中最好不要混写R代码。\nCSDN上有关Armadillo库的介绍，个人觉得还不错，https://blog.csdn.net/jnulzl/article/details/46808515\nc++并行运算对比 以及RcppArmadillo包的使用，如下，先做总结，推荐使用feature.apply包来并行c++代码，虽然有时候没有C++ openMP快，但是基本上符合人们需求，而且feature.apply包使用起来很简单，相对于其他R并行计算的包，不出错，记得使用doParallel包来并行C++总是出错，所以推荐feature.apply并行。"
  },
  {
    "objectID": "posts/md/RandC.html#c-加上-feature.apply-并行",
    "href": "posts/md/RandC.html#c-加上-feature.apply-并行",
    "title": "R结合C++",
    "section": "2.1 C++ 加上 feature.apply 并行",
    "text": "2.1 C++ 加上 feature.apply 并行\n把下面的代码存为sample_c.cpp，然后运行Rcpp::sourceCpp('sample_c.cpp')即可\n\nsample_mat ： 随机构造n阶正互反判断矩阵\neig_max： 求矩阵的最大特征值\nveig_max(int n,int k =10000): 求k个n阶的最大特征值，返回一个向量。\n\n// [[Rcpp::depends(RcppArmadillo)]]\n#include <RcppArmadillo.h>\n#include <Rcpp.h>\nusing namespace Rcpp;\nusing namespace arma;\n\n\n// [[Rcpp::export]]\nmat sample_mat(int n)\n{\n  // 第一步： 随机构造n阶正互反判断矩阵\n  vec  P = {1,2,3,4,5,6,7,8,9,1/2.0,1/3.0,1/4.0,1/5.0,1/6.0,1/7.0,1/8.0,1/9.0};\n  vec  v = randu<vec>(0.5*n*(n-1)); //声明一个向量，并赋予随机值\n  v *= 17;\n  v = floor(v);\n  \n  \n  mat A(n,n); // 声明一个n*n的矩阵\n  int i = 0,j = 0,k=0,temp = 0;\n  \n  for(i = 0; i<n;i++){\n    for(j =0; j<n;j++){\n      if( i >j){\n        temp =  static_cast<int>(v(k++));\n        A(i,j) = P(temp);\n        A(j,i) = 1/ P(temp);\n      }else{\n        A(i,j) =1;\n      }\n    }\n  }\n  return(A);\n}\n\n\n// [[Rcpp::export]]\ndouble eig_max(mat A)\n{\n  // 第二步：求矩阵的最大特征值\n  cx_vec eigval = eig_gen(A);\n  return max(real(eigval));\n}\n\n// [[Rcpp::export]]\nNumericVector veig_max(int n,int k =10000){\n  int m = 0;\n  mat A;\n  NumericVector res(k);\n  for(m = 0; m<k;m++){\n    A = sample_mat(n);\n    res(m) = eig_max(A);\n  }\n  return res;\n}"
  },
  {
    "objectID": "posts/md/RandC.html#利用c-openmp并行",
    "href": "posts/md/RandC.html#利用c-openmp并行",
    "title": "R结合C++",
    "section": "2.2 利用c++ openMP并行",
    "text": "2.2 利用c++ openMP并行\n同理，把下面代码保存为veig_max_mp.cpp, 运行 Rcpp::sourceCpp('veig_max_mp.cpp'),只输出一个veig_max_mp函数，\n由于c++中利用了并行，所R中不能再进行并行了，这样会报错。\n// [[Rcpp::plugins(openmp)]]\n// [[Rcpp::depends(RcppArmadillo)]]\n#include <RcppArmadillo.h>\n#include <Rcpp.h>\n#include <omp.h>\nusing namespace Rcpp;\nusing namespace arma;\n\ndouble CI(int n)\n{\n  vec  P = {1,2,3,4,5,6,7,8,9,1/2.0,1/3.0,1/4.0,1/5.0,1/6.0,1/7.0,1/8.0,1/9.0};\n  vec  v = randu<vec>(0.5*n*(n-1)); //声明一个向量，并赋予随机值\n  v *= 17;\n  v = floor(v);\n  \n  mat A(n,n); // 声明一个n*n的矩阵\n  int i = 0,j= 0,k=0,temp =0;\n  for(i = 0; i<n;i++){\n    for(j =0; j<n;j++){\n      if( i >j){\n        temp =  static_cast<int>(v(k++));\n        A(i,j) = P(temp);\n        A(j,i) = 1/ P(temp);\n      }else{\n        A(i,j) =1;\n      }\n      \n    }\n  }\n  cx_vec eigval;\n  \n  eig_gen(eigval,A);\n  // cout<< omp_get_max_threads() << endl;\n  return max(real(eigval));\n}\n\n// [[Rcpp::export]]\nNumericVector veig_max_mp(int n,int k =10000){\n  int ii = omp_get_max_threads();\n  omp_set_num_threads(ii-1);\n  int m = 0;\n  NumericVector res(k);\n  #pragma omp parallel for\n  for(m =0; m<k;m++){\n    res(m) = CI(n);\n  }\n  return res;\n}"
  },
  {
    "objectID": "posts/md/RandC.html#运行对比",
    "href": "posts/md/RandC.html#运行对比",
    "title": "R结合C++",
    "section": "2.3运行对比",
    "text": "2.3运行对比\n利用上面的函数，在R中运行进行对比(在24核32G的服务器上)\nsystem.time({\n  d = lapply(3:20,veig_max_mp, k=1000000)\n})\n\nlibrary(future.apply)\nplan(multicore)\nsystem.time({\n    b = future_lapply(3:20,veig_max,k=1000000)\n})\n\n\nsystem.time({\n    b = lapply(3:20,veig_max,k=1000000)\n})\n时间如下：\n> system.time({\n+   d = lapply(3:20,veig_max_mp, k=1000000)\n+ })\n    user   system  elapsed \n1991.430    0.731  199.972 \n> \n> library(future.apply)\nLoading required package: future\n> plan(multicore)\n> system.time(\n+   {\n+     b = future_lapply(3:20,veig_max,k=1000000)\n+   }\n+ )\n    user   system  elapsed \n1321.397    4.237  204.492 \n> system.time(\n+   {\n+     b = lapply(3:20,veig_max,k=1000000)\n+   }\n+ )\n    user   system  elapsed \n1514.744    0.805 1515.093 \n> sessionInfo()\nR version 3.5.2 (2018-12-20)\nPlatform: x86_64-redhat-linux-gnu (64-bit)\nRunning under: CentOS Linux 7 (Core)\n\nMatrix products: default\nBLAS/LAPACK: /usr/lib64/R/lib/libRblas.so_\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] future.apply_1.2.0 future_1.12.0     \n\nloaded via a namespace (and not attached):\n [1] compiler_3.5.2            parallel_3.5.2            tools_3.5.2              \n [4] RcppArmadillo_0.9.300.2.0 listenv_0.7.0             yaml_2.2.0               \n [7] Rcpp_1.0.1                codetools_0.2-16          digest_0.6.18            \n[10] globals_0.12.4"
  },
  {
    "objectID": "posts/md/运筹学与最优化R.html",
    "href": "posts/md/运筹学与最优化R.html",
    "title": "运筹学与最优化–在R软件中的实现",
    "section": "",
    "text": "参考链接1:\n参考链接2:\n备注链接:"
  },
  {
    "objectID": "posts/md/谈谈字符编码问题.html",
    "href": "posts/md/谈谈字符编码问题.html",
    "title": "谈谈字符编码问题",
    "section": "",
    "text": "最近在实验室编写文件，遇到一件奇怪的事情，在自己的笔记本上能正常编码，却在学校的电脑上编码总是乱码，于是经历种种磨难，算是弄明白了一点点，下面简单介绍一下字符编码的知识（由于编码种类繁多，我只简单的提一下，其余自己百度，文末有相关链接）"
  },
  {
    "objectID": "posts/md/谈谈字符编码问题.html#常见的字符集",
    "href": "posts/md/谈谈字符编码问题.html#常见的字符集",
    "title": "谈谈字符编码问题",
    "section": "常见的字符集：",
    "text": "常见的字符集：\n​ 百度百科定义： 字符(Character)是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。字符集(Character set)是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同，常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、 GB18030字符集、Unicode字符集等。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。中文文字数目大，而且还分为简体中文和繁体中文两种不同书写规则的文字，而计算机最初是按英语单字节字符设计的，因此，对中文字符进行编码，是中文信息交流的技术基础。\n​ 下面介绍几个常见的字符集：ASCII字符集、GB2312、 GBK、utf-8、utf-16、utf-32\n​ 所谓字符集就是按一定的规则去解释或者翻译0 1 代码的，有点像翻译表或者对照表。\n\nASCII 以及EASCII\n​ 首先，我们要明白计算机内部所有东西都是以1和0来表示的，刚开始我们用8位0 1代码进行表示，一共有2^8= 256种状态，由于当时计算机很昂贵并且很大，美国人只有用了127个字符就表示了英语中所有的字符，这就是ASSIC码，从此ASSIC码诞生了，\n\n并用后面的128256号状态来表示西欧其他国家的字符，于是把0256号状态的所有字符统称为扩展的ASCCI字符（即EASCII），即最高位为0 代表0~127号字符，最高位为1 是后面扩展的字符集,记住，此时计算机始终按照8位二进制进行编码.\n\n\nGB2312 、GBK 、GB 18030\n​ 等到了中国，发现这些0256号状态都被别人使用了，而且中国的汉字太多，于是中国人准备用两个字节来表示一个汉字，并应该兼容最初的0127号字符集，于是中国人这样设计，当最高位为0时，计算机就按ASSCI码(1位)进行编码，当发现最高位是1时，就按两个字节进行编码，eg: 1001000'10001011 这两个字节都对应两个十进制数分别是72和11 ，于是就想设计一个二维矩阵建立与汉字的对应关系，按照这个二维矩阵的行和列一样进行查找对比，就可以确定一个汉字了，并且保留了0~127号码的对应规则（这就是我们经常发现为什么英文不乱码而中文乱码的原因）.\n​ 这个二维矩阵对应的字符集，就成为GB2312字符集,这样和后面的EASCCI就冲突了，然而日本、韩国等世界上几乎每个国家都有自己的字符集，于是后面的第128~256号字符集经常发生冲突（即乱码，计算机不知道应该按照GB2312、EASSIC、日文的字符集、等进行编码，所有就会出现乱码 ）。\n​ 这里补充说明一点，GB2312字符集表示的汉字也比较少，于是在GB2312的基础上扩展产生GBK编码以及GB 18030 等汉字字符集)\n\n\nANSI\n​ 严格说ANSI并不是一个字符集。前面我们讲到每个国家都有自己的编码规则，于是Windows公司设计了ANSI规则，ANSI根据电脑操作系统的设置，自动关联对应的编码，eg： 在美国就按ASCII码进行编码，并自动设置为默认编码,同理在中国，就按GBK进行编码，而在日本，就按日本对应的字符集进行编码……\n​ 所以ANSI简单来说是一个自动判别系统,但这样在不同字符进行切换时，就会出现乱码的问题。于是迫切希望有同一的编码规则，于是Unicode 编码孕育而生。\n\n\nUnicode 、utf-8、utf-16、utf-32\n​ 由于世界上存在多种编码，当不同国家的人在进行发送文件时，会出现乱码（因为解读的规则不一样，同一段0 1 代码，中国按照GBK去解读，而西欧安装EASSCI字符集去解读，这样必然计算机弄不清楚，必会出现乱码）,于是有一个社区就说要不我们把世界上的所有文字都进行统一编码吧！这样就不会产生乱码了，于是产生了Unicode编码，当然Unicode是一个很大的集合，大概用了4个字节（即32位 0 1代码去表示）,这样美国人或者西欧人不干了，因为原本我存储一个英文单词words只需要5个字节，现在用Unicode就变成了20个字节，这样硬盘的空间严重浪费，于是产生出来utf-8、utf-16、utf-32字符集，这里重点解释一下utf-8字符集，这个是可变长编码，计算机可以根据前面的一个1个字节的编码规则进行自动判断，该是用一个字节去解读还是用2个、3个字节去解读(这里这个规则有点复杂，反正计算机能从第一个字节中解读出来，到底应该用几个字节取解读)。\n\nutf-8 : 使用1~4个字节存储一个Unicode字符。\nutf-16: 使用2或4个字节存储\nutf-32 : 使用4个字节存储"
  },
  {
    "objectID": "posts/md/谈谈字符编码问题.html#乱码产生的原因",
    "href": "posts/md/谈谈字符编码问题.html#乱码产生的原因",
    "title": "谈谈字符编码问题",
    "section": "乱码产生的原因",
    "text": "乱码产生的原因\n​ 假设在一个文本编辑器中写入hollo  world  你好世界，编码方式为utf-8，\n​ 当按下ctrl + s时，文本编辑器将会按照unicode字符集中查找每个字符对应的码，再按照utf-8的方式，将hollo  world存为单字节，而将你好世界存成2~4个字节，此过程称为 编码。\n​ 关掉文件，以utf-8方式打开文件，此时编辑器读取所有字节，按照之前存入的逆向逻辑，将字节分成一段一段，每一段即表示一个字符，查unicode表，依次解读为hollo  world  你好世界，此逆向过程称为 解码。\n​ 但假如上面的文件以gbk方式去解码会发生什么？gbk会按照它的逻辑，将每两个字节都当成一个字符，继而去gbk字符集里边去查对应的字符，结果可想而知，都是一些你不想看到奇奇怪怪的字符，不是你想要的字符,此即为乱码。\n​ 还有当在编程的时候，控制台显示器，能否支持该字符集，比如win下的cmd 默认支持GBk ，当你用UTF-8的字符去展示时，也会乱码，同样的道理，这是因为显示器的解读规则出了错误"
  },
  {
    "objectID": "posts/md/谈谈字符编码问题.html#常见的很多字符集有不同的名字",
    "href": "posts/md/谈谈字符编码问题.html#常见的很多字符集有不同的名字",
    "title": "谈谈字符编码问题",
    "section": "常见的很多字符集有不同的名字",
    "text": "常见的很多字符集有不同的名字\n由于不同字符集 之间差异很小，或者是别名，于是都统称为一类字符,后面遇到在补充.\n\nANSI = Windows 1252 = CP 1252 = Windows code page 1252 = Windows Latin-1"
  },
  {
    "objectID": "posts/md/谈谈字符编码问题.html#常见的例子",
    "href": "posts/md/谈谈字符编码问题.html#常见的例子",
    "title": "谈谈字符编码问题",
    "section": "常见的例子：",
    "text": "常见的例子：\n\n1、c 语言\nc语言有时在编译的时候经常为出现乱码 ，这是怎么解决？\n\n首先，我们应该知道这个文件的编码方式 —- 可以用Notepad++ 去查看文件的编码，或者用记事本进行查看.\n其次,我们应该以对应编码的方式去解码（在c语言中进行编译.）这样就不会产生乱码了.\n\neg: 这里我准备在R中进行调用shell 命名去调用cmd命令来编译C语言.\n\n\n\n\n#查看 当前cmd窗口的显示编码 一般为 936 代码GBK，\nshell(\"chcp\",intern = TRUE) # 参数intern = TRUE 把输出对象变成R对象（即输出在R中显示，并可以赋值给变量）\n\n\n#########  如果文件是按照 UTF-8 编码的\nshell(\"g++ -fexec-charset=GBK -finput-charset=UTF-8 testutf8.cpp -o abc.exe\")\nshell(\"abc.exe\",intern = TRUE)\n\n########### 如果文件是按照GBK编码的\nshell(\"g++  testgbk.cpp -o abc1.exe && abc1.exe\",intern = TRUE)\n\nshell(\"rm abc1.exe\")\nshell(\"rm abc.exe\")\n\n\n\n########## 如果你不清楚你的文件编码，R语言也可以进行相关的判断（不是很准确）\n# Ruchardet包 和 wand包"
  },
  {
    "objectID": "posts/md/谈谈字符编码问题.html#参考",
    "href": "posts/md/谈谈字符编码问题.html#参考",
    "title": "谈谈字符编码问题",
    "section": "参考:",
    "text": "参考:\nhttp://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\nhttps://github.com/LeoYuan/leoyuan.github.io/issues/25\nhttps://www.crifan.com/files/doc/docbook/char_encoding/release/webhelp/why_ansi_called_native.html"
  },
  {
    "objectID": "posts/md/数据集划分.html",
    "href": "posts/md/数据集划分.html",
    "title": "数据集划分—-训练集和测试集方法",
    "section": "",
    "text": "2. carte包–createDatePartition 来进行分区抽样\n\ninTrain =createDataPartition(响应变量y ,p=0.8,list=FALSE)\n\n\ninTrain : 产生对应数据集行的索引\n\ny 要分类或预测的变量,\n\np 对应y的数据个数的概率\n\nlibrary(caret)\nset.seed(2012) #随机种子\nIndex =createDataPartition(iris$Species,p=0.8,list=FALSE) # 不知道为何？ iris[,5]不能使用\ntrian_data = iris[Index,]  #作为训练集\ntest_data = iris[-Index,]   #作为测试集\n# 同样用上面第一种方法 产生数据集即可\n\n\n3. dplyr::sample_frac()函数\n\nsample_frac(tbl, size = 1, replace = FALSE, weight = NULL, .env = NULL)\n\nsample_frac(iris, 0.5, replace = TRUE)：随机选取部分数据(占总体的0.5)记录。\nlibrary(dplyr)\ntrain_data = sample_frac(iris, 0.8)#这里直接选取了iris数据集中的0.8的部分，假设作为训练集\ntest_data = setdiff(iris,train_data)#用差集 把test数据挑选出来\n\n\n4 . caTools::sample.split()函数\nlibrary(caTools)\nIndex = sample.split(iris[,5],SplitRatio = 0.8)\n\ntrain_data = subset(iris,Index==TRUE)\ntest_data = subset(iris,Index==FALSE)\n\n\n5. scorecard::split_df()函数\nlibrary(scorecard)\ndata_list = split_df(iris,ratio = 0.8)\ntrain_data = data_list$train\ntest_data = data_list$test\n\n\n6. 交叉验证数据\nlibrary(caret)\nfolds = createFolds(iris$Species,k=10)\nstr(folds)\n\ntrain= iris[-folds$Fold01,]\ntest =iris[folds$Fold01,]"
  },
  {
    "objectID": "posts/md/猫眼电影抓取.html",
    "href": "posts/md/猫眼电影抓取.html",
    "title": "猫眼电影票房抓取",
    "section": "",
    "text": "library(RSelenium)\nlibrary(stringr)\nsetwd(\"C:\\\\RSelenium\")\n######## 初始化浏览器####\nremDr <- remoteDriver(\n  browserName = \"chrome\",  # 浏览器可以自己设置firefox、chrome、phantomjs（要配置）\n  remoteServerAddr = \"localhost\",\n  port = 4444L)\n\nremDr$open() # 打开浏览器 \n#> [1] \"Connecting to remote server\"\n#> $applicationCacheEnabled\n#> [1] FALSE\n#> \n#> $rotatable\n#> [1] FALSE\n#> \n#> $mobileEmulationEnabled\n#> [1] FALSE\n#> \n#> $networkConnectionEnabled\n#> [1] FALSE\n#> \n#> $chrome\n#> $chrome$chromedriverVersion\n#> [1] \"2.37.544315 (730aa6a5fdba159ac9f4c1e8cbc59bf1b5ce12b7)\"\n#> \n#> $chrome$userDataDir\n#> [1] \"C:\\\\Users\\\\zsc\\\\AppData\\\\Local\\\\Temp\\\\scoped_dir10136_5944\"\n#> \n#> \n#> $takesHeapSnapshot\n#> [1] TRUE\n#> \n#> $pageLoadStrategy\n#> [1] \"normal\"\n#> \n#> $databaseEnabled\n#> [1] FALSE\n#> \n#> $handlesAlerts\n#> [1] TRUE\n#> \n#> $hasTouchScreen\n#> [1] FALSE\n#> \n#> $version\n#> [1] \"67.0.3396.99\"\n#> \n#> $platform\n#> [1] \"Windows NT\"\n#> \n#> $browserConnectionEnabled\n#> [1] FALSE\n#> \n#> $nativeEvents\n#> [1] TRUE\n#> \n#> $acceptSslCerts\n#> [1] FALSE\n#> \n#> $acceptInsecureCerts\n#> [1] FALSE\n#> \n#> $locationContextEnabled\n#> [1] TRUE\n#> \n#> $webStorageEnabled\n#> [1] TRUE\n#> \n#> $browserName\n#> [1] \"chrome\"\n#> \n#> $takesScreenshot\n#> [1] TRUE\n#> \n#> $javascriptEnabled\n#> [1] TRUE\n#> \n#> $cssSelectorsEnabled\n#> [1] TRUE\n#> \n#> $setWindowRect\n#> [1] TRUE\n#> \n#> $unexpectedAlertBehaviour\n#> [1] \"\"\n#> \n#> $webdriver.remote.sessionid\n#> [1] \"4b56b8063909582c3c83ee6449cee0da\"\n#> \n#> $id\n#> [1] \"4b56b8063909582c3c83ee6449cee0da\"\nurl=\"https://www.baidu.com/\"\nremDr$navigate(url)   # 打开网页\nSys.sleep(10)#由于网络原因，把时间设置多一点\n\n\n\n###########################进行搜索关键词\n#####  按属性--属性值搜索 ,可以是css,xpath ,id ,属性等 对应值\n## 注意findElement 和 findElements 的区别\nwebElem <- remDr$findElement(using = 'css', \"#kw\") # 找到这个元素--进行搜索关键词\nwebElem$sendKeysToElement(list(\"猫眼\",key=\"enter\")) # 输入关键词并提交\nSys.sleep(10)\n\n\n#### 获取当前页面的所有标题，每个链接的标题都包含在<h3 class = \"t\">标签中。我们将h3首先访问标题\n#### 注意 findElements和 findElement方法是获取一个或者多个的区别\nwebElems <- remDr$findElement(using = 'css', \"h3.t a\")\nwebElems$getElementText() # 获取当前选中的节点的标题，有一些时候有广告等不能保证每次都在第一个节点\n#> [[1]]\n#> [1] \"猫眼专业版-实时票房\"\nwebElems$getElementAttribute(\"href\")  # 获取当前选中的节点属性\n#> [[1]]\n#> [1] \"http://www.baidu.com/link?url=YDvi2e0Yjs1ptfGCxgkewv3E6DgGgwTHPjfAKJfBE5EU9Sa8WA-xbHh_hcKN7bjC\"\nwebElems$clickElement()   # 点击此元素\nSys.sleep(10)\n\n\n\n\n###########窗口页面跳转\nremDr$getCurrentUrl()# 可以看出当前页面还是百度的页面，并没有跳转到猫眼页面\n#> [[1]]\n#> [1] \"https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=0&rsv_idx=1&tn=baidu&wd=%E7%8C%AB%E7%9C%BC&rsv_pq=acd1c97500015f3c&rsv_t=0cc2OOqo%2BlNoq457a3mkHEq4etPV2GyS5BTIhno4%2FV7JnkZ9Vnp2acwulq8&rqlang=cn&rsv_enter=1&rsv_sug3=2&rsv_sug2=0&inputT=54&rsv_sug4=55\"\nremDr$getCurrentWindowHandle()# 查看当前属于哪个窗口页面\n#> [[1]]\n#> [1] \"CDwindow-8F6C1A2636C0DA716E6C8C75C865B191\"\nremDr$getTitle()# 当前窗口页面的标题\n#> [[1]]\n#> [1] \"猫眼_百度搜索\"\nremDr$getWindowHandles() # 获取当前浏览器所有的窗口页面\n#> [[1]]\n#> [1] \"CDwindow-8F6C1A2636C0DA716E6C8C75C865B191\"\n#> \n#> [[2]]\n#> [1] \"CDwindow-2C1F3D52E7A8D15E93073535B5699ACA\"\n\nSys.sleep(10)\n## 现在进行页面跳转\n### 这有两个窗口时，可以直接排除跳转，如有多个窗口，一般输入窗口代码进行跳转\ncurrWin <- remDr$getCurrentWindowHandle() # 当前窗口\nallWins <- remDr$getWindowHandles()          # 所有窗口，这里只有两个\notherWindow <- as.character( setdiff(allWins,currWin) )          # 排除当前窗口，获取其他窗口\nremDr$switchToWindow(otherWindow)          # 窗口跳转函数，若其他窗口有多个，需要指定一个\nremDr$getCurrentUrl()\n#> [[1]]\n#> [1] \"http://piaofang.maoyan.com/dashboard\"\nremDr$getTitle()# 跳转成功\n#> [[1]]\n#> [1] \"500 Internal Privoxy Error\"\nSys.sleep(10)\n\n\n\nremDr$maxWindowSize()# 窗口最大化--有时要\nlibrary(rvest)\nlibrary(stringr)\n\n# 提取当前页面的源代码\nwebpage=read_html(remDr$getPageSource()[[1]],encoding = \"utf-8\")\n# 提取电影的名字,当节点有很多时，但每个节点的属性只提取 一个时，可以用html_attr()函数\ntitle <-  webpage %>% html_nodes(\"table.dashboard-table td.moviename-td\") %>% html_attr(\"title\")\n\n\ntitle\n#>  [1] \"我不是药神\"                         \n#>  [2] \"邪不压正\"                           \n#>  [3] \"新大头儿子和小头爸爸3：俄罗斯奇遇记\"\n#>  [4] \"阿修罗\"                             \n#>  [5] \"超人总动员2\"                        \n#>  [6] \"动物世界\"                           \n#>  [7] \"小悟空\"                             \n#>  [8] \"侏罗纪世界2\"                        \n#>  [9] \"神奇马戏团\"                         \n#> [10] \"风语咒\"                             \n#> [11] \"幸福马上来\"                         \n#> [12] \"您一定不要错过\"                     \n#> [13] \"美丽童年\"                           \n#> [14] \"阿飞正传\"                           \n#> [15] \"天佑之爱\"                           \n#> [16] \"第七个小矮人\"                       \n#> [17] \"猛虫过江\"                           \n#> [18] \"金蝉脱壳2\"                          \n#> [19] \"冰雪女王2：冬日魔咒\"                \n#> [20] \"细思极恐\"                           \n#> [21] \"出·路\"                              \n#> [22] \"龙虾刑警\"\n## XML组件提供了网页采集链接 列表 和表格的便利函数 \n##  对应 ： getHTMLLinks()  readHTMLList() readHTMLTable()\n##### rvest 包 只提供了网页采集 表格的便利函数-- html_table(trim=T,header=T)\n# 提取商品的简介信息 ，若class属性有多个值时，只用一个即可\nSys.sleep(10)\nxinxi <- webpage %>% html_nodes(\"table.dashboard-table\") %>% html_table(header = F,trim=T)\ndata  = xinxi[[2]]\nnames(data) = xinxi[[1]] \ndata ## 如果要循环则翻页即可，而且由于此页面是实时更新的，所以只能获取当前时刻的,其中<U+00A0>为空字符\n#>                                                  影片 (点击  优先展示)\n#> 1                          01我不是药神上映11天<U+00A0><U+00A0>24.08亿\n#> 2                              02邪不压正上映3天<U+00A0><U+00A0>2.82亿\n#> 3  03新大头儿子和小头爸爸3：俄罗斯奇遇记上映10天<U+00A0><U+00A0>1.16亿\n#> 4                              04阿修罗上映3天<U+00A0><U+00A0>4593.8万\n#> 5                          05超人总动员2上映24天<U+00A0><U+00A0>3.39亿\n#> 6                             06动物世界上映17天<U+00A0><U+00A0>4.80亿\n#> 7                               07小悟空上映2天<U+00A0><U+00A0>559.1万\n#> 8                         08侏罗纪世界2上映31天<U+00A0><U+00A0>16.64亿\n#> 9                               09神奇马戏团点映<U+00A0><U+00A0>50.8万\n#> 10                                  10风语咒点映<U+00A0><U+00A0>73.4万\n#> 11                        11幸福马上来上映38天<U+00A0><U+00A0>9280.0万\n#> 12                     12您一定不要错过上映10天<U+00A0><U+00A0>477.9万\n#> 13                             13美丽童年上映3天<U+00A0><U+00A0>98.2万\n#> 14                          14阿飞正传上映21天<U+00A0><U+00A0>1888.6万\n#> 15                             15天佑之爱上映3天<U+00A0><U+00A0>26.0万\n#> 16                      16第七个小矮人上映30天<U+00A0><U+00A0>2545.8万\n#> 17                            17猛虫过江上映31天<U+00A0><U+00A0>2.03亿\n#> 18                         18金蝉脱壳2上映17天<U+00A0><U+00A0>9077.1万\n#> 19                19冰雪女王2：冬日魔咒2016-12<U+00A0><U+00A0>3565.2万\n#> 20                           20细思极恐上映10天<U+00A0><U+00A0>105.6万\n#> 21                               21出·路重映21天<U+00A0><U+00A0>32.5万\n#> 22                          22龙虾刑警上映24天<U+00A0><U+00A0>6865.6万\n#>    综合票房(万) 票房占比 排片场次 排片占比 场均人次 上座率\n#> 1      10718.21    54.9%   133823    45.6%       24  17.2%\n#> 2       5548.16    28.4%    93891    32.0%       17  13.0%\n#> 3       1049.08     5.3%    16284     5.5%       19  19.9%\n#> 4        753.19     3.8%    22813     7.7%       10  11.3%\n#> 5        391.33     2.0%     4074     1.3%       29  28.1%\n#> 6        321.86     1.6%     5207     1.7%       17  18.6%\n#> 7        264.19     1.3%     9186     3.1%       10  11.8%\n#> 8        240.23     1.2%     3833     1.3%       19  24.6%\n#> 9         50.82     0.2%      256    <0.1%       53  53.7%\n#> 10        32.82     0.1%      159    <0.1%       47  58.8%\n#> 11        17.09    <0.1%       91    <0.1%       55  53.3%\n#> 12        14.71    <0.1%      445     0.1%       12  14.4%\n#> 13        10.27    <0.1%      124    <0.1%       23  46.5%\n#> 14         7.20    <0.1%      316     0.1%        7  11.8%\n#> 15         5.33    <0.1%      290    <0.1%        8  17.4%\n#> 16         2.76    <0.1%       68    <0.1%       14  14.1%\n#> 17         2.69    <0.1%      317     0.1%        3   7.6%\n#> 18         2.35    <0.1%      607     0.2%        2   3.9%\n#> 19         2.08    <0.1%       24    <0.1%       26  21.6%\n#> 20         1.65    <0.1%      445     0.1%        2   3.4%\n#> 21         1.60    <0.1%       10    <0.1%       50  90.7%\n#> 22         1.07    <0.1%      142    <0.1%        3   4.9%\n\n\n\nsessionInfo()\n#> R version 3.5.1 (2018-07-02)\n#> Platform: x86_64-w64-mingw32/x64 (64-bit)\n#> Running under: Windows 10 x64 (build 16299)\n#> \n#> Matrix products: default\n#> \n#> locale:\n#> [1] LC_COLLATE=Chinese (Simplified)_China.936 \n#> [2] LC_CTYPE=Chinese (Simplified)_China.936   \n#> [3] LC_MONETARY=Chinese (Simplified)_China.936\n#> [4] LC_NUMERIC=C                              \n#> [5] LC_TIME=Chinese (Simplified)_China.936    \n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> other attached packages:\n#> [1] rvest_0.3.2     xml2_1.2.0      stringr_1.3.1   RSelenium_1.7.3\n#> \n#> loaded via a namespace (and not attached):\n#>  [1] Rcpp_0.12.17     knitr_1.20       magrittr_1.5     R6_2.2.2        \n#>  [5] httr_1.3.1       caTools_1.17.1   tools_3.5.1      binman_0.1.0    \n#>  [9] selectr_0.4-1    semver_0.2.0     htmltools_0.3.6  openssl_1.0.1   \n#> [13] yaml_2.1.19      rprojroot_1.3-2  digest_0.6.15    assertthat_0.2.0\n#> [17] bitops_1.0-6     curl_3.2         evaluate_0.10.1  wdman_0.2.2     \n#> [21] rmarkdown_1.10   stringi_1.2.3    compiler_3.5.1   backports_1.1.2 \n#> [25] XML_4.0-0        jsonlite_1.5"
  },
  {
    "objectID": "posts/md/运筹学与最优化matlab.html",
    "href": "posts/md/运筹学与最优化matlab.html",
    "title": "运筹学与最优化matlab",
    "section": "",
    "text": "运筹学与matlab"
  },
  {
    "objectID": "posts/md/R动画.html",
    "href": "posts/md/R动画.html",
    "title": "R动画",
    "section": "",
    "text": "动画的本质是有n张图片进行拼接,到达欺骗人的眼睛.\n在R中有常见的有两个包.\n\ngifski 包, 搭配 rmd 文件使用,\ngganimation 包\n\n\n\n安装 gifski 包：\nxfun::pkg_load2('gifski')\n再用代码段选项 animation.hook='gifski'，如:\n```R\nfor (i in 1:2) {\n  pie(c(i %% 2, 6), col = c('red', 'yellow'),\n    labels = NA)\n}\n```\n则会直接生成gif动画\nhttps://slides.yihui.org/2020-bearclub-rmarkdown.html#7\n\n\n\n见官网"
  },
  {
    "objectID": "posts/md/matlab优化工具04quadprog.html",
    "href": "posts/md/matlab优化工具04quadprog.html",
    "title": "matlab优化工具04二次规划之quadprog",
    "section": "",
    "text": "matlab优化工具04二次规划之quadprog\n二次规划问题是目标函数为 \\(\\textbf{x}\\) 的二次形式, 约束条件为线性等式或不等式约束\n\n二次规划的一般模型\n\\[\n\\begin{aligned}\n\\min \\quad & f^T x + \\frac{1}{2}x^T \\textbf{H} x \\\\\n\\text {s.t.} \\quad & \\textbf{A} \\cdot x \\leq b \\\\\n& \\textbf{Aeq} \\cdot x=beq \\\\\n& l b \\leq x \\leq ub\n\\end{aligned}\n\\]\n其中: \\(x, b, beq\\)是向量, \\(f^T\\) 为一次项的系数, \\(\\textbf{A}\\)是矩阵,\\(\\textbf{H}\\)是矩阵, \\(\\textbf{H}\\)是矩阵,即二次项系数,用以描述\\(x_i^2\\) 以及 \\(x_i x_j\\)项. \\(\\textbf{A}\\)线性不等式,\\(\\textbf{Aeq}\\)线性等式,\n当然,二次规划的目标函数中的二次项还可以用元素的形式表达,即 \\[\n\\begin{aligned}\n\\frac{1}{2}\\left(h_{11} x_{1}^{2}+h_{12} x_{1} x_{2}+\\cdots+h_{1 n} x_{1} x_{n}+h_{21} x_{1} x_{2}+h_{22} x_{2}^{2}+\\cdots+h_{n n} x_{n}^{2}\\right)\n\\end{aligned}\n\\]\n定理: 如果\\(\\textbf{H}\\) 矩阵为正定矩阵, 则二次规划问题是凸问题. 即它的求解与初始值无关,只要有可行解,则一定是全局最优解.\n如果二次规划问题非凸,则该函数不能得出原始问题的全局最优解,甚至可能不能得出可行解.\n\nmatlab 函数— — quadprog\n%% 语法\nx = quadprog(H,f,A,b,Aeq,beq,lb,ub)\nx = quadprog(H,f,A,b,Aeq,beq,lb,ub,x0)\nx = quadprog(H,f,A,b,Aeq,beq,lb,ub,x0,options)\nx = quadprog(problem)\n[x,fval,exitflag,output,lambda] = quadprog(___)\n\n%% 不解释了, 看前面的fmincon函数\nx0 初始值\n\n\n例1\n\\[\n\\begin{aligned}\nmin  & \\quad \\left(x_{1}-1\\right)^{2}+\\left(x_{2}-2\\right)^{2}+\\left(x_{3}-3\\right)^{2}+\\left(x_{4}-4\\right)^{2} \\\\\n& \\text{s.t.} \\begin{cases}\nx_{1}+x_{2}+x_{3}+x_{4} \\leqslant 5 \\\\\n3 x_{1}+3 x_{2}+2 x_{3}+x_{4} \\leqslant 10 \\\\\nx_{1}, x_{2}, x_{3}, x_{4} \\geqslant 0\n\\end{cases}\n\\end{aligned}\n\\]\n\n方法一: 根据上述方程,写出标准形式的二次规划\n\\[\nf(x)=x_{1}^{2}+x_{2}^{2}+x_{3}^{2}+x_{4}^{2}-2 x_{1}-4 x_{2}-6 x_{3}-8 x_{4}+30\n\\]\n然后写出 \\(\\textbf{H}\\)和\\(f^T\\),代码如下:\nclc,clear all;format compact;\nf = [-2;-4;-6;-8];\nH = diag([2,2,2,2]);\nA = [1,1,1,1;\n    3,3,2,1];\nb = [5;10];\nlb = [0,0,0,0];\nub = [];\nx0=[];\noptions = optimoptions('quadprog','Display','iter');\n[x,fval,exitflag,output,lambda] = quadprog(H,f,A,b,[],[],lb,ub,x0,options)\n% ---------------------------- 结果 -------------------------\nx =\n    0.0000\n    0.6667\n    1.6667\n    2.6667\nfval =\n  -23.6667\n\n\n方法2 : 采用问题描述的形式 — 结构体\n这种模式,不需要手工推导\\(\\textbf{H}\\) 矩阵\n%% 问题描述形式 --- 以结构体方式创建 \n%%\n% optimproblem('ObjectiveSense','max')  % 最优化问题的创建,  ObjectiveSense属性求最大值(默认最小值)\n%%  optimvar 决策变量的定义,n,m,k 设置决策变量的维度,不设置k则变量维度为n*m\n% x = optimvar('x',n,m,k,'LowerBound',lb,'UpperBound',ub)\n\n\n\nclc,clear all;format compact;\nx = optimvar('x',4,1,'LowerBound',[0;0;0;0],'UpperBound',[]);\nobjec = sum( (x - [1;2;3;4]).^2 );\nprob = optimproblem('Objective',objec);\nprob.Constraints.cons1 = sum(x) &lt;= 5;\nprob.Constraints.cons2 = 3*x(1) + 3*x(2) + 2*x(3) + x(4) &lt;=10;\nsols = solve(prob);\nx=sols.x\n\n%% ---------------------------- 结果 -------------------------\nx =\n    0.0000\n    0.6667\n    1.6667\n    2.6667\n    \n%% 上述问题还可以简化,利用向量的形式给出\nclc,clear all;format compact;\nx = optimvar('x',4,1,'LowerBound',[0;0;0;0],'UpperBound',[]);\nobjec = sum( (x - [1:4]').^2 );\nprob = optimproblem('Objective',objec);\nprob.Constraints.cons1 = sum(x) &lt;= 5;\nprob.Constraints.cons2 = [3,3,2,1] * x &lt;=10;\nsols = solve(prob);\nx=sols.x\n\n%% ---------------------------- 结果 -------------------------\nx =\n    0.0000\n    0.6667\n    1.6667\n    2.6667\n\n\n\n例2:\n\\[\n\\begin{aligned}\n\\min \\quad & -2 x_{1}+3 x_{2}-4 x_{3}+4 x_{1}^{2}+2 x_{2}^{2}+7 x_{3}^{2}-2 x_{1} x_{2}-2 x_{1} x_{3}+3 x_{2} x_{3} \\\\\n& \\text{s.t. }\\begin{cases}\n2 x_{1}+x_{2}+3 x_{3} \\geq 8 \\\\\nx_{1}+2 x_{2}+x_{3} \\leq 7 \\\\\n-3 x_{1}+2 x_{2} \\leq-5 \\\\\nx_{1}, x_{2}, x_{3} \\geq 0\n\\end{cases}\n\\end{aligned}\n\\]\n由于上述问题采用手工的方法比较麻烦,因此可以采用问题描述的形式求解该问题\nclc,clear all;format compact;\nx = optimvar('x',3,1,'LowerBound',[0;0;0],'UpperBound',[]);\nobjec = -2*x(1) + 3*x(2) - 4*x(3) + 4*x(1)^2 + 2*x(2)^2 + 7*x(3)^2 -2*x(1)*x(2) -2*x(1)*x(2) + 3*x(2)*x(3);\nprob = optimproblem('Objective',objec);\nprob.Constraints.cons1 = [2,1,3] * x &gt;= 8;\nprob.Constraints.cons2 = [1,2,1] * x &lt;=7;\nprob.Constraints.cons3 = [-3,2,0] * x &lt;= -5;\nsols = solve(prob);\nx=sols.x\n\n%% ---------------------------- 结果 -------------------------\nSolving problem using quadprog.\nYour Hessian is not symmetric. Resetting H=(H+H')/2.\n\nMinimum found that satisfies the constraints.\n\nOptimization completed because the objective function is non-decreasing in \nfeasible directions, to within the value of the optimality tolerance,\nand constraints are satisfied to within the value of the constraint tolerance.\n\n&lt;stopping criteria details&gt;\nx =\n    2.2500\n    0.8750\n    0.8750\n上述可以看到 Your Hessian is not symmetric. Resetting H=(H+H')/2. 说明给出了警告,指出自动生成的Hesse 矩阵是非对称的, 所以建议设置H=(H+H')/2 将其转化为对称矩阵. 由于问题描述模式没有输入H矩阵. 因此,应该将问题描述模式转为结构体模型,再来处理H矩阵(这样做不会产生警告,不过最后的结果都是一样的).\n&gt;&gt; p = prob2struct(prob);\np = \n  包含以下字段的 struct:\n\n     intcon: []\n         lb: [3×1 double]\n         ub: [3×1 double]\n         x0: []\n      Aineq: [3×3 double]\n      bineq: [3×1 double]\n        Aeq: []\n        beq: []\n         f0: 0\n     solver: 'quadprog'\n          H: [3×3 double]\n          f: [3×1 double]\n    options: []\n&gt;&gt; p.H = (p.H + p.H') / 2;\n&gt;&gt; x1 = quadprog(p)\nx1 =\n    2.2500\n    0.8750\n    0.8750\n\n\n\n双下标二次规划\n主要是根据线性模型中的运输问题直接扩展而来的, 即把线性模型中的运输问题的目标函数用二次项表示,其他的约束条件都不变\n线性模型中的运输问题\n\n\n\nimage-20210516105838325\n\n\n双下标二次规划的一个改进版本 \n%%  对凹费用运输问题的求解,假设 n = 4, m = 6, a,b,C,D 已知;\n%% 双虾标的运输问题（凹费用运输问题）\n% 已知 n, m,a,b,C,D\nclc,clear all;format compact;\nn = 4; m = 6;\na = [8,24,20,24,16,12]';\nb = [29,41,13,21];\nC= [300, 270, 460, 800;\n    740, 600, 540, 380;\n    300, 490, 380, 760;\n    430, 250, 390, 600; \n    210, 830, 470, 680;\n    360, 290, 400 ,310];\nD = [-7, -4, -6, -8;\n    -12, -9, -14, -7;\n    -13, -12, -8, -4;\n    -7, -9, -16, -8;\n    -4, -10, -21, -13;\n    -17,-9,-8,-4];\n\nx = optimvar('x',m,n,'LowerBound',0,'UpperBound',[]);\nobjec = sum(sum(C .* x + D.* (x.^2)) );\nprob = optimproblem('Objective',objec);\nprob.Constraints.cons1 = sum(x,1) == b;\nprob.Constraints.cons2 = sum(x,2) == a;\nsols = solve(prob);\nx=sols.x\n\n%% ---------------------------- 结果 -------------------------\nSolving problem using quadprog.\nThe problem is non-convex.\nx =\n     1     1     1     1\n     1     1     1     1\n     1     1     1     1\n     1     1     1     1\n     1     1     1     1\n     1     1     1     1\n&gt;&gt; \n注意: 上述结果不满足约束条件,即得出的结果不是可行解, 这时候, 则需要使用fmincon 函数了\n% 由于上述问题采用问题描述方式书写的，这里进行转化，转化为结构体模式\np = prob2struct(prob);\np.solver = 'fmincon'; %转为结构体必须修改必要的参数\nf = @(x) sum(C(:) .* x + D(:) .* x.^2);\np.Objective = f; %定义目标函数\nff  = optimset;\nff.TolX =eps; % 一个比较苛刻的误差值l\nff.TolFun=eps;\np.options = ff;\np.x0 =100*rand(m*n,1);\nx0 =fmincon_global(p,-10,10,n*m,50);\nX0 = reshape(x0,m,n)\n\n%% ---------------------------- 结果 -------------------------\nX0 =\n    6.0000    2.0000    0.0000    0.0000\n    0.0000    3.0000    0.0000   21.0000\n   20.0000    0.0000    0.0000    0.0000\n    0.0000   24.0000    0.0000    0.0000\n    3.0000    0.0000   13.0000    0.0000\n    0.0000   12.0000    0.0000    0.0000\n参考:\n\nmatlab函数官网\n&lt;&lt;薛定宇教授大讲堂卷5  MATLAB最优化计算&gt;&gt;_含目录py.pdf"
  },
  {
    "objectID": "posts/md/scrapy.html",
    "href": "posts/md/scrapy.html",
    "title": "Scrapy框架+selenium爬取京东相机",
    "section": "",
    "text": "（项目名为：jingdong)，会生成一系列文件夹，命令如下(cmd下运行)：\nscrapy startproject jingdong"
  },
  {
    "objectID": "posts/md/scrapy.html#创建爬虫文件",
    "href": "posts/md/scrapy.html#创建爬虫文件",
    "title": "Scrapy框架+selenium爬取京东相机",
    "section": "2 创建爬虫文件",
    "text": "2 创建爬虫文件\n在刚刚生成的jingdong文件夹下面找到spiders文件夹,在spider文件下创建一个爬虫文件（名字叫jd）– 用来解析网页的，命令如下(cmd下运行)：\nscarpy genspider jd \"list.jd.com\"\n# 创建一个jd.py的爬虫文件，爬虫名为jd ，以及指定爬虫允许爬取的范围：只能在jd.com下."
  },
  {
    "objectID": "posts/md/scrapy.html#编写items.py文件",
    "href": "posts/md/scrapy.html#编写items.py文件",
    "title": "Scrapy框架+selenium爬取京东相机",
    "section": "3 编写items.py文件",
    "text": "3 编写items.py文件\n创建爬虫目标（明确需要提取的数据），如下：\nimport scrapy\nclass JingdongItem(scrapy.Item):\n    # define the fields for your item here like:\n    # 所有商品的名称、链接、价格、销售店铺、评论数的信\n    # 商品名称\n    name = scrapy.Field()\n    # 商品的简介\n    abstract = scrapy.Field()\n    # 商品的链接\n    link = scrapy.Field()\n    # 商品的价格\n    price = scrapy.Field()\n    # 店铺名\n    shop_name = scrapy.Field()\n    # 评论数\n    commet = scrapy.Field()"
  },
  {
    "objectID": "posts/md/scrapy.html#设置setting文件开启管道",
    "href": "posts/md/scrapy.html#设置setting文件开启管道",
    "title": "Scrapy框架+selenium爬取京东相机",
    "section": "4 设置setting文件，开启管道",
    "text": "4 设置setting文件，开启管道\nITEM_PIPELINES = {\n    'jingdong.pipelines.JingdongPipeline': 300,\n}"
  },
  {
    "objectID": "posts/md/scrapy.html#编写spidersjd.py-文件-爬虫文件",
    "href": "posts/md/scrapy.html#编写spidersjd.py-文件-爬虫文件",
    "title": "Scrapy框架+selenium爬取京东相机",
    "section": "5 编写spiders/jd.py 文件 （爬虫文件）",
    "text": "5 编写spiders/jd.py 文件 （爬虫文件）\n编写爬虫文件（我们创建的jd.py,，在spiders这个文件夹下面），此文件用来处理请求和响应，以及提取数据\n# -*- coding: utf-8 -*-\nimport scrapy\nfrom jingdong.items import JingdongItem \n\nclass JdSpider(scrapy.Spider):\n    # 爬虫名\n    name = \"jd\"\n    # 允许爬虫作用的范围\n    allowed_domains = [\"list.jd.com\"]\n    # 页面提取url  也可以拼接url:https://list.jd.com/list.html?cat=652,654,831&page=0\n\n    # 爬虫起始的url\n    start_urls = ['https://list.jd.com/list.html?cat=652,654,831']\n    offset = 1 # 设置爬取的起始页数\n    def parse(self, response):\n        info_list = response.xpath('//div[@id=\"plist\"]//li[@class =\"gl-item\"]')\n        for each in info_list:\n            # 构建item对象，用来保存数据\n            item = JingdongItem()\n            ####################################################\n            ########## 一下为提取页面信息######################\n            # 提取商品的名称，\n            if len( each.xpath('./div/div[@class=\"p-name\"]/a/em/text()') ) == 0 :\n                item['name']=\"\"\n            else:\n                item['name'] = each.xpath('./div/div[@class=\"p-name\"]/a/em/text()').extract()[0]\n            \n            # 商品简介\n            if len(each.xpath('./div/div[@class=\"p-name\"]/a/i[@class=\"promo-words\"]/text()'))==0:\n                item['abstract']=\"\"\n            else:\n                item['abstract'] = each.xpath('./div/div[@class=\"p-name\"]/a/i[@class=\"promo-words\"]/text()').extract()[0]\n            \n            # 商品链接\n            if len(each.xpath('./div/div[@class=\"p-name\"]/a/@href'))==0:\n                item['link'] = \"\"\n            else:\n                item['link'] = each.xpath('./div/div[@class=\"p-name\"]/a/@href').extract()[0]\n            \n            # 商品价格\n            if len(each.xpath('./div/div[@class=\"p-price\"]/strong[1]/i/text()'))==0:\n                item['price'] = \"\"\n            else:\n                item['price'] = each.xpath('./div/div[@class=\"p-price\"]/strong[1]//i/text()').extract()[0]\n            \n            # 商品店铺名称\n            if len(each.xpath('./div/div[@class=\"p-shop\"]/span/a/text()'))==0:\n                item['shop_name']=\"\"\n            else:\n                item['shop_name'] = each.xpath('./div/div[@class=\"p-shop\"]/span/a/text()').extract()[0]\n            \n            # 商品评论数\n            if len(each.xpath('./div/div[@class=\"p-commit p-commit-n\"]/strong/a/text()'))==0:\n                item['commet']=\"\"\n            else:\n                item['commet'] = each.xpath('./div/div[@class=\"p-commit p-commit-n\"]/strong/a/text()').extract()[0]\n            # 通过yield 返回数据，返回数据后还能回来继续执行下面的代码\n            yield item\n        \n        # 直接从response获取需要爬取的链接，并发送给请求处理，直到链接处理完成\n        if len(response.xpath('//div[@class=\"p-wrap\"]//a[@class=\"pn-next\"]'))!= 0 and self.offset<1000:\n            # self.offset手动控制爬取的页面数  ，当然这里没有1000个页面，直到所有为止\n            self.offset = self.offset+1\n            next_url = response.xpath('//div[@class=\"p-wrap\"]//a[@class=\"pn-next\"]/@href').extract_first()\n            url = \"https://list.jd.com/\"+next_url# 找到下一页的url链接\n            yield scrapy.Request(url=url,callback= self.parse)"
  },
  {
    "objectID": "posts/md/scrapy.html#编写pipelines.py管道文件",
    "href": "posts/md/scrapy.html#编写pipelines.py管道文件",
    "title": "Scrapy框架+selenium爬取京东相机",
    "section": "6 编写pipelines.py(管道文件)",
    "text": "6 编写pipelines.py(管道文件)\n编写管道文件，处理spider返回的item数据，我把它存为json文件： 如下\nimport json\n\nclass JingdongPipeline(object):\n    def __init__(self):\n        self.f = open(\"jingdong_xiangji.json\",\"w\")\n        \n    def process_item(self, item, spider):\n        content = json.dumps(dict(item),ensure_ascii=False) + \",\\n\"\n        self.f.write(content)\n        return item # 一定要返回item  ，相当于告诉引擎，我做事做完了，请给我下一个item\n    \n    # 第一个方法：只执行一次\n    def close_spider(self,spider):\n        self.f.close()"
  },
  {
    "objectID": "posts/md/scrapy.html#编写middlewares.py下载中间件",
    "href": "posts/md/scrapy.html#编写middlewares.py下载中间件",
    "title": "Scrapy框架+selenium爬取京东相机",
    "section": "7 编写middlewares.py(下载中间件)",
    "text": "7 编写middlewares.py(下载中间件)\n由于京东这个网站，网页是动态加载的，于是结合selenium进行下载，（如果是静态页面，无需写这个文件，以及后面的第8步）\n\nfrom selenium import webdriver\n#检查页面是否加载完毕\nimport time\nfrom scrapy.http import HtmlResponse\nfrom selenium.common.exceptions import TimeoutException\nfrom selenium.webdriver.chrome.options import Options #设置Google的无头浏览器\n\nclass JingdongSpiderMiddleware(object):\n    # 开始运行的选项\n    def __init__(self):\n        chrome_options = Options()\n        prefs =  {\"profile.managed_default_content_settings.images\":2}\n        # 设置Chrome浏览器不加载图片的方法\n        chrome_options.add_experimental_option(\"prefs\",prefs) \n        #设置Google的无头浏览器\n        chrome_options.add_argument('--headless') \n        self.browser = webdriver.Chrome(chrome_options=chrome_options) \n        self.browser.maximize_window()  # 最大化浏览器\n        self.browser.implicitly_wait(10)#隐式等待10s\n        \n    #  最后结束的时候运行的选项\n    def __del__(self):\n        self.browser.close()\n        self.browser.quit()\n        \n    def process_request(self,request,spider):\n        try:\n            self.browser.get(request.url)\n            self.browser.implicitly_wait(6)\n            self.browser.execute_script('window.scrollTo(0,document.body.scrollHeight)')\n            time.sleep(3)\n            self.browser.execute_script('window.scrollTo(0,document.body.scrollHeight)')\n            time.sleep(3)\n            return HtmlResponse(url=self.browser.current_url,body=self.browser.page_source,encoding='utf-8',request=request,status=200)\n        except TimeoutException as e:\n            print(\"超时\")\n            self.browser.execute_script('window.stop()')\n            return HtmlResponse(url=request.url,status=500,request = request)"
  },
  {
    "objectID": "posts/md/scrapy.html#设置下载中间件",
    "href": "posts/md/scrapy.html#设置下载中间件",
    "title": "Scrapy框架+selenium爬取京东相机",
    "section": "8 设置下载中间件",
    "text": "8 设置下载中间件\nDOWNLOADER_MIDDLEWARES = {\n     'jingdong.middlewares.JingdongSpiderMiddleware': 543,\n}"
  },
  {
    "objectID": "posts/md/scrapy.html#最后的settings.py设置文件",
    "href": "posts/md/scrapy.html#最后的settings.py设置文件",
    "title": "Scrapy框架+selenium爬取京东相机",
    "section": "9 最后的settings.py(设置文件)",
    "text": "9 最后的settings.py(设置文件)\n由于爬虫有时候网站不让你爬 。有一个robots协议，我们不管这个，需要在setting.py设置，把ROBOTSTXT_OBEY = False即可\n最后我的setting.py 如下:\nBOT_NAME = 'jingdong'\n\nSPIDER_MODULES = ['jingdong.spiders']\nNEWSPIDER_MODULE = 'jingdong.spiders'\n########################### 以上全自动生成\n#以下为 手动改写\nROBOTSTXT_OBEY = False \nDOWNLOADER_MIDDLEWARES = {\n     'jingdong.middlewares.JingdongSpiderMiddleware': 543,\n}\nITEM_PIPELINES = {\n    'jingdong.pipelines.JingdongPipeline'\n    : 300,\n}\n\n## 解释： 'jingdong.pipelines.JingdongPipeline' ## 注意这里的字典 键要对应前面的类，\n#####  jingdong 为爬虫项目名，\n#####  pipelines为爬虫下面的pipelines.py文件的文件名，\n#####  JingdongPipeline为pipelines.py中的类名"
  },
  {
    "objectID": "posts/md/scrapy.html#最后执行爬虫文件",
    "href": "posts/md/scrapy.html#最后执行爬虫文件",
    "title": "Scrapy框架+selenium爬取京东相机",
    "section": "10 最后执行爬虫文件：",
    "text": "10 最后执行爬虫文件：\ncmd下执行：\nscrapy crawl jd\n# 注意：jd为 spiders/jd.py文件中name的值  即（name = \"jd\"）\n# 也可以执行  scrapy crawl jd  -o  jd_xiangji.csv  \n#### 即存为 json  又有保存了csv文件  ，生成的文件都在当前目录下（我们可以在爬虫的项目的文件下创建一个data文件夹，在这个文件夹下执行爬虫文件，就可以把代码和数据分开了。\n######################\n#  在cmd下运行的命令 只要在爬虫项目文件下运行都可以执行，"
  },
  {
    "objectID": "posts/md/scrapy.html#结果展示",
    "href": "posts/md/scrapy.html#结果展示",
    "title": "Scrapy框架+selenium爬取京东相机",
    "section": "11 结果展示",
    "text": "11 结果展示\n\n\n\n20180810scrapyjingdong\n\n\n一共 7192 条信息 = 120* 60 （最后一页没有60个商品）\n可以看出速度很快（大概20分钟左右）就抓取玩了"
  },
  {
    "objectID": "posts/md/installhugo.html",
    "href": "posts/md/installhugo.html",
    "title": "install old hugo version",
    "section": "",
    "text": "最近发现自己更新了 hugo 软件导致了主题的某些功能失效了, 于是需要退回旧版本的 hugo(0.55.5),\n\n\nhttps://gohugo.io/getting-started/installing/ 文章中的Install Hugo from Tarball 这一部分(个人电脑是 mac)\n\n\n\n直接从 Rstduio 进行更新\n\n前提是: 必须保证 R 以及 R 包是最新的\n使用如下命令\n\nblogdown::install_hugo(version = \"0.55.5\", use_brew = F, force = T, extended = TRUE)"
  },
  {
    "objectID": "posts/md/mactex卸载.html",
    "href": "posts/md/mactex卸载.html",
    "title": "mactex卸载",
    "section": "",
    "text": "参考： http://www.tug.org/mactex/uninstalling.html\nhttps://blog.csdn.net/nicekwell/article/details/97279215\nMacTeX是mac下的latex工具，卸载方法：\n1、/usr/local/texlive/2018/ 目录，这是占用空间最大的目录\n2、卸载GUI，到/Application/ 目录里删掉几个app即可。\n3、/Library/TeX\n4、~/Library/texlive/2019\nsudo rm -rf /usr/local/texlive/\n\nsudo rm -rf /Library/TeX/\n\nsudo rm -rf ~/Library/texlive\n\n\ncd /usr/local/\nsudo rm -rf texlive/\n\ncd /Library/\nsudo rm -rf TeX/\n\ncd ~/Library/texlive\nsudo rm -rf 2020\n\ncd ~/Library\nsudo rm -rf texlive"
  },
  {
    "objectID": "posts/md/GB7714.html",
    "href": "posts/md/GB7714.html",
    "title": "latex 参考文献格式: GB/7714",
    "section": "",
    "text": "注意所有一下运行环境均在MacTex 2018 下运行的, 如果是MacTex 2020 且更新到最新的话,以下方法会报错…原因是之后的版本修改了一些参数.(有空在出Mactex 2020的)"
  },
  {
    "objectID": "posts/md/GB7714.html#bst-文件",
    "href": "posts/md/GB7714.html#bst-文件",
    "title": "latex 参考文献格式: GB/7714",
    "section": "1. bst 文件",
    "text": "1. bst 文件\nbst样式文件来源:\nhttps://github.com/CTeX-org/gbt7714-bibtex-style\n\n1.1. 使用方法\n\n方法一:\n直接使用gbt7714 宏包,一般texlive自带该宏包,不过版本应该比较旧是1.XX 可以更新到2.*\n\\documentclass{article}\n\\usepackage[UTF8]{ctex} % 中文包,如果含有公式也适用\n\\usepackage[colorlinks,linkcolor=red]{hyperref} % 超链接\n\\bibliographystyle{gbt7714-numerical}\n\\usepackage[super]{gbt7714}\n\n\n\\begin{document}\n    \n正文\n\n\\cite{herrera2004some}\n\\cite{刘祖林2018基于近似一致性模糊数判断矩阵的决策模型研究}\n\\cite{xu2014weak,xu2018methods}\n\\cite{刘祖林2018基于近似一致性模糊数判断矩阵的决策模型研究}\n\\cite{刘祖林2018基于近似一致性模糊数判断矩阵的决策模型研究,张吉军2000模糊层次分析法,邓雪2012层次分析法权重计算方法分析及其应用研究}\n\n\\bibliography{test}\n\n\\end{document}\n\n\n方法二:\n也可以下载单个的bst文件, 放在.tex所在的目录下,这样使用\n\\documentclass{article}\n\\usepackage[UTF8]{ctex} % 中文包,如果含有公式也适用\n\\usepackage[colorlinks,linkcolor=red]{hyperref} % 超链接\n\n\\usepackage[super,sort&compress,square]{natbib}\n\\bibliographystyle{gbt7714-numerical}\n\\begin{document}\n正文\n\\cite{herrera2004some}\n\\cite{刘祖林2018基于近似一致性模糊数判断矩阵的决策模型研究}\n\\cite{xu2014weak,xu2018methods}\n\\cite{刘祖林2018基于近似一致性模糊数判断矩阵的决策模型研究}\n\\cite{刘祖林2018基于近似一致性模糊数判断矩阵的决策模型研究,张吉军2000模糊层次分析法,邓雪2012层次分析法权重计算方法分析及其应用研究}\n\n\\bibliography{test}\n\n\\end{document}\n\n\n\n1.2. 修改默认样式\n在 bst 文件开始处的 load.config 函数中，有一组配置参数用来控制样 式，下表列出了每一项的默认值和功能。若变量被设为#1则表示该项被启用， 设为#0则不启用。默认的值是严格遵循国标的配置。\n\n\n\nimage-20200825124849683"
  },
  {
    "objectID": "posts/md/GB7714.html#biblatex-格式",
    "href": "posts/md/GB7714.html#biblatex-格式",
    "title": "latex 参考文献格式: GB/7714",
    "section": "2. biblatex 格式",
    "text": "2. biblatex 格式\n由于版本原因,需要biblatex-gb7714-2015 下载对应的文件,放入当前目录\n\n最简单的方法是从本项目源码中下载 gb7714-2015.bbx, gb7714-2015ay.bbx, gb7714-2015.cbx, gb7714-2015ay.cbx 四个文件放到你要编译的主文档所在目录，如果需要使用gbk编码，则还需复制 gb7714-2015-gbk.def 文件。对于已经安装的用户需要更新到最新版，也可以下载这些文件替换系统已经安装的文件。\n\n首先,把后端改为biber, 然后使用biblatex格式来生成参考文献.\n\\documentclass{article}\n\\usepackage[UTF8]{ctex} % 中文包,如果含有公式也适用\n\\usepackage[colorlinks,linkcolor=red]{hyperref} % 超链接\n\n\\usepackage[backend = biber, style=gb7714-2015, gbnamefmt =  lowercase, gbbiblabel=bracket]{biblatex}\n\\addbibresource[location=local]{test.bib}\n\\renewcommand{\\bibfont}{\\zihao{5}\\songti}%设置参考文献的字体和字号\n\\setlength{\\bibitemsep}{2pt}%设置各条参考文献之间的间距为2pt\n\n\\begin{document}\n。。。正文。。。。。x\n\\cite{herrera2004some}\n\\cite{刘祖林2018基于近似一致性模糊数判断矩阵的决策模型研究}\n\\cite{xu2014weak,xu2018methods}\n\\cite{刘祖林2018基于近似一致性模糊数判断矩阵的决策模型研究}\n\\cite{刘祖林2018基于近似一致性模糊数判断矩阵的决策模型研究,张吉军2000模糊层次分析法,邓雪2012层次分析法权重计算方法分析及其应用研究}\n\n\\printbibliography[heading=bibliography,title=参考文献]\n\n\\end{document}\n\n更多详细信息,可参考:biblatex-gb7714-2015\n参考:\n更多详细信息,可参考:biblatex-gb7714-2015\n参考:\nbiblatex参考文献和引用样式caspervector\nbiblatex-zh-cn\nbiblatex-solution-to-latex-bibliography\nbiblatex-gb7714-2015\nbiber-zh-cn"
  },
  {
    "objectID": "posts/md/bib与enw相互转换.html",
    "href": "posts/md/bib与enw相互转换.html",
    "title": "bib与enw文件之间的相互转换",
    "section": "",
    "text": "方法一: JabRef 软件\n方法二: bibutils\n为了将BibTeX转换为带标签的Endnote，只需调用：\n$ bib2xml input.bib | xml2end > output.enw\n转换为RIS类似于：\n$ bib2xml input.bib | xml2ris > output.ris"
  },
  {
    "objectID": "posts/md/kaggle-泰坦.html",
    "href": "posts/md/kaggle-泰坦.html",
    "title": "泰坦尼克号预测(kaggle)",
    "section": "",
    "text": "options(width = 300)\nknitr::opts_chunk$set(message = F,warning = F,comment = \"#>\",collapse = TRUE)\n读入数据\n数据处理\n由于Cabin 变量丢失数据太多，于是可以删除这个变量\n以及Embarked这个是个字符串，于是用众数去替代，或者用一些相同的类型的人的指标去替代\n特征衍生工作\n从名字中提取称谓，并把相同意思的称谓进行融合\n构造 FamilySize 变量 ，\n对于Age变量，可以把age分类处理\n把一些字符变量转变为因子变量\n数据划分"
  },
  {
    "objectID": "posts/md/kaggle-泰坦.html#carte包",
    "href": "posts/md/kaggle-泰坦.html#carte包",
    "title": "泰坦尼克号预测(kaggle)",
    "section": "carte包",
    "text": "carte包\n\n随机森林建模\nlibrary(caret)\nlibrary(foreach)\nlibrary(doParallel)\n\nno_cores <- detectCores() -1\ncl<-makeCluster(no_cores)\nregisterDoParallel(cl)\n\nfitControl <- trainControl(method = \"repeatedcv\",\n                            number = 10,\n                            repeats = 1)\ngrif_rf = expand.grid(.mtry=c(11:13))\n\nset.seed(825)\nrf_cv_Fit1 <- train(Survived~Pclass +Name + Sex + Age_class + SibSp + Parch + Fare + Embarked + Name + FamilySize,\n                    data = train,\n                    metric =\"Kappa\",\n                    method = \"rf\", \n                    trControl = fitControl,tuneGrid = grif_rf,\n                    verbose = FALSE)\n随机森林—模型参数与评估\nrf_cv_Fit1\n#> Random Forest \n#> \n#> 891 samples\n#>   9 predictor\n#>   2 classes: '0', '1' \n#> \n#> No pre-processing\n#> Resampling: Cross-Validated (10 fold, repeated 1 times) \n#> Summary of sample sizes: 802, 802, 802, 802, 802, 802, ... \n#> Resampling results across tuning parameters:\n#> \n#>   mtry  Accuracy   Kappa    \n#>   11    0.8361423  0.6479535\n#>   12    0.8249064  0.6235846\n#>   13    0.8260175  0.6267026\n#> \n#> Kappa was used to select the optimal model using the largest value.\n#> The final value used for the model was mtry = 11.\n\npred_rf_cv = predict(rf_cv_Fit1,test,type = \"raw\")\n\n\nsubmit_rf_cv=data.frame(PassengerId=test$PassengerId,Survived=prediction)\n\n## 存储文件\n# write.csv(submit_rf_cv,\"data/submit_rf_cv.csv\",row.names = FALSE)\n\n# 模型评估\ntable(train$Survived,predict(rf_cv_Fit1,train,type = \"raw\"))\n#>    \n#>       0   1\n#>   0 532  17\n#>   1  54 288\n\n\nsvm建模\nlibrary(foreach)\nlibrary(doParallel)\n\nno_cores <- detectCores() -1\ncl<-makeCluster(no_cores)\n\n\nfitControl <- trainControl(method = \"repeatedcv\",\n                            number = 10,\n                            repeats = 1)\ngrif_svm = expand.grid(sigma=seq(1,100,10),C=seq(1,100,10),Weight=c(1,100 / table(train$Survived)))\n\nset.seed(825)\nsvm_cv_Fit1 <- train(Survived~Pclass +Name + Sex + Age_class + SibSp + Parch + Fare + Embarked + Name + FamilySize,\n                    data = train,\n                    metric =\"Kappa\",\n                    method = \"svmRadialWeights\", \n                    trControl = fitControl,tuneGrid = grif_svm,\n                    verbose = FALSE)\n\n\n\nsvm_cv_Fit1\n#> Support Vector Machines with Class Weights \n#> \n#> 891 samples\n#>   9 predictor\n#>   2 classes: '0', '1' \n#> \n#> No pre-processing\n#> Resampling: Cross-Validated (10 fold, repeated 1 times) \n#> Summary of sample sizes: 802, 802, 802, 802, 802, 802, ... \n#> Resampling results across tuning parameters:\n#> \n#>   sigma  C   Weight     Accuracy   Kappa    \n#>    1      1  0.1821494  0.6476529  0.3450120\n#>    1      1  0.2923977  0.6879650  0.4080850\n#>    1      1  1.0000000  0.7811111  0.5336090\n#>    1     11  0.1821494  0.7384270  0.4825548\n#>    1     11  0.2923977  0.7676404  0.5318205\n#>    1     11  1.0000000  0.7889513  0.5539126\n#>    1     21  0.1821494  0.7373034  0.4800775\n#>    1     21  0.2923977  0.7721348  0.5396339\n#>    1     21  1.0000000  0.7878277  0.5513716\n#>    1     31  0.1821494  0.7384270  0.4819020\n#>    1     31  0.2923977  0.7721348  0.5396500\n#>    1     31  1.0000000  0.7878277  0.5520975\n#>    1     41  0.1821494  0.7384395  0.4816815\n#>    1     41  0.2923977  0.7721348  0.5396500\n#>    1     41  1.0000000  0.7878277  0.5528006\n#>    1     51  0.1821494  0.7384519  0.4816418\n#>    1     51  0.2923977  0.7687765  0.5332258\n#>    1     51  1.0000000  0.7867166  0.5502534\n#>    1     61  0.1821494  0.7384519  0.4816418\n#>    1     61  0.2923977  0.7699001  0.5353125\n#>    1     61  1.0000000  0.7889638  0.5549527\n#>    1     71  0.1821494  0.7395755  0.4835483\n#>    1     71  0.2923977  0.7698876  0.5354221\n#>    1     71  1.0000000  0.7878527  0.5519801\n#>    1     81  0.1821494  0.7373408  0.4792572\n#>    1     81  0.2923977  0.7710112  0.5374317\n#>    1     81  1.0000000  0.7878527  0.5519801\n#>    1     91  0.1821494  0.7373408  0.4792572\n#>    1     91  0.2923977  0.7698876  0.5349684\n#>    1     91  1.0000000  0.7889763  0.5539713\n#>   11      1  0.1821494  0.5926966  0.2634169\n#>   11      1  0.2923977  0.6566167  0.3569706\n#>   11      1  1.0000000  0.7464170  0.4589756\n#>   11     11  0.1821494  0.7036954  0.4264619\n#>   11     11  0.2923977  0.7407366  0.4872806\n#>   11     11  1.0000000  0.7486642  0.4607651\n#>   11     21  0.1821494  0.6958302  0.4115283\n#>   11     21  0.2923977  0.7396130  0.4853630\n#>   11     21  1.0000000  0.7486767  0.4596743\n#>   11     31  0.1821494  0.6992010  0.4169313\n#>   11     31  0.2923977  0.7373658  0.4810659\n#>   11     31  1.0000000  0.7430587  0.4490506\n#>   11     41  0.1821494  0.7003246  0.4189393\n#>   11     41  0.2923977  0.7362422  0.4791788\n#>   11     41  1.0000000  0.7430462  0.4501862\n#>   11     51  0.1821494  0.7014357  0.4208375\n#>   11     51  0.2923977  0.7362422  0.4791788\n#>   11     51  1.0000000  0.7441698  0.4527104\n#>   11     61  0.1821494  0.7014357  0.4208375\n#>   11     61  0.2923977  0.7373658  0.4810659\n#>   11     61  1.0000000  0.7452934  0.4553096\n#>   11     71  0.1821494  0.7014357  0.4208375\n#>   11     71  0.2923977  0.7385019  0.4830801\n#>   11     71  1.0000000  0.7441698  0.4526016\n#>   11     81  0.1821494  0.7014357  0.4208375\n#>   11     81  0.2923977  0.7373783  0.4805621\n#>   11     81  1.0000000  0.7441698  0.4526016\n#>   11     91  0.1821494  0.7014357  0.4208375\n#>   11     91  0.2923977  0.7396255  0.4843557\n#>   11     91  1.0000000  0.7430462  0.4506031\n#>   21      1  0.1821494  0.5915730  0.2627613\n#>   21      1  0.2923977  0.6442697  0.3377452\n#>   21      1  1.0000000  0.7452934  0.4553119\n#>   21     11  0.1821494  0.6980774  0.4158949\n#>   21     11  0.2923977  0.7351311  0.4778643\n#>   21     11  1.0000000  0.7452934  0.4542599\n#>   21     21  0.1821494  0.7014482  0.4214853\n#>   21     21  0.2923977  0.7340075  0.4753755\n#>   21     21  1.0000000  0.7441698  0.4526315\n#>   21     31  0.1821494  0.7014482  0.4214853\n#>   21     31  0.2923977  0.7328839  0.4728575\n#>   21     31  1.0000000  0.7430462  0.4506291\n#>   21     41  0.1821494  0.7014482  0.4214853\n#>   21     41  0.2923977  0.7351436  0.4766543\n#>   21     41  1.0000000  0.7441698  0.4538285\n#>   21     51  0.1821494  0.7025718  0.4232449\n#>   21     51  0.2923977  0.7362672  0.4785697\n#>   21     51  1.0000000  0.7430462  0.4515215\n#>   21     61  0.1821494  0.7025718  0.4226345\n#>   21     61  0.2923977  0.7373908  0.4805335\n#>   21     61  1.0000000  0.7430462  0.4515215\n#>   21     71  0.1821494  0.7036954  0.4244115\n#>   21     71  0.2923977  0.7385144  0.4831184\n#>   21     71  1.0000000  0.7430462  0.4515215\n#>   21     81  0.1821494  0.7059426  0.4280555\n#>   21     81  0.2923977  0.7385144  0.4831184\n#>   21     81  1.0000000  0.7430462  0.4515215\n#>   21     91  0.1821494  0.7059426  0.4280555\n#>   21     91  0.2923977  0.7385144  0.4831184\n#>   21     91  1.0000000  0.7430462  0.4515215\n#>   31      1  0.1821494  0.5893258  0.2595359\n#>   31      1  0.2923977  0.6476654  0.3435429\n#>   31      1  1.0000000  0.7441823  0.4522360\n#>   31     11  0.1821494  0.6992010  0.4175620\n#>   31     11  0.2923977  0.7340075  0.4758536\n#>   31     11  1.0000000  0.7419351  0.4474695\n#>   31     21  0.1821494  0.7003246  0.4195318\n#>   31     21  0.2923977  0.7317603  0.4714543\n#>   31     21  1.0000000  0.7408115  0.4464669\n#>   31     31  0.1821494  0.7003246  0.4195318\n#>   31     31  0.2923977  0.7340200  0.4752511\n#>   31     31  1.0000000  0.7408115  0.4464669\n#>   31     41  0.1821494  0.7014482  0.4206810\n#>   31     41  0.2923977  0.7362672  0.4791020\n#>   31     41  1.0000000  0.7396879  0.4444013\n#>   31     51  0.1821494  0.7025718  0.4225303\n#>   31     51  0.2923977  0.7362672  0.4791020\n#>   31     51  1.0000000  0.7385643  0.4424209\n#>   31     61  0.1821494  0.7025718  0.4225544\n#>   31     61  0.2923977  0.7373908  0.4815624\n#>   31     61  1.0000000  0.7385643  0.4424209\n#>   31     71  0.1821494  0.7025718  0.4225544\n#>   31     71  0.2923977  0.7373908  0.4815624\n#>   31     71  1.0000000  0.7374407  0.4403604\n#>   31     81  0.1821494  0.7025718  0.4225544\n#>   31     81  0.2923977  0.7385144  0.4834688\n#>   31     81  1.0000000  0.7363171  0.4391270\n#>   31     91  0.1821494  0.7036954  0.4249922\n#>   31     91  0.2923977  0.7396380  0.4853753\n#>   31     91  1.0000000  0.7363171  0.4391270\n#>   41      1  0.1821494  0.5893258  0.2601027\n#>   41      1  0.2923977  0.6398002  0.3310217\n#>   41      1  1.0000000  0.7441823  0.4522816\n#>   41     11  0.1821494  0.6992010  0.4185330\n#>   41     11  0.2923977  0.7306367  0.4695862\n#>   41     11  1.0000000  0.7385643  0.4412077\n#>   41     21  0.1821494  0.6980774  0.4159480\n#>   41     21  0.2923977  0.7328964  0.4733640\n#>   41     21  1.0000000  0.7385643  0.4412077\n#>   41     31  0.1821494  0.6958552  0.4116192\n#>   41     31  0.2923977  0.7362672  0.4791020\n#>   41     31  1.0000000  0.7374407  0.4392273\n#>   41     41  0.1821494  0.6969913  0.4133824\n#>   41     41  0.2923977  0.7362672  0.4791020\n#>   41     41  1.0000000  0.7374407  0.4392273\n#>   41     51  0.1821494  0.6992385  0.4176660\n#>   41     51  0.2923977  0.7373908  0.4810085\n#>   41     51  1.0000000  0.7363171  0.4379938\n#>   41     61  0.1821494  0.6969913  0.4135130\n#>   41     61  0.2923977  0.7373908  0.4804740\n#>   41     61  1.0000000  0.7363171  0.4391270\n#>   41     71  0.1821494  0.6981149  0.4160191\n#>   41     71  0.2923977  0.7373908  0.4811373\n#>   41     71  1.0000000  0.7363171  0.4391270\n#>   41     81  0.1821494  0.6992385  0.4185078\n#>   41     81  0.2923977  0.7373908  0.4811373\n#>   41     81  1.0000000  0.7363171  0.4391270\n#>   41     91  0.1821494  0.6992385  0.4185078\n#>   41     91  0.2923977  0.7373908  0.4805263\n#>   41     91  1.0000000  0.7351935  0.4370889\n#>   51      1  0.1821494  0.5893258  0.2601027\n#>   51      1  0.2923977  0.6386767  0.3292930\n#>   51      1  1.0000000  0.7430712  0.4485869\n#>   51     11  0.1821494  0.6936205  0.4087871\n#>   51     11  0.2923977  0.7272784  0.4641883\n#>   51     11  1.0000000  0.7385643  0.4412077\n#>   51     21  0.1821494  0.6913858  0.4044756\n#>   51     21  0.2923977  0.7328964  0.4737335\n#>   51     21  1.0000000  0.7374407  0.4392273\n#>   51     31  0.1821494  0.6925094  0.4064855\n#>   51     31  0.2923977  0.7351436  0.4779378\n#>   51     31  1.0000000  0.7363171  0.4379938\n#>   51     41  0.1821494  0.6936330  0.4082625\n#>   51     41  0.2923977  0.7351436  0.4774471\n#>   51     41  1.0000000  0.7363171  0.4379938\n#>   51     51  0.1821494  0.6970037  0.4149275\n#>   51     51  0.2923977  0.7362672  0.4793616\n#>   51     51  1.0000000  0.7351935  0.4359333\n#>   51     61  0.1821494  0.6981273  0.4174162\n#>   51     61  0.2923977  0.7362672  0.4793616\n#>   51     61  1.0000000  0.7340699  0.4338953\n#>   51     71  0.1821494  0.6981273  0.4167874\n#>   51     71  0.2923977  0.7385144  0.4832641\n#>   51     71  1.0000000  0.7340699  0.4338953\n#>   51     81  0.1821494  0.6981273  0.4167874\n#>   51     81  0.2923977  0.7373908  0.4814395\n#>   51     81  1.0000000  0.7351935  0.4358535\n#>   51     91  0.1821494  0.7003745  0.4205404\n#>   51     91  0.2923977  0.7373908  0.4814395\n#>   51     91  1.0000000  0.7329463  0.4318763\n#>   61      1  0.1821494  0.5826217  0.2502068\n#>   61      1  0.2923977  0.6285643  0.3133638\n#>   61      1  1.0000000  0.7408240  0.4441011\n#>   61     11  0.1821494  0.6925094  0.4069598\n#>   61     11  0.2923977  0.7284020  0.4660563\n#>   61     11  1.0000000  0.7363296  0.4355851\n#>   61     21  0.1821494  0.6913858  0.4046547\n#>   61     21  0.2923977  0.7328964  0.4737335\n#>   61     21  1.0000000  0.7363296  0.4355851\n#>   61     31  0.1821494  0.6936330  0.4082625\n#>   61     31  0.2923977  0.7317728  0.4713558\n#>   61     31  1.0000000  0.7340824  0.4316345\n#>   61     41  0.1821494  0.6947566  0.4107686\n#>   61     41  0.2923977  0.7340200  0.4752675\n#>   61     41  1.0000000  0.7340824  0.4315119\n#>   61     51  0.1821494  0.6958801  0.4132805\n#>   61     51  0.2923977  0.7351436  0.4771909\n#>   61     51  1.0000000  0.7340824  0.4314321\n#>   61     61  0.1821494  0.6981273  0.4169757\n#>   61     61  0.2923977  0.7318227  0.4572936\n#>   61     61  1.0000000  0.7329588  0.4294738\n#>   61     71  0.1821494  0.6992509  0.4188250\n#>   61     71  0.2923977  0.7307116  0.4542080\n#>   61     71  1.0000000  0.7329463  0.4305823\n#>   61     81  0.1821494  0.7003745  0.4206999\n#>   61     81  0.2923977  0.7329588  0.4580270\n#>   61     81  1.0000000  0.7329463  0.4305823\n#>   61     91  0.1821494  0.7026217  0.4244271\n#>   61     91  0.2923977  0.7329588  0.4580270\n#>   61     91  1.0000000  0.7329463  0.4305823\n#>   71      1  0.1821494  0.5814981  0.2485895\n#>   71      1  0.2923977  0.6251935  0.3078469\n#>   71      1  1.0000000  0.7419476  0.4467029\n#>   71     11  0.1821494  0.6880150  0.3997900\n#>   71     11  0.2923977  0.7272784  0.4639733\n#>   71     11  1.0000000  0.7340824  0.4312532\n#>   71     21  0.1821494  0.6902622  0.4026816\n#>   71     21  0.2923977  0.7272784  0.4635862\n#>   71     21  1.0000000  0.7352060  0.4343127\n#>   71     31  0.1821494  0.6936330  0.4093879\n#>   71     31  0.2923977  0.7328964  0.4733328\n#>   71     31  1.0000000  0.7340824  0.4322522\n#>   71     41  0.1821494  0.6958801  0.4132805\n#>   71     41  0.2923977  0.7295880  0.4522289\n#>   71     41  1.0000000  0.7329588  0.4302141\n#>   71     51  0.1821494  0.6981273  0.4169757\n#>   71     51  0.2923977  0.7318227  0.4563957\n#>   71     51  1.0000000  0.7329588  0.4302141\n#>   71     61  0.1821494  0.6992509  0.4188250\n#>   71     61  0.2923977  0.7329463  0.4582203\n#>   71     61  1.0000000  0.7307116  0.4255170\n#>   71     71  0.1821494  0.7026217  0.4244271\n#>   71     71  0.2923977  0.7340699  0.4611126\n#>   71     71  1.0000000  0.7307116  0.4255170\n#>   71     81  0.1821494  0.7037453  0.4263832\n#>   71     81  0.2923977  0.7351935  0.4636264\n#>   71     81  1.0000000  0.7307116  0.4255170\n#>   71     91  0.1821494  0.7037453  0.4263832\n#>   71     91  0.2923977  0.7340824  0.4614589\n#>   71     91  1.0000000  0.7307116  0.4260402\n#>   81      1  0.1821494  0.5792634  0.2455210\n#>   81      1  0.2923977  0.6251935  0.3078469\n#>   81      1  1.0000000  0.7408240  0.4446288\n#>   81     11  0.1821494  0.6868914  0.3977439\n#>   81     11  0.2923977  0.7261673  0.4627250\n#>   81     11  1.0000000  0.7329588  0.4291927\n#>   81     21  0.1821494  0.6925094  0.4076129\n#>   81     21  0.2923977  0.7295256  0.4680218\n#>   81     21  1.0000000  0.7329588  0.4299807\n#>   81     31  0.1821494  0.6936330  0.4101861\n#>   81     31  0.2923977  0.7284519  0.4509761\n#>   81     31  1.0000000  0.7307116  0.4258822\n#>   81     41  0.1821494  0.6970037  0.4157226\n#>   81     41  0.2923977  0.7295755  0.4538531\n#>   81     41  1.0000000  0.7318352  0.4281951\n#>   81     51  0.1821494  0.6992509  0.4193634\n#>   81     51  0.2923977  0.7318227  0.4571451\n#>   81     51  1.0000000  0.7318352  0.4281951\n#>   81     61  0.1821494  0.7026217  0.4251154\n#>   81     61  0.2923977  0.7318352  0.4569506\n#>   81     61  1.0000000  0.7318352  0.4287183\n#>   81     71  0.1821494  0.7026217  0.4251154\n#>   81     71  0.2923977  0.7318477  0.4563842\n#>   81     71  1.0000000  0.7318352  0.4287183\n#>   81     81  0.1821494  0.7048689  0.4286436\n#>   81     81  0.2923977  0.7318477  0.4563842\n#>   81     81  1.0000000  0.7318352  0.4287183\n#>   81     91  0.1821494  0.7048689  0.4281019\n#>   81     91  0.2923977  0.7318602  0.4562315\n#>   81     91  1.0000000  0.7318352  0.4286214\n#>   91      1  0.1821494  0.5781523  0.2440235\n#>   91      1  0.2923977  0.6240699  0.3062144\n#>   91      1  1.0000000  0.7408240  0.4450119\n#>   91     11  0.1821494  0.6846442  0.3944491\n#>   91     11  0.2923977  0.7261673  0.4627498\n#>   91     11  1.0000000  0.7318352  0.4279203\n#>   91     21  0.1821494  0.6913858  0.4061352\n#>   91     21  0.2923977  0.7250811  0.4451708\n#>   91     21  1.0000000  0.7318352  0.4279203\n#>   91     31  0.1821494  0.6947566  0.4117704\n#>   91     31  0.2923977  0.7284519  0.4518740\n#>   91     31  1.0000000  0.7284644  0.4218471\n#>   91     41  0.1821494  0.6992509  0.4193634\n#>   91     41  0.2923977  0.7295880  0.4535101\n#>   91     41  1.0000000  0.7284644  0.4218471\n#>   91     51  0.1821494  0.7014981  0.4231977\n#>   91     51  0.2923977  0.7284769  0.4504299\n#>   91     51  1.0000000  0.7284644  0.4223703\n#>   91     61  0.1821494  0.7037453  0.4268340\n#>   91     61  0.2923977  0.7307241  0.4549168\n#>   91     61  1.0000000  0.7284644  0.4223703\n#>   91     71  0.1821494  0.7037453  0.4268340\n#>   91     71  0.2923977  0.7318477  0.4569850\n#>   91     71  1.0000000  0.7284644  0.4223703\n#>   91     81  0.1821494  0.7037453  0.4268340\n#>   91     81  0.2923977  0.7329838  0.4593189\n#>   91     81  1.0000000  0.7295880  0.4249469\n#>   91     91  0.1821494  0.7048689  0.4288071\n#>   91     91  0.2923977  0.7329838  0.4593189\n#>   91     91  1.0000000  0.7307116  0.4269096\n#> \n#> Kappa was used to select the optimal model using the largest value.\n#> The final values used for the model were sigma = 1, C = 61 and Weight = 1.\nsvm 参数搜索—范围进一步变小\n# 上面结果最好的参数为： sigma = 1, C = 61 and Weight = 1.\n\nno_cores <- detectCores() -1\ncl<-makeCluster(no_cores)\n#registerDoParallel(cl) # windows要加这个，mac不需要加这个\n\ngrif_svm2 = expand.grid(sigma=seq(1,10,1),C=seq(50,70,1),Weight=1)\n\nset.seed(825)\nsvm_cv_Fit2 <- train(Survived~Pclass +Name + Sex + Age_class + SibSp + Parch + Fare + Embarked + Name + FamilySize,\n                    data = train,\n                    metric =\"Kappa\",\n                    method = \"svmRadialWeights\", \n                    trControl = fitControl,tuneGrid = grif_svm2,\n                    verbose = FALSE)\n\n\n\nsvm_cv_Fit2\n#> Support Vector Machines with Class Weights \n#> \n#> 891 samples\n#>   9 predictor\n#>   2 classes: '0', '1' \n#> \n#> No pre-processing\n#> Resampling: Cross-Validated (10 fold, repeated 1 times) \n#> Summary of sample sizes: 802, 802, 802, 802, 802, 802, ... \n#> Resampling results across tuning parameters:\n#> \n#>   sigma  C   Accuracy   Kappa    \n#>    1     50  0.7867166  0.5502534\n#>    1     51  0.7867166  0.5502534\n#>    1     52  0.7878402  0.5523393\n#>    1     53  0.7878402  0.5523393\n#>    1     54  0.7878402  0.5523393\n#>    1     55  0.7878402  0.5523393\n#>    1     56  0.7878402  0.5523393\n#>    1     57  0.7878402  0.5523393\n#>    1     58  0.7889638  0.5549527\n#>    1     59  0.7889638  0.5549527\n#>    1     60  0.7889638  0.5549527\n#>    1     61  0.7889638  0.5549527\n#>    1     62  0.7889638  0.5549527\n#>    1     63  0.7889638  0.5549527\n#>    1     64  0.7878527  0.5523786\n#>    1     65  0.7878527  0.5523786\n#>    1     66  0.7878527  0.5523786\n#>    1     67  0.7878527  0.5523786\n#>    1     68  0.7878527  0.5519801\n#>    1     69  0.7878527  0.5519801\n#>    1     70  0.7878527  0.5519801\n#>    2     50  0.7822222  0.5437950\n#>    2     51  0.7822222  0.5437950\n#>    2     52  0.7822222  0.5437950\n#>    2     53  0.7833458  0.5458818\n#>    2     54  0.7833458  0.5458818\n#>    2     55  0.7833458  0.5458818\n#>    2     56  0.7833458  0.5458818\n#>    2     57  0.7822347  0.5433076\n#>    2     58  0.7822347  0.5433076\n#>    2     59  0.7789014  0.5348965\n#>    2     60  0.7777903  0.5321784\n#>    2     61  0.7766792  0.5294305\n#>    2     62  0.7755680  0.5266522\n#>    2     63  0.7744569  0.5238432\n#>    2     64  0.7744569  0.5238432\n#>    2     65  0.7744569  0.5238432\n#>    2     66  0.7744569  0.5238432\n#>    2     67  0.7744569  0.5238432\n#>    2     68  0.7744569  0.5238432\n#>    2     69  0.7744569  0.5238432\n#>    2     70  0.7744569  0.5238432\n#>    3     50  0.7677653  0.5079159\n#>    3     51  0.7677653  0.5079159\n#>    3     52  0.7677653  0.5079159\n#>    3     53  0.7677653  0.5079159\n#>    3     54  0.7677653  0.5079159\n#>    3     55  0.7677653  0.5079159\n#>    3     56  0.7677653  0.5079159\n#>    3     57  0.7677653  0.5079159\n#>    3     58  0.7677653  0.5079159\n#>    3     59  0.7688889  0.5099863\n#>    3     60  0.7688889  0.5099863\n#>    3     61  0.7688889  0.5099863\n#>    3     62  0.7688889  0.5099863\n#>    3     63  0.7688889  0.5099863\n#>    3     64  0.7688889  0.5099863\n#>    3     65  0.7688889  0.5099863\n#>    3     66  0.7688889  0.5099863\n#>    3     67  0.7688889  0.5099863\n#>    3     68  0.7677653  0.5073891\n#>    3     69  0.7666417  0.5053186\n#>    3     70  0.7666417  0.5053186\n#>    4     50  0.7576404  0.4904061\n#>    4     51  0.7576404  0.4904061\n#>    4     52  0.7565169  0.4884006\n#>    4     53  0.7565169  0.4884006\n#>    4     54  0.7565169  0.4884006\n#>    4     55  0.7565169  0.4884006\n#>    4     56  0.7565169  0.4884006\n#>    4     57  0.7565169  0.4884006\n#>    4     58  0.7553933  0.4862959\n#>    4     59  0.7553933  0.4862959\n#>    4     60  0.7553933  0.4862955\n#>    4     61  0.7542697  0.4843110\n#>    4     62  0.7542697  0.4843110\n#>    4     63  0.7542697  0.4843110\n#>    4     64  0.7542697  0.4843110\n#>    4     65  0.7542697  0.4843110\n#>    4     66  0.7542697  0.4843110\n#>    4     67  0.7542697  0.4843110\n#>    4     68  0.7542697  0.4843110\n#>    4     69  0.7542697  0.4843110\n#>    4     70  0.7542697  0.4843110\n#>    5     50  0.7509114  0.4678279\n#>    5     51  0.7509114  0.4678279\n#>    5     52  0.7509114  0.4678279\n#>    5     53  0.7509114  0.4678279\n#>    5     54  0.7509114  0.4678279\n#>    5     55  0.7509114  0.4678279\n#>    5     56  0.7509114  0.4678279\n#>    5     57  0.7509114  0.4678279\n#>    5     58  0.7509114  0.4678279\n#>    5     59  0.7509114  0.4678279\n#>    5     60  0.7509114  0.4678279\n#>    5     61  0.7509114  0.4678279\n#>    5     62  0.7509114  0.4678279\n#>    5     63  0.7509114  0.4678279\n#>    5     64  0.7509114  0.4678279\n#>    5     65  0.7509114  0.4678279\n#>    5     66  0.7509114  0.4678279\n#>    5     67  0.7509114  0.4678279\n#>    5     68  0.7497878  0.4657843\n#>    5     69  0.7497878  0.4657843\n#>    5     70  0.7497878  0.4657843\n#>    6     50  0.7464170  0.4566695\n#>    6     51  0.7464170  0.4566695\n#>    6     52  0.7464170  0.4566695\n#>    6     53  0.7464170  0.4566695\n#>    6     54  0.7464170  0.4566695\n#>    6     55  0.7452934  0.4539311\n#>    6     56  0.7452934  0.4539311\n#>    6     57  0.7441698  0.4519093\n#>    6     58  0.7441698  0.4519093\n#>    6     59  0.7441698  0.4519093\n#>    6     60  0.7441698  0.4519093\n#>    6     61  0.7441698  0.4519093\n#>    6     62  0.7441698  0.4519093\n#>    6     63  0.7441698  0.4519093\n#>    6     64  0.7441698  0.4519093\n#>    6     65  0.7441698  0.4519093\n#>    6     66  0.7441698  0.4519093\n#>    6     67  0.7441698  0.4519093\n#>    6     68  0.7441698  0.4519093\n#>    6     69  0.7441698  0.4519093\n#>    6     70  0.7441698  0.4519093\n#>    7     50  0.7430462  0.4497065\n#>    7     51  0.7430462  0.4497065\n#>    7     52  0.7430462  0.4497065\n#>    7     53  0.7430462  0.4497065\n#>    7     54  0.7430462  0.4497065\n#>    7     55  0.7430462  0.4497065\n#>    7     56  0.7430462  0.4497065\n#>    7     57  0.7430462  0.4497065\n#>    7     58  0.7430462  0.4497065\n#>    7     59  0.7430462  0.4497065\n#>    7     60  0.7430462  0.4497065\n#>    7     61  0.7419226  0.4477303\n#>    7     62  0.7408115  0.4446395\n#>    7     63  0.7408115  0.4446395\n#>    7     64  0.7408115  0.4446395\n#>    7     65  0.7408115  0.4446395\n#>    7     66  0.7408115  0.4446395\n#>    7     67  0.7408115  0.4446395\n#>    7     68  0.7408115  0.4446395\n#>    7     69  0.7396879  0.4414400\n#>    7     70  0.7408115  0.4434618\n#>    8     50  0.7441823  0.4508545\n#>    8     51  0.7441823  0.4508545\n#>    8     52  0.7441823  0.4508545\n#>    8     53  0.7441823  0.4508545\n#>    8     54  0.7430587  0.4488783\n#>    8     55  0.7419351  0.4469231\n#>    8     56  0.7419351  0.4469231\n#>    8     57  0.7419351  0.4469231\n#>    8     58  0.7419351  0.4469231\n#>    8     59  0.7419351  0.4469231\n#>    8     60  0.7419351  0.4469231\n#>    8     61  0.7419351  0.4469231\n#>    8     62  0.7419351  0.4469231\n#>    8     63  0.7419351  0.4469231\n#>    8     64  0.7419351  0.4469231\n#>    8     65  0.7408115  0.4443873\n#>    8     66  0.7408115  0.4443873\n#>    8     67  0.7408115  0.4443873\n#>    8     68  0.7408115  0.4443873\n#>    8     69  0.7408115  0.4443873\n#>    8     70  0.7408115  0.4443873\n#>    9     50  0.7408115  0.4443873\n#>    9     51  0.7408115  0.4443873\n#>    9     52  0.7408115  0.4443873\n#>    9     53  0.7408115  0.4443873\n#>    9     54  0.7408115  0.4443873\n#>    9     55  0.7408115  0.4443873\n#>    9     56  0.7408115  0.4443873\n#>    9     57  0.7408115  0.4443873\n#>    9     58  0.7408115  0.4443873\n#>    9     59  0.7408115  0.4443873\n#>    9     60  0.7408115  0.4443873\n#>    9     61  0.7408115  0.4443873\n#>    9     62  0.7408115  0.4443873\n#>    9     63  0.7408115  0.4443873\n#>    9     64  0.7408115  0.4443873\n#>    9     65  0.7408115  0.4443873\n#>    9     66  0.7419351  0.4469115\n#>    9     67  0.7419351  0.4469115\n#>    9     68  0.7419351  0.4469115\n#>    9     69  0.7419351  0.4469115\n#>    9     70  0.7419351  0.4469115\n#>   10     50  0.7408115  0.4443873\n#>   10     51  0.7408115  0.4443873\n#>   10     52  0.7408115  0.4443873\n#>   10     53  0.7408115  0.4443873\n#>   10     54  0.7419351  0.4469115\n#>   10     55  0.7419351  0.4469115\n#>   10     56  0.7419351  0.4469115\n#>   10     57  0.7419351  0.4469115\n#>   10     58  0.7419351  0.4469115\n#>   10     59  0.7419351  0.4469115\n#>   10     60  0.7430462  0.4500024\n#>   10     61  0.7430462  0.4500024\n#>   10     62  0.7430462  0.4500024\n#>   10     63  0.7430462  0.4500024\n#>   10     64  0.7430462  0.4500024\n#>   10     65  0.7430462  0.4500024\n#>   10     66  0.7430462  0.4500024\n#>   10     67  0.7430462  0.4500024\n#>   10     68  0.7430462  0.4500024\n#>   10     69  0.7430462  0.4500024\n#>   10     70  0.7430462  0.4500024\n#> \n#> Tuning parameter 'Weight' was held constant at a value of 1\n#> Kappa was used to select the optimal model using the largest value.\n#> The final values used for the model were sigma = 1, C = 58 and Weight = 1.\n\n# 参数进一步缩小 上面最好的为：  sigma = 1, C = 58 and Weight = 1.\nno_cores <- detectCores() -1\ncl<-makeCluster(no_cores)\n# registerDoParallel(cl)\n\ngrif_svm3 = expand.grid(sigma=seq(0,1,0.1),C=58,Weight=1)\n\nset.seed(825)\nsvm_cv_Fit3 <- train(Survived~Pclass +Name + Sex + Age_class + SibSp + Parch + Fare + Embarked + Name + FamilySize,\n                    data = train,\n                    metric =\"Kappa\",\n                    method = \"svmRadialWeights\", \n                    trControl = fitControl,tuneGrid = grif_svm3,\n                    verbose = FALSE)\n\n\n\nsvm_cv_Fit3\n#> Support Vector Machines with Class Weights \n#> \n#> 891 samples\n#>   9 predictor\n#>   2 classes: '0', '1' \n#> \n#> No pre-processing\n#> Resampling: Cross-Validated (10 fold, repeated 1 times) \n#> Summary of sample sizes: 802, 802, 802, 802, 802, 802, ... \n#> Resampling results across tuning parameters:\n#> \n#>   sigma  Accuracy   Kappa    \n#>   0.0    0.6161673  0.0000000\n#>   0.1    0.8013358  0.5669074\n#>   0.2    0.7979650  0.5612242\n#>   0.3    0.7911985  0.5513664\n#>   0.4    0.7900624  0.5519072\n#>   0.5    0.7878402  0.5495903\n#>   0.6    0.7889638  0.5520950\n#>   0.7    0.7889638  0.5524516\n#>   0.8    0.7889638  0.5537507\n#>   0.9    0.7878527  0.5518741\n#>   1.0    0.7889638  0.5549527\n#> \n#> Tuning parameter 'C' was held constant at a value of 58\n#> Tuning parameter 'Weight' was held constant at a value of 1\n#> Kappa was used to select the optimal model using the largest value.\n#> The final values used for the model were sigma = 0.1, C = 58 and Weight = 1.\n\n# 参数进一步缩小 上面最好的为： sigma = 0.1, C = 58 and Weight = 1.\nno_cores <- detectCores() -1\ncl<-makeCluster(no_cores)\n# registerDoParallel(cl)\n\ngrif_svm4 = expand.grid(sigma=seq(0,0.2,0.01),C=58,Weight=1)\n\nset.seed(825)\nsvm_cv_Fit4 <- train(Survived~Pclass +Name + Sex + Age_class + SibSp + Parch + Fare + Embarked + Name + FamilySize,\n                    data = train,\n                    metric =\"Kappa\",\n                    method = \"svmRadialWeights\", \n                    trControl = fitControl,tuneGrid = grif_svm4,\n                    verbose = FALSE)\n\n# stopImplicitCluster()\n\nsvm_cv_Fit4\n#> Support Vector Machines with Class Weights \n#> \n#> 891 samples\n#>   9 predictor\n#>   2 classes: '0', '1' \n#> \n#> No pre-processing\n#> Resampling: Cross-Validated (10 fold, repeated 1 times) \n#> Summary of sample sizes: 802, 802, 802, 802, 802, 802, ... \n#> Resampling results across tuning parameters:\n#> \n#>   sigma  Accuracy   Kappa    \n#>   0.00   0.6161673  0.0000000\n#>   0.01   0.8149064  0.5916957\n#>   0.02   0.8114981  0.5856433\n#>   0.03   0.8081273  0.5793144\n#>   0.04   0.8036330  0.5700091\n#>   0.05   0.7991511  0.5611674\n#>   0.06   0.8002622  0.5645199\n#>   0.07   0.8047191  0.5741737\n#>   0.08   0.8047066  0.5738563\n#>   0.09   0.8024719  0.5689492\n#>   0.10   0.8013358  0.5669074\n#>   0.11   0.8013358  0.5669991\n#>   0.12   0.8002122  0.5643613\n#>   0.13   0.8002122  0.5643613\n#>   0.14   0.8013233  0.5663641\n#>   0.15   0.8024469  0.5690019\n#>   0.16   0.8013358  0.5668501\n#>   0.17   0.8002122  0.5645959\n#>   0.18   0.7979650  0.5601587\n#>   0.19   0.7957179  0.5563902\n#>   0.20   0.7979650  0.5612242\n#> \n#> Tuning parameter 'C' was held constant at a value of 58\n#> Tuning parameter 'Weight' was held constant at a value of 1\n#> Kappa was used to select the optimal model using the largest value.\n#> The final values used for the model were sigma = 0.01, C = 58 and Weight = 1.\n\nsvm 模型预测\n\n# 最好的参数 为： sigma = 0.01, C = 58 and Weight = 1.\n\npred_svm_cv = predict(svm_cv_Fit4,test)\nsubmit_svm_cv=data.frame(PassengerId=test$PassengerId,Survived=prediction)\n\n## 存储文件\n# write.csv(submit_svm_cv,\"data/submit_svm_cv.csv\",row.names = FALSE)\n\n# 模型评估\ntable(train$Survived,predict(svm_cv_Fit4,train,type = \"raw\"))\n#>    \n#>       0   1\n#>   0 519  30\n#>   1  98 244"
  },
  {
    "objectID": "posts/md/kaggle-泰坦.html#kaggle的得分",
    "href": "posts/md/kaggle-泰坦.html#kaggle的得分",
    "title": "泰坦尼克号预测(kaggle)",
    "section": "kaggle的得分",
    "text": "kaggle的得分\n以下是把数据提交kaggle以后的得分,可以发现大概都在0.78分左右\n如果需要提升分数，需要重新构建新的特征工程再去预测建模"
  },
  {
    "objectID": "posts/md/matlab优化工具03全局优化之ga.html",
    "href": "posts/md/matlab优化工具03全局优化之ga.html",
    "title": "matlab优化工具03全局优化之ga",
    "section": "",
    "text": "首先,要明白遗传算法的基本思路,然后再利用这个函数求解问题,是非常方便的.\n新版本中很多优化函数的属性设置都采用: optimoptions('优化函数', '属性1','属性值1',....)\n故gaoptimset不推荐了,但是基本都差不多,可能个别参数名变了\n\n\n\\[\n\\begin{aligned}\n& \\min \\quad  f(x) \\\\\n& \\text {s.t.} \\begin{cases}\n\\textbf{A} \\cdot x \\leq b \\\\\n\\textbf{Aeq} \\cdot x=beq \\\\\nc(x) \\leq 0 \\\\\n\\operatorname{ceq}(x)=0 \\\\\nl b \\leq x \\leq u b\n\\end{cases}\n\\end{aligned}\n\\]\n其中 \\(f(x)\\)是目标函数, \\(x, b, beq\\) 是向量, \\(\\textbf{A}, \\textbf{Aeq}\\)是矩阵,\\(c(x)\\) 和 \\(ceq(x)\\) 是向量函數, \\(\\textbf{A}\\)线性不等式,\\(\\textbf{Aeq}\\)线性等式, \\(c(x)\\) 非线性不等式, \\(ceq(x)\\)非线性等式\n(求解最小值)语法:\nx = ga(fun,nvars,A,b,[],[],lb,ub,nonlcon,IntCon,options)\n[x,fval,exitflag,output,population,scores] = ga(___)\n\n\n% 解释:\nfun 为适应度句柄函数, 一般其输入为1*nvars的向量\nnvars, 即目标函数自变量的个数\nA,b,Aeq,beq,LB,UB,nonlcon参数与fmincon中类似,不在解释\nIntCon, 整数约束, 指定变量的下标则说明该变量为整数变量\noptions, 算法的属性设置\n\nx,最优解\nfval, 最优解对应的目标函数值\nexitflag, 算法停止的原因\noutput, 输出算法结构\npopulation, 最终得到种群适应度的列向量\nscores, 最终得到的种群\n\noptions = optimoptions('ga','PlotFcn',@gaplotbestf);\noptimoptions\nOptimization 解读, 详细解读,参考官网,这里只给出一些概念 \n\n{} 里面的值为默认值\n{}*表示存在线性约束时的默认值，对于MutationFcn，也表示存在边界时的默认值。\nI* 表示ga以不同方式处理整数约束的选项;；此符号不适用于gamultiobj。\nNM 表示该选项不适用于gamultiobj。\nOptions for ga, Integer ga, and gamultiobj\n\n\n\n\nOption\nDescription\nValues\n\n\n\n\nConstraintTolerance\n用以确定非线性约束的可行性,对于选项结构，请使用TolCon。\nPositive scalar | {1e-3}\n\n\nCreationFcn\n建立初始种群的函数句柄\n{'gacreationuniform'}\n\n\nCrossoverFcn\n子代交叉的函数句柄\n{'crossoverscattered'} for ga, {'crossoverintermediate'}*for gamultiobj\n\n\nCrossoverFraction\n交叉概率, 不包含由CrossoverFcn产生的子代\nPositive scalar | {0.8}\n\n\nDisplay\nLevel of display.\n'off'\n\n\nDistanceMeasureFcn\nFor gamultiobj only. 拥挤度函数\n{'distancecrowding'}\n\n\nEliteCount\n在当前这一代种群中指定保证在下一代存活的精英个体数目\nPositive integer |{ceil(0.05*PopulationSize)}\n\n\nFitnessLimit\nNM, 如果适应度函数的值达到 FitnessLmit 的值，则算法停止\nScalar | {-Inf} 即为一个实数，默认值 为 -lnf\n\n\nFitnessScalingFcn\n对适应度函数的值进行缩放, gamultiobj选项不可用。\n{'fitscalingrank'}\n\n\nFunctionTolerance\n容忍度, For an options structure, use TolFun.\nPositive scalar | {1e-6} for ga, {1e-4} for gamultiobj\n\n\nHybridFcn\nI* 在ga终止后继续优化的函数。指定为名称或函数句柄。\nFunction name or handle\n\n\nInitialPopulationMatrix\n初始种群.For an options structure, use InitialPopulation.\n为一个矩阵，默认值为 [ ]\n\n\nInitialPopulationRange\n初始种群的范围, 说明种群中数据元素类型的取值范围，\n取值为矩阵或向量\n\n\nInitialScoresMatrix\n初始适应度函数的评价得分值，\n为一个列向量，默认值为 [ ]\n\n\nMaxGenerations\n最大迭代次数\nPositive integer |{100*numberOfVariables} for ga, {200*numberOfVariables} for gamultiobj\n\n\nMaxStallGenerations\n适应度停滞限制.当目标函数在 StallTimeLimit代后没有改 善， 则算法停止，\n{50} for ga, {100} for gamultiobj\n\n\nMaxStallTime\n适应度停滞限制.当日标函数在 StaLlTimeLimit时间后没有改善，则算法停止，\n默认值为 lnf\n\n\nMaxTime\n算法总用时,超过后停止\nPositive scalar | {Inf}\n\n\nMigrationDirection\n迁移方向\n'both'\n\n\nMigrationFraction\n从一个子种群到另一个子种群的迁移概率\n0到1之间的数, 默认值0.2\n\n\nMigrationInterval\n\nPositive integer | {20}\n\n\nMutationFcn\n产生变异子代的函数句柄\n{'mutationgaussian'} for ga, {'mutationadaptfeasible'}* forgamultiobj\n\n\nNonlinearConstraintAlgorithm\n非线性约束算法\n{'auglag'} for ga, {'penalty'} for gamultiobj\n\n\nOutputFcn\nga 在每次迭代中调用的函数，\n取值为 @gaoutpulgen 或 [J(默认值〉\n\n\nParetoFraction\n仅用于gamultiobj, 保留帕累托解的比例?\nScalar | {0.35}\n\n\nPlotFcn\n边计算边绘制数据\nga or gamultiobj: {[]} | 'gaplotdistance' | 'gaplotgenealogy' | 'gaplotselection' | 'gaplotscorediversity' |'gaplotscores' | 'gaplotstopping' | 'gaplotmaxconstr' |Custom plot functiongaonly:‘gaplotbestf’\n\n\nPopulationSize\n种群的数量\nPositive integer | {50} when numberOfVariables <= 5, {200}otherwise\n\n\nPopulationType\n种群中数据元素类型的字符串\n‘bitstring’|‘custom’|{‘doubleVector’}\n\n\nSelectionFcn\n选择句柄函数，用以选择进行交叉和变异的父代\n{'selectionstochunif'} for ga, {'selectiontournament'} forgamultiobj\n\n\nUseParallel\n并行计算\ntrue\n\n\nUseVectorized\n指定函数是否向量化,For an options structure, use Vectorized with the values 'on' or 'off'.\ntrue| {false}\n\n\n\n\n\n\nimage-20210515160230482\n\n\n\n\n\nimage-20210515160240881\n\n\n\n\n\nimage-20210515160305942\n\n\n\n可以通过输出 output 参数, 来设置算法参数\n\n\n\n\n\\[\nmin \\quad g(x) = (x_1 -10)^3 + (x_2 -20 )^3  \\\\\ns.t. \\begin{cases}\n(x_1 - 5)^2 + (x_2 - 5)^2 \\geq 100\\\\\n13\\leq x_1 \\leq 100 \\\\\n0 \\leq x_2 \\leq 100\n\\end{cases}\\\\\n已知的最优点和最优值 g(x^*) = g(14.095,0.84296) = -6961.81381\n\\]\nclc,clear all;\nA = [];\nb = [];\nAeq = [];\nbeq = [];\nlb = [13,0];\nub = [100,100];\nnvars = 2;\noptions = optimoptions('ga','Display','final','PlotFcn','gaplotbestf','FunctionTolerance',1e-6);\n[x,fval] = ga(@myobjfun2,nvars ,A,b,Aeq,beq,lb,ub,@constrain,options)\n\n%% 目标函数\nfunction f = myobjfun2(x)\nf = (x(1) - 10)^3 + (x(2) - 20)^3;\nend\n\n%% 非线性约束\nfunction [c, ceq] = constrain(x)\n% 非线性不等式约束\nc = 100 - (x(1) - 5)^2 - (x(2)-5)^2;\n% 非线性等式约束\nceq = [];\nend\n结果如下:\nOptimization terminated: average change in the fitness value less than options.FunctionTolerance\n and constraint violation is less than options.ConstraintTolerance.\n\nx =\n   13.6602    0.0000\nfval =\n  -7.9509e+03\n不知道为什么? 居然比上面给出的结果还要好. 上题来源于 <<智能优化算法及其应用（王凌著）.pdf>>第一章绪论 第8页 — — 第6个函数\n参考:\n\n《MATLAB R2015b最优化计算》–李娅\nhttps://www.mathworks.com/help/gads/ga.html"
  },
  {
    "objectID": "posts/md/模拟退火算法.html",
    "href": "posts/md/模拟退火算法.html",
    "title": "模拟退火算法（待完善）",
    "section": "",
    "text": "什么是退火：指对物体（指的是固体）加温至熔化，再徐徐冷却，使之凝固成规则晶体的热力学过程，简而言之，是对物体加温后再冷却的一个物理过程。\n可见，物理退火过程由以下三部分组成：\n（1）加温过程： 一般一个物体不是一个有规则的晶体（下图左图），于是加热，当温度足够高时，固体的规则性被彻底破坏，固体熔解为液体（下图中图），从而消除系统原先可能存在的非均匀状态，使随后进行的冷却过程以某一平衡态为起点。溶解过程与系统的熵增过程相联系，系统能量也随温度的升高而增大。\n（2）等温过程。当某一温度固定后，要使系统达到热平衡态，才能进行降温，这就是“徐徐”的意思。如果降温降低很快，会出现猝火效应（对应后面讲解的局部最小值），即猝火效应是指固体只能冷凝为非均匀的亚稳态，系统能量也不会达到最小值。\n​ 由物理学知识可知，对于与周围环境交换热量而温度保持不变的封闭系统，系统状态的自发变化总是朝着自由能减少的方向进行，当自由能到达最小值时，系统达到热平衡态。此现象保证系统在每一温度下能到达平衡态的过程。这个跟熵很类似。（熵总是往这增大的方向进行）\n等温下热平衡过程可用Metropolis准则（即以概率接受新状态）进行模拟。\nMetropolis准则：\n假设当前状态为 \\(x(n)\\) , 系统受到一定扰动，状态变为 \\(x(n+1)\\),相应的系统能量由 \\(E(n)\\) 变为 \\(E(n+1)\\) ,定义状态 \\(x(n)\\) 变为 \\(x(n+1)\\) 的接受概率为 \\(p\\) :\n\\[\np=  \\begin{cases}\n1   &, E(n+1) < E(n) \\\\\ne^{\\left(-\\frac{E(n+1)-E(n)}{T}\\right)}  &,E(n+1) \\geq E(n) \\\\\n\\end{cases}\n\\]\n当状态转移之后，如果能量减小了（即 \\(E(n+1) < E(n)\\) ），那么这种转移就被接受了（以概率1发生）\n当状态转移之后，如果能量增大了(即 \\(E(n+1) \\geq E(n)\\) ），那么这种转移按照概率 \\(p= e^{\\left(-\\frac{E(n+1)-E(n)}{T}\\right)}\\) 去接受，具体操作： 首先在区间[0,1]产生一个均匀分布的随机数\\(\\xi\\)，如果 $< p（此时p= e^{(-)} ） $,则这种转移被接受，否则被拒绝。\n（3）冷却过程，液体粒子的热运动逐渐减弱，随着温度的徐徐降低（即系统能量逐渐下降），粒子运动逐渐有序，当温度减到足够小时，液体凝固成按一定形状排列，高密度，低能量的有规则晶体（下图右图）。\n\n\n\nmoni01\n\n\n对照表\n\n\n\n模拟退火\n物理退火\n\n\n\n\n解\n粒子状态\n\n\n最优解\n能量最低态\n\n\n设定初始温度\n熔解过程\n\n\nMetropolis采样过程\n等温过程\n\n\n控制参数的下降\n冷却\n\n\n目标函数\n能量\n\n\n\n\n\n\n基本思想： 其基本思想是模拟金属退火过程。\n基本步骤（求 \\(min \\ f(x)\\)）：\n(1)明确目的，第一步是确定问题域，包括变量 \\(x\\)的个数和维度，以及目标函数 \\(f( \\cdot )\\)的计算方式\n(2)初始化，随机产生一个初始解 \\(x_0\\)，令 $x_{best } = x_0 \\(，并计算目标函数值\\)f(x_0)\\(，同时设置**初始温度\\)T(0)\\(**,终止温度\\)T_{final}$ 和温度的下降公式及相应的参数。\n\nDo while $ T(0) > T_{final} $ # 外循环\n\n\n① for j = 1~ k #内循环 ， k为内循环的最大迭代次数\n② 运行Metropolis算法，以一定规则在当前状态 \\(x_{best}\\) 附近产生新的状态 \\(x_{new}\\)，计算 \\(f(x_{best})\\) 与 \\(f(x_{new})\\) ，并计算目标函数值得增量 \\(\\Delta f = f(x_{best}) - f(x_{new})\\) 。\n③\n\n如果\\(\\Delta f <0\\) ,则 \\(x_{best} := x_{new}\\) 。\n\n如果 \\(\\Delta f > 0\\) ,则计算\\(p = e^{ - \\frac{\\Delta f}{T}}\\),并从0~1之间产生一个随机数\\(\\xi\\)，\n\n如果 \\(\\xi < p\\),则\\(x_{best} := x_{new}\\)，否则,\\(x_{best} := x_{best}\\)。\n\n\n④ End for\n\n\n按温度的下降公式更新温度\\(T(0)\\)。 \nEnd Do\n输出当前最优点,计算结束。\n\n\n\n\n\n\n一般是按照某一概率密度分别函数（均匀分布、正太分布、指数分布）进行随机采样得到新的状态，如果是函数优化可以采取牛顿迭代的方法产生新的状态。\n\n\n\n指数式下降（简单式）: \\(T(0) := \\lambda T(0)​\\) , 其中\\(\\lambda<1​\\) ,一般取 0.8~0.99之间.\n经典式（常用式）： \\(T(0):= \\dfrac{T_0}{lg(1+t)}\\)\n快速降温： \\(T(0) := \\dfrac{T_0}{1+t}\\)\n\n\n\n初始温度足够高，温度下降的足够慢，能使系统达到高质量的解，但耗费时间也非常大。\n应该适当权衡初始温度和温度的下降。所有模拟退火算法的解与温度有很大的关系。\n\n\n\n（1）目标函数的值是否趋于稳定\n（2） 是否达到最大迭代次数\n\n\n\n（1）是否到达最低温度（常用）。\n（2）设置外循环的最大迭代次数。\n（3）外循环搜索到的最有值对应的目标函数值连续若干步保持不变。"
  },
  {
    "objectID": "posts/md/R语言字符处之stringr包.html",
    "href": "posts/md/R语言字符处之stringr包.html",
    "title": "R语言字符处理函数包—stringr包",
    "section": "",
    "text": "stringr包被定义为一致的、简单易用的字符串工具集。所有的函数和参数定义都具有一致性，比如，用相同的方法进行NA处理和0长度的向量处理。\n字符串处理虽然不是R语言中最主要的功能，却也是必不可少的，数据清洗、可视化等的操作都会用到。对于R语言本身的base包提供的字符串基础函数，随着时间的积累，已经变得很多地方不一致，不规范的命名，不标准的参数定义，很难看一眼就上手使用。字符串处理在其他语言中都是非常方便的事情，R语言在这方面确实落后了。stringr包就是为了解决这个问题，让字符串处理变得简单易用，提供友好的字符串操作接口。"
  },
  {
    "objectID": "posts/md/R语言字符处之stringr包.html#stringr的api介绍",
    "href": "posts/md/R语言字符处之stringr包.html#stringr的api介绍",
    "title": "R语言字符处理函数包—stringr包",
    "section": "2.stringr的API介绍",
    "text": "2.stringr的API介绍\nstringr包常用的字符串的处理以str_开头来命名，方便更直观理解函数的定义。我们可以根据使用习惯对函数进行分类：\n\n字符串拼接函数\n\n\n\n\n\n\n\n\n函数\n说明\nR Base中对应函数\n\n\n\n\nstr_c()str_join() 同str_c()\n字符串拼接\npaste(),paste0()\n\n\nstr_trim())\n去掉字符串的空格和TAB(\n\n\n\nstr_pad()\n用pad参数填充字符串的长度，长度自己设定\n\n\n\nstr_dup()\n复制字符串\n\n\n\nstr_wrap()\n控制字符串输出格式\nstrtrim()\n\n\nstr_sub()str_sub() <- value\n截取字符串抽取或替换正则表达式匹配子串\nregmatches()regmatches() <- value\n\n\n\n\n\n字符串计算函数\n\n\n\n函数\n说明\nR Base中对应函数\n\n\n\n\nstr_count()\n字符串计数，返回指定匹配出现的次数\n\n\n\nstr_length()\n返回字符的长度\nnchar()\n\n\nstr_sort()\n对字符值进行排序\n\n\n\nstr_order()\n字符串索引排序，\n\n\n\n\n\n\n字符串匹配函数\n\n\n\n\n\n\n\n\n函数\n说明\nR Base中对应函数\n\n\n\n\nstr_split()str_split_fixed() 同上\n按照模式分割字符串\nstrsplit()\n\n\nstr_match()str_match_all()\n从字符串中提取首个匹配组\n\n\n\nstr_replacestr_replace_all\n替换首个匹配模式\nsub()gsub()\n\n\nstr_replace_na()\n把NA替换为NA字符串\n\n\n\nstr_locate()str_locate_all()\n返回首个匹配模式的字符的位置\nregexpr()gregexpr()\n\n\nstr_extract()str_extract_all()\n提取首个匹配模式的字符\n\n\n\nstr_subset()\n返回匹配的字符串\n\n\n\nstr_detect()\n检测字符是否存在某些指定模式\ngrepl()\n\n\nword()\n从文本中提取单词\n\n\n\n\n\n\n字符串变换函数\n\n\n\n\n\n\n\n\n函数\n说明\nR Base中对应函数\n\n\n\n\nstr_conv()\n字符编码转换,基本函数中的比较好用\niconv(x, from = ““, to =”“)\n\n\nstr_to_upper()str_to_lower()\n字符串转成大写/小写\ntolower(x)toupper(x)\n\n\nstr_to_title()同大小写转换\n字符串转成首字母大写\n\n\n\n\n\n\n参数控制函数，\n仅用于构造功能的参数，不能独立使用。\n\nboundary: 定义使用边界\n\ncoll: 定义字符串标准排序规则。\n\nfixed: 定义用于匹配的字符，包括正则表达式中的转义符\nregex: 定义正则表达式"
  },
  {
    "objectID": "posts/md/R语言字符处之stringr包.html#stringr的详细使用",
    "href": "posts/md/R语言字符处之stringr包.html#stringr的详细使用",
    "title": "R语言字符处理函数包—stringr包",
    "section": "3.stringr的详细使用",
    "text": "3.stringr的详细使用\n3.1 字符串拼接函数\n3.1.1 str_c，字符串拼接操作，与str_join完全相同，与paste()行为不完全一致。\n函数定义：\nstr_c(..., sep = \"\", collapse = NULL)\nstr_join(..., sep = \"\", collapse = NULL)\n参数列表：\n\n…: 多参数的输入\nsep: 把多个字符串拼接为一个大的字符串，用于字符串的分割符。\ncollapse: 把多个向量参数拼接为一个大的字符串，用于字符串的分割符。\n\n把多个字符串拼接为一个大的字符串。\n> str_c('a','b')\n[1] \"ab\"\n> str_c('a','b',sep='-')\n[1] \"a-b\"\n> str_c(c('a','a1'),c('b','b1'),sep='-')\n[1] \"a-b\"   \"a1-b1\"\n把多个向量参数拼接为一个大的字符串。\n> str_c(head(letters), collapse = \"\")\n[1] \"abcdef\"\n> str_c(head(letters), collapse = \", \")\n[1] \"a, b, c, d, e, f\"\n\n# collapse参数，对多个字符串无效\n> str_c('a','b',collapse = \"-\")   \n[1] \"ab\"\n> str_c(c('a','a1'),c('b','b1'),collapse='-')\n[1] \"ab-a1b1\"\n拼接有NA值的字符串向量时，NA还是NA\n> str_c(c(\"a\", NA, \"b\"), \"-d\")\n[1] \"a-d\" NA    \"b-d\"\n对比str_c()函数和paste()函数之间的不同点。\n# 多字符串拼接，默认的sep参数行为不一致\n> str_c('a','b')\n[1] \"ab\"\n> paste('a','b')\n[1] \"a b\"\n\n# 向量拼接字符串，collapse参数的行为一致\n> str_c(head(letters), collapse = \"\")\n[1] \"abcdef\"\n> paste(head(letters), collapse = \"\")\n[1] \"abcdef\"\n \n#拼接有NA值的字符串向量，对NA的处理行为不一致\n> str_c(c(\"a\", NA, \"b\"), \"-d\")\n[1] \"a-d\" NA    \"b-d\"\n> paste(c(\"a\", NA, \"b\"), \"-d\")\n[1] \"a -d\"  \"NA -d\" \"b -d\" \n3.1.2 str_trim:去掉字符串的空格和TAB(\n函数定义：\nstr_trim(string, side = c(\"both\", \"left\", \"right\"))\n参数列表：\n\nstring: 字符串，字符串向量。\nside: 过滤方式，both两边都过滤，left左边过滤，right右边过滤\n\n去掉字符串的空格和TAB(\n#只过滤左边的空格\n> str_trim(\"  left space\\t\\n\",side='left') \n[1] \"left space\\t\\n\"\n\n#只过滤右边的空格\n> str_trim(\"  left space\\t\\n\",side='right')\n[1] \"  left space\"\n\n#过滤两边的空格\n> str_trim(\"  left space\\t\\n\",side='both')\n[1] \"left space\"\n\n#过滤两边的空格\n> str_trim(\"\\nno space\\n\\t\")\n[1] \"no space\"\n3.1.3 str_pad:补充字符串的长度\n函数定义：\nstr_pad(string, width, side = c(\"left\", \"right\", \"both\"), pad = \" \")\n参数列表：\n\nstring: 字符串，字符串向量。\nwidth: 字符串填充后的长度\nside: 填充方向，both两边都填充，left左边填充，right右边填充\npad: 用于填充的字符\n\n补充字符串的长度。\n# 从左边补充空格，直到字符串长度为20\n> str_pad(\"conan\", 20, \"left\")\n[1] \"               conan\"\n\n# 从右边补充空格，直到字符串长度为20\n> str_pad(\"conan\", 20, \"right\")\n[1] \"conan               \"\n\n# 从左右两边各补充空格，直到字符串长度为20\n> str_pad(\"conan\", 20, \"both\")\n[1] \"       conan        \"\n\n# 从左右两边各补充x字符，直到字符串长度为20\n> str_pad(\"conan\", 20, \"both\",'x')\n[1] \"xxxxxxxconanxxxxxxxx\"\n3.1.4 str_dup: 复制字符串\n函数定义：\nstr_dup(string, times)\n参数列表：\n\nstring: 字符串，字符串向量。\ntimes: 复制数量\n\n复制一个字符串向量。\n> val <- c(\"abca4\", 123, \"cba2\")\n\n# 复制2次\n> str_dup(val, 2)\n[1] \"abca4abca4\" \"123123\"     \"cba2cba2\"  \n\n# 按位置复制\n> str_dup(val, 1:3)\n[1] \"abca4\"        \"123123\"       \"cba2cba2cba2\"\n3.1.5 str_wrap，控制字符串输出格式\n函数定义：\nstr_wrap(string, width = 80, indent = 0, exdent = 0)\n参数列表：\n\nstring: 字符串，字符串向量。\nwidth: 设置一行所占的宽度。\nindent: 段落首行的缩进值\nexdent: 段落非首行的缩进值\n\n txt<-'R语言作为统计学一门语言，一直在小众领域闪耀着光芒。直到大数据的爆发，R语言变成了一门炙手可热的数据分析的利器。随着越来越多的工程背景的人的加入，R语言的社区在迅速扩大成长。现在已不仅仅是统计领域，教育，银行，电商，互联网….都在使用R语言。'\n\n# 设置宽度为40个字符\n> cat(str_wrap(txt, width = 40), \"\\n\")\nR语言作为统计学一门语言，一直在小众领域\n闪耀着光芒。直到大数据的爆发，R语言变成\n了一门炙手可热的数据分析的利器。随着越来\n越多的工程背景的人的加入，R语言的社区在\n迅速扩大成长。现在已不仅仅是统计领域，教\n育，银行，电商，互联网….都在使用R语言。 \n\n# 设置宽度为60字符，首行缩进2字符\n> cat(str_wrap(txt, width = 60, indent = 2), \"\\n\")\n  R语言作为统计学一门语言，一直在小众领域闪耀着光芒。直到大数\n据的爆发，R语言变成了一门炙手可热的数据分析的利器。随着越来\n越多的工程背景的人的加入，R语言的社区在迅速扩大成长。现在已\n不仅仅是统计领域，教育，银行，电商，互联网….都在使用R语言。 \n\n# 设置宽度为10字符，非首行缩进4字符\n> cat(str_wrap(txt, width = 10, exdent = 4), \"\\n\")\nR语言作为\n    统计学一\n    门语言，\n    一直在小\n    众领域闪\n    耀着光芒。\n    直到大数据\n    的爆发，R\n    语言变成了\n    一门炙手可\n    热的数据分\n    析的利器。\n    随着越来\n    越多的工程\n    背景的人的\n    加入，R语\n    言的社区在\n    迅速扩大成\n    长。现在已\n    不仅仅是统\n    计领域，教\n    育，银行，\n    电商，互联\n    网….都在使\n    用R语言。 \n3.1.6 str_sub,截取字符串\n函数定义：\nstr_sub(string, start = 1L, end = -1L)\n参数列表：\n\nstring: 字符串，字符串向量。\nstart : 开始位置\nend : 结束位置\n\n截取字符串。\n> txt <- \"I am Conan.\"\n\n# 截取1-4的索引位置的字符串\n> str_sub(txt, 1, 4)\n[1] \"I am\"\n\n# 截取1-6的索引位置的字符串\n> str_sub(txt, end=6)\n[1] \"I am C\"\n\n# 截取6到结束的索引位置的字符串\n> str_sub(txt, 6)\n[1] \"Conan.\"\n\n# 分2段截取字符串\n> str_sub(txt, c(1, 4), c(6, 8))\n[1] \"I am C\" \"m Con\" \n\n# 通过负坐标截取字符串\n> str_sub(txt, -3)\n[1] \"an.\"\n> str_sub(txt, end = -3)\n[1] \"I am Cona\"\n对截取的字符串进行赋值。\n> x <- \"AAABBBCCC\"\n\n# 在字符串的1的位置赋值为1\n> str_sub(x, 1, 1) <- 1; x\n[1] \"1AABBBCCC\"\n\n# 在字符串从2到-2的位置赋值为2345\n> str_sub(x, 2, -2) <- \"2345\"; x\n[1] \"12345C\"\n3.2 字符串计算函数\n3.2.1 str_count, 字符串计数\n函数定义：\nstr_count(string, pattern = \"\")\n参数列表：\n\nstring: 字符串，字符串向量。\npattern: 匹配的字符。\n\n对字符串中匹配的字符计数\n> str_count('aaa444sssddd', \"a\")\n[1] 3\n对字符串向量中匹配的字符计数\n> fruit <- c(\"apple\", \"banana\", \"pear\", \"pineapple\")\n> str_count(fruit, \"a\")\n[1] 1 3 1 1\n> str_count(fruit, \"p\")\n[1] 2 0 1 3\n对字符串中的’.’字符计数，由于.是正则表达式的匹配符，直接判断计数的结果是不对的。\n> str_count(c(\"a.\", \".\", \".a.\",NA), \".\")\n[1]  2  1  3 NA\n\n# 用fixed匹配字符\n> str_count(c(\"a.\", \".\", \".a.\",NA), fixed(\".\"))\n[1]  1  1  2 NA\n\n# 用\\\\匹配字符\n> str_count(c(\"a.\", \".\", \".a.\",NA), \"\\\\.\")\n[1]  1  1  2 NA\n3.2.2 str_length,字符串长度\n函数定义：\nstr_length(string)\n参数列表：\n\nstring: 字符串，字符串向量。\n\n计算字符串的长度:\n> str_length(c(\"I\", \"am\", \"张丹\", NA))\n[1]  1  2  2 NA\n3.2.3 str_sort, 字符串值排序，同str_order索引排序\n函数定义：\nstr_sort(x, decreasing = FALSE, na_last = TRUE, locale = \"\", ...)\nstr_order(x, decreasing = FALSE, na_last = TRUE, locale = \"\", ...)\n参数列表：\n\nx: 字符串，字符串向量。\ndecreasing: 排序方向。\nna_last:NA值的存放位置，一共3个值，TRUE放到最后，FALSE放到最前，NA过滤处理\nlocale:按哪种语言习惯排序\n\n对字符串值进行排序。\n# 按ASCII字母排序\n> str_sort(c('a',1,2,'11'), locale = \"en\")  \n[1] \"1\"  \"11\" \"2\"  \"a\" \n\n# 倒序排序\n> str_sort(letters,decreasing=TRUE)         \n [1] \"z\" \"y\" \"x\" \"w\" \"v\" \"u\" \"t\" \"s\" \"r\" \"q\" \"p\" \"o\" \"n\" \"m\" \"l\" \"k\" \"j\" \"i\" \"h\"\n[20] \"g\" \"f\" \"e\" \"d\" \"c\" \"b\" \"a\"\n\n# 按拼音排序\n> str_sort(c('你','好','粉','丝','日','志'),locale = \"zh\")  \n[1] \"粉\" \"好\" \"你\" \"日\" \"丝\" \"志\"\n对NA值的排序处理\n #把NA放最后面\n> str_sort(c(NA,'1',NA),na_last=TRUE) \n[1] \"1\" NA  NA\n \n#把NA放最前面\n> str_sort(c(NA,'1',NA),na_last=FALSE) \n[1] NA  NA  \"1\"\n\n#去掉NA值 \n> str_sort(c(NA,'1',NA),na_last=NA)    \n[1] \"1\"\n3.3 字符串匹配函数\n3.3.1 str_split,字符串分割，同str_split_fixed\n函数定义：\nstr_split(string, pattern, n = Inf)\nstr_split_fixed(string, pattern, n)\n参数列表：\n\nstring: 字符串，字符串向量。\npattern: 匹配的字符。\nn: 分割个数\n\n对字符串进行分割。\n> val <- \"abc,123,234,iuuu\"\n\n# 以,进行分割\n> s1<-str_split(val, \",\");s1\n[[1]]\n[1] \"abc\"  \"123\"  \"234\"  \"iuuu\"\n\n# 以,进行分割，保留2块\n> s2<-str_split(val, \",\",2);s2\n[[1]]\n[1] \"abc\"          \"123,234,iuuu\"\n\n# 查看str_split()函数操作的结果类型list\n> class(s1)\n[1] \"list\"\n\n# 用str_split_fixed()函数分割，结果类型是matrix\n> s3<-str_split_fixed(val, \",\",2);s3\n     [,1]  [,2]          \n[1,] \"abc\" \"123,234,iuuu\"\n\n> class(s3)\n[1] \"matrix\"\n3.3.2 str_subset:返回的匹配字符串\n函数定义：\nstr_subset(string, pattern)\n参数列表：\n\nstring: 字符串，字符串向量。\npattern: 匹配的字符。\n\n> val <- c(\"abc\", 123, \"cba\")\n\n# 全文匹配\n> str_subset(val, \"a\")\n[1] \"abc\" \"cba\"\n\n# 开头匹配\n> str_subset(val, \"^a\")\n[1] \"abc\"\n\n# 结尾匹配\n> str_subset(val, \"a$\")\n[1] \"cba\"\n3.3.3 word, 从文本中提取单词\n函数定义：\nword(string, start = 1L, end = start, sep = fixed(\" \"))\n参数列表：\n\nstring: 字符串，字符串向量。\nstart: 开始位置。\nend: 结束位置。\nsep: 匹配字符。\n\n> val <- c(\"I am Conan.\", \"http://fens.me, ok\")\n\n# 默认以空格分割，取第一个位置的字符串\n> word(val, 1)\n[1] \"I\"               \"http://fens.me,\"\n> word(val, -1)\n[1] \"Conan.\" \"ok\"    \n> word(val, 2, -1)\n[1] \"am Conan.\" \"ok\"       \n\n# 以,分割，取第一个位置的字符串 \n> val<-'111,222,333,444'\n> word(val, 1, sep = fixed(','))\n[1] \"111\"\n> word(val, 3, sep = fixed(','))\n[1] \"333\"\n3.3.4 str_detect匹配字符串的字符\n函数定义：\nstr_detect(string, pattern)\n参数列表：\n\nstring: 字符串，字符串向量。\npattern: 匹配字符。\n\n> val <- c(\"abca4\", 123, \"cba2\")\n\n# 检查字符串向量，是否包括a\n> str_detect(val, \"a\")\n[1]  TRUE FALSE  TRUE\n\n# 检查字符串向量，是否以a为开头\n> str_detect(val, \"^a\")\n[1]  TRUE FALSE FALSE\n\n# 检查字符串向量，是否以a为结尾\n> str_detect(val, \"a$\")\n[1] FALSE FALSE FALSE\n3.3.6 str_match,从字符串中提取匹配组\n函数定义：\nstr_match(string, pattern)\nstr_match_all(string, pattern)\n参数列表：\n\nstring: 字符串，字符串向量。\npattern: 匹配字符。\n\n从字符串中提取匹配组\n> val <- c(\"abc\", 123, \"cba\")\n\n# 匹配字符a，并返回对应的字符\n> str_match(val, \"a\")\n     [,1]\n[1,] \"a\" \n[2,] NA  \n[3,] \"a\" \n\n# 匹配字符0-9，限1个，并返回对应的字符\n> str_match(val, \"[0-9]\")\n     [,1]\n[1,] NA  \n[2,] \"1\" \n[3,] NA  \n\n# 匹配字符0-9，不限数量，并返回对应的字符\n> str_match(val, \"[0-9]*\")\n     [,1] \n[1,] \"\"   \n[2,] \"123\"\n[3,] \"\"  \n从字符串中提取匹配组，以字符串matrix格式返回\n> str_match_all(val, \"a\")\n[[1]]\n     [,1]\n[1,] \"a\" \n\n[[2]]\n     [,1]\n\n[[3]]\n     [,1]\n[1,] \"a\" \n\n> str_match_all(val, \"[0-9]\")\n[[1]]\n     [,1]\n\n[[2]]\n     [,1]\n[1,] \"1\" \n[2,] \"2\" \n[3,] \"3\" \n\n[[3]]\n     [,1]\n3.3.7 str_replace，字符串替换\n函数定义：\nstr_replace(string, pattern, replacement)\n参数列表：\n\nstring: 字符串，字符串向量。\npattern: 匹配字符。\nreplacement: 用于替换的字符。\n\n> val <- c(\"abc\", 123, \"cba\")\n\n# 把目标字符串第一个出现的a或b，替换为-\n> str_replace(val, \"[ab]\", \"-\")\n[1] \"-bc\" \"123\" \"c-a\"\n\n# 把目标字符串所有出现的a或b，替换为-\n> str_replace_all(val, \"[ab]\", \"-\")\n[1] \"--c\" \"123\" \"c--\"\n\n# 把目标字符串所有出现的a，替换为被转义的字符\n> str_replace_all(val, \"[a]\", \"\\1\\1\")\n[1] \"\\001\\001bc\" \"123\"        \"cb\\001\\001\"\n3.3.8 str_replace_na把NA替换为NA字符串\n函数定义：\nstr_replace_na(string, replacement = \"NA\")\n参数列表：\n\nstring: 字符串，字符串向量。\nreplacement : 用于替换的字符。\n\n把NA替换为字符串\n> str_replace_na(c(NA,'NA',\"abc\"),'x')\n[1] \"x\"   \"NA\"  \"abc\"\n3.3.9 str_locate，找到的模式在字符串中的位置。\n函数定义：\nstr_locate(string, pattern)\nstr_locate_all(string, pattern)\n参数列表：\n\nstring: 字符串，字符串向量。\npattern: 匹配字符。\n\n> val <- c(\"abca\", 123, \"cba\")\n\n# 匹配a在字符串中的位置\n> str_locate(val, \"a\")\n     start end\n[1,]     1   1\n[2,]    NA  NA\n[3,]     3   3\n\n# 用向量匹配\n> str_locate(val, c(\"a\", 12, \"b\"))\n     start end\n[1,]     1   1\n[2,]     1   2\n[3,]     2   2\n\n# 以字符串matrix格式返回\n> str_locate_all(val, \"a\")\n[[1]]\n     start end\n[1,]     1   1\n[2,]     4   4\n\n[[2]]\n     start end\n\n[[3]]\n     start end\n[1,]     3   3\n\n# 匹配a或b字符，以字符串matrix格式返回\n> str_locate_all(val, \"[ab]\")\n[[1]]\n     start end\n[1,]     1   1\n[2,]     2   2\n[3,]     4   4\n\n[[2]]\n     start end\n\n[[3]]\n     start end\n[1,]     2   2\n[2,]     3   3\n3.3.10 str_extract从字符串中提取匹配模式\n函数定义：\nstr_extract(string, pattern)\nstr_extract_all(string, pattern, simplify = FALSE)\n参数列表：\n\nstring: 字符串，字符串向量。\npattern: 匹配字符。\nsimplify: 返回值，TRUE返回matrix，FALSE返回字符串向量\n\n> val <- c(\"abca4\", 123, \"cba2\")\n\n# 返回匹配的数字\n> str_extract(val, \"\\\\d\")\n[1] \"4\" \"1\" \"2\"\n\n# 返回匹配的字符\n> str_extract(val, \"[a-z]+\")\n[1] \"abca\" NA     \"cba\" \n\n\n> val <- c(\"abca4\", 123, \"cba2\")\n> str_extract_all(val, \"\\\\d\")\n[[1]]\n[1] \"4\"\n\n[[2]]\n[1] \"1\" \"2\" \"3\"\n\n[[3]]\n[1] \"2\"\n\n> str_extract_all(val, \"[a-z]+\")\n[[1]]\n[1] \"abca\"\n\n[[2]]\ncharacter(0)\n\n[[3]]\n[1] \"cba\"\n3.4 字符串变换函数\n3.4.1 str_conv:字符编码转换\n函数定义：\nstr_conv(string, encoding)\n参数列表：\n\nstring: 字符串，字符串向量。\nencoding: 编码名。\n\n对中文进行转码处理。\n# 把中文字符字节化\n> x <- charToRaw('你好');x\n[1] c4 e3 ba c3\n\n# 默认win系统字符集为GBK，GB2312为GBK字集，转码正常\n> str_conv(x, \"GBK\")\n[1] \"你好\"\n> str_conv(x, \"GB2312\")\n[1] \"你好\"\n\n# 转UTF-8失败\n> str_conv(x, \"UTF-8\")\n[1] \"���\"\nWarning messages:\n1: In stri_conv(string, encoding, \"UTF-8\") :\n  input data \\xffffffc4 in current source encoding could not be converted to Unicode\n2: In stri_conv(string, encoding, \"UTF-8\") :\n  input data \\xffffffe3\\xffffffba in current source encoding could not be converted to Unicode\n3: In stri_conv(string, encoding, \"UTF-8\") :\n  input data \\xffffffc3 in current source encoding could not be converted to Unicode\n把unicode转UTF-8\n> x1 <- \"\\u5317\\u4eac\"\n> str_conv(x1, \"UTF-8\")\n[1] \"北京\"\n3.4.2 str_to_upper,字符串大写转换。\n函数定义：\nstr_to_upper(string, locale = \"\")\nstr_to_lower(string, locale = \"\")\nstr_to_title(string, locale = \"\")\n参数列表：\n\nstring: 字符串。\nlocale:按哪种语言习惯排序\n\n字符串大写转换:\n> val <- \"I am conan. Welcome to my blog! http://fens.me\"\n\n# 全大写\n> str_to_upper(val)\n[1] \"I AM CONAN. WELCOME TO MY BLOG! HTTP://FENS.ME\"\n\n# 全小写\n> str_to_lower(val)\n[1] \"i am conan. welcome to my blog! http://fens.me\"\n\n# 首字母大写\n> str_to_title(val)\n[1] \"I Am Conan. Welcome To My Blog! Http://Fens.Me\"\n字符串在平常的数据处理中经常用过，需要对字符串进行分割、连接、转换等操作，本篇中通过介绍stringr，灵活的字符串处理库，可以有效地提高代码的编写效率。有了好的工具，在用R语言处理字符串就顺手了。\n本文转载张丹的粉丝日志，链接：http://blog.fens.me/r-stringr/，"
  },
  {
    "objectID": "posts/md/remove-dataframe-columns.html",
    "href": "posts/md/remove-dataframe-columns.html",
    "title": "数据框删除列的方法汇总",
    "section": "",
    "text": "iris[1:10,-5] # 1. 通过索引删除列\niris[1:10,-c(4,5)] # 删除多列\n\niris[1:10,-which(names(iris)%in%c(\"Petal.Width\",\"Species\"))]# 2.根据列名进行删除\n\nsubset(iris, select = -c(Petal.Width, Species))# 3 根据列名进行删除\n\niris[1:10,1:4]# 筛选出需要的列"
  },
  {
    "objectID": "posts/md/GitHubDesktop权限问题解决办法.html",
    "href": "posts/md/GitHubDesktop权限问题解决办法.html",
    "title": "GitHubDesktop权限问题解决办法",
    "section": "",
    "text": "Error\n\nAuthentication failed. You may not have permission to access the repository or the repository may have been archived. Open options and verify that you're signed in with an account that has permission to access this repository.\n\n网上百度了一下，发现有两种解决办法：\n1.退出后重新登录\n2.设置项目repository settings改为https的远程url地址\n经过测试，发现这两种方式都没有起到作用\n于是我猜可能和win收购github有关，\n解决办法：\n设置了项目的repository settings\n将remote repository设置成：https://注册名:密码@github.com/xmilt/xmilt.github.io.git\n才能正常pull和push等操作。"
  },
  {
    "objectID": "posts/md/博客搭建.html",
    "href": "posts/md/博客搭建.html",
    "title": "博客搭建——blogdown之md",
    "section": "",
    "text": "2、打开Rstudio—-下载blogdown包\nif(!require(devtools)) install.packages('devtools')\ndevtools::install_github('rstudio/blogdown')\n等待安装，缺什么安装什么，\n\n\n3、在rstudio中安装hugo软件,只需运行下面函数即可\nblogdown::install_hugo()\n注意：他会自动安装hugo软件，不过很小，10m一下，找到下载的hugo.exe文件路径，把他添加到电脑的环境变量中，不然后面会出错，软件可以随便放位置，切记加入环境变量中\n\n\n4、创建测试网站\n\n可用命令blogdown::new_site(),\n在rstudio中的左上角点击【file】–【New Project】—【Website using blogdown】\n\n\n\n\nNewProject\n\n\n适当选择自己的要求即可，点击【Create Project】创建完成，此时已经自动创建好了博客，\n\n\n5、创建完成\n在刚刚所在目录【E:_blog】下面有很多文件，其他的可以不用管，可以找到一个config.tom配置文件，更改与你相关的信息，添加relativeurls =true保存(意思是引用想对路径)，也可以不用暂时不用管这个，毕竟我们只是了解创建博客步骤，但是还是请你留意两个文件content\\ 和public\\ ，content\\ 用来写文章的文件，暂时还没有public\\文件夹,这个是把content\\ 文件夹下面的文章转变为html博客文章\n\n\n6、运行blogdown:::serve_site() 博客创建完成.\n\n也可以点击【adds】–【serve_site】，rstudio右边会有本地浏览\n\n\n\n7、发布到网上\n\n创建github和netlify网站的账号，下载git客服端，以及github客服端，可能有相关配置，配置好即可\n打开github客服端，点击【file】–【Create a new repository】添加仓库地址即我们刚刚的创建博客的地址，选择E\\test_blog ，选择子目录和父目录都不可以，只能选择他，填写相关Name 和 Description完成即可，可以勾选 …..a README,创建完成\n初次可以看到History里面有我们刚刚的文件 ，点击Publish repository，弹出对话框，有一个Name，这个是要上传给github仓库的名字，它自动创建为test_blog,也有描述内容，注意他勾选了一个Keep this code private ，这个要点取消，最后一步点击【Publish repository】,等待完成\n上github官网，查看你的仓库，已经有一个test_blog仓库\n进入netlify官网 ,点击【New site from Git】—【github】（取消勾选下面的LImit Github……..）–选择刚刚的test_blog仓库—在显示Publish directory 的地方如数public—最后点击部署，等待完成\n找到部署完成以后会有个绿色的网站，我的是：https://thirsty-hawking-274891.netlify.com,点击进入，就是我们部署的博客了，\n网站名太难记，可以改名，改为自己喜欢的民资，只能改netlify的前面的地方,我改为：qaz.netlify.com\n\n\n\n8、发布新帖\n\n方法一：将原有的.md或 .Rmd拷贝粘贴，改一下标题和内容即可；\n方法二：在RSudio代码窗口点击 Addins- New Post， 按提示填写即可。\n\n写完以后，保存，运行建站函数blogdown::build_site() 。这样文件发生变化，github客服端自动检测，只需要你填写【Change】下面的summary和Description，点击提交给master，再次同步到github（点击Fetch origin） 完成，netlify自动同步github的内容 进入你的博客网站可以看到有了新变化\n\n\n\n\n9、添加disqus评论功能(科学上网)\n\n注册登录disqus ,点击头像 –settings —Add Disqus To site–[GET STARTED]—–I want to install Disqus on my site ——输入刚刚的网站 ：qaz.netlify.com\n找到安装disqus，有很多图标，但是没有hugo，因此选择 下面I don’t see my platform listed, install manually with Universal Code 即可–不用管 直接configure—-配置网站地址，点击下一步到最后\n注意：一定要找对 shortname ，在网显示为： Your website shortname is ********\n在rstudio，刚刚的博客配置config.toml中有一个disqusShortname填上你的名字\n以及添加：baseurl = \"http://qaz.netlify.com\"\n运行建站函数：blogdown::build_site(local=FALSE)再次同步\n\n\n\n10 、大功告成 一个带有评论的博客，如需要自己的模板，折腾吧"
  },
  {
    "objectID": "posts/md/论文写作工具.html",
    "href": "posts/md/论文写作工具.html",
    "title": "学术论文写作工具",
    "section": "",
    "text": "1、必备： CTEX套装 或者 TexLive (推荐),安装Texlive时候，推荐搭配Texstudio\n2、有没有发现写公式很麻烦：mathpix 工具可以直接截图，把截图的公式转变为Latex 代码，太复杂的可能识别不了，但是已经很好了\n3、AxMath 可以像mathtpye那样输入公式，更重要的一点是可以直接转变为latex代码，\n4、LaTeX代码转为Word公式:\n​ 可以参考这篇文章： http://www.latexstudio.net/archives/4650.html\n​ 如果在word里面直接输入LaTex代码转word公式,eg: 输入$x^2 + y^2$ ,然后选中其按 alt + \\即可转换，不过有点慢，耐心等待\n5、 Typora 工具，写markdown的，可以写md文件，然后转出latex文件，不过转出的导言区一般是有问题的，我们直接要正文部分，向导言区的头文件之类，要根据文件适当自己添加，这是由于公式的问题，公式之间不能用空行。\n\\documentclass{article}\n\\usepackage{ctex} % 中文包,如果含有公式也适用\n\\usepackage[colorlinks,linkcolor=red]{hyperref} % 超链接\n\\begin{document}\n。。。正文。。。。。x\n\\end{document}\n6、推荐写公式时，不用空白行。"
  },
  {
    "objectID": "posts/md/论文写作工具.html#表格to-latex",
    "href": "posts/md/论文写作工具.html#表格to-latex",
    "title": "学术论文写作工具",
    "section": "2. 表格to latex",
    "text": "2. 表格to latex\n\n方法一：http://www.tablesgenerator.com/latex_tables :这个网站不错，就是打开有点慢（推荐）。 以及这个网站https://tableconvert.com/\n方法二： 可以安装Excel2latex 插件，自己百度\n方法三：在rstudio中使用stargazer包 (三线头表格,头是双线）\n方法四： 在rstudio中使用xtable包( 三线头表格，头是单线)\n\n#####  方法三：#####\nlibrary(stargazer)\nlibrary(xlsx) \n# 推荐使用这个包，因为不会发生小数点精度的问题，但是列名可能会发生改变\n# 原本的列名是 3，4，....,9 读入后变成了X3,X4,....,X9.\ndata = read.xlsx(file =\"工作簿1.xlsx\",sheetIndex = 1,\n                 header = T,colClasses = \"character\")\ndata\nstargazer(data,summary = F,rownames = F)\n\n\n##### 方法四： #####\nxtable::xtable(head(iris),digits=3,caption=\"Head of Iris Data\")\n# 其中函数中的digits=3控制输出精度，caption就是表格的标题。\n注意看下图： 把代码粘贴到latex编译器中，上图为方法三画的(一般学术论文，表的标题在上方，图的标题在下方) ，下图为方法四画的。\n\n\n\n2019042601"
  },
  {
    "objectID": "posts/md/论文写作工具.html#引用图片格式",
    "href": "posts/md/论文写作工具.html#引用图片格式",
    "title": "学术论文写作工具",
    "section": "3. 引用图片格式",
    "text": "3. 引用图片格式\n\\begin{figure}\n    \\centering\n    \\includegraphics[height=8cm,width=10cm]{cci01.jpeg} % []是设置图片大小，{}是名称\n    \\caption{22.086 percentile} % 图片标题\n    \\label{fig1} % 交叉引用的名称\n\\end{figure}"
  },
  {
    "objectID": "posts/md/hugo遇到的问题.html",
    "href": "posts/md/hugo遇到的问题.html",
    "title": "hugo-blogdown搭建网页过程中的小问题",
    "section": "",
    "text": "2、hugo生成网页首页产生0001样式\n这是由于文章开头没有声明yaml格式，注意title author可以用双引号也可以不用，但请注意date的日期格式，尽量用date: 2017-12-28 这样的格式\n\n\n3 运行blogdown:::serve_site()函数本地监听没有反应\n即运行blogdown:::serve_site()改函数时，本地不能预览，这是由于我们自己写的rmd或者md文件的编码不是UTF-8引起的，所以我们一般要设置Rstudio的全局属性中保存UTF-8编码，但是这样在保存文件时又会产生新的问题，特别是保存的是csv文件\n还有一种情况是设置了全局属性echo = TRUE这个选项，不过这个选项还有待验证\n参见：\n\n\n4、网站图片引入居中设置\n方法一：嵌入html标签\n<img src=\"./xxx.png\" width = \"300\" height = \"200\" alt=\"图片名称\" align=center />\n方法二：\n    <div align=\"center\">\n        ![New Project](/img/NewProject.png)\n    </div>\n注意：一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）\n所以，<div></div>前面都有缩进\n\n\n5、遇到：转换文件名时出了问题—名字太长?\n在发布博客文章是，用rmd生成文章遇到\n\n\n\n2018091301item01\n\n\n解决方法： 这是由于rmd的文件名中有中文，写成英文即可。\n疑问： rmd文章短的时候可以用中文名。但是中文长的时候就不能用中文\n\n\n6、 hogo生成动态网页 不显示图片\n比如 DT包 、plotly包、dygraph、等\n建议引用widgetframe包 如下 （并且rmd文件不能有中文名，不然不能识别，文章的标题可以是中文）\nlibrary(dygraphs)\nlibrary(widgetframe)\n## 载入需要的程辑包：htmlwidgets\n## Loading required package: htmlwidgets\nts <- dygraph(nhtemp, main = \"New Haven Temperatures\")\nframeWidget(ts, height = 350, width = '95%')"
  },
  {
    "objectID": "posts/md/重装系统后的常用工具.html",
    "href": "posts/md/重装系统后的常用工具.html",
    "title": "重装系统后一些有用的激活工具",
    "section": "",
    "text": "包含win10 和office2019 激活工具 链接：https://pan.baidu.com/s/1eOQUPdlrvViL2XSucEdkmQ 提取码：08be 复制这段内容后打开百度网盘手机App，操作更方便哦"
  },
  {
    "objectID": "posts/md/latex参考文献生成.html",
    "href": "posts/md/latex参考文献生成.html",
    "title": "latex 参考文献生成(总结)",
    "section": "",
    "text": "生成latex参考文献大致有4种方法…..\n使用环境: MacTeX 2018 + texstudio, texstudio编译器改为xelatex"
  },
  {
    "objectID": "posts/md/latex参考文献生成.html#什么是.bib-文件",
    "href": "posts/md/latex参考文献生成.html#什么是.bib-文件",
    "title": "latex 参考文献生成(总结)",
    "section": "0. 什么是*.bib 文件",
    "text": "0. 什么是*.bib 文件\n注意: 后面三种,都将涉及bib文件, 如何生成bib文件, 我们可以建立一个后缀名为.bib的文件,这里我建立一个bib文件, 如text.bib, 去google学术或百度学术找一篇文献,这里我随便找了一篇文献如下:\n\n\n\nimage-20200809111644929\n\n\n\n\n\nimage-20200809111700803\n\n\n\n\n\nimage-20200809111722093\n\n\n把上图的内容复制到我们所创建的test.bib文件中即可.\n注意: 生成参考文献的好坏,80% 都看你的bib数据文件"
  },
  {
    "objectID": "posts/md/latex参考文献生成.html#使用-thebibliography-环境-手动书写",
    "href": "posts/md/latex参考文献生成.html#使用-thebibliography-环境-手动书写",
    "title": "latex 参考文献生成(总结)",
    "section": "1. 使用 thebibliography 环境– 手动书写",
    "text": "1. 使用 thebibliography 环境– 手动书写\n使用格式:\n\\begin{thebibliography}{99}\n        \\bibitem{citekey1} ***自己书写参考文献***\n        \\bibitem{citekey2} ***自己书写参考文献***\n        .....\n\\end{thebibliography}\n完整的案例如下:\n\\documentclass{article}\n\n\\usepackage{ctex}%加载ctex宏包，中文支持\n\n\\begin{document}\n    \n    测试文档，参考文献\\cite{hosseini2016modeling,wang2019snow}\n    \\begin{thebibliography}{99}\n        \\bibitem{hosseini2016modeling}  Hosseini~S, Barker~K. Modeling infrastructure resilience using {{Bayesian}} networks: {{A}} case study of inland waterway ports [J]. Computers \\& Industrial Engineering, 2016, 93: 252-266.\n        \\bibitem{wang2019snow}\n        Wang~J, Liu~H. Snow removal resource location and allocation optimization for urban\n        road network recovery: a resilience perspective [J]. Journal of Ambient Intelligence and Humanized Computing, 2019,\n        10\\penalty0 (1): 395-408.\n    \\end{thebibliography}\n\\end{document}\n个人不推荐"
  },
  {
    "objectID": "posts/md/latex参考文献生成.html#使用-.bst-文件-自动生成",
    "href": "posts/md/latex参考文献生成.html#使用-.bst-文件-自动生成",
    "title": "latex 参考文献生成(总结)",
    "section": "2. 使用 *.bst 文件 – 自动生成",
    "text": "2. 使用 *.bst 文件 – 自动生成\ntexlive 2018 系统自带的bst文件数量大致有375个\n$ cd  /usr/local/texlive/2018/texmf-dist/bibtex/bst \n$ find . -name *.bst | WC -l\n系统默认的参考文献风格在目录base中\n$ cat /usr/local/texlive/2018/texmf-dist/bibtex/bst/base\n一共8种,为最基本的参考文献风格样式, 解释如下\nplain，按字母的顺序排列，比较次序为作者、年度和标题.\nunsrt，样式同plain，只是按照引用的先后排序.\nalpha，用作者名首字母+年份后两位作标号，以字母顺序排序.\nabbrv，类似plain，将月份全拼改为缩写，更显紧凑.\nieeetr，国际电气电子工程师协会期刊样式.\nacm，美国计算机学会期刊样式.\nsiam，美国工业和应用数学学会期刊样式.\napalike，美国心理学学会期刊样式.\n如果系统自带—- 一般情况下直接使用就好, 案例如下\n\\documentclass{article}\n\\usepackage{ctex}%加载ctex宏包，中文支持\n\\begin{document}\n\n测试文档，参考文献\\cite{xu2018methods,xu2014weak}\n\n\\bibliographystyle{unsrt} % unsrt 可以替换为任意风格的样式文件\n\\bibliography{test}% 这里填写bib文件名,无后缀\n\n\\end{document}\n生成的pdf截图如下:\n\n\n\nimage-20200809112144024\n\n\n比如我要使用/usr/local/texlive/2018/texmf-dist/bibtex/bst/elsarticle/elsarticle-num-names.bst 这个参考文献样式, 只需直接替换使用即可,如下,\n\\documentclass{article}\n\\usepackage{ctex}%加载ctex宏包，中文支持\n\\begin{document}\n    测试文档，参考文献\\cite{xu2018methods,xu2014weak}\n    \\bibliographystyle{elsarticle-num-names}\n    \\bibliography{test}\n\\end{document}\n还有一种方法, 把对应的bst文件拷贝到当前目录使用(当然,你也可以指定bst文件的具体路径), 然后在使用即可.\n当然有些期刊自己会提供对应的*.bst样式文件, 那么安照期刊的要求来即可.\n顺便提一句, 通过 *.bst生成的参考文献当前目录会生成一个后缀名为.bbl的文件,你可以打开它, 里面是一个完整的 thebibliography 环境, 即可以通过bst文件自动生成thebibliography环境里面的条目信息.\n补充:\n我要投稿,怎么知道是用哪个*.bst文件, 一般情况下期刊官网会提供, 若没有提供,按以下步骤查找\n\n首先记住你要准备投的期刊, 然后在 这个网站搜索, 一般情况下, 你准备的期刊参考文献有一个别名, 说白了可能是其他期刊的文献格式, 于是你找到那个别名.\n然后在目录/usr/local/texlive/2018/texmf-dist/bibtex/bst下去搜索你要的bst 参考文献\n\n备注:\n爱思唯尔(Elsevier)期刊模板:\nlatex 官网自带的 elsevier 模板:"
  },
  {
    "objectID": "posts/md/latex参考文献生成.html#使用.csl-样式文件-自动生成",
    "href": "posts/md/latex参考文献生成.html#使用.csl-样式文件-自动生成",
    "title": "latex 参考文献生成(总结)",
    "section": "3. 使用*.csl 样式文件 – 自动生成",
    "text": "3. 使用*.csl 样式文件 – 自动生成\n由于Zotero软件提供了大量的csl样式文件,大致接近1万个参考文献样式, 而 latex 软件本身是不能直接支持csl文件的\n\n方法一: 可以使用 像Zotero, Mendeley 软件支持, 但是不能像bst文件那样使用,只能手动粘贴.参考文献数量多了,自然不方便\n方法二: 借助 pandoc , 该软件提供了大量命令参数, 感兴趣的可以去探索, 而xieyihui 通过使用*.Rmd文件进行了封装(前提要安装并了解R + Rstudio), 个人在巨人的肩上, 进行了简单封装,提供了一个R包journalabbr提供了一个本地app 和一个在线app, 该app提供期刊缩写, 美化bib数据库文件以及提供类似bst文件那样批量生成一个完整的 thebibliography 环境. app截图如下:\n\n\n\n\nimage-20200809120534362"
  },
  {
    "objectID": "posts/md/latex参考文献生成.html#使用biblatex-未来的版本",
    "href": "posts/md/latex参考文献生成.html#使用biblatex-未来的版本",
    "title": "latex 参考文献生成(总结)",
    "section": "4. 使用biblatex – 未来的版本",
    "text": "4. 使用biblatex – 未来的版本\n这里仅以国标gb7714为例子\n首先把texstudio编译器改为xelatex, 并把bibtex 后端改为 biber. , 提供一个案例如下\n\\documentclass{article}\n\\usepackage{ctex}%加载ctex宏包，中文支持\n\n\\usepackage[backend = biber, style=gb7714-2015,gbnamefmt =  lowercase,\ngbbiblabel=bracket]{biblatex}\n\\addbibresource[location=local]{test.bib}\n\\renewcommand{\\bibfont}{\\zihao{5}\\songti}%设置参考文献的字体和字号\n\\setlength{\\bibitemsep}{2pt}%设置各条参考文献之间的间距为2pt\n\n\\begin{document}\n    测试文档，参考文献\\cite{xu2018methods,xu2014weak}\n\n\\printbibliography[heading=bibliography,title=参考文献]\n\\end{document}\n\n更多,可参考 biblatex-gb7714-2015\nbiblatex参考文献和引用样式caspervector.pdf\nbiblatex-zh-cn\nbiblatex-solution-to-latex-bibliography\nbiblatex-gb7714-2015\n关于 国标gb7714 我们后面在进一步介绍."
  },
  {
    "objectID": "posts/md/R语言并行化计算之foreach包.html",
    "href": "posts/md/R语言并行化计算之foreach包.html",
    "title": "并行化计算之foreach包",
    "section": "",
    "text": "解读foreach()函数\nlibrary(\"doParallel\")      #加载doParallel包用于之后注册进程\nlibrary(\"foreach\")         #导入foreach包\n########################################################################\n##########  foreach()函数主要是对原本的for循环进行并行运算 ###############\n#########################################################################\n#############并行化格式\ndetectCores() #这个网上说是核数，但实际上是线程数，和真实的物理核多一倍，4核8线程\ncl<- makeCluster(detectCores())      # 不过R中能运行满线程 ，即detectCores()返回的核数。\nregisterDoParallel(cl)       #进行进程注册\nmydata1 <- foreach(\n          ...,        # 并行化参数（循环参数）,当参数为两个以上时，选长度较短的循环完为止.\n          .combine,  #合并方式，default是list，“c”返回vector,cbind和rbind返回矩阵,也可以自定义函数.\n                      # \"+\"和\"*\"是対返回后的list进行同列操作\n          .init,      #.combine函数的第一个变量,当.combine参数被具体化是才用\n          .final=NULL, #返回最后结果\n          .inorder=TRUE,#返回和原始输入相同顺序的结果\n          .multicombine=FALSE,#设定.combine函数的传递参数，FALSE表示其参数是2，TRUE可以设定多个参数\n          .maxcombine=if (.multicombine) 100 else 2,  #设定.combine的最大参数\n          .errorhandling=c('stop', 'remove', 'pass'),#如果循环中出现错误，对错误的处理方法\n          .packages=NULL,# 指定在%dopar%运算过程中依赖的package（%do%会忽略这个选项）。\n          .export=NULL, # 在编译函数的时候需要预先加载一些内容进去，类似parallel的clusterExport\n          .noexport=NULL,\n          .verbose=FALSE) ##是否打印运行信息\n  ) %dopar% {***} #并行的代码，也可以是相应的函数,即我们for循环的函数体\n\nstopCluster(cl)   # 结束集群\n注意：平时我们大多数使用时，很多参数都选取默认状态，其中常用参数为：... 、.combine、.packages.\n基本操作\nlibrary(\"doParallel\")      #加载doParallel包用于之后注册进程\nlibrary(\"foreach\")         #导入foreach包\ncl<- makeCluster(detectCores()-1)      \nregisterDoParallel(cl)       #进行进程注册\ngetDoParWorkers()  #  #查看注册了多少个核\n\ncode=function(){\n    x1<-(a + b);\n    x2<-a*b;\n    c(x1,x2);  \n}\n\n# 并行化参数,当参数为两个以上时，选长度较短的循环完为止.\n(x <- foreach(a=1:10, b=rep(10, 3),.combine=list) %dopar% code())\n\n(x <- foreach(a=1:10, b=rep(10, 3), .combine=\"c\") %dopar% code())#每次的结果按向量排列合并为向量\n\n(x <- foreach(a=1:10, b=rep(10, 3), .combine=\"cbind\") %dopar% code())#每次的结果按列排列合并为矩阵\n\n(x <- foreach(a=1:10, b=rep(10, 3), .combine=\"rbind\") %dopar% code())#每次的结果按行排列合并为矩阵\n\n#  # \"+\"和\"*\"是対返回后的list(或者rbind)结果，对其结果进行同列\"+\"或\"*\"操作\n(x <- foreach(a=1:10, b=rep(10, 3), .combine=\"+\")%dopar% code())  \n\n(x <- foreach(a=1:10, b=rep(10, 3), .combine=\"*\") %dopar% code())\n\n\n#.combine使用自定义函数,也是对返回的list进行同列操作\n\ncfun <- function(a, b) paste(a,b,sep = \",\")\n(x <- foreach(a=1:3, b=rep(10, 3), .combine=\"cfun\") %dopar% code())\n\nstopCluster(cl)   # 结束集群\n常用操作\n巧好最近在研究爬虫，以R爬虫为列，\n\nlibrary(rvest)\nlibrary(data.table)\nlibrary(tibble)\nlibrary(dplyr)\nlibrary(stringr)\n##################################################################\n################  对某单一页面进行操作提取\npeople_information=function(url){\n  web=read_html(url,encoding = \"GBK\")\n  people_info=web %>% html_nodes(\"table.teach_info_table>tr>td\")%>% html_text()\n  people_info=people_info[-5] #这里是储存照片的地方\n  \n  people_attr=c()\n  people_value=c()\n  for(i in 1:length(people_info)){\n    if(i%%2==1){\n      people_attr=append(people_attr,people_info[i])\n    }else {\n      people_value=append(people_value,people_info[i])\n    }\n  }\n  \n  people_info=data.frame(people_attr,people_value) %>% apply(.,2,function(x){gsub(\"(\\\\t)\",\"\",x)}) %>% as.data.frame()\n  people_info=apply(people_info, 2, str_trim)\n  Sys.sleep(5)\n  return(people_info)\n}\n#########################################################################\n########### 读取我们要爬取的所有链接（这里的链接，我提前已经爬取好了，存储在本地）\ndf=fread(\"people.csv\",encoding = \"UTF-8\")\nlink_finally=df[,link_finally]\nlen=length(link_finally)# 3000+多个网页\np_info=data.frame()\n\n\n################################################################\n##################### 并行化爬取\nlibrary(\"doParallel\")      #加载doParallel包用于之后注册进程\nlibrary(\"foreach\")         #导入foreach包\n##### 我要循环爬取的信息\nmyfun=function(i){\n  people_information(i) %>% as.data.frame()\n}\n##### 每次循环完成获得的数据，进行如下两两合并\nbind_fun=function(a,b){\n  full_join(a,b,by = \"people_attr\")  %>% as.data.frame()\n}\n######### 并行开始\ncl<- makeCluster(detectCores()-1)      \nregisterDoParallel(cl)       #进行进程注册\np_info <- foreach(i=link_finally[1:len], #循环的长度,不在是\"in\"\n                  .combine=\"bind_fun\",\n                  .packages = c(\"rvest\", \"data.table\",\"tibble\",\"dplyr\",\"stringr\") \n                  ) %dopar% myfun(i)\nstopCluster(cl)   \n####### 结束并行\n\n##########################################################################\n##### 对抓取的结果p_info数据进行处理\ncolnames(p_info)=1:dim(p_info)[2]\np_info=t(p_info)\nwrite.csv(p_info,\"people_info3333.csv\",row.names = F)\n补充函数\n\ndetectCores() #查看自己电脑的线程数，\ngetDoParWorkers( ) #查看注册了多少个核，配合doMC package中的registerDoMC( )使用\n\ngetDoParRegistered( ) # 查看doPar是否注册；如果没有注册返回FALSE\n\ngetDoParName( ) #查看已经注册的doPar的名字\n\ngetDoParVersion( ) #查看已经注册的doPar的version"
  },
  {
    "objectID": "posts/md/运筹学最短路问题.html",
    "href": "posts/md/运筹学最短路问题.html",
    "title": "运筹学最短路问题",
    "section": "",
    "text": "最短路算法参考(自制ppt)pdf:"
  },
  {
    "objectID": "posts/md/R语言绘图中添加中文方法汇总.html",
    "href": "posts/md/R语言绘图中添加中文方法汇总.html",
    "title": "基本绘图中添加指定中文字体",
    "section": "",
    "text": "barplot(df[sex == '男',table(Year)],main = \"男性条形统计图\",family = 'Songti SC') \n\n\n\nlibrary(showtext)\n#使用下面的函数查看所有字体,选择中文字体添加\nfont_files()\nshowtext_auto(enable = TRUE)\nfont_add('Songti', 'Songti.ttc','STKaiti','STXihei')  #添加中文字体\nquartz(family = \"STXihei\") \n#可以把STXihei替换成任意想要的字体，如'Songti', 'Songti.ttc','STKaiti'等"
  },
  {
    "objectID": "posts/md/R语言绘图中添加中文方法汇总.html#方法五-ggplot2绘图中添加指定中文字体",
    "href": "posts/md/R语言绘图中添加中文方法汇总.html#方法五-ggplot2绘图中添加指定中文字体",
    "title": "基本绘图中添加指定中文字体",
    "section": "方法五: ggplot2绘图中添加指定中文字体",
    "text": "方法五: ggplot2绘图中添加指定中文字体\nlibrary(ggplot2) \np = ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, col = Species)) + geom_point()\np = p + labs(title = \"iris数据集\")\np = p + theme(plot.title = element_text(hjust = 0.5))  #标题居中\np = p + theme(text=element_text(family=\"Songti SC\"))\np"
  },
  {
    "objectID": "posts/md/dplyr.html",
    "href": "posts/md/dplyr.html",
    "title": "dplyr – 1基本函数简介",
    "section": "",
    "text": "由于R语言每一个步骤没有赋值的话，是不会改变原有的数据，都是建立一个新的数据。原有数据不改变。\n\ndplyr::tbl_df(iris)： 将数据转化为tbl类。只会显示适合屏幕大小的数据：\ndplyr::glimpse(iris)： tbl数据的信息密集概括。 类似str()函数\ndplyr::%>%： 将左边的对象作为第一个参数（或参数 .）传递到右边的函数中。利用%>%进行“Piping”管道操作增强了代码的可读性， R  x %>% f(y) 相当于  f(x, y)      y %>% f(x, ., z) 相当于  f(x, y, z )"
  },
  {
    "objectID": "posts/md/dplyr.html#filter-行过滤",
    "href": "posts/md/dplyr.html#filter-行过滤",
    "title": "dplyr – 1基本函数简介",
    "section": "1、filter 行过滤",
    "text": "1、filter 行过滤\n\nfilter(iris, Sepal.Length > 7)：抽取符合逻辑条件的数据记录。\n\ndistinct(iris)：删除重复记录。 distinct(iris, Species) 保留iris某一列的唯一值\nsample_frac(iris, 0.5, replace = TRUE)：随机选取部分数据(占总体的0.5)记录。\n\nsample_n(iris, 10, replace = TRUE)：随机选取n条数据记录。\n\nslice(iris, 10:15)：通过位置选取数据记录。\n\ntop_n(storms, 2, date)：选取并排列前n条数据记录 （若为分组数据则按组排序）"
  },
  {
    "objectID": "posts/md/dplyr.html#select-列过滤",
    "href": "posts/md/dplyr.html#select-列过滤",
    "title": "dplyr – 1基本函数简介",
    "section": "2、select 列过滤",
    "text": "2、select 列过滤\nrename(.data, ...)\nrename_all(.tbl, .funs = list(), ...)\nrename_if(.tbl, .predicate, .funs = list(), ...)\nrename_at(.tbl, .vars, .funs = list(), ...)\n\n\nselect(.data, ...)\nselect_all(.tbl, .funs = list(), ...)\nselect_if(.tbl, .predicate, .funs = list(), ...)\nselect_at(.tbl, .vars, .funs = list(), ...)\n\nArguments\n\n\n\n.tbl\nA tbl object.\n\n\n\n\n.funs\nA function fun, a purrr style lambda ~ fun(.) or a list of either form.\n\n\n...\nAdditional arguments for the function calls in .funs. These are evaluated only once, with tidy dots support. 注意: .funs一般是一个函数列表,处理自变量之外,一般不知道额外参数,要指定额外参数,此时需要在这里特别指定.\n\n\n.predicate\nA predicate function to be applied to the columns or a logical vector. The variables for which .predicate is or returns TRUEare selected. This argument is passed torlang::as_function() and thus supports quosure-style lambda functions and strings representing function names.直译过来,指的是谓词函数, 必须是返回ture or false 的逻辑函数. 像is.character,all,is.null等等.\n\n\n.vars\nA list of columns generated by vars(), a character vector of column names, a numeric vector of column positions, or NULL. 可以用字符串 或者列索引(数字) 组成的列,匹配列名用\n\n\n\n\nselect(df, newname=a, b, c ): 通过列名或帮助函数选取列变量。 同时也可以对列名进行重命名。\nselect(df, a:b): 选取在a和b之间的所有列（包含 a和b）\nselect(df, -a): 选取除a以外的所有列\nselect(df,...,funs):\ndf: 数据框\nfuns: 所用函数( 注意:: 一般不建议在选择列的同时,对列进行操作)\n\n\n\ncontains(\".\")： 选取名称中含有字符的列。\n\nstarts_with(\"Sepal\") :选取名称以指定字符串为首的列。\n\n\nends_with(\"Length\") ：选取名称以指定字符串结尾的列。\n\nmatches(\".t.\")： 选取名称符合指定表达式规则的列。\n\nnum_range(\"x\", 1:5):选取名为x1、x2、x3、x4、x5的列。\n\none_of(c(\"Species\", \"Genus\")) :选取名称在指定名字组内的列。 e.g. a:b eg. -a\neverything([ df ])： 列较多的情况下把不需要排序的列用evything()直接列出。当有df是返回1:df的列数,当为向量是返回1: 向量长度。 eg: select(iris,Species,everything())\n\n\n\nselect_if(df, <条件>, fun):对df数据集 选出满足条件为真的列执行fun。\n\n<条件>是对整个列属性进行判断筛选(真则保留，假则丢弃)。然后在对列名进行处理。\nfuns是对列名进行筛选处理.\n注意： 当同时使用<条件>, fun 时，以条件为准，fun是对满足条件后的列的列名进行处理，不能对列进行进一步筛选。\nselect(df,...,funs) 和select_if(df,<条件>)的区别\n\nselect_if的条件是对列的属性进行筛选\nselect中的funs函数是对列名进行筛选\n\n\nselect_at(.tbl, .vars, .funs = list(), ...) 是对select_if的加强版\n\nselect_at(mtcars, vars(-contains(\"ar\"), starts_with(\"c\")) 可以看做是多个对列名多个条件的筛选。"
  },
  {
    "objectID": "posts/md/dplyr.html#mutate-添加新变量组成新数据集-原数据不改变",
    "href": "posts/md/dplyr.html#mutate-添加新变量组成新数据集-原数据不改变",
    "title": "dplyr – 1基本函数简介",
    "section": "3、mutate 添加新变量，组成新数据集。 原数据不改变 。",
    "text": "3、mutate 添加新变量，组成新数据集。 原数据不改变 。\n\nrename() 重命列名 eg. rename(iris, petal_length = Petal.Length)\n\nrename_all(iris,funs(c(1:5)))或rename_all(iris,funs(c(\"A\",\"B\",\"C\",\"D\",\"E\")))把整个列名都重新赋值\nrename_at(.tbl, .vars, .funs = list())\nrename_if(.tbl, .predicate, .funs = list())\n建议把参数.vars=... , .funs = ...显示调用，不然函数会报错\n\nmutate(mtcars, gpm = 1/mpg)： 在原有数据的基础上添加新列（多列）组成新数据集。 原数据不改变 。\ntransmute(mtcars, gpm = 1/mpg)：直接创建一个新列（多列）组成新数据集。\n\nmutate_all(.tbl, .funs, …) : 对每一列应用 funs，组成新数据集，\nmutate_at(.tbl, .vars, .funs, ..., .cols = NULL)：对指定的列运行窗口函数，组成新数据，\nmutate_if(.tbl, .predicate, .funs, …)：对指定类型的列运行窗口函数，组成新数据，\n\nvars(): 表示需要进行概述的列\n.funs的用法\n\n建议显示调用改参数.funs=\n\n直接在函数中写明需要运行的函数: mutate_all(faithful, .funs(log))\n结合funs写出调用的函数: mutate_all(faithful, funs(log(.), log2(.)))\n\n运行两个以上函数，保留原数据的基础上增加新列，新列会自动根据函数名自动重命名\n也可以自己重命名,：mutate_all(faithful, funs(a=log(.), b= log2(.)))\n当funs只有一个时且自己进行重命名时，会保留原数据的基础上增加新列构成新数据，mutate_all(faithful, funs(a=log2(.)))\nmutate_if(car,is.character,as.factor )也可以直接省略括号\n\n\n还可以把NULL赋值给列，已达到删除列的效果。\n以下用法类似： summarise_all(.tbl, .funs, ...)\nsummarise_if(.tbl, .predicate, .funs, ...)\nsummarise_at(.tbl, .vars, .funs, ..., .cols = NULL)\nmutate_all(.tbl, .funs, ...)\nmutate_if(.tbl, .predicate, .funs, ...)\nmutate_at(.tbl, .vars, .funs, ..., .cols = NULL)\ntransmute_all(.tbl, .funs, ...)\ntransmute_if(.tbl, .predicate, .funs, ...)\ntransmute_at(.tbl, .vars, .funs, ..., .cols = NULL)\n\n\n窗体函数（.funs）\n\nlead(x, n = 1L, default = NA, order_by = NULL, ...)\nlag(x, n = 1L, default = NA, order_by = NULL, ...)　\n\nlead和lag函数主要用于替换数据，lead表示整体向前替换，lag表示整体向后替换，n表示替换的个数，default表示要替换的结果，默认为NA 。order_by是根据某一列进行排序。\n\ncume_dist()： 累积分布。\ndense_rank()： 无缝排序。\nmin_rank()： 排序。并列时，其他序号顺延。\nntile() ： 把向量分为n份。\npercent_rank()： 把数据在[0, 1]中重组并排列。\nrow_number()： 排序。并列时，位置在前的并列数 据序号在前。\nbetween()： 数值是否在a和b之间？\n\ncumall()： 累积all函数\ncumany() ： 累积any函数\ncummean() ： 累积mean函数\ncumsum() ： 累积sum函数\ncummax() ： 累积max函数\ncummin()： 累积 min函数\ncumprod()： 累积prod函数\npmax() ： 针对元素的max函数\npmin()： 针对元素的min函数"
  },
  {
    "objectID": "posts/md/dplyr.html#概况数据行组成新数据集-原数据不改变",
    "href": "posts/md/dplyr.html#概况数据行组成新数据集-原数据不改变",
    "title": "dplyr – 1基本函数简介",
    "section": "4、概况数据（行），组成新数据集。 原数据不改变 。",
    "text": "4、概况数据（行），组成新数据集。 原数据不改变 。\n\nsummarise(iris, avg = mean(Sepal.Length)) 将数据概括为单行数值。\n\nsummarise_all(.tbl, .funs, ...) : 对每一列运行概述函数\nsummarise_at(.tbl, .vars, .funs, ..., .cols=NULL) :对指定的列运行概述函数\nsummarise_if(.tbl, .predicate, .funs): 对指定类型的列运行概述函数\n\ncount(iris, Species, wt = Sepal.Length) 计算各变量中每一个特定值的⾏行数（带权重或不带 权重）.\n\nwt可选参数\n\n不带wt时：对分组进行计数统计\n带wt时，对分组后的变量Sepal.Length进行求和统计\n\n\n\n利用概述函数概括数据信息，输入数值向量而返回单一数值，如：\n计数\n\nlength(x)：返回一组向量（包括列表）或因子的长度\nnrow() / ncol()：总行数/总列数\nn()：返回观测行的行数，不能单独使用（可被用于 summarise()、mutate()、filter() ）\nn_distinct(x, na.rm=FALSE)：返回不重复的行数\n\nsum(!is.na())：计算非空值的行数\n\n\n位置与序列\n\nfirst(x)/last(x) 向量的最后一个值。\n\nnth(x,n) 返回向量的第n个值。\n\n分布\n\nIQR() 向量的IQR（四分位距）。\nmin() /max() 向量中的最小(大)值。\n\nmean() 向量中的均值。 mean(!is.na()) ：非空值的均值\nmedian() 向量中的中位数。\n\nvar() 向量中的⽅方差。\n\nsd() 向量中的标准差。\nrange() 返回值域，即最大最小值\ncolSums(x) / rowSums(x)：各列/行求和\ncolMeans(x) / rowMeans(x)：各列/行求均值\n\n\n\n##5、分组汇总 - group_by(.data, ..., add = FALSE)\n\nungroup(x, ...)\n\n...： 表示用于分组的列名；\nadd= FALSE默认)\n\nFALSE，表示会覆盖原来的分组，相当于对源数据重新分组；\n若为TRUE,则不覆盖，相当于在原来的基础上在进行分组；\n\n\ngroup_by(iris, Species) 把在Species中的值相同的数据组合成行。\nungroup(iris) 从数据框中移除组合信息。\n\niris   %>%   group_by(Species)   %>%   summarise(…)为每一个分组分别计算行概述。\n\niris   %>%   group_by(Species)   %>%   mutate(…) 按组计算新变量。\n\n\n同样也有\ngroup_by_all(.tbl, .funs = list(), ...)\ngroup_by_at(.tbl, .vars, .funs = list(), ..., .add = FALSE)\ngroup_by_if(.tbl, .predicate, .funs = list(), ..., .add = FALSE)"
  },
  {
    "objectID": "posts/md/matlab优化工具01线性规划之linprog.html",
    "href": "posts/md/matlab优化工具01线性规划之linprog.html",
    "title": "matlab优化工具01线性规划之linprog",
    "section": "",
    "text": "常用这些函数， 写个笔记\n\n\n\n\n\n\n\nimage-20210516093622862\n\n\n\n\n\n\n遗传算法 ga() , 推荐, 可以处理带有约束问题的优化, 还可以求解混合整数规划\n模式搜索算法 patternsearch()\n模拟退火求解 simulannealbnd()\n粒子群算法 particleswarm\n\n\n\n\n\n\noptimset 函数用于获取 MATLAB 优化工具箱所有的属性设置选项\n\n%% 函数用法与解释\noptions = optimset('paraml',vaJuel,'param2',value2,...)  % 如果选择用系统的默认值，则只需将参数的值设为 \\[\\].\noptimset: 列出一个完整的优化参数列表及相应的可选值。\noptions = optimset : 创建一个名为 optoptionslOns 的优化参数结构体，其成员参数的取值为系统的默认值。\noptions = optimset(optimfun): 创建一个名为 options 的优化参数结构体，其所有参数名及值为优化函数 optimfun 的默认值。\noptions=optimset(oldopts, 'paraml' ,valuel ,...) :将优化参数结构体 oldopts中的参数 paraml 改为 valuel 并将更改后的优化参数结构体命名为 options\noptions = optimset(oldopts，newopts): 将已有的优化参数结构体 oldopts 与新的 优化参数结构体 newopts 合井， newopts 中的任意非空参数值将覆盖 oldopts 中的相应参数值。\n\n\n%% eg: 列出所有的优化参数列表\n>> optimset\n%% 结果省略\n\noptimget 函数: 想查看某个优化参数的值\n\n%%\nval= optimget(options, 'param' ) : 获取优化参数结构体 options 中参数 param 的值。\nval = optimget(options, 'param'， default): 如果参数 param 在 options 中没有定义，则返回其默认值\n%% eg: 查看某个优化参数的值\nclc,clear all;\noptions = optimset('fmincon') % 省略结果\noptions =optimset(options, 'Display' , 'iter') %修改 Display 属性值为iter\nval = optimget(options,'Display') % 重新获取fmincon 函数的 Display属性值\n\n\n\nimage-20210516102520466\n\n\n\n\n\n\\[\n\\begin{aligned}\n& \\min \\quad   f^T x \\\\\n& \\text {s.t.} \\begin{cases}\n\\textbf{A} \\cdot x \\leq b \\\\\n\\textbf{Aeq} \\cdot x=beq \\\\\nlb \\leq x \\leq ub\n\\end{cases}\n\\end{aligned}\n\\] 其中 \\(f^T, x, b, beq\\) 是向量, \\(\\textbf{A}, \\textbf{Aeq}\\)是矩阵,\\(\\textbf{A}\\) 线性不等式, \\(\\textbf{Aeq}\\) 线性等式,\n\n\n% 语法\nx = linprog(f,A,b,Aeq,beq,lb,ub,options)\nx = linprog(problem)\n[x,fval,exitflag,output,lambda] = linprog(___)\n%% 如果不存在某个约束或变量,设置为空即可\n\n\n\n\\[\n\\begin{aligned}\nmin \\quad f(x) = -5x_1 - 4x_2 - 6x_3 \\\\\ns.t. \\begin{cases}\nx_1 - x_2 + x_3 \\leq 20\\\\\n3x_1 + 2x_2+4x_3 \\leq 42\\\\\n3x_1+2x_2 \\leq 30\\\\\nx_1,x_2,x_3 \\geq 0\n\\end{cases}\n\\end{aligned}\n\\]\n%% matlab 实现 --- 方法一\nclc, clear all;\nf = [-5; -4; -6]; % 列向量\nA = [1,-1,1;\n    3,2,4;\n    3,2,0];\nb = [20;42;30]; % 列向量\nlb = zeros(1,3); % 行向量\nub = []; % 为空,则表示无上限,即正无穷\noptions = optimoptions('linprog','Algorithm','dual-simplex','Display','iter');\n[x,fval,exitflag,output,lambda]  = linprog(f,A,b,[],[],lb,ub,options)\n\n% ------------------ 结果 ------------------\nx =\n         0\n   15.0000\n    3.0000\nfval =\n   -78\nexitflag =\n     1\n%% 方法二: 以结构体方式创建 \n%%\n% optimproblem('ObjectiveSense','max')  % 最优化问题的创建,  ObjectiveSense属性求最大值(默认最小值)\n%%  optimvar 决策变量的定义,n,m,k 设置决策变量的维度,不设置k则变量维度为n*m\n% x = optimvar('x',n,m,k,'LowerBound',lb,'UpperBound',ub)\n\n\nprob = optimproblem('ObjectiveSense','min');\nx = optimvar('x',3,1,'LowerBound',[0;0;0]);\nprob.Objective = -5*x(1) - 4*x(2) -6*x(3); \nprob.Constraints.c1 = x(1) - x(2) + x(3) <= 20;\nprob.Constraints.c2 = 3*x(1) + 2*x(2) + 4*x(3) <= 42;\nprob.Constraints.c3 = 3*x(1) + 2*x(2) <= 30\n\n\nsols = solve(prob)\nx0 = sols.x\n\n% ------------------ 结果 ------------------\nx0 =\n         0\n   15.0000\n    3.0000\n\n\n\n\n如果目标函数以及约束条件中的变量是以矩阵描述,则按照一一对应规则变成向量的形式即可求解\n有些时候书写比较麻烦,比如运输问题, 则可以编写函数使其自动化\n\n\n\nimage-20210516105838325\n\n\n\nfunction [x,f0, flag] = transport_linprog(C,s,d,indkey)\n[m,n] = size(C); A=[]; B =[];\nfor i = 1:n\n    Aeq(i,(i-1)*m+1:i*m) =1;\nend\nfor i = 1:m\n    Aeq(n+i,i:m:n*m) =1;\nend\nxm = zeros(1,n*m);\nf= C(:);\nBeq=[s(:);d(:)];\nif nargin == 3\n    [x,f0,flag] = linprog(f,A,B,Aeq,Beq,xm);\nelse\n    [x,f0,flag] = intlinprog(f,indkey,A,B,Aeq,Beq,xm);\n    x = round(x);\nend\nx = reshape(x,m,n); %将向量解还原为矩阵所需的形式\nend\n%% 例题\nC = [464,513,654,867;\n    352,416,690,791;\n    995,682,388,685];\ns = [80,65,70,85];\nd=[75;125;100];\n[x0,f0] = transport_linprog(C,s,d)\n\n% ------------------ 结果 ------------------\nOptimal solution found.\nx0 =\n     0    20     0    55\n    80    45     0     0\n     0     0    70    30\nf0 =\n      152535\n\n\n\n\n\nimage-20210516111020291\n\n\nC= [15,18,21,24;\n    19,23,22,18;\n    26,17,16,19;\n    19,21,23,17]\ns = [1,1,1,1];% s和d向量可以是列向量也可以是行向量\nd = [1,1,1,1];\n[n,m] = size(C);\n[x0,f0] = transport_linprog(C,s,d,1:n*m)\n% ------------------ 结果 ------------------\nx0 =\n     0     1     0     0\n     1     0     0     0\n     0     0     1     0\n     0     0     0     1\nf0 =\n    70\n参考:\n\nmatlab函数官网\n<<薛定宇教授大讲堂卷5  MATLAB最优化计算>>_含目录py.pdf\n<<MATLAB R2015b最优化计算—李娅>>_含目录\n<<MATLAB优化算法_张岩，吴水根著_北京：清华大学出版社>>"
  },
  {
    "objectID": "posts/md/混合粒子群算法matlab.html",
    "href": "posts/md/混合粒子群算法matlab.html",
    "title": "混合粒子群算法matlab",
    "section": "",
    "text": "链接"
  },
  {
    "objectID": "posts/md/R中语言文件目录相关操作.html",
    "href": "posts/md/R中语言文件目录相关操作.html",
    "title": "R语言文件目录相关操作",
    "section": "",
    "text": "R语言对文件系统的操作，包括文件操作和目录操作，函数API都定义在base包中。"
  },
  {
    "objectID": "posts/md/R中语言文件目录相关操作.html#目录操作",
    "href": "posts/md/R中语言文件目录相关操作.html#目录操作",
    "title": "R语言文件目录相关操作",
    "section": "2. 目录操作",
    "text": "2. 目录操作\n2.1 查看目录\n查看当前目录下的子目录。\n setwd()               #设定某个目录为当前目录\n getwd()               # 当前的目录\n list.dirs()           # 查看当前目录的子目录  参数详见dir()\n \n dir()                 #查看当前目录的子目录和文件。\n dir(path=\"C:/windows\")#查看指定目录的子目录和文件\n dir(path=\"C:/windows\",all.files=TRUE)# 列出目录下所有的目录和文件，包括隐藏文件\n dir(path=\"C:/windows\",pattern='^R')#只列出以字母R开头的子目录或文件\n \n file.info(\".\")         # 查看当前目录权限\n2.2 创建目录\ndir.create(\"your dir\")        # 在当前目录下，新建一个目录\ndir.create(path=\"a1/b2/c3\",recursive = TRUE)  #递归创建一个3级子目录./a1/b2/c3，直接创建会出错\n2.3 检查目录是否存在\nsystem(\"tree\")                      # 通过系统命令查看目录结构\nfile.exists(\"./a1\")             # 查看某个目录是否存在,可以多层次调用目录\n2.4 检查目录的权限\ndf<-dir(full.names = TRUE)         #获取当前目录的所有目录(不含子目录)和文件名（含后缀）\nfile.access(df, model=0) == 0      # 检查文件或目录是否存在，mode=0\n                                  # 检查文件或目录是否可执行，mode=1，目录为可以执行\n                                  # 检查文件或目录是否可写，mode=2\n                                 # 检查文件或目录是否可读，mode=4\n2.5修改目录权限。\n Sys.chmod(\"./create\", mode = \"0555\", use_umask = TRUE)  # 修改目录权限，所有用户只读\n \n2.6 对目录重名\nfile.rename(\"create\", \"newcreate\")            # 对tcreate目录重命名为newcreate\nunlink(\"newcreate\", recursive = TRUE)         # 删除newcreate目录   递归删除\n2.7 其他功能函数\nfile.path(\"p1\",\"p2\",\"p3\")                  # 拼接目录字符串\ndirname(path=\"\")                           #获得某个路径的目录名\nbasename(path=\"\")                          #获得某个目录的最底层目录或者文件名\nnormalizePath(c(R.home(), tempdir()))      #获取目录的绝对路径"
  },
  {
    "objectID": "posts/md/R中语言文件目录相关操作.html#文件操作",
    "href": "posts/md/R中语言文件目录相关操作.html#文件操作",
    "title": "R语言文件目录相关操作",
    "section": "3. 文件操作",
    "text": "3. 文件操作\n3.1 查看文件\nfile.exists(\"readme.txt\")         # 检查文件是否存在\nfile.info(\"readme.txt\")            # 查看文件完整信息\nfile.access(\"readme.txt\",0)        # 查看文件访问权限，存在详情见2.4\nfile_test(\"-d\", \"readme.txt\")      #判断是文件还是目录。-d ,是目录返回ture\nfile_test(\"-f\", \"readme.txt\")      # 判断是否是文件 .  -f 是文件但会ture\n3.2 创建文件\nfile.create(\"A.txt\")            # 创建一个空文件 A.txt\ncat(\"file B\\n\", file = \"B.txt\") # 把相关的内容写入B.txt文件中，没有这个文件则创建文件并写入内容 \n\nreadLines(\"A.txt\")         # 读取A.txt并打印\nfile.append(\"A.txt\", rep(\"B.txt\", 10))   # 合并文件,把文件B.txt的内容，合并到 A.txt。\nfile.copy(\"A.txt\", \"C.txt\")    #把文件A.txt复制到文件C.txt ,文件复制\n3.3 修改文件权限\n# 修改文件权限，创建者可读可写可执行，其他人无权限\nSys.chmod(\"A.txt\", mode = \"0700\", use_umask = TRUE)\n3.4 文件重命名\nfile.rename(\"A.txt\",\"AA.txt\")     # 给文件A.txt重命名为AA.txt\n3.5 删除文件\n有两个函数可以使用file.remove和unlink，其中unlink函数使用同删除目录操作是一样的。\nfile.remove(\"A.txt\", \"B.txt\", \"C.txt\")      # 删除文件\nunlink(\"readme.txt\")                   # 删除文件\nsystem(\"ls -l\")            # 查看目录文件"
  },
  {
    "objectID": "posts/md/R中语言文件目录相关操作.html#几个特殊的目录",
    "href": "posts/md/R中语言文件目录相关操作.html#几个特殊的目录",
    "title": "R语言文件目录相关操作",
    "section": "4. 几个特殊的目录",
    "text": "4. 几个特殊的目录\n\nR.home() 查看R软件的相关目录\n.Library 查看R核心包的目录\n.Library.site 查看R核心包的目录和root用户安装包目录\n.libPaths() 查看R所有包的存放目录\nsystem.file() 查看指定包所在的目录\n\n参考：http://blog.fens.me/r-file-folder/"
  },
  {
    "objectID": "posts/md/C语言.html",
    "href": "posts/md/C语言.html",
    "title": "用c语言设置定时关机",
    "section": "",
    "text": "发现代码，win有自动防范木马的可能，于是要手动去在定时任务勾选某些指标，所以不可行。\n# include<stdio.h>\n# include <windows.h>\nint main() {\n  //如果存在任务名为myTaskName2 则强制删除，若没有则报错，但不终止该程序的运行\n    system(\"schtasks /delete /tn myTaskName2 /f\"); \n    // 创建一个任务名为myTaskName2的任务,/tr 后面是 要执行的命令， 双引号要转义，/st 后面接的是触发时间\n    system(\"schtasks /create /tn myTaskName2  /f /tr \\\"shutdown -s -f -t 10\\\" /sc once /st 22:35:00\");\n\n    system(\"schtasks /delete /tn myTaskName4 /f\");\n    system(\"schtasks /create /tn myTaskName4  /f /tr \\\"shutdown -s -f -t 10\\\" /sc once /st 22:42:00\");\n\n    system(\"schtasks /delete /tn myTaskName3 /f\");\n    system(\"schtasks /create /tn myTaskName3  /f /tr \\\"shutdown -s -f -t 10\\\" /sc once /st 22:52:00\");\n\n    system(\"schtasks /delete /tn myTaskName5 /f\");\n    system(\"schtasks /delete /tn myTaskName6 /f\");\n    system(\"schtasks /delete /tn myTaskName7 /f\");\n    system(\"schtasks /create /tn myTaskName5  /f /tr \\\"shutdown -s -f -t 10\\\" /sc once /st 23:00:00\");\n    system(\"schtasks /create /tn myTaskName6  /f /tr \\\"shutdown -s -f -t 10\\\" /sc once /st 23:15:00\");\n    system(\"schtasks /create /tn myTaskName7  /f /tr \\\"shutdown -s -f -t 10\\\" /sc once /st 23:27:00\");\n\n    system(\"schtasks /delete /tn myTaskName8 /f\");\n    system(\"schtasks /delete /tn myTaskName9 /f\");\n    system(\"schtasks /create /tn myTaskName8  /f /tr \\\"shutdown -s -f -t 10\\\" /sc once /st 23:43:00\");\n    system(\"schtasks /create /tn myTaskName9  /f /tr \\\"shutdown -s -f -t 10\\\" /sc once /st 23:58:00\");\n\n    return 0;\n}"
  },
  {
    "objectID": "posts/md/C语言.html#直接注入关机命令",
    "href": "posts/md/C语言.html#直接注入关机命令",
    "title": "用c语言设置定时关机",
    "section": "直接注入关机命令",
    "text": "直接注入关机命令\n这样感觉，电脑右下角一直有一个图标， 于是再次改进\n# include<stdio.h>\n#include <time.h>\n#include<stdlib.h>\n#include <string.h>\n#include<windows.h>\n\nvoid loop_shut(){\n    while(1){\n        system(\"shutdown -s -f -t 5\");\n        Sleep(1);\n    }\n}\nint main()\n{\n    char str1[100]=\"shutdown -s -f -t \";\n    char str2[32];\n    char *str3; \n    int now_hour=0,now_min=0,now_second=0;\n    struct tm * tmpointer;  //申明tm结构体指针\n    time_t secs;  //申明time_t类型变量\n    time(&secs); //获取当前系统日期与时间\n    tmpointer = localtime(&secs); //获取tm结构的日期时间,获取当地日期与时间\n    printf(\"\\Now: %d-%d-%d %d:%d:%d\\n\",tmpointer->tm_mon,tmpointer->tm_mday,\n    tmpointer->tm_year+1900,tmpointer->tm_hour,tmpointer->tm_min,tmpointer->tm_sec); \n    //获取当前系统时间 \n    now_hour = tmpointer->tm_hour;\n    now_min = tmpointer->tm_min;\n    now_second = tmpointer->tm_sec;\n    \n    \n    \n    printf(\"\\n当前时间:%d:%d:%d\",tmpointer->tm_hour,tmpointer->tm_min,tmpointer->tm_sec);\n    \n    //设置关机时间\n    int close_hour = 22,close_min =30,close_sec = 0;\n    printf(\"\\n关机时间:%d:%d:%d\\n\",close_hour,close_min,close_sec);\n\n    int i=0,j=0;\n    int diff_hour ,diff_min;//时间差\n    int left_time ;//离关机时间还剩多少秒 (单位:秒)\n    diff_hour = now_hour - close_hour; //离关机时间还剩多少个小时 \n    diff_min = now_min -close_min;// 离关机时间还剩多少个分钟 \n    printf(\"时间差: 小时:%d  分钟:%d \\n\",diff_hour,diff_min);\n    //时间在 关机时间后 \n    if(diff_hour > 0) {\n        // 当前小时在关机时间之后  \n        printf(\"正在关机1\\n\");\n        system(\"shutdown -s -f -t 10\");//立即关机 \n        loop_shut(); \n            \n    }else if(diff_hour ==0){\n        //当前小时 正在关机时间处 \n        if(diff_min <0){\n            //没超过关机时间 \n            printf(\"正在关机2\\n\");\n            diff_min =(-1) * diff_min;\n            i = diff_min*60;\n            printf(\"还剩%d秒==%d分钟\\n\",i,diff_min);\n            itoa(i,str2,10);//把数字转变为字符串 ，后面的10 为10进制 \n            strcat(str1,str2);  //拼接字符串 \n            system(str1);\n        }else if(diff_min ==0){\n            printf(\"正在关机3\\n\");\n            system(\"shutdown -s -f -t 20\");//立即关机 \n            loop_shut();\n        }else{\n            //超过关机时间 \n            printf(\"正在关机4\\n\");\n            system(\"shutdown -s -f -t 20\");//立即关机 \n            loop_shut();\n        }\n    }else{\n        //当前小时 在关机时间之前 \n        printf(\"正在关机5\\n\");\n        left_time = diff_hour*(-1)*60 + diff_min*(-1);\n        i = left_time*60;\n        printf(\"还剩%d秒==%d分钟\\n\",i,left_time);\n        itoa(i,str2,10);//把数字转变为字符串 ，后面的10 为10进制 \n        strcat(str1,str2);  //拼接字符串 \n        system(str1);\n    }\n  return 0; \n}"
  },
  {
    "objectID": "posts/md/C语言.html#结合定时任务关机",
    "href": "posts/md/C语言.html#结合定时任务关机",
    "title": "用c语言设置定时关机",
    "section": "结合定时任务关机",
    "text": "结合定时任务关机\n到某个时间以后，如果在重启，就会直接关机（除非你手速快）,并把生成的exe文件设置为开机启动。\n# include <stdio.h>\n# include <time.h>\n# include <stdlib.h>\n# include <string.h>\n# include <windows.h>\n\nvoid loop_shut() {\n    while(1) {\n        system(\"shutdown -s -f -t 5\");\n        Sleep(6);\n    }\n}\nint main() {\n    //设置关机时间\n    int close_hour = 22,close_min =35,close_sec = 0;\n\n    int diff_hour ,diff_min;//声明变量用来存储时间差\n    int temp;\n    //声明变量获取时间结构\n    int now_hour=0,now_min=0,now_second=0;\n    struct tm * tmpointer;  //申明tm结构体指针\n    time_t secs;  //申明time_t类型变量\n    time(&secs); //获取当前系统日期与时间\n    tmpointer = localtime(&secs); //获取tm结构的日期时间,获取当地日期与时间\n\n    //获取当前系统时间\n    now_hour = tmpointer->tm_hour;\n    now_min = tmpointer->tm_min;\n    now_second = tmpointer->tm_sec;\n\n    //时间差\n    diff_hour = now_hour - close_hour; //离关机时间还剩多少个小时\n    diff_min = now_min -close_min;// 离关机时间还剩多少个分钟\n    //关机程序，时间在22:30分以后 以及早上7点之前\n    temp = ( diff_hour >0 ||(diff_hour ==0 && diff_min>=0) ) || (now_hour <7); \n    if(temp) {\n        // 已过关机时间之后\n        printf(\"正在关机1\\n\");\n        //system(\"shutdown -s -f -t 5\");//立即关机 ,有时候需要保存一点重要资料\n        loop_shut();\n    } else {\n        printf(\"不关机!\");\n    }\n    return 0;\n}\n同时在win的程序计划任务中自己添加几个任务，到点自动关机，注意第一个留一点时间，保存文件，后面一个直接关机.并设置选项，不然不会自动运行 如下:\n\n\n亲试，根本还没有看到桌面，就显示关机了."
  },
  {
    "objectID": "posts/md/hugo---blogdown生成的目录.html",
    "href": "posts/md/hugo---blogdown生成的目录.html",
    "title": "hugo–blogdown生成的目录",
    "section": "",
    "text": "2、静态文件\n不需要hugo处理的文件叫做静态文件。存放在 站点的static 目录是个好主意。\n\nstatic目录下的文件将会原封不动的复制到public下面，比如您建立了个img的目录存图片，在md文件中将直接使用”img/aaa.jpg”来引用图片，\n特别的，如果您的站点有php等脚本运用，和一些其他的文件，比如各搜索引擎的验证文件等，也可以放在这里。不建议直接将文件存放于public目录，因为我习惯不高兴就删了全来！相信你也会有不高兴的时候的。（后面比如要上传的google网站分析的html文件）\n\n\n\n3、站点配置文件\n站点根目录下有一个”config.toml“就是配置文件 E:\\test_blog下的config.toml\n\n信息存在的地，hugo有三个地方可以放信息，\n\n一个是站点的配置文件“config.toml”，\n一个是我们文章文件md文件的头部（默认的用三个“—”号开始和结束，也可以用三个“+++”号\n最后一个是“data”数据目录。\n\ncongfig.toml该文件默认支持的全部参数：可以用键值对，也可以用赋值语句\n以 hugo-lithium-theme主题为例\n介绍几个后面可能会用的参数\nbaseurl = \"http://qaz.netlify.com\"    # 基础路径,当自己有网站的时候就写自己的\nrelativeurls = true                    #使用想对路径方便本地浏览\nlanguageCode = \"zh-cn\"                #编码\ntitle = \"A Hugo website\"            #网站的title\ntheme = \"hugo-lithium-theme\"\ngoogleAnalytics = \"\"                 #谷歌网站分析添加自己的id，形如：UA-XXXXXX-X\ndisqusShortname = \"http-qaz-netlify-com\"  # disqusShortname 的名字，一定要找准\nignoreFiles = [\"\\\\.Rmd$\", \"\\\\.Rmarkdown$\", \"_files$\", \"_cache$\"] \nhasCJKLanguage = true         #若要统计中文字数设置为ture,默认统计英文\n\n\n\n4、自定义信息\n站点配置文件并不是只能存放默认的配置项目的，它一样可以存放自定义的数据，并且在模版中被调用。\n下面是本站的目录的自定义信息：\n[permalinks]\n    post = \"/:year/:month/:day/:slug/\"\n\n[[menu.main]]\n    name = \"About\"\n    url = \"/about/\"\n[[menu.main]]\n    name = \"GitHub\"\n    url = \"https://github.com/rstudio/blogdown\"\n[[menu.main]]\n    name = \"Twitter\"\n    url = \"https://twitter.com/rstudio\"\n\n[params]\n    description = \"A website built through Hugo and blogdown.\"\n\n    # options for highlight.js (version, additional languages, and theme)\n    highlightjsVersion = \"9.11.0\"\n    highlightjsCDN = \"//cdn.bootcss.com\"\n    highlightjsLang = [\"r\", \"yaml\"]\n    highlightjsTheme = \"github\"\n\n    MathJaxCDN = \"//cdn.bootcss.com\"\n    MathJaxVersion = \"2.7.1\"\n\n    [params.logo]\n    url = \"logo.png\"\n    width = 50\n    height = 50\n    alt = \"Logo\"\n找到E:\\test_blog\\themes\\hugo-lithium-theme\\layouts\\ 下面有两个文件夹\n一个_default/ partials/"
  },
  {
    "objectID": "posts/md/R语言字符处理---基本函数.html",
    "href": "posts/md/R语言字符处理---基本函数.html",
    "title": "R语言字符处理—基本函数",
    "section": "",
    "text": "函数\n说明\n\n\n\n\nEncoding(x) Encoding(x) <- value enc2native(x) enc2utf8(x)\n读取或设置字符向量的编码常结合iconv(x, from = ““, to =”“)函数使用注意：Encoding(x) <- value 这是一种赋值函数\n\n\nnchar(x, type = “chars”, allowNA = FALSE, keepNA = NA)nzchar(x, keepNA = FALSE)\nnchar()返回字符长度nzchar()判断是否空字符keepNA为真是NA保留，不计入计数对于缺失值NA，nchar和nzchar函数默认是字符数为2的字符串。对于NULL，nchar和nzchar函数会忽略掉。\n\n\nsubstr(x, start, stop)substring(text, first, last = 1000000L)substr(x, start, stop) <- valuesubstring(text, first, last = 1000000L) <- value\n提取或替换字符向量的子字段，substring同substr功能一样\n\n\nstrtrim(x, width)\n按显示宽度截断字符串\n\n\npaste (…, sep = ” “, collapse = NULL)paste0(…, collapse = NULL)\n通过sep连接间隔连接对象,返回字符串向量设定collapse的话，会通过collapse连接间隔将上一步的字符串向量连接成一个字符串\n\n\nstrsplit(x, split, fixed = FALSE, perl = FALSE, useBytes = FALSE)\n基于split子句分割字符向量xfixed为TRUE的话，完全匹配split；否则，基于正则表达式。可以使用split=NULL来分割每个字符。\n\n\nchartr(old, new, x)\n将x中的字符old变换为字符new注意替换的是单个对应的字符，而非字符串\n\n\ntolower(x)toupper(x)\n大小写转换\n\n\nsprintf(fmt, …)\n系统C库函数sprintf封装器，格式化输出函数"
  },
  {
    "objectID": "posts/md/R语言字符处理---基本函数.html#正则表达式字符串匹配函数",
    "href": "posts/md/R语言字符处理---基本函数.html#正则表达式字符串匹配函数",
    "title": "R语言字符处理—基本函数",
    "section": "正则表达式—–字符串匹配函数",
    "text": "正则表达式—–字符串匹配函数\n\n\n\n\n\n\n\n函数\n说明\n\n\n\n\ngrep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE,fixed = FALSE, useBytes = FALSE)\n若x为list，则找出和(参数pattern)匹配的序列编号若x为字符串，则判别改字符串中是否包含特定的字符,包含返回1，不包含返回integer(0)若x为字符向量,同list只找到第一个即可\n\n\ngrepl(pattern, x, ignore.case = FALSE, perl = FALSE,fixed = FALSE, useBytes = FALSE)\n返回TRUE 或FALSE\n\n\nsub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE,fixed = FALSE, useBytes = FALSE)\n只替换匹配到的第一个字符串\n\n\ngsub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE,fixed = FALSE, useBytes = FALSE)\n替换匹配到的所用字符串\n\n\nregexpr(pattern, text, ignore.case = FALSE, perl = FALSE,fixed = FALSE, useBytes = FALSE)\n返回第一个和(参数pattern)匹配的起始位置(或下标)和匹配长度(pattern的长度，若为正则，则是匹配字符串的实际长度)若没有则返回: -1\n\n\ngregexpr(pattern, text, ignore.case = FALSE, perl = FALSE,fixed = FALSE, useBytes = FALSE)\nregexpr()函数只匹配第一个，想要多次匹配则用gregexpr()函数\n\n\nregexec(pattern, text, ignore.case = FALSE, perl = FALSE,fixed = FALSE, useBytes = FALSE)\n和regexpr()函数一样\n\n\n\n共同参数解析： 1、fixed = TRUE: 使用精确匹配 2、perl = TRUE: 使用Perl风格正则表达式 3、fixed = FALSE且perl = FALSE: 使用POSIX 1003.2扩展正则表达式 4、 useBytes = TRUE时逐字节匹配，否则逐字符匹配\n\n\nregmatches(x, m, invert = FALSE)regmatches(x, m, invert = FALSE) <- value\n抽取或替换正则表达式匹配子串 invert = TRUE则抽取或替换不匹配子串 str<-c(“Now is”,“the”,” time “) m<-regexpr(” +“,str)regmatches(str,m)<-”9999”str\n\n\nglob2rx(pattern, trim.head = FALSE, trim.tail = TRUE)\n将通配符模式变成正则表达式\n\n\n\n\n\n\n\n\ngrep()函数参数：\n\n\n\n\n\n\n\n参数\n功能\n\n\n\n\npattern\n包含正则表达式的字符串\n\n\nx\n寻找匹配的字符向量，或者可以通过字符向量强制转换的对象。支持长向量\n\n\nignore.case\n如果为FALSE，则模式匹配区分大小写；如果为TRUE，则在匹配期间忽略大小写\n\n\nperl\n如果为TRUE，使用perl匹配的正则表达式\n\n\nvalue\n如果为FALSE，则返回包含由grep确定的匹配的索引的向量，如果为TRUE，则返回包含匹配元素本身的向量\n\n\nfixed\n如果为TRUE，则pattern是要按原样匹配的字符串\n\n\nuseBytes\n如果为TRUE，则匹配是逐字节而不是逐字符完成的\n\n\ninvert\n如果为TRUE，则返回不匹配的元素的索引或值\n\n\n\ngrep()能对向量中特定条件的元素进行查询，默认return为index,。grep()语法与grep()大致相似，但默认return为logical。"
  },
  {
    "objectID": "posts/md/corr详解matlab.html",
    "href": "posts/md/corr详解matlab.html",
    "title": "corr详解(MATLAB)",
    "section": "",
    "text": "corrcoef是对两个列向量，或者一个矩阵的每列进行的，用的是pearson相关\ncorr可以对两个矩阵的每列进行，也可以对一个矩阵的每列进行，相关的类型可以是pearson或者Kendall或者Spearman\n总之，corr强大很多\n\n\n\n\n\n输入：一个矩阵A，\n方法：计算矩阵A的每一列与每一列之间的皮尔逊相关系数，得到一个对称的相关系数矩阵。\n返回： 一个相关系数矩阵R，\nA = randn(n,m); % A是一个n*m的矩阵\ncorrcoef(A) % 返回一个m*m的对称矩阵\n\n\n\n输入： 两个向量，A，B均为列向量\n返回：一个2*2 对称的相关系数矩阵\n如果A, B 均为矩阵，则先把A，B转变为列向量，然后再计算皮尔逊相关系数，即等价于如下形式\nA = randn(n,m); % A是一个n*m的矩阵\nB = randn(n,m); % B是一个n*m的矩阵,\n%% 注意A，B矩阵的个数一定要一样\ncorrcoef(A,B）       % 返回一个2*2的对称矩阵\ncorrcoef(A(:),B(:)) % 等价 corrcoef(A,B）\n\n\n\n\n\n\n输入：一个矩阵X\n方法: 计算矩阵X的每一列与每一列之间的皮尔逊相关系数，得到一个对称的相关系数矩阵。\n返回： 返回一个对称的相关系数矩阵rho\n\n\n\n输入： X为\\(n*m1\\)的矩阵，Y为\\(n*m2\\)的矩阵\n方法：返回输入矩阵X和Y中每对列之间的成对相关系数矩阵。\n返回一个\\(m1*m2\\)的矩阵，其中第i行第j列元素代表X的第i列与Y第j列的相关系数\n\n\n\nR = corr(X,'Type','Pearson')\nR = corr(X,Y,'Type','Pearson')\nR = corr(X,Y,'Type','Kendall')\nR = corr(X,Y,'Type','Spearman')"
  },
  {
    "objectID": "posts/md/R中常用批处理操作.html",
    "href": "posts/md/R中常用批处理操作.html",
    "title": "R中常用的批处理操作",
    "section": "",
    "text": "setwd('/Users/zsc/Desktop/音乐mp3/')\n\nlibrary(stringr)\noldname = list.files(pattern = '.*mp3')\nnewname = str_extract(d,'.*(?=158)')\ndf = data.frame(oldname = oldname, newname = newname)\ndf\nfile.rename(df$oldname, df$newname)"
  },
  {
    "objectID": "posts/md/R中常用批处理操作.html#批量统计-pdf-的页数",
    "href": "posts/md/R中常用批处理操作.html#批量统计-pdf-的页数",
    "title": "R中常用的批处理操作",
    "section": "批量统计 pdf 的页数",
    "text": "批量统计 pdf 的页数\nlibrary(qpdf)\nsetwd('/Users/zsc/Desktop/pdf/')\nd = list.files()\nd\n\nd1 = str_extract(d,'.*?.pdf$')\n\n\nlibrary(purrr)\nmap_dbl(d1, pdf_length)\n\nmap_dbl(d1, pdf_length) %>% sum()"
  },
  {
    "objectID": "posts/md/R中常用批处理操作.html#移除latex生成的临时文件",
    "href": "posts/md/R中常用批处理操作.html#移除latex生成的临时文件",
    "title": "R中常用的批处理操作",
    "section": "移除latex生成的临时文件",
    "text": "移除latex生成的临时文件\np = getwd()\ncat(p,'\\n')\nt = '*.aux|*.bbl|*.bcf|*.blg|*.log|*.xml|*.out|*.spl|*.synctex.gz' \ndel = list.files(path = p,pattern = t)\nfile.remove(del)"
  },
  {
    "objectID": "posts/md/相关图之corrgram.html",
    "href": "posts/md/相关图之corrgram.html",
    "title": "相关图之corrgram",
    "section": "",
    "text": "相关图： 所谓相关图是基于变量间的相关系数大小，通过可视化方法反应不同变量组合间相关关系的差异图形。可以把相关图分为相关矩阵图、相关层次图"
  },
  {
    "objectID": "posts/md/相关图之corrgram.html#相关矩阵图",
    "href": "posts/md/相关图之corrgram.html#相关矩阵图",
    "title": "相关图之corrgram",
    "section": "相关矩阵图",
    "text": "相关矩阵图\nR语言中，绘制相关矩阵图的包主要有两个：corrgram::corrgram和corrplot::corrplot\n此处都以mtcars数据集为例，说明这两个函数的使用"
  },
  {
    "objectID": "posts/md/相关图之corrgram.html#相关矩阵图-corrgram",
    "href": "posts/md/相关图之corrgram.html#相关矩阵图-corrgram",
    "title": "相关图之corrgram",
    "section": "相关矩阵图 — — corrgram",
    "text": "相关矩阵图 — — corrgram\n\ncorrgram::corrgram()函数\ncorrgram(x, type = NULL, order = FALSE, labels, panel = panel.shade,\n    lower.panel = panel, upper.panel = panel, diag.panel = NULL,\n    text.panel = textPanel, label.pos = c(0.5, 0.5), label.srt = 0,\n    cex.labels = NULL, font.labels = 1, row1attop = TRUE, dir = \"\",\n    gap = 0, abs = FALSE, col.regions = colorRampPalette(c(\"red\", \"salmon\",\n    \"white\", \"royalblue\", \"navy\")), cor.method = \"pearson\",\n    outer.labels = NULL, ...)\n\n\n参数解释：  \nx: 数据框或者相关矩阵,输入数据框时，会自动识别数值型列进行计算相关矩阵，然后再绘图\norder: 是否让变量按主成分分析相关矩阵排列.可以设置为TRUE或\"PCA\",默认FALSE\npanel : 设置非对角线的面板形状,默认为阴影图\nlower.panel: 设置相关矩阵下三角矩阵面板形状\nupper.panel： 设置相关矩阵上三角矩阵面板形状\n    面板形状设置参数： \n    panel.pie   用饼图的填充比例来表示相关性大小\n        panel.shade 用阴影的深度来表示相关性\n        panel.ellipse   绘制置信椭圆和平滑拟合曲线\n        panel.pts   绘制散点图\n    \ntext.panel 和 diag.panel 选项控制着主对角线元素类型。 \n    textPanel    输出变量的名字（默认）\n    panel.minmax    输出变量的最大最小值\n        panel.txt      输出的变量名字          \n画出相关矩阵图\nlibrary(corrgram)\ncorrgram(cor(mtcars)) \n\ncorrgram(mtcars)\n\ncorrgram(iris)\n\n\n\n设置排序处理\ncorrgram(mtcars,order = T) # 等价 corrgram(mtcars,order = \"PCA\")\n\n\n\n设置上下三角面板形状\ncorrgram(mtcars,order = \"PCA\",lower.panel = panel.shade,upper.panel = panel.pie)\n\n只显示下三角部分图\ncorrgram(mtcars,order = \"PCA\",lower.panel = panel.shade,upper.panel = NULL)\n\n\n\n调整版面颜色\ncorrgram(mtcars,order = T,lower.panel = panel.shade,upper.panel = panel.pie,\n            col.regions = colorRampPalette(c(\"darkgoldenrod4\", \"burlywood1\",\"white\",\"darkkhaki\", \"darkgreen\")))\n\ncorrgram(mtcars,order=TRUE,\n            lower.panel=panel.ellipse,\n            upper.panel=panel.pts,\n            text.panel=panel.txt,\n            diag.panel=panel.minmax,\n            main=\"Correlogram of Mtcars intercorrelations\" )"
  },
  {
    "objectID": "posts/md/latex缩写期刊.html",
    "href": "posts/md/latex缩写期刊.html",
    "title": "latex 缩写期刊",
    "section": "",
    "text": "以下软件对参考文献都不能完美的满足我的要求, 因此可以结合不同软件的优势,达到最后的效果"
  },
  {
    "objectID": "posts/md/latex缩写期刊.html#zotero",
    "href": "posts/md/latex缩写期刊.html#zotero",
    "title": "latex 缩写期刊",
    "section": "1. zotero",
    "text": "1. zotero\n设置—首选项—bitter bibtex —export — 最下面有一个期刊缩写,选购就能导出缩写的期刊名了\n\n特点:\n\n使用该软件, 系统自带的期刊缩写对照表很少, 且不能添加对照表,\n不会自动更新bib文件\n可以按照key键的顺序(升序) 导出bib数据库, 只需导出时选中[biter bibtex]选项即可\n也可以安装以前的方式导出bib数据库, 只需导出时选中[bibtex]选项即可"
  },
  {
    "objectID": "posts/md/latex缩写期刊.html#mendeley",
    "href": "posts/md/latex缩写期刊.html#mendeley",
    "title": "latex 缩写期刊",
    "section": "2. Mendeley",
    "text": "2. Mendeley\n\n特点:\n\n默认情况下, 联网会自动更新bib数据库, 这一点很烦(for me), 因此可以直接断网使用该软件\n期刊缩写很好,内置了很多比较全的期刊缩写.但某些期刊仍不全面,且缩写的格式看不见\n\n\n\n\n\nmendeley01\n\n\n\n\n\nmendeley02"
  },
  {
    "objectID": "posts/md/latex缩写期刊.html#jabref软件",
    "href": "posts/md/latex缩写期刊.html#jabref软件",
    "title": "latex 缩写期刊",
    "section": "3. Jabref软件",
    "text": "3. Jabref软件\n特点:\n\n内置的期刊缩写相对较少, 但是可以手动添加期刊缩写列表(官网有), 就是电脑卡\n由于bib文件中使用的是\\& , 而jabref软件中默认使用&, 这样对照表中可能不会存在相应的缩写\n不能导出按照key键顺序导出相应的bib文件\n使用期刊缩写时,首先使用展开期刊全名,才去缩写,不然有可能找不到,\n不会自动更新bib文件\n下面是使用期刊缩写步骤, 先管理期刊缩写名(选择使用哪种类型的对照表),在进行期刊缩写"
  },
  {
    "objectID": "posts/md/latex缩写期刊.html#自用软件包journalabbr",
    "href": "posts/md/latex缩写期刊.html#自用软件包journalabbr",
    "title": "latex 缩写期刊",
    "section": "4. 自用软件包journalabbr",
    "text": "4. 自用软件包journalabbr\n\n利用Jabref软件提供了大量的期刊缩写列表https://github.com/JabRef/abbrv.jabref.org,但是在Jabref软件中使用经常死机.\n借助 pandoc , 该软件提供了大量命令参数, 感兴趣的可以去探索, 而xieyihui 通过使用*.Rmd文件进行了封装(前提要安装并了解R + Rstudio), 个人在巨人的肩上, 进行了简单封装,提供了一个R包journalabbr提供了一个本地app 和一个在线app, 解决了Jabref缩写期刊时遇到的缺点. 该app主要功能: 提供期刊缩写, 美化bib数据库文件以及提供类似bst文件那样批量生成一个完整的 thebibliography 环境. app截图如下:\n\n\n\n\nimage-20200809120534362"
  },
  {
    "objectID": "posts/md/git笔记.html",
    "href": "posts/md/git笔记.html",
    "title": "git 笔记",
    "section": "",
    "text": "安装不多说,\n初次运行 git前的配置, 配置全局信息: 用户名与邮箱,(此处的用户名与邮箱需要到 github 注册)\n$ git config --global user.name \"XXX\"\n$ git config --global user.email \"email@example.com\"\n如果已经多次使用 git ,可以用以下命令进行查看\n$ git config -l   % 查看所有配置信息\n$ git config --global -l   % 查看全局配置信息\n$ cat ~/.gitconfig   % 用户的配置文件\n注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。\n一些终端基础命令\n$ ls -al    # 查看所有文件夹\n$ pwd       # 查看当前所在的目录\n$ clear     # 清屏(终端)"
  },
  {
    "objectID": "posts/md/git笔记.html#创建本地仓库",
    "href": "posts/md/git笔记.html#创建本地仓库",
    "title": "git 笔记",
    "section": "2 . 创建本地仓库",
    "text": "2 . 创建本地仓库\n\n\n\ngit01\n\n\n\n2.1 创建版本库 (即初始化一个空仓库, 这个目录下的所有路径都称作工作区)\n版本库又名仓库(repository)，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。\n$ git init    # 该命令会在当前目录下创建了隐藏目录.git(与 git有关的信息都存储在这个文件夹里面)\n$ git status    # 可以让我们时刻掌握仓库当前的状态, 检查当前文件状态\n#可根据返回的字体颜色进行判断(红色代表在工作区,绿色代表在暂存区,什么都看不见证明所有修改的东西都已经提交到历史区)\n\n\n2.2 把工作区中的文件(夹)提交到暂存区\n当本地编写文件完成后(在工作区) , 把一些文件提交到暂存区\n$ git add XXX     # 把 XXX 单个文件或文件夹提交到暂存区\n$ git add .       # 把当前仓库中所有最新修改的文件都提交到暂存区\n$ git add -A      # 等价于 git add .\n\n\n2.3 把暂存区提交到历史区\n狭义的版本库指的是历史区,广义的版本库指的是这个目录下的所有操作.\n$ git commit -m \"描述信息\"    # 是把暂存区的所有文件一次性提交到历史区\n\n\n2.4 查看历史区的 commit id\n即查看你一共使用了多少次git commit -m '', 每一次该命令使用都会产生一个 commit id . 下面的命令都可以查看提交的历史(也可以在 github 网站的code查看,前提本地仓库与远程仓库以及同步 )\n$ git log       # 可以查看提交历史，以便确定要回退到哪个版本。 (可用于穿梭历史),\n$ git reflog    # 查看命令历史，以便确定要回到未来的哪个版本。 (可用于穿梭未来,包含历史的回滚),\n\n\n2.5 退回某个commit id 版本\n\n\n\ngit02\n\n\n可以用于回滚(即可以回到历史版本,也可回到未来版本(zhu)) ,\n$ git reset --hard ****   #可以指定回到某个提交的历史版本, **** 为 commit id,id可以不写全\n从工作区提交到暂存区,从暂存区提交到历史区: 是把内容复制一份传过去的,本区域依然存在这些信息(只有这样才能对比出那些文件是否进行了修增改删)\n\n\n2.6 从暂存区撤销到工作区, 以及从工作区撤销修改\n$ git  reset HEAD <file># 从暂存区中删除该文件,但是文件内容不会修改(只撤销提交这个记录,即删除 git add操作),\n$ git checkout --<file> # 把工作区的修改后文件的文件还原(撤销修改)\n$ git checkout .          # 放弃没有提交的修改(类似回退到最新的一次提交)\n\n\n2.7 .gitignore\n.gitignore 用于定义忽略提交的文件\n\n所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。\n匹配模式最后跟反斜杠（/）说明要忽略的是目录。\n可以使用标准的 glob 模式匹配。\n\n.idea\n/vendor       # 忽略目录\n*.txt\n!a.txt    # *.txt 和 !a.txt 结合,表示除了a.txt以外的所有 txt 文件都被忽略\n\n\n2.8一些其他操作\n$ git commit --amend   # 修改最新一次提交的备注, \n# 如果还有新的文件要和上次提交一起, 可以先把新文件添加到暂存区,然后使用 git commit --amend  就可以把新文件添加到最新的一次提交当中\n\n\n$ git rm <file>          # 一般情况下, 仓库中(版本库)和本地都会删除该文件\n$ git rm --cached <file>   # 删除仓库中的文件,不删除本地文件\n\n$ git clean -fd    # 删除没有add 的文件和目录 \n$ git clean -n     # 显示将要删除的文件或目录"
  },
  {
    "objectID": "posts/md/git笔记.html#github",
    "href": "posts/md/git笔记.html#github",
    "title": "git 笔记",
    "section": "3. github",
    "text": "3. github\n\n3.1 github 简介\n\n网站: https://www.github.com\n一个开源的源代码管理平台\n\nsetting 用户设置\n\nprofile 修改自己的基本信息\nAccount 可以修改用户名\nsecurity 可以修改自己的密码\n….\n\n\n\n3.2 创建远程仓库,\n直接去 github 网页上点击new repository--> 填写信息--> 创建仓库创建\n\npublic 公共仓库作为开源项目\nprivate 私有仓库作为内部团队合作项目\n\nsetting —> collaborators 设置合作开发人员\ncode 可以查看历史版本信息和分支信息\n\n\n\n\n3.3 把本地仓库信息提交到远程仓库\n\n3.3.1第一步: 首先建立本地仓库与远程仓库的链接\n$ git remote -v   # 查看当前仓库与那个远程仓库建立了链接,没有建立链接,则不显示\n\n设置本地仓库与远程仓库建立一个链接, 链接名为 origin (可以更改,但一般都用这个)\n$ git remote add origin [git 远程仓库地址]\n\n删除管理信息\n$ git remote rm origin\n\n\n3.3.2 第二步: 本地仓库提交到远程仓库\n#提交之前最好先拉取--- 即把远程和本地的进行同步合并\n$ git pull origin master\n#把本地代码提交到远程仓库(可能需要 github 的用户名和密码)\n$ git push origin master #将 master 分支推送到 origin 服务器\n$ git push -u origin master 上面命令将本地的master分支推送到origin主机\n# 加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令: git push，默认只推送当前分支"
  },
  {
    "objectID": "posts/md/git笔记.html#分支",
    "href": "posts/md/git笔记.html#分支",
    "title": "git 笔记",
    "section": "4 分支",
    "text": "4 分支\n\n4.1 分支的功能\n分支的作用: 用于为项目增加新功能或修复Bug时使用。\n\n\n\ngit03\n\n\n假设当前节点处于 id03 , 一般默认处于 master 分支上, 现在要\n创建分支:  git branch dev\n查看分支:  git branch     # 分支前面有一个* 号,代表处于当前分支\n切换分支:  git checkout dev\n创建并切换分支:  git checkout -b dev\n合并dev分支到 master : \n        git checkout master  % 先切换分支,然后再合并\n        git merge dev\n删除分支:  git branch -d dev\n删除没有合并的分支: git branch -D dev\n删除远程分支:  git push origin :dev\n\n查看未合并的分支(切换到master):  git branch --no-merged\n查看已经合并的分支(切换到master) : git branch --merged\n\n\n\n\ngit04\n\n\n\n\n4.2 合并分支可能会产生冲突\n\n4.2.1 git 分支冲突\n产生原因: 不同分支修改同一个文件或不同开发者修改同一个分支文件都可能造成冲突，造成无法提交代码。\n\n手动使用编辑器修改冲突的文件\n添加暂存 git add . 表示已经解决冲突\ngit commit 提交完成\n\n另一种解决冲突的办法—- 强制推送\n\n\n4.2.2. git强制覆盖本地文件（与git远程仓库保持一致）：\n# 方法一: 多条命令执行\ngit fetch --all\ngit reset --hard origin/master\ngit pull\n\n# 方法二: 单条命令执行, git强制覆盖本地命令（单条执行）：\ngit fetch --all && git reset --hard origin/master && git pull\n\n\n4.2.3. git强制推送本地代码到远程仓库\n强制用本地的代码去覆盖掉远程仓库的代码:\ngit push -f origin master\n%注释： origin远程仓库名，master分支名，-f为force，意为：强行、强制。\n% 一般情况下 推送可简写为 git push. \n\n\n\n4.3 储藏（Stashing）\n当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。\n“暂存” 可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用。\n\n储藏当前工作状态 git stash\n查看储藏列表 git stash list\n应用(恢复到)最近的储藏 git stash apply\n应用(恢复到)更早的储藏 git stash apply stash@{2}\n删除储藏 `git stash drop stash@{0} 其中stash@{0} 表示存储的标识.\n应用并删除储藏 git stash pop\n\n\n\n4.4 Tag\nGit 也可以对某一时间点上的版本打上标签 ，用于发布软件版本如 v1.0\n\n添加标签 git tag v1.0\n列出标签 git tag\n推送标签 git push --tags\n删除标签 git tag -d v1.0.1\n删除远程标签 git push origin :v1.0.1\n\n\n\n4.5 生成zip压缩包\n方法一: git archive --format zip --output \"./output.zip\" master -0\n方法二: git archive --format zip --output dump.zip master\n\n\n4.6 移动分支的基础点, 产生干净的合并记录 –rebase\n\n\n\ngit05\n\n\n\n\n\ngit06\n\n\n\n\n4.7 git 压缩提交记录次数\n发现自己提交次数有点多，想来合并以前的一些提交记录，减少提交次数，命令如下:\ngit rebase -i HEAD~n  //n代表你要查看的提交记录条数\n\n\n\nimage-20200528104231661\n\n\nhttps://blog.csdn.net/xiaowu_zhu/article/details/83345313"
  },
  {
    "objectID": "posts/md/git笔记.html#git-别名-alias",
    "href": "posts/md/git笔记.html#git-别名-alias",
    "title": "git 笔记",
    "section": "5. git 别名 alias",
    "text": "5. git 别名 alias\n# 方式一: 命令设置别名,  a == add .   # 即 git a  == git add .\n$ git config --global alias.a add . \n$ git config --global alias.c commit\n\n# 方式二: 直接修改配置文件\n$ subl ~/.gitconfig   #用sublime 打开git的配置文件, 注意该配置文件的地址\n# mac 一般在~目录下, win一般也在用户目录下"
  },
  {
    "objectID": "posts/md/tibble包的列-行名转换.html",
    "href": "posts/md/tibble包的列-行名转换.html",
    "title": "tibble包的列和行名相互转换以及添加行和列",
    "section": "",
    "text": "tibble包：\n\nhas_rownames(df)：检查是否存在行名\nremove_rownames(df) ： 移除行名\nrownames_to_column(df, var = “rowname”) ： 行名变为某列\n\nrowid_to_column(df, var = “rowid”)： 行名变为某列,只能变为数字,个人不推荐\n\ncolumn_to_rownames(df, var = “rowname”) ： 某列变为行名，并删除某列,要求这个列值唯一\n\nlibrary(tibble)\nhead(mtcars)\nhas_rownames(mtcars) #检查是否存在行名\nnew_mtcars=rownames_to_column(mtcars, var = \"new_col\") #行名变为某列,行名此时被移除\nhead(new_mtcars)\n\n\n\nhas_rownames(rownames_to_column(mtcars, var = \"new_col\"))\nhas_rownames(rowid_to_column(mtcars, var = \"new_col\"))\n\n\ndf=remove_rownames(mtcars)#： 移除行名\nhead(df)\ncolumn_to_rownames(new_mtcars, var = \"new_col\")#  某列变为行名，并删除某列,要求这个列值唯一"
  },
  {
    "objectID": "posts/md/tibble包的列-行名转换.html#添加行与列",
    "href": "posts/md/tibble包的列-行名转换.html#添加行与列",
    "title": "tibble包的列和行名相互转换以及添加行和列",
    "section": "2、添加行与列",
    "text": "2、添加行与列\n添加行： + add_row(.data, …, .before = NULL, .after = NULL)\n添加列： + add_column(.data, …, .before = NULL, .after = NULL)\n\n\n.before 指添加在第n行(列)，默认在最后\n.after 指添加在第n行(列)后（即n+1行(列)）\n\n\ndf <- tibble(x = 1:3, y = 3:1)\n\nadd_row(df, x = 4, y = 0) #默认在最后添加\n\nadd_row(df, x = 4, y = 0, .before = 2)# 指定添加在第二行\n\n\nadd_row(df, x = 4:5, y = 0:-1) #也可以用向量添加多行，但是不推荐\n\nadd_row(df, x = 4) #添加变量不完整，则用NA添加，但是不能创建新变量\n# 但是不能创建新变量，这个是错的  add_row(df, z = 10)\ndf <- tibble(x = 1:3, y = 3:1)\n\nadd_column(df, z = -1:1, w = 0)\n\n# 不能覆盖创建原来的列，也不能修改原来的列"
  },
  {
    "objectID": "posts/md/创建自己的rmd模板.html",
    "href": "posts/md/创建自己的rmd模板.html",
    "title": "创建属于自己的rmarkdown模板文件",
    "section": "",
    "text": "下载链接: zscbeautiful\n下载下来后, 把css和html 分别放在对应的目录中替换即可\nTip: 我的mac路径为/Library/Frameworks/R.framework/Versions/4.0/Resources/library/prettydoc/ , 只需把下载下来的文件进行替换即可\n创建模板的步骤:  新建文件 —> R mardown —> From Template\n如图:\n\n\n\nuBfWNi\n\n\n参考: https://cosx.org/2019/10/prettydoc-internals-ljj/"
  },
  {
    "objectID": "posts/md/画函数图像R语言.html",
    "href": "posts/md/画函数图像R语言.html",
    "title": "画函数图像–R语言",
    "section": "",
    "text": "据我了解, 计算机软件中画的函数图像大概有两种方法:\n在本文中我们将利用R语言来画函数图像—- 重点以ggplot2来展示"
  },
  {
    "objectID": "posts/md/画函数图像R语言.html#y-fx-的函数图像",
    "href": "posts/md/画函数图像R语言.html#y-fx-的函数图像",
    "title": "画函数图像–R语言",
    "section": "1. \\(y = f(x)\\) 的函数图像",
    "text": "1. \\(y = f(x)\\) 的函数图像\n比如:\n\\[\n\\begin{aligned}\ny &= sin(x),\\\\\ny &= cos(x), \\\\\ny &= \\dfrac{1}{1+e^{(-x)}},\\\\\ny &= x^2 .\n\\end{aligned}\n\\]\n这是我们中学最常见的函数.\n\n方法一: curve()画函数图像\n所用函数调用格式\ncurve(expr, from = NULL, to = NULL, n = 101, add = FALSE,\n      type = \"l\", xname = \"x\", xlab = xname, ylab = NULL,\n      log = NULL, xlim = NULL, ...)\n# expr：函数名称或一个关于变量x的函数表达式；\n# from，to：表示绘图的起止范围；\n# n：一个整数值，表示x取值的数量；\n# add：是一个逻辑值，当为TRUE时，表示将绘图添加到已存在的绘图中；\n# type：与plot函数中type含义相同\n#定义公式\nsigmoid <- function(x) 1/(1+exp(-x))\n\n#画sigmid图像\ncurve(sigmoid,-10,10)\n\n#画sin(x)函数图像\ncurve(sin,-10,10)\n\n# 画y=x^2的图像\ncurve(x^2,-10,10)\n\n\n\n方法二: ggplot2\n首先介绍两个映射\n\ngeom_path() 按照观测值在数据中出现的顺序连接观测值(如果画函数图,推荐此映射,原因后面知晓)。\ngeom_line()按变量在x轴上的顺序连接它们。\n\nlibrary(ggplot2)\n\n# 定义函数\nsigmoid <- function(x) 1/(1+exp(-x))\n\n# 创建数据点\nx<-seq(-5, 5, by=0.01)\ny<-sigmoid(x)\ndf<-data.frame(x, y)\n\n# 用ggplot2来画图\ng <- ggplot(df, aes(x,y))\ng <- g + geom_path(col='red') ## 用geom_line 替代也是可以的,但不推荐\ng <- g + geom_hline(yintercept = 0.5) + geom_vline(xintercept = 0) #坐标轴\ng <- g +  labs(title=\"sigmoid\", x=\"x\", y=\"y\")\ng <- g +theme(plot.title = element_text(hjust = 0.5))  #标题居中\ng"
  },
  {
    "objectID": "posts/md/画函数图像R语言.html#函数图像具有参数方程",
    "href": "posts/md/画函数图像R语言.html#函数图像具有参数方程",
    "title": "画函数图像–R语言",
    "section": "2. 函数图像具有参数方程",
    "text": "2. 函数图像具有参数方程\n例如: 圆, 椭圆, 抛物线, 双曲线 方程.\n\n2.1 画\\(x^2+y^2 = 4\\)的函数图像\n这里我们只以ggplot2为例,\n思路一: 可以利用分段函数的思想画,先把原函数解出显示的表达式 \\(y = -\\sqrt{4-x}\\) 或者\\(y = \\sqrt{4-x}\\), 然后分段画, 这里不讲解\n思路二: 像上面这些函数,都能表示成参数方程的形式, 利用参数方程来画该函数图像\n首先写出圆的参数方程一般形式:\n\\[\n\\begin{cases}\nx = rcos\\theta,\\\\\ny = rsin\\theta\n\\end{cases}\n\\]\nlibrary(ggplot2)\nr = 2\ntheta=seq(0, 2*pi, by=0.001)\nx = r*cos(theta)\ny = r*sin(theta) \ndf <- data.frame(x, y, theta,frame = 1:length(theta))\ng <- ggplot(df, aes(x,y))\ng <- g + geom_path(col='red')\ng\n\n###################\n####让上面的图动起来\nlibrary(gganimate)\nlibrary(transformr)\ntemp = g + transition_reveal(along = frame)\n\nanimate(temp,\n        nframes=100,#总帧数(默认)\n        duration=10 #总时长，单位为秒，默认为10秒\n        )\n\n\n\n2.2 椭圆\n椭圆的参数方程\n\\[\n\\begin{cases}\nx = acos\\theta,\\\\\ny = bsin\\theta\n\\end{cases}\n\\]\nlibrary(ggplot2)\na = 2\nb = 3\ntheta=seq(0, 2*pi, by=0.001)\nx = a*cos(theta)\ny = b*sin(theta) \ndf <- data.frame(x, y, theta,frame = 1:length(theta))\ng <- ggplot(df, aes(x,y))\ng <- g + geom_path(col='red')\n## 让图动起来\ntemp = g + transition_reveal(along = frame)\n\nanimate(temp)\n\n\n\n2.3 抛物线\n抛物线参数方程\n\\[\n\\begin{cases}\nx = 2pt^2, \\\\\ny = 2pt\n\\end{cases} (t为参数, t \\in R)\n\\]\np = 4\nt = seq(3,-3,-0.2)\nx = 2*p*t^2\ny = 2*p*t \ndf <- data.frame(x, y, t,frame = 1:length(t))\ng <- ggplot(df, aes(x,y))\ng <- g + geom_path(col='red')\n## 让图动起来\ntemp = g + transition_reveal(along = frame)\n\nanimate(temp)\n\n\n\n2.4 双曲线\n在ggplot中没有找到好的画法\na = 3\nb = 1\ntheta=round(seq(0,2*pi,0.2),2)\n\nx = a/cos(theta)\ny = b*tan(theta) \ndf <- data.frame(x, y, theta,frame = 1:length(theta))\ng <- ggplot(df, aes(x,y))\ng <- g + geom_path(col='red')\ng\n\n# 以分段的思想来画双曲线\n\n\nx <- seq(1,3,length = 100)\ny1 <- sqrt(x^2 - 1);y2 <- -sqrt(x^2 - 1)\n\nxx1 = c(rev(x),x); yy1 = c(rev(y2),y1)\n\nxx2 = c(rev(-x),-x);yy2 = c(rev(y2),y1)\n\ndf <- data.frame(xx1,yy1,xx2,yy2, frame = 1:length(xx1))\ng <- ggplot(df) + geom_path(aes(xx1,yy1),col='red') \ng <- g + geom_path(aes(xx2,yy2),col='blue')\ng \n\ntemp = g + transition_reveal(along = frame)\n\nanimate(temp)\n\n\n\n2.4 Lissajous 曲线(利萨如曲线)\n参数方程:\n\\[\n\\begin{cases}\nx = asin(p\\theta),\\\\\ny = 2sin(q\\theta+\\varphi)\n\\end{cases}\n\\]\na = 1\nb = 1\nphi = 0\np = 1\nq = 2\nt = seq(0, 2 * pi, by = 0.001)\nx = a * sin(p * t)\ny = b * sin(q * t + phi)\ndf <- data.frame(x, y, t, frame = 1:length(x))\ng <- ggplot(df, aes(x, y))\ng <- g + geom_path(col = 'red')\n\ntemp = g + transition_reveal(along = frame)\n\nanimate(temp)\n\na = 3\nb = 12\nphi = 0\np = 13\nq = 18\nt = seq(0, 2 * pi, by = 0.001)\nx = a * sin(p * t)\ny = b * sin(q * t + phi)\ndf <- data.frame(x, y, t, frame = 1:length(t))\ng <- ggplot(df, aes(x, y))\ng <- g + geom_path(col = 'red')\ng\n\ntemp = g + transition_reveal(along = frame)\n\nanimate(temp)"
  },
  {
    "objectID": "posts/md/画函数图像R语言.html#隐函数",
    "href": "posts/md/画函数图像R语言.html#隐函数",
    "title": "画函数图像–R语言",
    "section": "3 .隐函数",
    "text": "3 .隐函数\n这个暂时不知道, 且不常见,建议找MATLAB这种专业软件画或者ggb也行."
  },
  {
    "objectID": "posts/md/latex笔记.html",
    "href": "posts/md/latex笔记.html",
    "title": "latex 笔记",
    "section": "",
    "text": "\\eqref{eq:eq1}   :交叉引用公式编号自动带括号:"
  },
  {
    "objectID": "posts/md/latex笔记.html#完整模板解析",
    "href": "posts/md/latex笔记.html#完整模板解析",
    "title": "latex 笔记",
    "section": "2, 完整模板解析",
    "text": "2, 完整模板解析\n\\documentclass[review]{elsarticle}\n\n%\\usepackage{ctex}\n\\usepackage{lineno, hyperref}\n\\hypersetup{colorlinks=true, citecolor=blue, anchorcolor=blue}\n\n\n\\modulolinenumbers[5]\n\n%\\usepackage[colorlinks, linkcolor=blue, anchorcolor=blue, citecolor=blue]{hyperref}\n\n\\usepackage{amsmath}\n\\usepackage{amssymb}\n\\usepackage{amsthm}\n\n\\usepackage[american]{babel} % 具有多语种处理功能的宏包,英文为默认文字,和microtype包一起使用,用于页面两端对齐\n\\usepackage{microtype} % 用于页面两端对齐\n\n\\usepackage{graphicx} % 插图包 ---  \\includegraphics[height=高度][angle=旋转角度]{图片文件名}\n\\usepackage{multirow} % 处理表格 --列合并用”\\multicolumn“，行合并用。\\multirow{2}{*}{显示的文本}\n% 引用 ---  \\multirow 函数/标志符： {占用行数} {方框边界竖线|文字居左中右|方框边界竖线} {内容}\n% 引用 --- \\multicolumn 函数/标志符： {占用列数} {方框边界竖线|文字居左中右|方框边界竖线} {内容}\n\n\\usepackage{indentfirst} %段首缩进需要的宏包 \n\\setlength{\\parindent}{2em}%设置段首缩进两个汉字 %\\noindent强制不缩进\n% \\setlength{\\parskip}{1em}%paragraph skip,调整的是段落间距离\n\n%\\usepackage{lscape} % 表格横置, 只需要引用 landscape 环境即可\n%\\usepackage{pdflscape} % 页面横置,只需引用landscape环境即可\n%\\usepackage[figuresright]{rotating} % 将表格旋转为纵向放置，使用rotating宏包 % 要使用 sidewaystable 环境\n%\\usepackage{natbib}\\usepackage[authoryear]{natbib}\n\n\\usepackage{enumerate} % enumerate 宏包 ,可以给有序列表设置 label,以及有缩进\n%\\usepackage{enumitem} % 可以给出缩进调整间距, label\n%\\usepackage{showkeys} % 引用时显示引用的 label\n%\\usepackage{paralist} % 列表相互嵌套是的缩进 ,也可以给出相应 label ,但是 label 和缩进都要设置\n\n\n%%%%%%  交叉引用 开始%%%%%%%\n%% 第一部分 自定义新环境,\n\\theoremstyle{definition} %自定义环境内的风格,比如字体是否为斜体,等等,这里采用的是正体\n\\newtheorem{thm}{Theorem}\n\\newtheorem{cor}{Corollary}\n\\newtheorem{lem}{Lemma}\n\\newtheorem{pot}{\\bf Proof}\n\\newtheorem{rmk}{Definition}\n\\newtheorem{pro}{Property}\n\\newtheorem{example}{Example}\n%\\newtheorem{exmp}{Example}\n\n%% 第二部分 ,如果想要在引用时,自动添加definition,Theorem等字样,使用下面这部分\n\\usepackage[capitalize, nameinlink]{cleveref} %交叉应用 在数字前自动添加某些字符; 引用时 用\\cref{}的形式\n\\crefname{thm}{Theorem}{Theorems}\n%\\crefname{cor}{Corollary}{Corollarys}\n\\crefname{lem}{Lemma}{Lemmas}\n\\crefname{pot}{Proof} {Proofs} \n\\crefname{rmk}{Definition}{Definitions} \n\\crefname{pro}{Property}{Propertys}\n\\crefname{example}{Example}{Examples} \n\\crefname{figure}{Figure}{Figures} % 图片以及表格有默认的,但是也可以重新定义\n% \\DeclareUnicodeCharacter{0301}{\\'{e}} %pdflatex 需要用到 UTF-8 字符时，需要此命令\n\n%%%%%%  交叉引用结束 %%%%%%%\n\n\\journal{European Journal of Operational Research}\n\n\n% 参考文献的引用样式,可以去网上找各大期刊的模板\n\\bibliographystyle{elsarticle-harv}\\biboptions{authoryear}\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%一下为正文部分\n\\begin{document}\n\\section{Introduction}\n\n\\section{Preliminaries}\n\\section*{Acknowledgements} \n\n\\setcitestyle{numbers}\n\\bibliography{references} % 这里引用的 bibtex 参考文献\n\\end{document}\n注释:\n对自定义环境格式的设置\n\\theoremstyle{definition} %环境内的风格,比如字体是否为斜体,等等,这里采用的是正体\n%\\theoremstyle{plain} is the default. it sets the text in italic and adds extra space above and below the \\newtheorems listed below it in the input. it is recommended for theorems, corollaries, lemmas, propositions, conjectures, criteria, and (possibly; depends on the subject area) algorithms.\n%\\theoremstyle{plain} 是默认值。它将文本设置为斜体，并在输入的\\\\newTheorem的上方和下方添加额外的空间。建议用于定理、推论、引理、命题、猜想、标准和（可能；取决于主题区域）算法。\n\n%\\theoremstyle{definition} adds extra space above and below, but sets the text in roman. it is recommended for definitions, conditions, problems, and examples; i've alse seen it used for exercises.\n%\\theoremstyle{definition} 在上方和下方添加额外的空格，但将文本设置为罗马文本。建议用于定义、条件、问题和示例；我也见过它用于练习。\n\n%\\theoremstyle{remark} is set in roman, with no additional space above or below. it is recommended for remarks, notes, notation, claims, summaries, acknowledgments, cases, and conclusions.\n%\\theoremstyle{remark} 设置为罗马，上面或下面没有额外的空间。建议用于备注、注释、注释、索赔、总结、确认、案例和结论。\n2， 参考文献尽量使用*.bib的格式 ，这样方便管理，然后使用 jabref软件进行 *.bib 文件格式的管理\n3， bib文件可以用Google学术生成导出bibtex格式文件\n4， 参考文献 – 使用作者加年份排版 如下：（同时使用）,一般去网上找对应期刊的 bst 文件模板即可\n\\usepackage{natbib} %参考文献 \n\\setcitestyle{authoryear,round,comma,aysep={;},yysep={,},notesep={, }}\n\\usepackage{hyperref} %为了更加好看可以设置超链接颜色,首先要确保引用的包不能冲突，\n\\hypersetup{colorlinks=true,citecolor=blue} %设置超链接颜色\n特别注意::: 有些模板以及引用了相关的包，这样会造成相应包的冲突，可以尝试：\n1、 先不引用这个包以及相关设置，检查能否运行 –能进行下一步\n2、 利用这个包的相关参数进行修改，看能否达到自己的目的\nzscdeMacBook-Air.local\n如果以上还是出现包的冲突，则仔细检查\n注意：：：\n%\\bibliographystyle{elsarticle-num} \n% 不能与  \\setcitestyle{authoryear,round,comma,aysep={;},yysep={,},notesep={, }}同时使用\n5、 参考文献的使用\n文章开始前：{document}前\n\\bibliographystyle{elsarticle-num}  % 使用模板自带的参考文献格式\n% \\bibliographystyle{plainnat} % 包自带的格式\n% \\setcitestyle{authoryear,round,comma,aysep={;},yysep={,},notesep={, }} % 简单的自定义格式 \n%%注意以上三种不能冲突使用，只能择其一\n文章结尾：使用 即可\n\n\\section*{References}\n%%%%\\setcitestyle{numbers} % 注意这里只是 修改参考文献的样式\n\\bibliography{references} % references.bib文件。即参考文献\n\\end{document}\n6、现在很多文章的定理、定义、推论、例子都采用统一编号，不再是独立编号。如定义 1.1，接下来可能 是定理 1.2，然后推论 1.3，等等。这可以用如下的定义来完成:\n \\newtheorem{thm}{Theorem}[section] %如果不采用章节号做前缀，则不用[section] \n \n \\newtheorem{defn}[thm]{Definition} %这句定义使得defn环境和thm共享编号 \n \n \\newtheorem{lem}[thm]{Lemma} %这句定义使得lem环境和thm共享编号\n \n\\newtheorem{thm}{Theorem}\n\\newtheorem{cor}{Corollary}\n\\newtheorem{lem}{Lemma}\n\\newtheorem{pot}{\\bf Proof}\n\\newtheorem{rmk}{Definition}\n\\newtheorem{pro}{Property}\n7、公式环境的区别\n公式环境的区别： 参考latex入门(刘海洋)\n\ngather 环境得到的公式每行居中\nalign环境允许按照等号或其他关系（只需要在关系符号前加 & ）对齐\n\n\n组合公式快环境\ncases 环境太特殊( 不推荐)\ngathered  组合公式与要组合的公式 居中排列组合一个整体\naligned   类似align\nalignedat\n8 enumerate 编号缩进问题, 直接使用空格\n\\begin{enumerate}[\\hspace{2em} 1). ]\n    \\item $A^*$ also is RC matrix.\n\n    \\item every row of matrix $A^*$ is arranged in ascending order.\n\n    \\item every column of matrix $A^*$ is arranged in descending order.\n\\end{enumerate}"
  },
  {
    "objectID": "posts/md/发邮件mailR包.html",
    "href": "posts/md/发邮件mailR包.html",
    "title": "R语言发邮件–mailR包",
    "section": "",
    "text": "亲测试邮箱为163邮箱 和QQ邮箱"
  },
  {
    "objectID": "posts/md/发邮件mailR包.html#mailr-包参数",
    "href": "posts/md/发邮件mailR包.html#mailr-包参数",
    "title": "R语言发邮件–mailR包",
    "section": "mailR 包参数",
    "text": "mailR 包参数\nmailR 包中只有一个接口函数—send.mail ,该包依恋java环境，请首先配置该环境，下面是该函数的一些基本参数：\nsend.mail(from, to, subject = \"\", body = \"\", encoding = \"iso-8859-1\",\n  html = FALSE, inline = FALSE, smtp = list(), authenticate = FALSE,\n  send = TRUE, attach.files = NULL, debug = FALSE, ...)\n\n\n\n参数\n说明\n\n\n\n\nfrom\n发件人邮箱\n\n\nto\n收件人邮箱\n\n\nsubject\n邮件标题\n\n\nbody\n邮件的内容(正文),内容可以是文本也可以是html网页格式\n\n\nhtml\n一个bool值，是否应该讲邮箱正文解析为HTML\n\n\ninline\n一个bool值，HTML文件中的图像是否应该被嵌入\n\n\nsmtp\n重要的参数，设置服务器参数用的\n\n\nauthenticate\n是否应该使用smtp中的参数\n\n\nattach.files\n指定相应的附件，若是多个则用字符向量表示\n\n\nfile.names\n（省略参数），对相应的附件进行重命名\n\n\ndebug\n你是否要查看详细的调试信息"
  },
  {
    "objectID": "posts/md/发邮件mailR包.html#邮箱",
    "href": "posts/md/发邮件mailR包.html#邮箱",
    "title": "R语言发邮件–mailR包",
    "section": "163 邮箱:",
    "text": "163 邮箱:\n如果发送频率过快，容易被封号，暂时发布出去了，只有等解封以后再发,\n注意： 在测试的时候，尽量写的和平时邮件一样的格式，不然会被认为是垃圾邮件\nlibrary(mailR)\nsender <- \"********@163.com\"  # 发件人\nrecipients <- c(\"******@qq.com\") # 收件人，可以多个\nsend.mail(from = sender,\n          to = recipients,\n          subject = \"Program Done.\",\n          body = \"My program is finished.\",\n          smtp = list( \n            host.name = \"smtp.163.com\",  # 163邮箱的服务器地址\n            port = 465,\n            user.name = \"********@163.com\",\n            passwd = \"*********\", # 这个是授权码而非密码\n            ssl = TRUE,\n            tls =TRUE), \n          encoding = \"utf-8\",\n          authenticate = TRUE,\n          send = TRUE)\n报错：其中的信息：（表示发送的邮件过多）\nCaused by: com.sun.mail.smtp.SMTPSendFailedException: 554 DT:SPM 163 smtp2,DNGowAA3E32d1ONbg+8oAA--.78S2 1541657766,please see http://mail.163.com/help/help_spam_16.htm?ip=182.88.95.17&hostid=smtp2&time=1541657766"
  },
  {
    "objectID": "posts/md/发邮件mailR包.html#qq-邮箱",
    "href": "posts/md/发邮件mailR包.html#qq-邮箱",
    "title": "R语言发邮件–mailR包",
    "section": "QQ 邮箱:",
    "text": "QQ 邮箱:\nQQ邮箱好像不存在发多了被封号的问题，我猜如果发到一定量，也应该会出现上述问题吧\nsender <- \"******@qq.com\"\nrecipients <- c(\"*******@163.com\",\"*******@qq.com\") \nsend.mail(from = sender,\n          to = recipients,\n          subject = \"你好！我的朋友\",\n          body = \"第一次用程序写邮件!!哈哈\",\n          smtp = list(\n            host.name = \"smtp.qq.com\", ## QQ邮箱的服务器地址\n            port = 465,\n            user.name = \"********@qq.com\",\n            passwd = \"*********\", ## 这个是授权码而非密码\n            ssl = TRUE), \n          encoding = \"utf-8\",\n          authenticate = TRUE,\n          attach.files =c(\"./bbbb.xlsx\",\"01_hellworld.cpp\"), #附件\n          file.names = c(\"aaa\",\"bbb\"), # 对附件进行重命名\n          file.descriptions = c( \"xlsx 文件\",\"c++文件作业\"),# 附件的说明\n          send = TRUE)"
  },
  {
    "objectID": "posts/md/RSelenium.html",
    "href": "posts/md/RSelenium.html",
    "title": "利用RSelenium包模拟浏览器爬取网页信息",
    "section": "",
    "text": "现在很多网页都采用AJAX这种异步加载的网页结构，简单的页面爬取不了这些数据\n例如：\n2、这是需要R包—RSelenium包\n使用RSelenium包的准备\n0、JAVA 环境的准备 ，安装是否成功可以进行xlsx包进行测试\n1、Chrome驱动 下载,注意chrome驱动一定要和chrome浏览器对应 ,比如我的浏览器 65.0.3325.181 ，对应表放在文章最后,或者点击这里,,怎么查看浏览器版本，点击谷歌浏览器右上【…】—【帮助】–【关于Google Chrome】就可以看到浏览器版本了。\n2、Selenium Standalone Server下载 我用的是 selenium-server-standalone-3.11.0.jar\n3、PhantomJS下载 ,无头浏览器。(这个个人需要的话就下载，我用Google浏览器就够了)"
  },
  {
    "objectID": "posts/md/RSelenium.html#安装流程",
    "href": "posts/md/RSelenium.html#安装流程",
    "title": "利用RSelenium包模拟浏览器爬取网页信息",
    "section": "2、安装流程：",
    "text": "2、安装流程：\n\n使用前的基本配置\n\n首先，安装JAVA JDK 1.8。\n然后，安装Chrome（最新版本）。\n之后，把解压后的ChromeDriver.exe（最新版本）放在Chrome的安装路径下。一定要和chrome.exe放在同一个目录下面。例如\n把chromedriver.exe所在目录的路径(建议放在和chrome.exe)放入环境变量中即可,\n基本配置基本完成"
  },
  {
    "objectID": "posts/md/RSelenium.html#rselenium使用与实例",
    "href": "posts/md/RSelenium.html#rselenium使用与实例",
    "title": "利用RSelenium包模拟浏览器爬取网页信息",
    "section": "3、RSelenium使用与实例",
    "text": "3、RSelenium使用与实例\n\n3.1、使用前的基础步骤\n1、首先 ，打开cmd ，切换到 selenium-server-standalone-3.0.1.jar文件所在的位置，我的都在C:，切换以后 ，运行\njava -jar selenium-server-standalone-3.11.0.jar\n显示 ：\n\n\n\npeizhi1\n\n\n或者直接在Rstudio中运行system('java -jar \"C:/RSelenium/selenium-server-standalone-3.11.0.jar\"',wait = FALSE)代码即可。\n2、运行后，最小化，不要关闭，在打开Rstudio,\n3、通过R调用Selenium Server并打开网页，对页面进行点击，选取相应条件。通过RSelenium与rvest共同爬取数据。通过 一步一步解读Rcode来解释这一过程。\n\n\n3.2、案例1\n浏览器的基本操作\nlibrary(RSelenium)\nlibrary(stringr)\nsetwd(\"C:\\\\RSelenium\")\n\n\n######## 初始化浏览器####\nremDr <- remoteDriver(\n  browserName = \"chrome\",  # 浏览器可以自己设置firefox、chrome、phantomjs（要配置）\n  remoteServerAddr = \"localhost\",\n  port = 4444L)\n\nremDr$open() # 打开浏览器 \n\nremDr$getStatus()# 使用该status方法查询远程服务器的状态。\n# 关闭浏览器  \n# remDr$quit()  # 直接退出  \n# remDr$close()  # close用于关闭当前会话，也可以用作关闭浏览器  \n访问DOM中的元素 \nurl=\"https://www.baidu.com/\"\nremDr$navigate(url)   # 打开网页\n# remDr$closeWindow() # 关闭网页 \n# remDr$goBack() # 页面返回操作, 页面返回，前进操作，一定要有浏览记录才有这个操作\n# remDr$goForward() # 页面前进操作\n# remDr$refresh() # 页面刷新\n\n######################################################################################\n################################# 定位元素\n# # 可以看出百度首页上有一个查询框,对应源代码为<input id=...class=... name= ...</input>\n# # 对应<input id=\"kw\" name=\"wd\" class=\"s_ipt\" value=\"\" maxlength=\"255\" autocomplete=\"off\">\n\n########## 按属性--属性值搜索\nwebElem <- remDr$findElement(using = 'name', value = \"wd\") # 添上对应属性与属性值\n########## 按id--id值搜索\nwebElem <- remDr$findElement(using = 'id', value = \"kw\")\n########## 按class--class值搜索\nwebElem <- remDr$findElement(using = 'class', value = \"s_ipt\")\n########## 按css选择器进行搜索\nwebElem <- remDr$findElement(using = 'css', \"#kw\") #css选择器id用#  ，class用.\nwebElem <- remDr$findElement(using = 'css', \".s_ipt\") \n########## 按xpath进行搜索\nwebElem <- remDr$findElement(using = 'xpath', \"//*[@id='kw']\") \nwebElem <- remDr$findElement(using = 'xpath', \"//*[@class='s_ipt']\") \n\n\n#####################################################################################\n###################上面找了这么多元素，拿来干嘛呢-----可以发送事件给元素\n#####################################################################################\nurl <- 'http://www.baidu.com'  \nremDr$navigate(url)  \n############################### 单击操作\n#### 单击操作---方法一\nwebElem <- remDr$findElement(using = 'xpath', value = '//*[@id=\"su\"]')  \nremDr$mouseMoveToLocation(webElement = webElem)  # 移动鼠标至该元素 \nremDr$click() # 单击  \n#### 单击操作---方法二\nwebElem <- remDr$findElement(using = 'xpath', value = '//*[@id=\"su\"]')  \nwebElem$clickElement() # 单击  \n\n\n################################## 进行搜索关键词\nwebElem <- remDr$findElement(using = 'css', \"#kw\") # 找到这个元素--进行搜索关键词\nwebElem$sendKeysToElement(list(\"京东\",key=\"enter\"))\n#### 提取搜索后页面的所有标题，每个链接的标题都包含在<h3 class = \"t\">标签中.\nwebElems <- remDr$findElements(using = 'css', \"h3.t\")##注意 findElement(s)方法的区别\nresHeaders <- unlist(lapply(webElems, function(x){x$getElementText()})) #\nresHeaders# 获取网页搜索后的标题\np=which(resHeaders ==resHeaders[1])# 可以看出有名字重复的标签\nwebElem=webElems[[min(p)]]# 找到对应的标题\nwebElem$clickElement() ######  并对标题进行鼠标点击\n\n\n###############################################\nremDr$getCurrentUrl() ##获取当前url\nremDr$getTitle() #当前页面的title\nwebpage=remDr$getPageSource()[[1]][1] #获取当前页面 渲染以后的源代码\n\n# ########################\n# ### 保存为本地文件\n# con=file(\"test.html\",encoding = \"utf-8\")\n# writeLines(webpage,con)\n# close(con)\n# ##########################\n\n窗口页面切换\n许多时候我们点链接的时候，会打开新的标签页 selenium 则会保持在原来的页面上，这是我们便需要切换页面\nremDr$getCurrentUrl()# 获取当前窗口页面的url\nremDr$getCurrentWindowHandle()# 查看当前属于哪个窗口页面\nremDr$getTitle()# 当前窗口页面的标题\nremDr$getWindowHandles() # 获取当前浏览器所有的窗口页面\n## 现在进行页面跳转\nremDr$getWindowHandles()[[2]] %>% remDr$switchToWindow()\n上面展示了从第一个标签页切换到第二个标签页的\nframe 切换\n现在流行组件式开发。反正就是 HTML 嵌套 HTML，明明选对元素，但是结果就是不对。这是便需要切换到对应的 frame 中。\n# 如果 Frame 有 id\nremDr$switchToFrame(\"id\")\n# 没有 id ，需要自己定位，css xpath... 都行\nremDr$switchToFrame(remDr$findElement(using = \"css\",value = \"\"))\n# 多层的话，就层层切\n# 返回到原来的位置\nremDr$switchToFrame(NULL)\n注入JavaScript \n##########输入URL 并打开这个网页##############\nurl=\"http://www.cpppc.org:8082/efmisweb/ppp/projectLibrary/toPPPList.do\"\nremDr$navigate(url)  # 打开网页\nwebpage=remDr$getPageSource()[[1]][1] #获取当前页面 渲染以后的源代码\n\n################# 页面拉到最下面 --JavaScript脚本\nscripts <- \"window.scrollTo(0,document.body.scrollHeight)\"  \nremDr$executeScript(script = scripts,args = list(\"dummy\"))\nSys.sleep(3)\n\n\n#######################################\n# ###  模拟点击下一页按钮--css选择器 或者 xpath---JavaScript\n####################################\n# ### 方法一---css\n# nextBtn <- remDr$findElement(using = 'css selector',\n#                              value = \".pag > a:nth-child(7)\")\n# nextBtn$clickElement()# 点击元素\n\n# ### 方法二 ---xpath\n# nextBtn <- remDr$findElement(using = 'xpath',\n#                              value = \"/html/body/div[3]/div/div[3]/div[2]/div/a[3]\")\n# nextBtn$clickElement()# 点击元素\n\n# ### 方法三 --JavaScript\nnextpage=\"getNextPage();\"  ####  可用str_c()字符串拼接而成\nremDr$executeScript(nextpage,args = list(\"dummy\"))\n####################################\nwebpage=remDr$getPageSource()[[1]][1] #获取当前页面 渲染以后的源代码\n\n###########################\n##### 结合rvest包解析元素####\n##########################\nlibrary(rvest)\nweb_page=read_html(remDr$getPageSource()[[1]][1])\n\n\n3.3、案例2\n备注 ：有些网页 点击下一页会报错 ，这时候需要最大化窗口：\n#####  航班信息网站\nurl=\"http://www.umetrip.com/mskyweb/fs/fa.do?dep=CTU&arr=PEK&date=2018-04-04&channel=\"\nremDr$navigate(url)  # 打开网页\n\n################# 页面拉到最下面 --JavaScript脚本\nscripts <- \"window.scrollTo(0,document.body.scrollHeight)\"\nremDr$executeScript(script = scripts,args = list(\"dummy\"))\nSys.sleep(3)\n\n#################################################\n##### 找到下一页按钮点击它,有时点击下一页会报错，这时候需要最大化窗口后单击下一页：\n######  最大化窗口页面-\nremDr$maxWindowSize()## 最大化窗口页面-\nnextBtn <- remDr$findElement(using=\"id\",value = \"p_next\")\nnextBtn$clickElement()\n\n#################\n\n\n3.4、案例3\n截屏 按钮 ：\n截图使用screenshot(display = FALSE, useViewer = TRUE, file = NULL)函数,\n\ndisplay：是否在控制台显示\nfile：截图后存放的路径，截的图像是PNG格式。\n\nremDr$screenshot(display = F,file=\"aa.png\")\n\n\n3.5、案例4\n微博登录 —自己输入-这个可以人为干预，Selenium可以记录后台的所有操作\nurl=\"https://weibo.com/\"\nremDr$navigate(url)  # 打开网页\n\n## 这里，返回浏览器，输入用户名和密码以及验证码\nremDr$getCurrentUrl() #返回当前页面的url\n\n## 搜索关键词\ninput <- remDr$findElement(using = \"class\",value = \"W_input\")\ninput$sendKeysToElement(list(\"中国R语言会议\",key=\"enter\"))\n上述代码参考雪晴数据网的课程用RSelenium打造灵活强大的网络爬虫\n参考：http://ropensci.github.io/RSelenium/articles/RSelenium-basics.html\n\nchromedriver与chrome的对应关系表:\n\n\n\nchromedriver版本\n支持的Chrome版本\n\n\n\n\nv2.37\nv64-66\n\n\nv2.36\nv63-65\n\n\nv2.35\nv62-64\n\n\nv2.34\nv61-63\n\n\nv2.33\nv60-62\n\n\nv2.32\nv59-61\n\n\nv2.31\nv58-60\n\n\nv2.30\nv58-60\n\n\nv2.29\nv56-58\n\n\nv2.28\nv55-57\n\n\nv2.27\nv54-56\n\n\nv2.26\nv53-55\n\n\nv2.25\nv53-55\n\n\nv2.24\nv52-54\n\n\nv2.23\nv51-53\n\n\nv2.22\nv49-52\n\n\nv2.21\nv46-50\n\n\nv2.20\nv43-48\n\n\nv2.19\nv43-47\n\n\nv2.18\nv43-46\n\n\nv2.17\nv42-43\n\n\nv2.13\nv42-45\n\n\nv2.15\nv40-43\n\n\nv2.14\nv39-42\n\n\nv2.13\nv38-41\n\n\nv2.12\nv36-40\n\n\nv2.11\nv36-40\n\n\nv2.10\nv33-36\n\n\nv2.9\nv31-34\n\n\nv2.8\nv30-33\n\n\nv2.7\nv30-33\n\n\nv2.6\nv29-32\n\n\nv2.5\nv29-32\n\n\nv2.4\nv29-32"
  },
  {
    "objectID": "posts/md/matlab优化工具02非线性规划之fmincon.html",
    "href": "posts/md/matlab优化工具02非线性规划之fmincon.html",
    "title": "matlab优化工具02非线性规划之fmincon",
    "section": "",
    "text": "由于经常用到一些matlab中基本的优化函数, 于是写一个笔记, 由于新版本的文档和以前版本的文档有点不一样, 搞得查起来有点费劲, 不过推荐新版本的文档\n\n\n\\[\n\\begin{aligned}\n& \\min \\quad  f(x) \\\\\n& \\text {s.t.} \\begin{cases}\n\\textbf{A} \\cdot x \\leq b \\\\\n\\textbf{Aeq} \\cdot x=beq \\\\\nc(x) \\leq 0 \\\\\n\\operatorname{ceq}(x)=0 \\\\\nl b \\leq x \\leq u b\n\\end{cases}\n\\end{aligned}\n\\]\n其中 \\(f(x)\\)是目标函数, \\(x, b, beq\\) 是向量, \\(\\textbf{A}, \\textbf{Aeq}\\)是矩阵,\\(c(x)\\) 和 \\(ceq(x)\\) 是向量函數, \\(\\textbf{A}\\)线性不等式,\\(\\textbf{Aeq}\\)线性等式, \\(c(x)\\) 非线性不等式, \\(ceq(x)\\)非线性等式\n% 2.基本语法\n[x,fval] = fmincon(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon,options)\n[x,fval,exitflag,output,lambda,grad,hessian] = fmincon(___)\n%% 等号左边参数解释\nx 的返回值是决策向量x的取值，fval 的返回值是目标函数f(x)的取值\nexitflag 参数，描述函数计算的退出条件\noutput, 输出模型的优化信息参数\nlambda, 返回解x处包含拉格朗日乘子的lambda参数\ngrad, 返回解x处fun函数的梯度值\nhessian, 返回解x处fun函数的hessian矩阵\n\n%% 等号右边参数解释\nfun是用M文件定义的函数f(x),代表了(非)线性目标函数, 对于复杂问题, 建议写出目标函数以及非线性约束的梯度\nx0是x的初始值\nA,b,Aeq,beq定义了线性约束 ,如果没有线性约束，则A=[],b=[],Aeq=[],beq=[]\nlb和ub是变量x的下界和上界，如果下界和上界没有约束，则lb=[],ub=[],也可以写成lb的各分量都为 -inf, ub的各分量都为inf\nnonlcon是用M文件定义的非线性向量函数约束,如果没有则写[]\noptions定义了优化参数，不填写表示使用Matlab默认的参数设置\neg:\noptions = optimoptions('fmincon','Display','iter','Algorithm','sqp');\noptions = optimoptions('fmincon','SpecifyObjectiveGradient',true);\noptions = optimoptions('fmincon','Display','iter','PlotFcn','optimplotfval');\n\n\n\n\n\n\n\n\noptions 常见取值\n说明\n\n\n\n\nAlgorithm\n优化算法: 'interior-point' (default)'trust-region-reflective''sqp''sqp-legacy' (optimoptions only)'active-set'\n\n\nDisplay\n如果设置为 off 即不显示输出;设置为 iter 即显示每一次的迭代信息;设置为 final 只显示最终结果\n\n\nFinDiffType\n变量有限差分梯度的类型。取 ‘forward’日才即为向前差分，其为默认值;取 ’central’ 时为中心差分，其精度更精确\n\n\nFunValCheck\n检查目标函数与约束是否都有效。当设置为 on 时，遇到复数、 NaN、Inf 等，即显示 出错信息;当设置为 off时，不显示出错信息，其为默认值\n\n\nGradConstr\n用户定义的非线性约束函数。当设置为 on 时，返回 4 个输出;设置为 off 时.即为非线性约束的梯度估计有限差\n\n\nGradObj\n用户定义的目标函数梯度。对于大规模问题为必选项，对中小规模问题为可选项\n\n\nMaxFunEvals\n函数评价所允许的最大次数\n\n\nMaxlter\n函数所允许的最大迭代次数\n\n\nOutputFcn\n在每次迭代中指定一个或多个用户定义的口标优化函数,The default is none ( [ ] ).\n\n\nPlotFcn\n算法执行时,绘制各种度量值,默认[];‘optimplotx’ 画当前点‘optimplotfunccount’ 画函数计数‘optimplotfval’ 绘制函数值‘optimplotfvalconstr’ 以直线的形式绘制最佳可行目标函数值。该图显示不可行点为红色，可行点为蓝色，可行性公差为1e-6。‘optimplotconstruplication’ 绘制最大约束冲突‘optimplotstepsize’ 画步长‘optimplotfirstorderopt’ 绘制一阶最优性度量\n\n\nFunctionTolerance\n函数值的容忍度.默认值为 le-6\n\n\nConstraintTolerance\n目标函数的约束性.默认值为 le-6\n\n\nUseParallel\n是否并行计算\n\n\n\n\n\n\nimage-20210515121746768\n\n\n\n\n\nimage-20210515121800630\n\n\n\n\n\nimage-20210515121820017\n\n\n\n\n\n\\[\n\\begin{aligned}\n& \\min f(x) = x_{1}^{2}+x_{2}^{2}+x_{3}^{2}+8 \\\\\n& \\text { s. t. }\\begin{cases}\nx_{1}^{2}-x_{2}+x_{3}^{2} \\geq 0 \\\\\nx_{1}+x_{2}^{2}+x_{3}^{2} \\leq 20 \\\\\n-x_{1}-x_{2}^{2}+2=0 \\\\\nx_{2}+2 x_{3}^{2}=3 \\\\\nx_{1}, x_{2}, x_{3} \\geq 0\n\\end{cases}\n\\end{aligned}\n\\]\nclc, clear all\nx0 = rand(3, 1);  % 初始值\nAeq = [];               % 线性等式约束的系数（左边的系数）\nbeq = [];                % 线性等式约束的值 （右边的值）\n%A = [];                % 线性不等式约束的系数\n%b = [];                % 线性等式约束的值,(列向量)\nub = [];      % 变量的上限（取等号）\nlb = repelem(0, 3);      % 变量的下限（取等号）\n% 方法一: 用句柄函数调用\n[x, y] = fmincon(@myobjfun, x0, [], [], Aeq, beq, lb, ub, @constrain)\n% 方法二: 用如下形式调用\n[x1, y1] = fmincon('myobjfun', x0, [], [], Aeq, beq, lb, ub, 'constrain')\n\n\n\n%% 目标函数\nfunction f = myobjfun(x)\nf=x(1).^2+x(2).^2+x(3).^2+8;\nend\n\n%% 非线性约束条件\nfunction [c,ceq]=constrain(x)\nc=[-x(1).^2+x(2)-x(3).^2\n    x(1)+x(2).^2+x(3).^3-20]; % 非线性不等式约束\nceq=[-x(1)-x(2).^2+2\n    x(2)+2*x(3).^2-3]; % 非线性等式约束\nend\n\n%% 对于非线性约束条件,还可以这样写\nfunction [c,ceq]=constrain(x)\n% 非线性不等式约束\nc(1)= -x(1).^2+x(2)-x(3).^2;\nc(2)=x(1)+x(2).^2+x(3).^3-20; \n% 非线性等式约束\nceq(1) = -x(1)-x(2).^2+2;\nceq(2) = x(2)+2*x(3).^2-3; \nend\n\n\n\nmatlab 官网上的例子, 当然如果不设置梯度,也能计算,不过复杂的问题,建议设置梯度\noptions = optimoptions('fmincon','SpecifyObjectiveGradient',true);\nfun = @rosenbrockwithgrad;\nx0 = [-1,2];\nA = [];\nb = [];\nAeq = [];\nbeq = [];\nlb = [-2,-2];\nub = [2,2];\nnonlcon = [];\nx = fmincon(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon,options)\n\n%% 目标函数\nfunction [f,g] = rosenbrockwithgrad(x)\n% Calculate objective f\nf = 100*(x(2) - x(1)^2)^2 + (1-x(1))^2;\n\nif nargout > 1 % gradient required\n    g = [-400*(x(2)-x(1)^2)*x(1)-2*(1-x(1));\n        200*(x(2)-x(1)^2)];\nend\n\n\n\n%%必须是一下情形\nfunction [c, ceq, Gc, Gceq] = mycon(x)\nc = ...          %非线性不等式约束\nceq = ....       % 非线性等式约束\nif nargout > 2\n    Gc = ....    % 不等式约束的梯度\n    Gceq = ....  % 等式约束的梯度\nend\nend\n\n\n\nimage-20210515115110873\n\n\n\n\n\n\\[\n\\begin{aligned}\n\\min & \\quad  x_{5} \\\\\n& \\begin{cases}\nx_{3}+9.625 x_{1} x_{4}+16 x_{2} x_{4}+16 x_{4}^{2}+12-4 x_{1}-x_{2}-78 x_{4}=0 \\\\\n16 x_{1} x_{4}+44-19 x_{1}-8 x_{2}-x_{3}-24 x_{4}=0 \\\\\n-0.25 x_{5}-x_{1} \\leq -2.25 \\\\\nx_{1}-0.25 x_{5} \\leq 2.25 \\\\\n-0.5 x_{5}-x_{2} \\leq-1.5 \\\\\nx_{2}-0.5 x_{5} \\leq 1.5 \\\\\n-1.5 x_{5}-x_{3} \\leq -1.5 \\\\\nx_{3}-1.5 x_{5} \\leq 1.5\n\\end{cases}\n\\end{aligned}\n\\]\n上述问题的局部最优解: [ 1.9638    0.9276   -0.2172    0.0695    1.1448] ,目标函数值为 1.1448\n全局最优解: [2.4544    1.9088    2.7263    1.3510    0.8175], 目标函数值为 0.8175. 前4个变量不讨论\nclc,clear all;\n\nA = [-1,  0,  0, 0, -0.25;\n      1,  0,  0, 0, -0.25;\n      0, -1,  0, 0, -0.5;\n      0,  1,  0, 0, -0.5;\n      0,  0, -1, 0, -1.5;\n      0,  0,  1, 0, -1.5];\nb = [-2.25; 2.25; -1.5; 1.5; -1.5; 1.5];\nP.objective = @(x)x(5);\nP.Aineq = A;\nP.Bineq = b;\n%P.lb = [];\nP.nonlcon = @mynocon;\nP.solver = 'fmincon';\nP.options = optimset;\nP.x0 = rand(5,1);\n[x,f0,flag] = fmincon(P) %给出初值并求解\n\n%% 非线性约束\nfunction [c, ceq] = mynocon(x)\nc = [];\nceq = [x(3) + 9.625*x(1)*x(4) + 16*x(2)*x(4) + 16*x(4)^2 + 12 - 4*x(1) - x(2) - 78*x(4);\n    16*x(1)*x(4) + 44 - 19*x(1) - 8*x(2) - x(3) - 24*x(4)];\nend\n\n\n\n%% ---------------------------------------- 结果 ----------------------------------------\nLocal minimum found that satisfies the constraints.\n\nOptimization completed because the objective function is non-decreasing in \nfeasible directions, to within the value of the optimality tolerance,\nand constraints are satisfied to within the value of the constraint tolerance.\n\n<stopping criteria details>\nx =\n    1.9638\n    0.9276\n   -0.2172\n    0.0695\n    1.1448\nf0 =\n    1.1448\nflag =\n     1\n\n\n%% fmincon 函数的全局优化\n% 由于 fmincon 函数求解，依靠初始值， \n% 该全局优化函数，主要采用循环结构， 产生多个随机数赋值给fmincon函数作为初始值，\n% 依次调用fmincon函数求解原始问题， 并比较每次得出的目标函数值，并记录最小的目标函数值\n% 这样，就可能得出原始问题的全局最优解。\n\nfunction [x,f0,flag] = fmincon_global(f,a,b,n,N,varargin)\n%% 参数解释：\n% f 可以是结构体变量，也可以是目标函数的函数句柄\n% a 与b为决策变量所在的区间， 即 自变量x的上下限，可以是向量\n% n 为决策变量的个数， 即自变量的个数\n% N 产生多少个初值， 一般5~10个就好了\n% varargin 一些其他参数，应该包含描述约束的参数，与fmincon()函数完全一致\n% 即，fmincon 函数调用中除了 f与x0之外所有的后续变元\n%% 返回值： \n% x 很有可能是问题的全局最优解\n% f0 为最优目标函数\n%% 函数调用格式：\n% x = fmincon(problem,a,b,n,N)\n% x = fmincon(f,a,b,n,N,A,b,Aeq,beq)\n% x = fmincon(f,a,b,n,N,A,b,Aeq,beq,lb,ub)\n% x = fmincon(f,a,b,n,N,A,b,Aeq,beq,lb,ub,nonlcon)\n% x = fmincon(f,a,b,n,N,A,b,Aeq,beq,lb,ub,nonlcon,options)\n% x = fmincon(problem)\n% [x,fval] = fmincon(___)\n% [x,fval,exitflag,output] = fmincon(___)\n% [x,fval,exitflag,output,lambda,grad,hessian] = fmincon(___)\n%%\nx0 = rand(n,1);\nk0 = 0;\n% 处理结构体\nif strcmp(class(f),'struct')\n    k0=1;\nend\nif k0==1\n    f.x0 = x0;\n    [x,f0,flag] = fmincon(f); %结构体描述的问题直接求解\nelse\n    [x,f0,flag] = fmincon(f,x0,varargin{:}); %非结构体描述的问题直接求解\nend\n\nif flag == 0\n    f0 = 1e10;\nend\nfor i = 1:N\n    x0 = a(:) + (b(:) - a(:)).* rand(n,1);% 用循环结构尝试不同的随机搜索初值\n    if k0 ==1\n        f.x0 = x0;\n        [x1,f1,flag] = fmincon(f); %结构体描述的问题直接求解\n    else\n        [x1,f1,flag] = fmincon(f,x0,varargin{:}); %非结构体描述的问题直接求解\n    end\n    if flag > 0 & f1 < f0\n        % 如果找到更改的解，则保存\n        x = x1;\n        f0 = f1;\n    end\nend\n\n求解上述问题\nclc,clear all;\nA = [-1,  0,  0, 0, -0.25;\n      1,  0,  0, 0, -0.25;\n      0, -1,  0, 0, -0.5;\n      0,  1,  0, 0, -0.5;\n      0,  0, -1, 0, -1.5;\n      0,  0,  1, 0, -1.5];\nb = [-2.25; 2.25; -1.5; 1.5; -1.5; 1.5];\nP.objective = @(x)x(5);\nP.Aineq = A;\nP.Bineq = b;\n%P.lb = [];\nP.nonlcon = @mynocon;\nP.solver = 'fmincon';\nP.options = optimset;\nP.x0 = rand(5,1);\ntic % 计算耗时\n[x,f0,flag] = fmincon_global(P,-10,10,5,10) %给出初值并求解\ntoc\n\n\n%% ---------------------------------------- 结果 ----------------------------------------\nx =\n    2.4544\n    1.9088\n    2.7263\n    1.3510\n    0.8175\nf0 =\n    0.8175\nflag =\n     1\n历时 1.545311 秒。\n\n\n\n\n\\[\n\\begin{aligned}\nMin \\quad & \\sum_{i=1}^{n} \\sum_{j=1}^{n}\\left(\\omega_{i}-a_{i j} \\omega_{j}\\right)^{2}\\\\  \ns.t \\quad & \\sum_{i=1}^{n} \\omega_{i}=1,\\\\\n& 1\\geq \\omega_{i} \\geq 0, \\quad i=1,2, \\ldots, n\n\\end{aligned}\n\\]\nMatlab模板\n把上述文件存储为fmin.m，以后只需要更改目标函数myobjfun(x,AA)即可,其中x代表未知数, AA 代表目标函数的系数，\nfunction x = fmin(AA) % 调用函数接口\nn = size(AA,1) ; % 未知数x的长度 \nx0 = repelem(1/n,n);    % 初始迭代位置\nAeq = repelem(1,n);     % 线性等式约束的系数（左边的系数）\nbeq = 1;                % 线性等式约束的值 （右边的值）\n%A = [];                % 线性不等式约束的系数\n%b = [];                % 线性等式约束的值\nub = repelem(1,n);      % 变量的上限（取等号）\nlb = repelem(0,n);      % 变量的下限（取等号）\n[x,fval] = fmincon(@(x)myobjfun(x,AA),x0,[],[],Aeq,beq,lb,ub);\n%[x,fval] = fmincon(@myobjfun,x0,[],[],Aeq,beq,lb,ub,[],[],options,A);\nend\n\n\n% 目标函数\nfunction s = myobjfun(x,AA)\nn = size(AA,1);\ns =0;\nfor i = 1:n\n    for j = 1:n\n        s= s+ (x(i)- AA(i,j)*x(j))^2;\n    end\nend\nend\n参考:\n\n官网函数解释https://www.mathworks.com/help/optim/ug/fmincon.html\nhttps://wenku.baidu.com/view/6bcb651d0b4e767f5acfce97.html?sxts=1561344526517\nhttps://blog.csdn.net/qq_38784454/article/details/80329021\n《MATLAB数学建模》李昕——清华大学出版\n《MATLAB R2015b最优化计算》–李娅"
  },
  {
    "objectID": "posts/md/rmd中文.html",
    "href": "posts/md/rmd中文.html",
    "title": "Windows系统下R Markdown 设置中文pdf完美解决方案",
    "section": "",
    "text": "后文有与之对应的方法。\n需要安装完整版的CTeX_2.92套装（有没有感觉文件很大，文章最后教大家一个简单的安装版本），还要自己新建一个文本文件命名为header.tex,其内容为\\usepackage{ctex} ,把这个文件和运行的rmarkdown文件保存在同级目录中，然后把rmarkdown的头文件yaml改写为如下情况：\n---\ntitle: 'Untitled'\nauthor: 'zsc'\ndate: \"`r Sys.Date()`\"\noutput:\n  pdf_document:\n  includes:\n    in_header: header.tex\n  keep_tex: yes\n  latex_engine: xelatex\n---\n这样就可以生成中文的pdf了\n于是我仿照上面的步骤，写了一个函数rmarkdown_pdf 保存为rmarkdown_pdf.R\nrmarkdown_pdf=function(file_name,new_filename=file_name){\ncat(\"\\\\usepackage{ctex}\\n\", file = \"header.tex\")\ntxt=\"---\ntitle: 'Untitled'\nauthor: 'zsc'\ndate: \\\"`r Sys.Date()`\\\"\noutput:\\n  pdf_document:\\n    includes:\\n      in_header: header.tex\\n    keep_tex: yes\\n    latex_engine: xelatex\n---\n\"\nx=readLines(file_name,n=-1,encoding = \"UTF-8\")\nla=max(which(x==\"---\")[1:2])\ncat(c(txt,x[(la+1):length(x)]),sep = \"\\n\",file = new_filename,append = F)\nrm(list = ls())\n}\n在把这个函数加载到自定义环境中，\n\n第一步：安装目录找到Rprofile.site这个文件，我的是在“D:”这个目录；\n第二步：用文本文件打开Rprofile.site，配置文件里按照R语言自定义函数的格式自定义一个函数保存即可。\n\n.First<-function(){\n# 也可以加载包library(data.table)\n# 加载函数\nsource(\"函数rmarkdown_pdf.R存放的路径\")路径为1111/22/33 \n}\n这种设置，会产生很多的中间文件（系统并未自己删除），亲测成功：\n\n\n\npdf1"
  },
  {
    "objectID": "posts/md/rmd中文.html#ctex的版安装问题",
    "href": "posts/md/rmd中文.html#ctex的版安装问题",
    "title": "Windows系统下R Markdown 设置中文pdf完美解决方案",
    "section": "CteX的版安装问题",
    "text": "CteX的版安装问题\n原来是CteX的版本的问题 —-解决方案如下\n\n\n卸载CteX(注意卸载干净)；\n\n\n然后到MiKTek官网下载最新版64位MiKTek软件并安装(当前最新版本:basic-miktex-2.9.6615-x64.exe);几乎就是next就好了（建议把安装目录改了）\n\n\n安装以后,直接在Rstudio中点击knitr生成中文的pdf，系统会自动调用MiKTek里面的文件，并弹出对话框将要安装下列的包，安装包的时候注意选择更新源（一般选择离自己较近的下载源（我选清华）） ，会自动安装很多的包，\n\n\n\n\n\npdf4\n\n\n\n\n\npdf5\n\n\n\n\n\npdf6\n\n\n​ 点击install就好了（每安装一个文件都要弹出对话框并让你点击安装，这样很麻烦，可以把always前面的√取消掉），直到rmarkdown可以生成中文为止。\n\n（4）这种安装的方法也实用与方法一也适合,如果卸载CteX的时候没卸载干净，后面卸载basic-miktex-2.9.6615的时候，总是报错，总之是不能卸载的，所以我每次卸载的时候都是直接删除安装的目录（为何要卸载，测试软件啊！！！！！），大功告成！！！\n\n\n\n\npdf2\n\n\n​\n所用以上操作–我是翻墙操作的，毕竟下载软件的时候比较快"
  },
  {
    "objectID": "posts/md/rmd中文.html#补充",
    "href": "posts/md/rmd中文.html#补充",
    "title": "Windows系统下R Markdown 设置中文pdf完美解决方案",
    "section": "补充：",
    "text": "补充：\n这个补充是我后面遇到的情况，忘记了，总是编译不通过，就连方法二都没通过，于是逐一排查电脑，后面电脑环境成功安装以后，进而进一步补充说明（2018年11月17日）\n\n如果没有用上述模板（rticles模板），想要Rmd 文件生成对应的中文，直接knitr是行不通的，会报以下错误，当然想要正常显示用模板方便很多啊！\n\n\n\nbuchong01\n\n\n\noutput file: test.knit.md\n\n! Package inputenc Error: Unicode character 浣?(U+4F60)\n(inputenc)                not set up for use with LaTeX.\n\n错误: Failed to compile test.tex. See test.log for more info.\n此外: Warning message:\nIn grepl(\"==> Fatal error occurred\", x[i], fixed = TRUE) :\n  输入的字符串1不适用于此语言环境\n停止执行\n    ```\n\n 2. 方法一：如果Rmd中有中文，你想要正常显示，可以忽视中文，让中文显示空白，这时，只需设置YAML选项，\n\n```R\noutput:\n   pdf_document:\n       latex_engine: xelatex\n![](https://cdn.jsdelivr.net/gh/zscmmm/imgs2208save@master/img/buchong02.png)\n\n3. 方法二：如果想让中文显示，需要如下设置，这都是基于rticles模板的或者基于Latex的（由谢易辉的提供的案列进行总结的）\n\n方法一：\n\n![](https://cdn.jsdelivr.net/gh/zscmmm/imgs2208save@master/img/buchong03.png)\n\n直接在YAML格式中添加参数即可：\n如图\n4. 方法三： 首先在你的Rmd文件开始部分加入：\n\n---\noutput:\n    pdf_document:\n        includes:\n            in_header: header.tex\n---\n然后，建立一个新文件 header.tex，\n内容如下：\n\\usepackage{ctex} \n%\\setCJKmainfont{Adobe 宋体 Std}      % 中文缺省字体，\n%\\setCJKsansfont{Adobe 黑体 Std}      % 中文无衬线字体，   调用命令： \\sffamily\n%\\setCJKmonofont{Adobe 仿宋 Std}     % 中文打字机（等宽）字体， 调用命令： \\ttfamily\n去掉注释，更改你自己定义的字体。\n然后利用rmarkdown包正常编译Rmd文件就可以了。\n本机环境\n> sessionInfo()\nR version 3.5.1 (2018-07-02)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows >= 8 x64 (build 9200)\n\nMatrix products: default\n\nlocale:\n[1] LC_COLLATE=Chinese (Simplified)_China.936  LC_CTYPE=Chinese (Simplified)_China.936   \n[3] LC_MONETARY=Chinese (Simplified)_China.936 LC_NUMERIC=C                              \n[5] LC_TIME=Chinese (Simplified)_China.936    \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] compiler_3.5.1  backports_1.1.2 rprojroot_1.3-2 htmltools_0.3.6 tools_3.5.1     yaml_2.2.0     \n [7] Rcpp_1.0.0      rmarkdown_1.10  knitr_1.20      digest_0.6.18   evaluate_0.12"
  },
  {
    "objectID": "posts/md/使用R软件遇到的问题.html",
    "href": "posts/md/使用R软件遇到的问题.html",
    "title": "R软件常见问题",
    "section": "",
    "text": "读取csv文件出现中文乱码方案，增加编码格式参数\nread.csv(trainPath,header=TRUE,stringsAsFactors=TRUE,encoding = \"UTF-8\")\n保存csv文件中出现乱码，编码格式参数\nwrite.csv(outp, file = path, quote = F, fileEncoding = \"UTF-8\")\n#存储utf-8也乱码，我的电脑有时会发疯，有时又不会\nsource 加载R脚本中文乱码\nsource(\"core.R\",encoding=\"utf-8\")\nRStudio中脚本中文乱码，编码格式设置：tools -> global option…., 设置为UTF-8，最后，在打开文件的时候，选择File -> Reopen with encoding菜单，选择我们使用UTF-8编码打开文件，这样子就可以正确地显示中文了。\nR语言环境的显示问题\nsessionInfo()\nSys.getlocale()\nSys.setlocale(category = \"LC_ALL\",local=\"us\")\nSys.setlocale(category = \"LC_ALL\",local=\"chinese\")"
  },
  {
    "objectID": "posts/md/使用R软件遇到的问题.html#保存数据编码问题win中",
    "href": "posts/md/使用R软件遇到的问题.html#保存数据编码问题win中",
    "title": "R软件常见问题",
    "section": "2、保存数据编码问题(win中)",
    "text": "2、保存数据编码问题(win中)\n由于用Rstudio设置了保存的编码都用UTF-8，所以在保存文件时（特别是csv文件），经常遇到乱码的现象，比如使用data.table:::fwrite()、自带的write.csv()、readr:::write_csv()都乱码\n产生的原因：\n因为excel打开文件时默认使用unicode的编码方式（还有的网友说是默认以ANSI编码方式打开，待考）。在Unicode基本多文种平面定义的字符（无论是拉丁字母、汉字或其他文字或符号），一律使用2字节储存。恰恰utf-8是1字节的存储方式，所以excel直接打开时会出现乱码。\n解决办法：\n\n方法1、数据导入–不建议\n打开 Excel，执行“数据”->“自文本”，选择 CSV 文件，出现文本导入向导，选择“分隔符号”，下一步，勾选“逗号”，去掉“ Tab 键”，下一步，完成，在“导入数据”对话框里，直接点确定。导入之后，所有汉字显示正常，乱码问题解决。\n万一这个文本里面的有逗号，巧好分割时候是逗号（csv文件是以逗号进行存储的）,这就会对不齐了，产生新的问题\n方法2、先另存再打开\n使用记事本打开CSV文件，“文件”->“另存为”，编码方式选择ANSI，保存完毕后，用EXCEL打开这个文件就不会出现乱码的情况。\n不会乱码以后选择另存为excel\n方法3、用readr:::write_excel_csv()函数解决\n直接用write_excel_csv()这个函数就可以解决上述问题"
  },
  {
    "objectID": "posts/md/使用R软件遇到的问题.html#加载java问题",
    "href": "posts/md/使用R软件遇到的问题.html#加载java问题",
    "title": "R软件常见问题",
    "section": "3、加载java问题",
    "text": "3、加载java问题\n\n首先下载java ，把java加入环境变量，测试是否安装成功，在cmd命名下输入: java -version,返回\nC:\\Users\\zsc>java -version\njava version \"1.8.0_151\"\nJava(TM) SE Runtime Environment (build 1.8.0_151-b12)\nJava HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode)\n如果上述都没问题，在R中运行rjava还是报错怎么办？比如，导入包library(xlsx)的时候，出错：\n\n> library(xlsx)\n载入需要的程辑包：rJava\nError: package or namespace load failed for ‘rJava’:\n loadNamespace()里算'rJava'时.onLoad失败了，详细内容：\n  调用: inDL(x, as.logical(local), as.logical(now), ...)\n  错误: unable to load shared object 'D:/Program Files (x86)/R/R-3.4.2/library/rJava/libs/x64/rJava.dll':\n  LoadLibrary failure:  找不到指定的模块。\nError: 无法载入程辑包‘rJava’\n解决方法：因为在运行R的过程中，通常会需要调用rJava.dll来运行虚拟环境。这种情况，一般是系统中装了JAVA环境后安装其他软件的时候再次装了JAVA的类库rJava.dll，R的运行环境无法调用确认项。找到自己安装的JAVA环境，去配置R的系统环境中的rJava.dll：\n​ Sys.setenv(JAVA_HOME='D:/Program Files (x86)/Java/jdk1.8.0_144/jre')\n再次运行library(xlsx),就可以了！(不过每次都要设置，可以在R的配置文件中更改哦！)"
  },
  {
    "objectID": "posts/md/使用R软件遇到的问题.html#ggplot2作图标题无法居中",
    "href": "posts/md/使用R软件遇到的问题.html#ggplot2作图标题无法居中",
    "title": "R软件常见问题",
    "section": "4、ggplot2作图标题无法居中",
    "text": "4、ggplot2作图标题无法居中\n好像新版的ggplot2包标题默认居左，只需要在作图函数后面加上\n​ theme(plot.title = element_text(hjust = 0.5))\n这行就好了"
  },
  {
    "objectID": "posts/md/使用R软件遇到的问题.html#r更新",
    "href": "posts/md/使用R软件遇到的问题.html#r更新",
    "title": "R软件常见问题",
    "section": "5、R更新",
    "text": "5、R更新\nWindows系统中使⽤installr 套件的方式来更新R。建议在R终端机（termianl）中操作。\ninstall.packages(\"installr\") # 安装installr\ninstallr::updateR() # 未来要更新的R的时候，只要执行这行即可​"
  },
  {
    "objectID": "posts/md/shiny截图.html",
    "href": "posts/md/shiny截图.html",
    "title": "R&shiny自动截图",
    "section": "",
    "text": "library(shiny)\nlibrary(ggplot2)\nhistogram <- function(x1, x2, binwidth = 0.1, xlim = c(-3, 3)) {\n    df <- data.frame(\n        x = c(x1, x2),\n        g = c(rep(\"x1\", length(x1)), rep(\"x2\", length(x2)))\n    )\n    \n    ggplot(df, aes(x, fill = g)) +\n        geom_histogram(binwidth = binwidth) +\n        coord_cartesian(xlim = xlim)\n}\nui <- fluidPage(\n    fluidRow(\n        column(3, \n               numericInput(\"lambda1\", label = \"lambda1\", value = 3),\n               numericInput(\"lambda2\", label = \"lambda2\", value = 4),\n               numericInput(\"n\", label = \"n\", value = 1e4, min = 0),\n               # 增加一个按钮\n               actionButton(\"simulate\", \"Simulate!\")\n        ),\n        column(9, plotOutput(\"hist\"))\n    )\n)\n\nserver <- function(input, output, session) {\n    x1 <- reactive({\n        a = input$simulate\n        print(a)\n        rpois(input$n, input$lambda1)\n    })\n    x2 <- reactive({\n        b = input$simulate\n        print(b)\n        rpois(input$n, input$lambda2)\n    })\n    output$hist <- renderPlot({\n        histogram(x1(), x2(), binwidth = 1, xlim = c(0, 40))\n    }, res = 96)\n}\n\nmm =shinyApp(ui, server)\nSys.sleep(5)\nlibrary(webshot)\nappshot(mm, \"01_hello1.png\",webshot_timeout= 100,delay=10)\n# 其中delay参数最好设置大一点, 特别是当使用动态网页时\n\n## 还可以根据css来截图\nappshot(mm, \"01_hello2.png\",webshot_timeout= 100,delay=10,selector='body')\n感兴趣可以参考webshot包网站: https://wch.github.io/webshot/reference/webshot.html"
  },
  {
    "objectID": "posts/md/线性规划的一般模型(test).html",
    "href": "posts/md/线性规划的一般模型(test).html",
    "title": "线性规划的一般模型(草稿)",
    "section": "",
    "text": "\\[\n\\begin{aligned}\n\\min \\quad z &=  c_1x_1+c_2x_2+ \\cdots + c_nx_n  \\\\\ns.t. \\quad\n& \\begin{cases}\n& a_{11}x_1+a_{12}x_2+ \\cdots + a_{1n}x_n  \\leq b_1   \\\\\n& a_{21}x_1+a_{22}x_2+ \\cdots + a_{2n}x_n  \\leq b_2   \\\\\n& \\quad \\cdots \\qquad \\cdots   \\qquad \\cdots \\\\\n& a_{m1}x_1+a_{m2}x_2+ \\cdots + a_{mn}x_n  \\leq b_m  \\\\\n& x_1,x_2,x_3,\\cdots,x_n \\geq 0\n\\end{cases}\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "posts/md/datatable1.html",
    "href": "posts/md/datatable1.html",
    "title": "data.table – 1基本函数",
    "section": "",
    "text": "data.table本质上是一个list，它们的列包含的元素个数都相同。"
  },
  {
    "objectID": "posts/md/datatable1.html#数据框转为data.table",
    "href": "posts/md/datatable1.html#数据框转为data.table",
    "title": "data.table – 1基本函数",
    "section": "1.3 数据框转为data.table",
    "text": "1.3 数据框转为data.table\n对于数据的处理，data.table包提供了一个非常简洁的通用格式：DT[i,j,by]，\n\n其中i控制列, j控制列, by控制分组. 上述表达式的意思是: 对于数据集DT，先选取子集行i, 然后通过by分组计算j。i设定数据的选取条件，j设定结果的计算方式，by设定数据的分组情况。通过这个，我们可以在一行代码中很方便地完成处理过程。首先需要把数据变为data.table类型\n\nlibrary(data.table)\nlibrary(magrittr)\n### 方法一: 赋值转换\nmtcars_dt <- data.table(mtcars) # 也可以强制转化 as.data.table()\n\n### 方法二: 引用转换\nsetDT(mtcars)  # 不需要赋值,这是引用转换, mtcars这个数据集已经变成了data.table 数据类型了"
  },
  {
    "objectID": "posts/md/datatable1.html#直接采用逻辑语句慢",
    "href": "posts/md/datatable1.html#直接采用逻辑语句慢",
    "title": "data.table – 1基本函数",
    "section": "2.1 直接采用逻辑语句（慢）",
    "text": "2.1 直接采用逻辑语句（慢）\nmtcars_dt <- data.table(mtcars) # 一共32行,11列\n#直接采用逻辑语句（慢）\nmtcars_dt[cyl==8 ]\nmtcars_dt[cyl==8 & carb==4]\nmtcars_dt[cyl %in% c(\"8\",\"6\")]# 等价 mtcars_dt[cyl %in% c(8,6)]"
  },
  {
    "objectID": "posts/md/datatable1.html#设置获取使用主键适中",
    "href": "posts/md/datatable1.html#设置获取使用主键适中",
    "title": "data.table – 1基本函数",
    "section": "2.2 设置/获取/使用主键(适中)",
    "text": "2.2 设置/获取/使用主键(适中)\n\n\n\n\n\n\n\n函数\n说明\n\n\n\n\nsetkey(x,V1)\n该函数可以对一个data.table按照某一列进行排序,排序之后,这个data.table 对象会被标记为排过序了, 由于不会在内存中复制被排序的data.table对象,所以非常高效.\n\n\nsetkey(x,V1,V2,V3, ...)\n等价于setkeyv(x,c(\"V1\",\"V2\",...) )\n\n\nsetkeyv(x,c(\"V1\",\"V2\",...) )\n可以按照多列一起排序.先根据V1排序,然后根据V2排序, 以此类推.\n\n\ntable()\n查看内存中所有data.table 的详细信息,包括key键,\n\n\n\n\nsetkey(x,V1)传入列名作为参数，不需要引号, 而setkeyv(x,c(\"V1\",\"V2\",...) ) 传入一个字符型的向量, 这两个函数都没有返回值, 直接对data.table进行更新操作,和:=类似\n每一个table.table中只有一组key键, 像普通的data.frame, 每一行有且只有一个行名且行名具有唯一性, 行名可以看做是data.frame的索引. 而data.table可以利用主键进行索引, 且可以对多列设置主键,且主键不强调唯一性. 也就是说，不同列的主键可以是一样的。既然行可以通过主键排序，那么排序的时候，具有同样主键的一些行，会被排在一起。\n在data.table里，操作符”:=“和所有的以set开头函数（比如setkey,setorder,setname等）一样，它们都会更新输入的原数据。\n\n#使用主键(会对筛选的数据进行重排序--适中)\nmtcars_dt <- data.table(mtcars) \nsetkey(mtcars_dt,cyl,carb)# 设置key键\nmtcars_dt #可以看出已经排序了\ntables()              # 查看内存中所有data.table 的详细信息,包括key键\niris_dt = data.table(iris)\ntables()              # \nsetkeyv(mtcars_dt,c(\"cyl\",\"carb\"))#先设置的cyl,carb列为主键\nmtcars_dt[.(8,4)]     # 等价 mtcars_dt[cyl==8 & carb==4]\ntables()              # 查看内存中所有data.table 的详细信息"
  },
  {
    "objectID": "posts/md/datatable1.html#二级索引indices快",
    "href": "posts/md/datatable1.html#二级索引indices快",
    "title": "data.table – 1基本函数",
    "section": "2.3 二级索引(indices)（快）",
    "text": "2.3 二级索引(indices)（快）\n\na) 什么是二级索引? 二级索引和主键有什么区别?\n\n前面介绍了setkey 和setkeyv的使用,每一次使用setkey, data.table 对象都会在内存里被重新排序, 时间复杂度是O(nlogn). 而 setindex 和setindexv 则不会对data.table对象进行重新排序, 它只会计算某列的顺序，将这个顺序向量保存在一个额外的，叫做index的属性里面。 此外,一个data.table对象只能有一组key, 但是可以有多个二级索引(indices). 二级索引的时间复杂度是O(logn)\n\n\n\n\n\n\n\n\n函数\n说明\n\n\n\n\nsetindex(x,V1)\n设置索引—即将V1列设置为该data.table的二级索引  等价setindexv(x,c(\"V1\"))\n\n\nsetindex(x,V1,V2,...)\n设置多列索引—即将V1,V2列设置为该data.table的二级索引 等价setindexv(x,c(\"V1\",\"V2\",...))\n\n\nsetindexv(x,c(\"V1\",\"V2\",...))\n以字符的方式设置索引\n\n\nsetindex(x, NULL)\n删除所有的二级索引。\n\n\nindices(x)\n获取data.table对象的所有二级索引, 如果该data.table没有二级索引，那么返回NULL。\n\n\n\n# 设置和获取二级索引\nmtcars_dt <- data.table(mtcars) \nsetindex(mtcars_dt,cyl,carb) # 等价于 setindexv(mtcars_dt,c(\"cyl\",\"carb\"))\nnames(attributes(mtcars_dt)) # 查询data.table 的属性\nindices(mtcars_dt)\nmtcars_dt #  注意并没有对数据进行重新排序, 而setkey会对数据进行重新排序\nsetindexv(mtcars_dt,c(\"vs\", \"am\", \"gear\",\"carb\"))\nindices(mtcars_dt)\n\n\n\nb)为什么使用二级索引\n原因是对一个data.table重新排序成本太高, 除非你要进行大量选子集的操作,建议使用setkey 来提取子集. 我们想快速地提取子集(subset)同时又不必重新排序,此时二级索引就派上用处了."
  },
  {
    "objectID": "posts/md/datatable1.html#二级索引的快速使用-参数on",
    "href": "posts/md/datatable1.html#二级索引的快速使用-参数on",
    "title": "data.table – 1基本函数",
    "section": "2.4 二级索引的快速使用 — 参数on",
    "text": "2.4 二级索引的快速使用 — 参数on\n上面我们都在讲先设置二级索引,然后在进行操作,这样能不能合成一步?—-于是参数on诞生了, 参数on使得语法更简洁，并且能自动创建并重用二级索引\n参数on\n\n通过创建索引进行subset。每次都能节省setindex()的时间。\n通过检查属性，可以简单地重用已经存在的二级索引。\n参数on必须是一个字符型的向量。\n注意参数on也可以用来指定主键。事实上，为了更佳的可读性，我们鼓励在参数on里面指定主键。\n参数on它不会把这个二级索引自动创建为data.table的一个属性。需要额外设置参数才可以(设verbose = TRUE).\n\nmtcars_dt[.(1),on=\"am\"]#同时满足cyl=8,gear=4的行\n## 等价的备选方案 -- mtcars_dt[list(1), on = \"am\"]\n## 注意 on=\"am\"表明我们要基于am这一列进行过滤,过滤的条件是am == 1, 1必须放置.()里面\n## 原因是 am是numeric类型,如果不是numeric类型,就不用这样做\n\niris_dt = data.table(iris)\niris_dt[\"setosa\",on=\"Species\"]  \n#等价的备选方案\niris_dt[.(\"setosa\"),on=\"Species\"] \niris_dt[list(\"setosa\"),on=\"Species\"] \n\n# 选择 Species =setosa 或者 Species =virginica\niris_dt[.(c(\"setosa\",\"virginica\")) ,on=\"Species\"] \niris_dt[.(c(\"setosa\",\"virginica\"),c(3.0)) ,on=c(\"Species\",\"Sepal.Width\")] \n\n# 注意小心有NA行,原因在于Petal.Length列没有等于5.1的值\niris_dt[.(c(\"setosa\",\"virginica\"),c(5.1)) ,on=c(\"Species\",\"Petal.Length\")] \n\n\n#### on参数也可以像j那样直接使用列名 ,无需加引号\nmtcars_dt[.(8,4),on=c(\"cyl\",\"carb\")]#同时满足cyl=8,gear=4的行\nmtcars_dt[.(8,4),on=.(cyl,carb)]# 等价同上,"
  },
  {
    "objectID": "posts/md/datatable1.html#自动索引-只支持操作符-和-in",
    "href": "posts/md/datatable1.html#自动索引-只支持操作符-和-in",
    "title": "data.table – 1基本函数",
    "section": "2.5 自动索引 — 只支持操作符 == 和 %in%",
    "text": "2.5 自动索引 — 只支持操作符 == 和 %in%\n回顾一下，我们先学习如何通过主键使用快速二分法搜索进行subset。接着，我们学习了使用二级索引，它带来更好的效果，而且语法也更简洁。\n等等，有没有更好的方法？\n有！优化R的原生语法，使用内置的索引。这样我们毋需使用新的语法，就能得到同样的效果。这就是自动索引。 目前，它只支持操作符 == 和 %in% 。而且只对一列起作用。某一列会被自动创建为索引，并且作为data.table的属性保存起来。这跟参数on不同，参数on会每次创建一个临时索引，所以才会被叫做“二级索引”。\niris_dt[Petal.Length == 5.1, ] \niris_dt[Petal.Length %in% c(5.1,5.2), ] \n注意, 以上都是针对i参数设置,因此可以同j参数, by参数同时使用\n还有, 在进行行筛选时,尽量打个逗号,区分i和j"
  },
  {
    "objectID": "posts/md/datatable1.html#格式-等价list",
    "href": "posts/md/datatable1.html#格式-等价list",
    "title": "data.table – 1基本函数",
    "section": "3.1 .()格式 == 等价list()",
    "text": "3.1 .()格式 == 等价list()\n用.()来包围列名，和list() 等价\n# 列筛选 --方法一, 直接输入列名\nmtcars_dt[, .(mpg, cyl, hp)] %>% head()\nmtcars_dt[, c(\"mpg\", \"cyl\", \"hp\")]# 返回的都是data.table\nmtcars_dt[, c(\"mpg\", \"cyl\", \"hp\"), with =F]\n\n# 列筛选 --方法二 如果没用list()或者.()包围列名 ，则返回的是向量（这不是我们想要的结果），如下\nmtcars_dt[, c(mpg, cyl, hp)] %>% head()\n\n# 列筛选 --方法三, 可以把列名改写成对应的数字列,但返回的是data.table类型\nmtcars_dt[, c(1, 2, 4)] %>% head()\nmtcars_dt[, c(1, 2, 4)] %>% class()\n\n# 列筛选-- 方法四, 如果列名已经存储到一个变量里面了, 怎么根据它来选择列\nlibrary(data.table)\nmtcars_dt = as.data.table(mtcars)\na = c(1,2,4)\nb = c(\"mpg\", \"cyl\", \"hp\")\nmtcars_dt[,..a] # 在变量名前加两个点,  如果这样输入: mtcars_dt[,a], 则报错\nmtcars_dt[,..b]# 在变量名前加两个点,  如果这样输入: mtcars_dt[,b], 则报错\n\n\n# 列筛选 --方法五, 要排除列名怎么办，可以用数字\nmtcars_dt[, -c(1, 2, 4)] %>% head() # 等价\nmtcars_dt[, c(\"mpg\", \"cyl\", \"hp\") :=NULL]  # 等价\nmtcars_dt[, -c(\"mpg\", \"cyl\", \"hp\"), with = F] %>% head() # 等价\nmtcars_dt[, !c(\"mpg\", \"cyl\", \"hp\"), with = F] %>% head() # 等价\n\n# 下面只能用冒号(:)链接，不然会报错\nmtcars_dt[, -(2:4)] %>% head() # 删除第2:4列变量\nmtcars_dt[, mpg:disp, with = FALSE] %>% head() # 等价\nmtcars_dt[,-(mpg:disp), with = FALSE] %>% head() # 等价"
  },
  {
    "objectID": "posts/md/datatable1.html#在j参数上可以进行计算",
    "href": "posts/md/datatable1.html#在j参数上可以进行计算",
    "title": "data.table – 1基本函数",
    "section": "3.2 在j参数上可以进行计算：",
    "text": "3.2 在j参数上可以进行计算：\n# 返回按列计算的值\nmtcars_dt[,.(sum(mpg),mean(cyl))]\n\n# 当列的长度不一的时候，会循环对齐\nmtcars_dt[,.(mpg,mean(cyl))] %>% head()\n\n\n# 还可以输入多个表达式，用花括号括起来即可\nmtcars_dt[,{print(mpg);plot(disp)}]\n\n# {} 还有帮助我们隐藏一些过度中间变量\nmtcars_dt[,.(x = cyl^2 +1, y = cyl^2 +2)] %>% head() # 这样cyl^2计算了两次,这样效率慢\n\nmtcars_dt[,{temp = cyl^2; .(x = temp+1,y=temp+2)}] %>% head() \n关键词.SD 和.SDcol 的作用 , 后面会讲解\n\n## 对data.table的每一列进行计算\nmtcars_dt[,sapply(.SD, function(x){sum(is.na(x))/.N})]\n\n## 也可以指定列进行计算\nmtcars_dt[,sapply(.SD, function(x){sum(is.na(x))/.N}),.SDcol = c(\"A\",\"B\",\"C\")]\n\niris_dt = data.table(iris)\ncol_names = colnames(iris_dt)\n\n## 计算所有数值变量的均值, 可以先对变量名进行筛选\nnum_col = sapply(iris_dt, function(x) class(x) == \"numeric\" )\niris_dt[, lapply(.SD, mean), .SDcols = num_col]\n\n#####  在数据框中把指定的列转换为因子列\n## 方法一   ---- 这种方法已被弃用 with=F, 推荐使用方法2 \n# col_names 为一个字符向量\n# iris_dt[, col_names := lapply(.SD, function(x)as.factor(x)),.SDcols = col_names,with=F]\niris_dt[,col_names,with=F]  # 选择以col_names变量的内容的列\n\n\n## 方法二\n## (col_names):=  代表的是字符串向量，如果只使用col_names则表示列名为col_names的变量\niris_dt[, (col_names) := lapply(.SD, function(x)as.factor(x)) , .SDcols = col_names]\n\niris_dt[,(\"Sepal.Length\"):=as.factor(Sepal.Length)] #同上\n\n                                \n## 如果左边用数字并打上() 代表第几列，指定第几列的操作\niris_dt[,(2:3):=Species] # 把第2：3列的值进行更新，即第2:3列都为Species列\n\n### 用函数对列名进行筛选后,然后对这些列进行统一处理\n#eg: 列名以S结尾的列全部转为因子,    \niris_dt[, lapply(.SD, function(x)as.factor(x)) , .SDcols = endsWith(names(iris_dt), \"S\")]\n# startsWith(names(iris_dt), \"S\") # 表示以S开头的筛选变量方式"
  },
  {
    "objectID": "posts/md/datatable1.html#选取子集",
    "href": "posts/md/datatable1.html#选取子集",
    "title": "data.table – 1基本函数",
    "section": "3.3 选取子集",
    "text": "3.3 选取子集\n选取子集仍然采用subeset函数，语法格式为：subset(x, subset, select)，x是data.table对象，subset是行满足条件，select是列满足条件\n# 用 .() 来包围列名，和list() 等价，都返回data.table数据类型,只要参数 j 返回一个list，这个list的每一个元素都会被转换成结果data.table的一列\n\nsubset(mtcars_dt,cyl==8,select =c('mpg','cyl','disp'))\n# 等价\nmtcars_dt[cyl==8,.(mpg,cyl,disp)]\n# 等价\nmtcars_dt[cyl==8,list(mpg,cyl,disp)]\n\n## 注意 ，没用list()或者.()包围列名 ，则返回的是向量，如下\nmtcars_dt[,c(mpg,cyl,hp)]"
  },
  {
    "objectID": "posts/md/datatable1.html#对列进行排序",
    "href": "posts/md/datatable1.html#对列进行排序",
    "title": "data.table – 1基本函数",
    "section": "3.4 对列进行排序",
    "text": "3.4 对列进行排序\n\n排序采用setorder函数，输入待排序的列名，默认升序，降序列名前加-\n\n注意：升序，降序都是按assic 值的大学排序\n\nsetorder(mtcars_dt,mpg,-hp) #注意，这里直接对原数据进行了重排序，这点和R很多函数不一样，\n#几乎等价\nmtcars_dt[order(cyl,-hp)] #这个就基本符合R语言规律，不改变原数据。\n\n# 还可以使用key键排序,这样会改变原数据"
  },
  {
    "objectID": "posts/md/datatable1.html#对列进行增删变量",
    "href": "posts/md/datatable1.html#对列进行增删变量",
    "title": "data.table – 1基本函数",
    "section": "3.5 对列进行增删变量",
    "text": "3.5 对列进行增删变量\n都是直接对原数据进行修改，无需重复赋值\n\n3.5.1 添加变量有三种语法格式：\nDT[i, LHS:=RHS, by=...] #适用单变量添加，等号（＝）前面为新的变量名,没有写明变量名，自动为V+  \nDT[i, c(\"LHS1\",\"LHS2\") := list(RHS1, RHS2), by=...] #双变量添加  \nDT[i, `:=`(LHS1=RHS1,LHS2=RHS2, ...), by=...] #多变量添加，注意`:=`  \n\n# 有条件的添加变量\nmtcars_dt <- data.table(mtcars) \nmtcars_dt[, cyl1:= 1*(cyl <= 6)]\nmtcars_dt[, cyl2:= ifelse(cyl <=6, 1,0)]\nmtcars_dt[, cyl_mpg:= ifelse(cyl <=6, mpg,cyl)]# 当cyl小于6时,则用mpg的数据,大于6时,则用cyl值保持不变\n\n\n3.5.2 删除变量 — 变量:=NULL\n\n# 这里发现一个bug，数据集被改动了,但是rstudio中的变量的维度没变，但是数据集确实改变了\nmtcars_dt[,`:=`(mpg1=1/mpg,new=cyl+gear)]#增加变量mpg1 与new变量\nmtcars_dt[,mpg1:=NULL] #删除变量mpg1  也可以mtcars_dt[,`:=`(mpg1=NULL,new=NULL)],也可以用 mtcars_dt[, c(\"mpg\") :=NULL] \n\n# 如果要删除多列时，可用以下方法,\nmtcars_dt[, c(\"mpg\", \"cyl\", \"hp\") :=NULL]  # 注意用 :=  会直接更改原数据\nmtcars_dt[, -c(\"mpg\", \"cyl\", \"hp\"), with = F]  # 这个会产生一个副本（或者叫拷贝）\nmtcars_dt[, !c(\"mpg\", \"cyl\", \"hp\"), with = F] # 同上，产生拷贝\nmtcars_dt[, -c(1, 2, 4)]     #  同上，产生拷贝\n\n# 删除多列\ncol = c(\"mpg\", \"cyl\", \"hp\")\nmtcars_dt[, col :=NULL]  # 这个只能删除列名为col的变量\n\nmtcars_dt[, (col) :=NULL] # 能删除以col为变量的内容作为mtcars的列名，\n# 上面等价mtcars_dt[, c(\"mpg\", \"cyl\", \"hp\") :=NULL] \n\n# 下面只能有冒号(:)链接，不然会报错\nmtcars_dt[, mpg:disp, with = FALSE] %>% head() # 等价\nmtcars_dt[,-(mpg:disp), with = FALSE] %>% head() # 等价\n理解数据存储以及变量名 。比如：数字，字符串 ，矩阵的内容，都会直接存在内存中，把数字3赋值给变量a,就相当于a指向数字3，改变a不会对内存进行修改，只是指针发生了改变，\n操作符“:=”会更新原数据。操作符“:=”对输入的数据进行浅度复制，只是一份指向列的指针向量的复制，在内存里，数据不是真的被复制了。他会随着指针指向的对象变化而变化，\n不更新原数据用函数 copy()。函数 copy() 对输入参数进行深度复制，因此对副本做的所有更新操作，都不会对原数据生效。简单理解：就是在内存中创建了一个和原来一模一样的数据."
  },
  {
    "objectID": "posts/md/datatable1.html#分组汇总只需在by指定分组变量在j指定计算函数即可",
    "href": "posts/md/datatable1.html#分组汇总只需在by指定分组变量在j指定计算函数即可",
    "title": "data.table – 1基本函数",
    "section": "4.1 分组汇总只需在by指定分组变量，在j指定计算函数即可",
    "text": "4.1 分组汇总只需在by指定分组变量，在j指定计算函数即可\n#按cyl与vs分组，对统计分组下的mpg均值，disp的总和,分组数据个数num，共返回cyl，vs，以及分组下的三个新变量 \nmtcars_dt[,.(mean_mpg = mean(mpg),num=length(mpg),sum_disp = sum(disp)),by=.(cyl,vs)]"
  },
  {
    "objectID": "posts/md/datatable1.html#data.table有一个特殊的变量.n可以直接计算分组的观测值个数",
    "href": "posts/md/datatable1.html#data.table有一个特殊的变量.n可以直接计算分组的观测值个数",
    "title": "data.table – 1基本函数",
    "section": "4.2 data.table有一个特殊的变量.N可以直接计算分组的观测值个数。",
    "text": "4.2 data.table有一个特殊的变量.N可以直接计算分组的观测值个数。\n- 当参数j里面只有一列，我们可以省略 .()，如下：mtcars_dt[,.N,by=.(cyl,vs)]   \n- 当参数by里面只有一列，我们可以省略 .()，如下：mtcars_dt[,.N,by=cyl]\nmtcars_dt[,.(mean_mpg = mean(mpg),.N),by=.(cyl,vs)]"
  },
  {
    "objectID": "posts/md/datatable1.html#by参数还有接受表达式",
    "href": "posts/md/datatable1.html#by参数还有接受表达式",
    "title": "data.table – 1基本函数",
    "section": "4.3 by参数还有接受表达式：",
    "text": "4.3 by参数还有接受表达式：\n# 可以对要分组的列进行表达式判断，按其真假进行分组\nmtcars_dt[,.(mean_mpg = mean(mpg),.N),by=.(cyl>5,vs)]\n# 也可以用函数进行简单的分组\nmtcars_dt[,.(hp),by=sign(cyl-6)]"
  },
  {
    "objectID": "posts/md/datatable1.html#sd-和.sdcol-关键词",
    "href": "posts/md/datatable1.html#sd-和.sdcol-关键词",
    "title": "data.table – 1基本函数",
    "section": "4.4 .SD 和.SDcol 关键词",
    "text": "4.4 .SD 和.SDcol 关键词\n对j参数进行计算时，必须分别对每列指定 mean() 函数吗 ？\n如上面的例子，要对分组变量进行计算难道都要指定每一列？可以采用.SD 函数，它常和.SDcols函数联合使用。\n\n.SD 是经过i 和by 处理之后剩下的那部分数据集, 本质是一个data.table对象.\n另一种理解, .SD代表行经过i 筛选后, 除了by参数指定的列以外的所有列组成的新的data.table, 是原数据的子集\n首先,对i参数进行筛选, 然后把 by参数指定的那一列会被提前到首列, 其余列被按by指定的列进行分组组成新的data.table对象, 分成多少组,就有多少个data.table 对象, 这里的多个data.table对象出现的顺序是按照by指定列值出现的顺序\n.SD只能在位置j中使用, 且只能在:=右边使用\n由于.SD 默认包含用于分组的所有列。我们需要指定列进行计算 —–可用关键词.SDcol\n.SDcols指定.SD包括哪些列. eg: .SDcols = c(\"disp\",\"hp\"), 则 .SD 从默认的所有列改为只包含disp和hp这两列。\n我们也可以使用- 或者!来移除列。比如:我们指定!(colA:colB) 或者-(colA:colB)表示移除从 colA 到 colB 的所有列。\n\nlibrary(data.table)\nmtcars_dt = data.table::as.data.table(mtcars)\nmtcars_dt[, .SD, by=cyl] # 注意此时cyl 从第二列变成了第一列,故by指定的列提前到第一列,其余列顺序保持不变\n\nmtcars_dt[, print(.SD), by=cyl] # 注意了多个data.table对象, 每一个对象是按照cyl值的先后顺序输出的\n\nmtcars_dt[, lapply(.SD[, 1:2, with=F], mean), by=cyl] #.SD代表除了by指定的所有列组成的新data.table, 并选择新的data.table的前两列进行计算\n\n# 按cyl vs变量进行分组后，对其余的每一列求均值\nmtcars_dt[,lapply(.SD, mean),by=.(cyl,vs)]\n\n# 按cyl分组以后对其余变量求和\nmtcars_dt[,lapply(.SD, sum),by=.(cyl)] \n\n# 如果要对大量的变量做聚合计算，可以使用.SD函数，和.SDcols函数。\n# 默认的，.SD函数指对所有变量进行计算\nmtcars_dt[, lapply(.SD, mean)]\n\n#只对某些特定的列 结合.SDcols参数\nmtcars_dt[, lapply(.SD, mean), .SDcols = c(\"cyl\", \"vs\")]#只对cyl, vs列进行计算\n\n# 对多个变量实现多个统计指标计算\nmtcars_dt[, sapply(.SD, function(x) c(mean=mean(x), median=median(x)))]"
  },
  {
    "objectID": "posts/md/datatable1.html#如果要对子集进行分组统计怎么办即对选出的i进行分组统计.",
    "href": "posts/md/datatable1.html#如果要对子集进行分组统计怎么办即对选出的i进行分组统计.",
    "title": "data.table – 1基本函数",
    "section": "4.5 如果要对子集进行分组统计怎么办？，即对选出的i进行分组统计.",
    "text": "4.5 如果要对子集进行分组统计怎么办？，即对选出的i进行分组统计.\n可用by=列名即可允许按每一个已知i的子集分组，在使用by=.EACHI时需要设置键值\nmtcars_dt[cyl==4 | cyl==8,mean(mpg),by = cyl]"
  },
  {
    "objectID": "posts/md/mac常用软件.html",
    "href": "posts/md/mac常用软件.html",
    "title": "mac 常用软件",
    "section": "",
    "text": "xcode-select --install"
  },
  {
    "objectID": "posts/md/mac常用软件.html#homebrew-主页-httpsbrew.sh",
    "href": "posts/md/mac常用软件.html#homebrew-主页-httpsbrew.sh",
    "title": "mac 常用软件",
    "section": "2.homebrew 主页: https://brew.sh/",
    "text": "2.homebrew 主页: https://brew.sh/\n\n2.1安装\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n\n\n2.2 卸载(未试过)\n方法一: 网上找的,\n可参考: https://blog.csdn.net/qq_41234116/article/details/79366454\n方法 2: 官方版本\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\"\nhttps://github.com/Homebrew/brew/blob/master/docs/FAQ.md\nhttps://stackoverflow.com/questions/23251665/how-to-uninstall-homebrew\n\n\n2.3 安装包 和卸载包\nbrew install <packageName>     % 这个安装的是只有命令行的工具\nbrew cask install google-chrome   % 注意 brew cask install  安装的是有图像界面的 app\nbrew uninstall <packageName>\nbrew cask uninstall <packageName>\nbrew list    % 已安装列表\nbrew update   % 注意每次使用这个是 都很慢, 可进行源的更新\nbrew cask search <packageName>  %查询<packageName>\nbrew cask info <packageName>   % 查看版本信息\nbrew config             %查看brew配置\nbrew outdated   % 查看那些包（软件）可以更新\nbrew upgrade             # 更新所有的包，Homebrew 会安装新版本的包，但旧版本仍然会保留\nbrew upgrade $FORMULA    # 更新指定的包\nbrew cleanup             # 清理所有包的旧版本，将旧有的软件安装包进行清理\nbrew cleanup $FORMULA    # 清理指定包的旧版本\nbrew cleanup -n          # 查看可清理的旧版本包，不执行实际操作\nbrew cask install qlcolorcode  # 预览使得文本具有颜色,即给代码上色\nbrew cask install qlstephen  # 语法高亮\n### 更新brew cask 安装过的软件...\nbrew cask outdated # 查看过时的软件\nbrew cask upgrade  # 更新所有过时的软件\nbrew cask upgrade *** # 更新指定软件\nbrew cask reinstall qq         #推荐，直接重新安装\n超级右键   macApp 安装\n\n\n2.4 homebrew 的清华更新源\n清华镜像官网:\nhttps://mirror.tuna.tsinghua.edu.cn/help/homebrew/\nhttps://mirrors.tuna.tsinghua.edu.cn/help/homebrew-bottles/\n下面给出清华镜像官网链接(注意在 终端下直接运行下面的四句命令即可), ,一般情况下,替换镜像的命令镜像网站会给出,所以以后要进行更新源的操作,直接去相应的镜像网站找更新命令\ngit -C \"$(brew --repo)\" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git\n\ngit -C \"$(brew --repo homebrew/core)\" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git\n\ngit -C \"$(brew --repo homebrew/cask)\" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.git\n\nbrew update\n复原\ngit -C \"$(brew --repo)\" remote set-url origin https://github.com/Homebrew/brew.git\n\ngit -C \"$(brew --repo homebrew/core)\" remote set-url origin https://github.com/Homebrew/homebrew-core.git\n\ngit -C \"$(brew --repo homebrew/cask)\" remote set-url origin https://github.com/Homebrew/homebrew-cask.git\n\nbrew update\n还可以参考::https://www.cnblogs.com/DjangoBlogs/p/10762310.html\n\n\n2.5Homebrew-bottles 镜像使用帮助\n注:该镜像是 Homebrew 二进制预编译包的镜像。本镜像站同时提供 Homebrew 的 formula 索引的镜像（即 brew update 时所更新内容），请参考Homebrew 镜像使用帮助。\n\n2.5.1临时替换\nexport HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles\n\n\n2.5.2长期替换\necho 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles' >> ~/.bash_profile\nsource ~/.bash_profile\n注意: 个人理解 Homebrew-bottles 安装的是 类似安装包的形式,即编译好的包.\n\n\n\n2.6 Homebrew 关闭自动更新\n\n2.5.1临时关闭\nexport HOMEBREW_NO_AUTO_UPDATE=true\n\n\n2.5.2长期关闭\necho 'export HOMEBREW_NO_AUTO_UPDATE=true' >> ~/.bash_profile\nsource ~/.bash_profile\n\n\n\n2.7 mac Linux命令解释\n\nexport A = B 把 B 写入 A中,不过重启后无效, 还可以设置环境变量,不过 mac 一般会自动配置,不怎么用这个,用的较多的是~/.bash_profile文件来管理环境变量.\necho 'xxx' >>  file 把'xxx'内容追加到 file 文件末尾, 用一个>表示覆盖 file文件.\nsource ~/.bash_profile 刷新配置文件\ncat file 查看 file 文件\nvim file 利用 vim 打开 file文件,vim 可以编辑修改 file 文件"
  },
  {
    "objectID": "posts/md/mac常用软件.html#常用软件",
    "href": "posts/md/mac常用软件.html#常用软件",
    "title": "mac 常用软件",
    "section": "3. 常用软件",
    "text": "3. 常用软件\n\n谷歌浏览器 ,\nTypora 写作软件,\nsublime-text3,\ngithub桌面版,\nmathpix-snipping-tool公式识别器,\ntencent-lemon : 腾讯柠檬垃圾清理软件\ncontexts: 快速切换 mac 窗口\nfirefox(火狐浏览器,虽然 Google 浏览器很强了,不过国内有些软件需要这个)\nthe-unarchiver (只能)解压软件\nkeka 解压压缩都行,\nqq : mac上只有 qq,暂时没有 TIM\niina % 视频播放器\nmounty %挂着 NTFS\nbaidunetdisk %百度网盘\n\nbrew cask install google-chrome\nbrew cask install typora\nbrew cask install sublime-text   \nbrew cask install github\nbrew cask install mathpix-snipping-tool\nbrew cask install tencent-lemon\nbrew cask install contexts\nbrew cask install firefox\nbrew cask install the-unarchiver \nbrew cask install keka\n        brew cask install qq\n                    brew cask install iina \nbrew cask install mounty \n            brew cask install baidunetdisk \n\nloopback: 收费软件,需要找到破解版,不建议用这个安装,结合 mac 自带的录屏软件,可以录制有声音的视频,不管是系统声音还是软件声音都行.\n\nbrew cask install loopback\n\njava 的安装,个人建议还是从官网下载安装对应的版本,我记得第一次试的时候,好像没有配置成功\n\n% 先安装 r 以及 rstudio 在安装java, 看能否配置成功\n        brew cask install r\n            brew cask install rstudio\n            \nbrew cask install java   %将会安装jdk的最新版本，jdk内嵌jre\nbrew cask install java8  %安装jdk8的最新版本\n\ngrammarly : 语法安装软件, 个人不推荐,因为有浏览器插件就够了\ncajviewer: caj 云阅读\nzotero: 论文参考文献管理, 可以快速进行期刊缩写与展开\nmendeley : 论文参考文献管理，可以快速进行期刊缩写与展开\njabref : 论文管理软件, 只适合 bibtex 文件的管理, 这个可以缩写期刊, 以及查找文献的 doi, 并且不修改原有的bibtex 文件信息(除非手动修改), 注意一定要找到对应期刊的 bst 文件,才能显示出适合的参考文献格式, 可以集合 zotero 以及 mendeley 的软件查找相应的参考文献样式或者直接从网站https://www.zotero.org/styles查找下载相关参考文献的样式, 最终结合 bibtex 生成最终的 pdf(bibtex文件生成的临时文件 *.bbl 就是对应的的thebibliography环境以及bibitem条目 ), 备注: 个人推荐 jabref, 然后全部的参考文献都去 Google 学术上下载 bibtex 文件,不能一会从百度学术一会从谷歌学术下载,或者从相应的参考软件下载,这样会很乱, 注意:谷歌浏览器插件MyBibCitation Generator 也能产生相应的参考文献样式\njabref % 建议安装开发版本,这个默认是稳定版本\n\nbrew cask install grammarly \nbrew cask install cajviewer \nbrew cask install zotero\nbrew cask install mendeley\nbrew cask install jabref     \n# 建议安装开发版本,这个默认是稳定版本s"
  },
  {
    "objectID": "posts/md/Rweka.html",
    "href": "posts/md/Rweka.html",
    "title": "Rweka包解读",
    "section": "",
    "text": "WOW()：查看Weka函数的参数。\nWeka_control()：设置Weka函数的参数。\nread.arff()：读(ARFF)格式的数据。一般的数据需要用这两个函数（先写再读）进行转换成（arff）格式的数据\nwrite.arff()：将数据写入Weka Attribute-Relation File Format (ARFF)格式的文件。"
  },
  {
    "objectID": "posts/md/Rweka.html#数据预处理",
    "href": "posts/md/Rweka.html#数据预处理",
    "title": "Rweka包解读",
    "section": "2. 数据预处理",
    "text": "2. 数据预处理\n\nNormalize()：无监督的标准化连续性数据,即min-max标准化。对于字符、逻辑、因子变量跳过，只对连续数据标准化\nDiscretize()：用MDL(最小描述长度)方法，有监督的离散化连续性数值数据。感觉用处不大，把连续的数据全离散成“all”字符"
  },
  {
    "objectID": "posts/md/Rweka.html#分类和回归",
    "href": "posts/md/Rweka.html#分类和回归",
    "title": "Rweka包解读",
    "section": "3. 分类和回归",
    "text": "3. 分类和回归\n\nIBk()：k最近邻分类，用法和LBR一样\nLBR()：naive Bayes法分类\n\n   RWeka包中的IBK函数实现knn算法\n        * model=IBk(formula, data, subset, na.action,control = Weka_control(), options = NULL)\n                + formula:公式，分类变量~特征，和回归一样\n                + data : 训练数据集,必须为*.raff格式的数据,对于R中的数据，\n                      + 可以先把某个对象先用write.arff(iris,'iris.arff')写成raff文件格式\n                      + 再次用read.arff(\"iris.arff\")读入R内存中即可\n                + control:参数控制 control=Weka_control(K= 22,X = TRUE) \n                      + X K都为大写，表示自动选取1：K=22里面最适合的K近邻分类 \n             \n        * evaluate_Weka_classifier(object, newdata = NULL, cost = NULL, \n                                   numFolds = 0, complexity = FALSE,\n                                   class = FALSE, seed = NULL, ...)\n                + object: 一个Weka_classifier对象,Rweka建立的分类对象模型\n                + newdata: 测试数据，若为省略或为0 ，则为训练数据\n                + numFolds： k-交叉验证\n\nJ48()：C4.5决策树算法（决策树在分析各个属性时，是完全独立的）。\nLMT()：组合树结构和Logistic回归模型，每个叶子节点是一个Logistic回归模型，准确性比单独的决策树和Logistic回归方法要好。\nM5P()：M5 模型数算法，组合了树结构和线性回归模型，每个叶子节点是一个线性回归模型，因而可用于连续数据的回归。\nDecisionStump()：单层决策树算法，常被作为boosting的基本学习器。\nSMO()：支持向量机分类\nAdaBoostM1()：Adaboost M1方法。-W参数指定弱学习器的算法。\nBagging()：通过从原始数据取样(用替换方法)，创建多个模型。\nLogitBoost()：弱学习器采用了对数回归方法,学习到的是实数值\nMultiBoostAB()：AdaBoost 方法的改进，可看作AdaBoost 和 “wagging”的组合。\nStacking()：用于不同的基本分类器集成的算法。\nLinearRegression()：建立合适的线性回归模型。\nLogistic()：建立logistic回归模型。\nJRip()：一种规则学习方法。\nM5Rules()：用M5方法产生回归问题的决策规则。\nOneR()：简单的1-R分类法。\nPART()：产生PART决策规则。"
  },
  {
    "objectID": "posts/md/Rweka.html#聚类",
    "href": "posts/md/Rweka.html#聚类",
    "title": "Rweka包解读",
    "section": "4) 聚类",
    "text": "4) 聚类\n\nCobweb()：这是种基于模型方法，它假设每个聚类的模型并发现适合相应模型的数据。不适合对大数据库进行聚类处理。\nFarthestFirst()：快速的近似的k均值聚类算法\nSimpleKMeans()：k均值聚类算法\nXMeans()：改进的k均值法，能自动决定类别数\nDBScan()：基于密度的聚类方法，它根据对象周围的密度不断增长聚类。它能从含有噪声的空间数据库中发现任意形状的聚类。此方法将一个聚类定义为一组“密度连接”的点集。"
  },
  {
    "objectID": "posts/md/Rweka.html#关联规则",
    "href": "posts/md/Rweka.html#关联规则",
    "title": "Rweka包解读",
    "section": "5）关联规则",
    "text": "5）关联规则\n\nApriori()：Apriori 是关联规则领域里最具影响力的基础算法，是一种广度优先算法，通过多次扫描数据库来获取支持度大于最小支持度的频繁项集。它的理论基础是频繁项集的两个单 调性原则：频繁项集的任一子集一定是频繁的；非频繁项集的任一超集一定是非频繁的。在海量数据的情况下，Apriori 算法的时间和空间成本非常高。\nTertius()：Tertius算法。"
  },
  {
    "objectID": "posts/md/Rweka.html#预测和评估",
    "href": "posts/md/Rweka.html#预测和评估",
    "title": "Rweka包解读",
    "section": "6）预测和评估：",
    "text": "6）预测和评估：\n\npredict()：根据分类或聚类结果预测新数据的类别\ntable()：比较两个因子对象\nevaluate_Weka_classifier()：评估模型的执行，如：TP Rate，FP Rate，Precision，Recall，F-Measure。"
  },
  {
    "objectID": "posts/md/R语言与可视化.html",
    "href": "posts/md/R语言与可视化.html",
    "title": "R语言与可视化",
    "section": "",
    "text": "静态图形\n\n基础统计图\ngrDevice\nLattile\nGrid\nggplot2\n地图\nggmap\nggplot2\nmaptools\nmaps\nsp\n网络\nigraph\nlinkcomm\nstatmet\n特殊图形\n基因组的(ggbio……)\n\n\n\n动态图形\n\n非浏览器平台\nrgl\nrggobi(ggobi)\nanimation(animation)\nRGtk2\niplots\n\n\n\n动态图形\n\n浏览器平台\nggvis\nrCharts(http://ramnathv.github.io/rCharts/)\nrecharts (https://recharts.cosx.org/)\nplotly(https://plotly-r.com/, https://plot.ly/r/)\ngooglevis\nRemap(https://github.com/Lchiffon/REmap)\nhtmlwidgets 框架\n\nleaflet(地图)\ndygraphs (时间序列)\ndiagrammeR(diagram) – 化学结构\nnetwork3D (网格)\nDT (表格)\nthreeJS (3D数据展示)"
  },
  {
    "objectID": "posts/md/正则表达式通用.html",
    "href": "posts/md/正则表达式通用.html",
    "title": "正则表达式(通用)",
    "section": "",
    "text": "注意： 由于每个软件的正则表达式的转义字符是不一样的，比如R中一般用\\\\.来代表匹配小数点.\n表格中的\\ ，但在软件中可能需要\\\\才能表达出来，eg:\\d 匹配任意一个数字， 可能需要使用\\\\d\n\n\n\n\n\n\n\n\n\n\n\n元字符\n说明\n\n\n\n\n.\n匹配任意单个字符，字母、数字甚至是.字符本身\n\n\n|\n逻辑或操作符\n\n\n[ ]\n匹配该字符集合中的一个字符（各个字符之间是or关系） 注意:  [.] 只匹配点本身,不是特殊字符,不用转义.\n\n\n[^ ]\n对字符集合求非就是排除该字符集合[^0-9] ： 匹配任何不适数字的字符\n\n\n-\n定义一个区间,[A-Za-z09]: 匹配(大小)字母和数字-只有出现在[]之间才是元字符-出现在其他地方，则表示一个普通字符\n\n\n\\\n对下一个字符进行转义\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n元字符\n说明\n\n\n\n\n*\n匹配前一个字符(或字符集合或子表达式)的零次或多次重复\n\n\n+\n匹配前一个字符(或字符集合或子表达式)的一次或多次重复\n\n\n?\n匹配前一个字符(或字符集合或子表达式)的零次或一次重复\n\n\n*?\n*的懒惰型版本\n\n\n+?\n+的懒惰型版本\n\n\n{n}\n匹配前一个字符(或字符集合或子表达式)的n次重复\n\n\n{m,n}\n匹配前一个字符(或字符集合或子表达式)至少m次且至多n次重复\n\n\n{n, }\n匹配前一个字符(或字符集合或子表达式)n次重复或更多次重复（至少n次）\n\n\n{n, }?\n{n, }的懒惰型版本\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n元字符\n说明\n\n\n\n\n^\n匹配字符串的开头\n\n\n$\n匹配字符串的结束\n\n\n\\A\n匹配字符串的开头（大多数语言不支持, 类似^）\n\n\n\\Z\n匹配字符串的结束（大多数语言不支持, 类似$）\n\n\n\\<\n匹配单词的开头（是，支持的语言并不多见）\n\n\n\\>\n匹配单词的结束（是，支持的语言并不多见）\n\n\n\\b\n匹配单词的边界（开头或结束）eg: \\bcap\\b: 表示匹配cap这个完整单词. 因为\\b是边界，且匹配到的字符串长度为3个字符，而不是5个字符简单的说, \\b匹配的是一个这样的位置，一边是单词（能够被\\w匹配的字母、数字、和下划线,另一边是其他内容（能够被\\W相匹配的字符)\n\n\n\\B\n\\b的反义\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n元字符\n说明\n\n\n\n\n[\\b]\n退格字符\n\n\n\\c\n匹配一个控制字符\n\n\n\\d\n匹配任意一个数字字符（等价与 [0-9]）\n\n\n\\D\n\\d的反义 【匹配任意一个非数字字符（等价与[^0-9]）】\n\n\n\\f\n换页符\n\n\n\\n\n换行符\n\n\n\\r\n回车符\n\n\n\\s\n任何一个空白字符 （等价[\\f\\n\\r\\t\\v])\n\n\n\\S\n\\s的反义 （等价[^\\f\\n\\r\\t\\v])\n\n\n\\t\n制表符(Tab字符）\n\n\n\\v\n垂直制表符\n\n\n\\w\n匹配任意一个字母数字字符（大小写均可）或下划线字符 （等价[a-zA-Z0-9_]）\n\n\n\\W\n\\w的反义 （等价[^a-zA-Z0-9_]）\n\n\n\\x\n匹配一个16进制数字\n\n\n\\0\n匹配一个8进制数字\n\n\n\n\n\n\n\n\n但并不是所用的语言都支持，JavaScript不支持\n\n\n\n\n\n\n\n\n字符类\n说明\n\n\n\n\n[:alnum:]\n任何一个字母或数字（等价与[a-zA-Z0-9]）\n\n\n[:alpha:]\n任何一个字母（等价与[a-zA-Z]）\n\n\n[:blank:]\n空格或制表符（等价与[\\t ] ) 注意：这里t后面有一个空格\n\n\n[:cntrl:]\nASCII控制字符（ASCII 0 到31，再加上ASCII 127）\n\n\n[:digit:]\n任何一个数字（等价于[0-9])\n\n\n[:graph:]\n和[:print:]一样，但不包括空格\n\n\n[:lower:]\n任何一个小写字母（等价于[a-z]）\n\n\n[:print:]\n任何一个可以打印的字符\n\n\n[:punct:]\n既不属于[:alnum:]也不属于[:cntrl:]的任何一个字符\n\n\n[:space:]\n任何一个空白符，包括空格（等价于[^\\f\\n\\r\\t\\v ]） 注意v后面有一个空格\n\n\n[:upper:]\n任何一个大写字母（等价于[A-Z]）\n\n\n[:xdigit:]\n任何一个16进制数字（等价于[a-fA-F0-9])\n\n\n\n\n\n\n\nimage-20200713131134821\n\n\n\n\n\n\n必须在（和）里面使用\n\n\n\n\n\n\n\n\n元字符\n说明\n\n\n\n\n( )\n定义一个子表达式( ()|() ) 子表达式嵌套\n\n\n\\1\n对前面的子表达式进行回溯引用，并且只能用于匹配括号里面的子表达式eg: 匹配第1个子表达式；\\2代表第2个子表达式：以此类推有些语言用的是 $1, $2, ....可以理解为变量\n\n\n(?=)\n向前查找\n\n\n(?<=)\n向后查找\n\n\n(?!)\n负向前查找（对向前查找取非）\n\n\n(?<!)\n负向后查找（对向后查找取非）\n\n\n(?(<条件>)ture)\n嵌入条件（if then） eg：(?(backference)ture-regex)在条件里使用回溯引用，可以不进行转义?(\\1)等价?(1)\n\n\n(?(<条件>)ture\\|false )\n嵌入条件（if then else）语法：(?(backference)ture-regex\\|false-regex)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n元字符\n说明\n\n\n\n\n\\E\n结束\\L或\\U转换\n\n\n\\l\n把下一个字符转换为小写\n\n\n\\u\n把下一个字符转换为大写\n\n\n\\L\n把\\L到\\E之间的字符全部转换为小写（\\U、\\L要和\\E配合使用）\n\n\n\\U\n把\\U到\\E之间的字符全部转换为大写\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n元字符\n说明\n\n\n\n\n(?m)\n多行匹配模式（许多语言不支持）将换行符视为字符串分隔符\n\n\n\n在多行匹配模式下，^即可以匹配字符串的开头，也可以匹配行换行符之后的起始位置(新行)$不仅能匹配字符串结尾，还能匹配换行符之后的结束位置。\n\n\n\n使用时: (?m)必须出现在整个模式的最前面\n\n\n\n\n\n\n\n注意: 子表达式的查找替换问题\n常常需要从查找某些特定的文本, 然后从中提取某些信息, 即查找替换本身都是正则表达式组成, 例如\n\n查: (,)([A-Za-z0-9])    % 查找\n换: $1 $2   or  \\1 \\2   % 在子表达式中间价格空格等等\n注意: sublime  替换时可能出现大小写问题,一定要不要点击保持大写这个按钮,就是替换前面的那个 AB 按钮\n\n注意：POSIX字符类的使用\n通常情况下： 使用两个来[[开头，以]]结束, 这是使用POSIX字符类所必须的.外层的[ ] 表示定义一个字符集合,内层的[ ]表示POSIX字符类本身的组成部分\n\n[[:blank:]]    %代表一个空格, \n参考链接:正则表达式必知必会(已修整)"
  },
  {
    "objectID": "posts/md/非线性规划.html",
    "href": "posts/md/非线性规划.html",
    "title": "非线性规划",
    "section": "",
    "text": "非线性规划问题\n\\[\n\\begin{aligned}\n\\min \\quad & f(x)\\\\\n\\text { s.t. } & \\begin{cases}\n{g(x)=0} \\\\{l_{h} \\leq h(x) \\leq u_{h}} \\\\ {l_{x} \\leq x \\leq u_{x}}\n\\end{cases}\n\\end{aligned}\n\\]\n其中, \\(f(x),g(x),h(x)\\) 都是光滑函数,\n solnp(pars, fun, eqfun = NULL, eqB = NULL, ineqfun = NULL, ineqLB = NULL, \n     ineqUB = NULL, LB = NULL, UB = NULL, control = list(), ...)\n  # 参数解释\n  pars  :  初始值(向量), \n  fun   :  最小化的目标函数值，输入为pars参数，输出为一个单一值,等价上述问题的f(x)\n  eqfun :  (可选) 等式约束(左边) ，等价与上述问题的 g(x)\n  egB : (可选) 等式约束右边值，等价上述问题g(x) = 0 的0 \n  ineqfun : (可选) 不等式约束，等价上述问题的 h(x)\n  ineqLB :(可选) 不等式约束的下限 ，等价于上述问题的 lh\n  ineqUB :(可选) 不等式约束的上限 ，等价于上述问题的 uh\n  LB :(可选) 参变量的下限 ，等价于上述问题的lx\n  UB: (可选) 参变量的上限 ，等价于上述问题的ux \n  control :(可选) 优化参数控制表。\n例子： \\[\n\\begin{aligned}\n\\min  & \\quad exp({\\prod_{i=1}^{5}x_i}) \\\\\n\\text {s.t.} & \\begin{cases}\n& x_1^2 +x_2^2 +x_3^2+x_4^2+x_5^2 = 10 \\\\\n& x_2x_3-5x_4x_5 = 0 \\\\\n& x_1^3 +x_2^3 = -1\n\\end{cases}\n\\end{aligned}\n\\]\n# POWELL Problem\nlibrary(Rsolnp)\nfn1=function(x){\n    exp(x[1]*x[2]*x[3]*x[4]*x[5])\n}\neqn1=function(x){\n    z1=x[1]*x[1]+x[2]*x[2]+x[3]*x[3]+x[4]*x[4]+x[5]*x[5]\n    z2=x[2]*x[3]-5*x[4]*x[5]\n    z3=x[1]*x[1]*x[1]+x[2]*x[2]*x[2]\n    return(c(z1,z2,z3))\n}\n\nx0 = c(-2, 2, 2, -1, -1)\npowell=solnp(x0, fun = fn1, eqfun = eqn1, eqB = c(10, 0, -1))\n具体参考:https://cran.r-project.org/web/packages/Rsolnp/index.html"
  },
  {
    "objectID": "posts/md/非线性规划.html#rdonlp2",
    "href": "posts/md/非线性规划.html#rdonlp2",
    "title": "非线性规划",
    "section": "Rdonlp2",
    "text": "Rdonlp2\n这个包有一定的问题，我在运行的时候第一次几乎都正常，能得到正确结果，第二次直接系统崩溃。\nif(!require('Rdonlp2')) install.packages(\"Rdonlp2\", repos=\"http://R-Forge.R-project.org\")\n模型格式如下： \\[\n\\begin{array}{l}{\\min z=f(\\mathbf{x})} \\\\ {\\qquad \\begin{array}{l}{\\mathrm{x}_{1} \\leqslant \\mathrm{x} \\leqslant \\mathrm{x}_{\\mathrm{u}}} \\\\ {\\mathrm{b}_{1} \\leqslant \\mathrm{Ax} \\leqslant \\mathrm{b}_{\\mathrm{u}}} \\\\ {\\mathrm{c}_{1} \\leqslant \\mathrm{c}(\\mathrm{x}) \\leqslant \\mathrm{c}_{\\mathrm{u}}}\\end{array}}\\end{array}\n\\] 具体可参考: (R软件在最优化中的应用)[]"
  },
  {
    "objectID": "posts/md/非线性规划.html#matlab-fmincon",
    "href": "posts/md/非线性规划.html#matlab-fmincon",
    "title": "非线性规划",
    "section": "Matlab:: fmincon",
    "text": "Matlab:: fmincon\n可参考 官网函数解释https://www.mathworks.com/help/optim/ug/fmincon.html\nhttps://wenku.baidu.com/view/6bcb651d0b4e767f5acfce97.html?sxts=1561344526517\nhttps://blog.csdn.net/qq_38784454/article/details/80329021\n《MATLAB数学建模》李昕——清华大学出版\n\nexample\n\\[\n\\begin{array}{l}\n\\min f(x) \\\\\n\\text {s.t.}\\left\\{\\begin{array}{l}\nA \\cdot x \\leq b \\\\\n\\text {Aeq} \\cdot x=beq \\\\\nc(x) \\leq 0 \\\\\n\\operatorname{ceq}(x)=0 \\\\\nl b \\leq x \\leq u b\n\\end{array}\\right.\n\\end{array}\n\\] 其中 \\(f(x)\\)是目标函数, \\(x, b, beq\\)是向量, \\(A, Aeq\\)是矩阵, \\(c(x)\\) 和 \\(ceq(x)\\) 是向量函數\n% 2.基本语法\n[x,fval]=fmincon(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon,options)\n% 参数解释\nx的返回值是决策向量x的取值，fval的返回值是目标函数f(x)的取值\nfun是用M文件定义的函数f(x),代表了(非)线性目标函数\nx0是x的初始值\nA,b,Aeq,beq定义了线性约束 ,如果没有线性约束，则A=[],b=[],Aeq=[],beq=[]\nlb和ub是变量x的下界和上界，如果下界和上界没有约束，则lb=[],ub=[],也可以写成lb的各分量都为 -inf,ub的各分量都为inf\nnonlcon是用M文件定义的非线性向量函数约束\noptions定义了优化参数，不填写表示使用Matlab默认的参数设置\n\n\n例\n\\[\n\\begin{aligned}\n\\min f(x) = x_{1}^{2}+x_{2}^{2}+x_{3}^{2}+8 \\\\\n\\text { s. t. }\\left\\{\\begin{array}{l}\nx_{1}^{2}-x_{2}+x_{3}^{2} \\geq 0 \\\\\nx_{1}+x_{2}^{2}+x_{3}^{2} \\leq 20 \\\\\n-x_{1}-x_{2}^{2}+2=0 \\\\\nx_{2}+2 x_{3}^{2}=3 \\\\\nx_{1}, x_{2}, x_{3} \\geq 0\n\\end{array}\\right.\n\\end{aligned}\n\\]\nclc,clear all\nx0 = rand(3,1);  % 初始值\nAeq = [];               % 线性等式约束的系数（左边的系数）\nbeq = [];                % 线性等式约束的值 （右边的值）\n%A = [];                % 线性不等式约束的系数\n%b = [];                % 线性等式约束的值\nub = [];      % 变量的上限（取等号）\nlb = repelem(0,3);      % 变量的下限（取等号）\n\n[x,y]=fmincon(@myobjfun,x0,[],[],Aeq,beq,lb,ub,@constrain)\n\nfunction f = myobjfun(x)\nf=x(1).^2+x(2).^2+x(3).^2+8;\nend\n\nfunction [g,h]=constrain(x)\ng=[-x(1).^2+x(2)-x(3).^2\n    x(1)+x(2).^2+x(3).^3-20]; % 不等式\nh=[-x(1)-x(2).^2+2\n    x(2)+2*x(3).^2-3]; % 等式约束\nend\n也可以这样写\n(1)编写M函数myobjfun.m 定义目标函数：\nfunction f=myobjfun(x)\n    f=x(1).^2+x(2).^2+x(3).^2+8;\nend\n(2)编写M函数constrain.m定义非线性约束条件:\nfunction [g,h]=constrain(x)\n  g=[-x(1).^2+x(2)-x(3).^2\n      x(1)+x(2).^2+x(3).^3-20];\n  h=[-x(1)-x(2).^2+2\n      x(2)+2*x(3).^2-3];\n  end\n(3)编写主程序函数\n[x,y]=fmincon('fun1',rand(3,1),[],[],[],[],zeros(3,1),[],'fun2')\n运行即可得到结果\n参考 : https://www.cnblogs.com/goodtwo/p/11146540.html"
  },
  {
    "objectID": "posts/md/非线性规划.html#常用非线性规划模型我",
    "href": "posts/md/非线性规划.html#常用非线性规划模型我",
    "title": "非线性规划",
    "section": "常用非线性规划模型(我)",
    "text": "常用非线性规划模型(我)\n\\[\n\\begin{aligned}\nMin \\quad & \\sum_{i=1}^{n} \\sum_{j=1}^{n}\\left(\\omega_{i}-a_{i j} \\omega_{j}\\right)^{2}\\\\  \ns.t \\quad & \\sum_{i=1}^{n} \\omega_{i}=1,\\\\\n& 1\\geq \\omega_{i} \\geq 0, \\quad i=1,2, \\ldots, n\n\\end{aligned}\n\\]\n于是自己写了几个函数模板:\n\nR\nlibrary(Rsolnp)\n## 最小化的目标函数\nobj=function(x){\n  A1 = matrix(c(1,4,3,1,3,4,\n                1/4,1,7,3,1/5,1,\n                1/3,1/7,1,1/5,1/5,1/6,\n                1,1/3,5,1,1,1/3,\n                1/3,5,5,1,1,3,\n                1/4,1,6,3,1/3,1),ncol = 6,nrow = 6,byrow = T)\n  s = 0\n  n = nrow(A1)\n  for(i in 1:n){\n    for(j in 1:n){\n      s= s+ (x[i]- A1[i,j]*x[j])^2;\n    }\n  }\n  return(s)\n}\n## 编写解上述非线性规划的函数\nfmin = function(f,n){# n代表参数的个数\n  eqn1=function(x){\n    sum(x)\n  } # 等式约束的左边  ，eqB 为等式约束的右边，如果有多个则用向量\n  powell=solnp(pars= rep(1/n,n), fun = f, eqfun = eqn1, eqB = 1,LB= rep(0,n) ,UB = rep(1,n))\n  fx = powell$values\n  x = powell$pars\n  return(  list('x' = x, 'fx' = fx[length(fx)]) )\n}\nfmin(obj,n = 6) #调用即可，n代表参数的个数\n\n\n\n########################################\nlibrary(Rdonlp2)\nobjFun = function(x){\n  A1 = matrix(c(1,4,3,1,3,4,\n                1/4,1,7,3,1/5,1,\n                1/3,1/7,1,1/5,1/5,1/6,\n                1,1/3,5,1,1,1/3,\n                1/3,5,5,1,1,3,\n                1/4,1,6,3,1/3,1),ncol = 6,nrow = 6,byrow = T)\n  s = 0\n  n = nrow(A1)\n  for(i in 1:n){\n    for(j in 1:n){\n      s= s+ (x[i]- A1[i,j]*x[j])^2;\n    }\n  }\n  return(s)\n}\nfmin = function(objFun,n){ # 这里n为未知参数的个数.\n  x0 = rep(1/n,n)\n  lb = rep(0,n) # 自变量的下限\n  ub = rep(1,n) # 自变量的上限\n  Aeq = matrix(rep(1,n),1,n) \n  lbeq = 1\n  ubeq = 1\n  ret = donlp2(x0,objFun,par.lower = lb , par.upper = ub,A = Aeq,lin.lower = lbeq,lin.upper = ubeq)\n  list('x' = ret$par,'objvalue' = ret$fx)\n}\n\nfmin(objFun,n = 6)# 只需要改写objFun 就可以了\n\n\nMatlab\n把上述文件存储为fmin.m，以后只需要更改目标函数myobjfun(x,AA)即可,其中x代表未知数, AA 代表目标函数的系数，\nfunction x = fmin(AA) % 调用函数接口\nn = size(AA,1) ; % 未知数x的长度 \nx0 = repelem(1/n,n);    % 初始迭代位置\nAeq = repelem(1,n);     % 线性等式约束的系数（左边的系数）\nbeq = 1;                % 线性等式约束的值 （右边的值）\n%A = [];                % 线性不等式约束的系数\n%b = [];                % 线性等式约束的值\nub = repelem(1,n);      % 变量的上限（取等号）\nlb = repelem(0,n);      % 变量的下限（取等号）\n[x,fval] = fmincon(@(x)myobjfun(x,AA),x0,[],[],Aeq,beq,lb,ub);\n%[x,fval] = fmincon(@myobjfun,x0,[],[],Aeq,beq,lb,ub,[],[],options,A);\nend\n\n\n% 目标函数\nfunction s = myobjfun(x,AA)\nn = size(AA,1);\ns =0;\nfor i = 1:n\n    for j = 1:n\n        s= s+ (x(i)- AA(i,j)*x(j))^2;\n    end\nend\nend"
  },
  {
    "objectID": "posts/md/R中时间类型概念.html",
    "href": "posts/md/R中时间类型概念.html",
    "title": "R中时间类型概念",
    "section": "",
    "text": "在R中，所有有关时间和日期的类(包),都可以处理日历时间(eg:2018年4月13日)，只有某些特定的类才能处理日期时间类型(eg:2018年4月13日 下午6:45)\n\n\n\n\n\n\n\n\n\n\n类\n处理类型\n说明\n强制转换\nR所在包\n\n\n\n\nDate类\n日历日期\n实际存储的为数字，是从1970年1月1日算起到该时间以天计算的一个数值.eg: “2018-04-13”\nas.Date()\n基本函数\n\n\nPOSIXct类\n日期时间\n实际存储的为数字，是从1970年1月1日算起到该时间以秒计算的一个数值.eg: “2018-04-13 19:47:18 CST”个人建议使用这个，存储数据\nas.POSIXct()\n基本函数\n\n\nPOSIXlt类\n日期时间\n实际存储为含有9个元素的列表,其中包括年、月、日、小时、分钟、秒。eg: “2018-04-13 19:47:18 CST”存储非结构化数据\nas.POSIXlt()\n基本函数\n\n\nDate类\n日历日期\n同上\nas_date()\nlubridate包\n\n\nPOSIXct类\n日期时间\n同上\nas_datetime()\nlubridate包\n\n\ndifftime类\n时间\n实际存储的为数字，是从当天00:00:00算起到该时间以秒计算的一个数值.eg:“00:01:25”\nhms::as.hms(85)\nlubridate包\n\n\n\n在实际工作中，只要满足要求，尽量适用比较简单的类型，先考虑Date ，在考虑POSIXct"
  },
  {
    "objectID": "posts/md/R中时间类型概念.html#r中处理时间序列的包",
    "href": "posts/md/R中时间类型概念.html#r中处理时间序列的包",
    "title": "R中时间类型概念",
    "section": "R中处理时间序列的包：",
    "text": "R中处理时间序列的包：\n\nchron ： 常用于计量经济学和时间序列分析中\nlubridate： 推荐,特别适用于处理日期时间算法\nmondate: 特别适用于处理以月为单位的日期，（会计和精算工作中常用）\ntimeDate： 很强大，对时间精度要求高的话，可以考虑"
  },
  {
    "objectID": "posts/md/R中时间类型概念.html#时间的基本用法",
    "href": "posts/md/R中时间类型概念.html#时间的基本用法",
    "title": "R中时间类型概念",
    "section": "时间的基本用法",
    "text": "时间的基本用法\n\n字符串转换为日期： as.Date(x ,format=“%m/%d/%y”) ,建议format参数不能省，否则有时会出错\n日期转化为字符串: as.characher() 或者 format()\n把日期（Date类和POSIXct类）转换为整数 ： unclass(x)或者 as.integer(x)\n把整数转化为日期: as.Date() 或者 as.POSXIce()\n把年、月、日 …等元素合并为日期 ：\n\nISOdatetime(year, month, day, hour, min, sec, tz = ““)\nISOdate(year, month, day, hour = 12, min = 0, sec = 0, tz = “GMT”)\n\n给定日期 提取年、月、日、…等：\n\n先把其转化为POSIXlt类，根据POSIXlt类是一个列表，提取相应的元素\n\n\n当然这些是R的基本函数与方法，有更强大的处理时间的lubridate包,推荐使用。"
  },
  {
    "objectID": "posts/md/goinstall.html",
    "href": "posts/md/goinstall.html",
    "title": "1、go语言安装与LiteIDE的配置",
    "section": "",
    "text": "在cmd 命令中输入 ：go env 显示\nset GOARCH=amd64                              #    cpu架构   \nset GOBIN=                                  # 工作目录下的bin文件夹  \nset GOEXE=.exe                               # 生成可执行文件的后缀  \nset GOHOSTARCH=amd64                        #交叉编译参数  \nset GOHOSTOS=windows                        #交叉编译参数   \nset GOOS=windows                          #当前系统名称  \nset GOPATH=C:\\Users\\zsc\\go               # 我的工作目录  \nset GORACE=                                       #  \nset GOROOT=F:\\go                             #go的安装目录  \nset GOTOOLDIR=F:\\go\\pkg\\tool\\windows_amd64   #   \nset GCCGO=gccgo  \nset CC=gcc  \nset GOGCCFLAGS=-m64 -mthreads -fmessage-length=0 -fdebug-prefix-map=C:\\Users\\zsc\\AppData\\Local\\Temp\\go-build974907835=/tmp/go-build -gno-record-gcc-switches\nset CXX=g++  \nset CGO_ENABLED=1   \nset CGO_CFLAGS=-g -O2  \nset CGO_CPPFLAGS=  \nset CGO_CXXFLAGS=-g -O2  \nset CGO_FFLAGS=-g -O2  \nset CGO_LDFLAGS=-g -O2  \nset PKG_CONFIG=pkg-config  \n好像这后面的可以不用管，去电脑的环境变量里面新增\n\n\n\ngo1-2\n\n\n解压下载好的liteide，把解压后的目录放在go安装的目录中（我的安装go目录为F：）进入F:.exe 文件，双击进入\n接着配置liteide工具，点击【工具】–【选择环境】–【win64】 ，，再次进入【工具】–【编辑当前环境】\n\n\n\ngo1-3\n\n\n好像就成功了\n再次检查一下，进入cmd 输入 go env 与go version，go的版本1.9.2，成功\n\n\n\ngo1-4\n\n\n进入LiteIDE测试\n点击【文件】–新建—GO1 command Project 即可，输入go程序，\n// week1 project main.go\npackage main\n\nimport \"fmt\"\n\nfunc createMessage(name string) string {\n    if len(name) == 0 {\n        return \"Hello world\"\n    } else {\n        return \"Hello \" + name\n    }\n}\nfunc main() {\n    fmt.Println(createMessage(\"Tom\"))\n    fmt.Println(createMessage(\"\"))\n}\n先编译（ctrl+B）—在运行(ctrl+alt+R)，就能看到结果：（和c的运行一样）\n\n\n\ngo1-5\n\n\n对静态语言不熟悉，几乎小白，见谅！"
  },
  {
    "objectID": "mac.html",
    "href": "mac.html",
    "title": "mac笔记",
    "section": "",
    "text": "mac终端样式PS1\nmac重装系统1起因\nmac重装系统2系统制作与安装\nmac重装系统3系统设置\nmac重装系统4软件安装\nmac重装系统5sublime配置\nmac重装系统6抹掉所有内容和设置\nmacOS tcping 检测IP端口"
  },
  {
    "objectID": "matlab.html",
    "href": "matlab.html",
    "title": "matlab笔记",
    "section": "",
    "text": "MATLAB函数中参数的问题\nmatlab 问题集合基础\nMATLAB 与 R 在排序上的区别\nMATLAB集合"
  },
  {
    "objectID": "uncertain.html",
    "href": "uncertain.html",
    "title": "uncertain理论笔记",
    "section": "",
    "text": "不确定多属性决策方法徐泽水pdf\n1.5.2离差最大化的多属性决策方法\n1.6 基于信息熵的多属性决策方法\n1.7方案有偏好信息的多属性决策方法\n2.1 模糊互补判断矩阵的排序方法\n3.1 基于理想点的多属性决策方法\n3.2 基于方案满意度的多属性决策方法\n3.3 基于方差最大化模型的多属性决策方法\n4.1 基于可能度的多属性决策方法\n4.2基于投影的多属性决策方法(含4.3区间归一化)\n正互反矩阵一致性调整方法(徐泽水1999)\n求区间可能度矩阵的算法(Liu 2009)\n残缺区间群体决策模型（GDM Liu 2012)"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "自动迁移\n学习笔记"
  },
  {
    "objectID": "posts/uncertain/2019-02-26-3-3基于方差最大化模型的多属性决策方法.html",
    "href": "posts/uncertain/2019-02-26-3-3基于方差最大化模型的多属性决策方法.html",
    "title": "3.3 基于方差最大化模型的多属性决策方法",
    "section": "",
    "text": "Show the code##  3.3 基于方差最大化模型的多属性决策方法---徐泽水《不确定多属性决策方法与应用》84页 --3.3.2 实例分析\nlibrary(data.table)\nlibrary(dplyr)\nA = c(18400,3,100,80,300,60,40,1.2,\n      19600,4,120,100,400,80,40,1.3,\n      29360,6,540,120,150,100,50,1.5) \n\nA= matrix(A,nrow = 3,ncol = 8,byrow = T) %>% data.table()\nA # 原始决策矩阵\n#>       V1 V2  V3  V4  V5  V6 V7  V8\n#> 1: 18400  3 100  80 300  60 40 1.2\n#> 2: 19600  4 120 100 400  80 40 1.3\n#> 3: 29360  6 540 120 150 100 50 1.5\n\n#### 第一步: 把原始决策矩阵A 利用适当的方法进行规范化为R，R为归一化后的矩阵\n### norm_matrix()函数，根据书中收益型属性（按公式1.2）与成本型属性(按公式1.4)分别进行归一化\n#####  注意这个与前面的norm_matrix 函数结果相同，只是代码显得更少了,保证了列名不变\nnorm_matrix = function(A, shouyi = NULL, chengben = NULL) {\n  stopifnot(!is.null(shouyi) | !is.null(chengben))\n  if (is.matrix(A)) A = data.table(A)\n  m = ncol(A)\n  if (is.null(chengben)) chengben = setdiff(1:m, shouyi)\n  if (is.null(shouyi)) shouyi = setdiff(1:m, chengben)\n  # 如果输入的shouyi与chengben向量交集不为空，且并集不是全集，则算法出错\n  stopifnot(length(intersect(shouyi, chengben)) == 0, setequal(union(shouyi, chengben), 1:m))\n  R =copy(A) # 重新赋值\n  if (length(chengben) == 0) {\n    R[, colnames(R)[shouyi] := lapply(.SD, function(x) x / max(x)), .SDcols = shouyi] # 收益型属性归一化 （书中1.2式）\n  } else if (length(shouyi) == 0) {\n    R[, colnames(R)[chengben] := lapply(.SD, function(x) min(x) / x  ), .SDcols = chengben]# 成本型属性归一化 （书中1.3式）\n  } else{\n    R[, colnames(R)[shouyi] := lapply(.SD, function(x) x / max(x)), .SDcols = shouyi] # 收益型属性归一化 （书中1.2式）\n    R[, colnames(R)[chengben] := lapply(.SD, function(x) min(x) / x  ), .SDcols = chengben]# 成本型属性归一化 （书中1.3式）\n  }\n  return(setDF(R))\n}\nR = norm_matrix(A, chengben = c(1:3))\nround(R,3)\n#>      V1   V2    V3    V4    V5  V6  V7    V8\n#> 1 1.000 1.00 1.000 0.667 0.750 0.6 0.8 0.800\n#> 2 0.939 0.75 0.833 0.833 1.000 0.8 0.8 0.867\n#> 3 0.627 0.50 0.185 1.000 0.375 1.0 1.0 1.000\n\n\n\n#### 第二步 ： 利用模型 M-3.11 求解线性规划\nM_w = function(R,lower_c,upper_c){\n  n = nrow(R)\n  m = ncol(R)\n  deta = matrix(0,nrow = n,ncol = m)\n  for(i in 1:n){\n    for(j in 1:m){\n      for(k in 1:n){\n        deta[i,j] = deta[i,j] + (R[i,j] - R[k,j])^2\n      }\n    }\n  }\n  \n  library(Rglpk)\n  obj = c(apply(deta, 2, sum)) # 设置目标函数\n  mat = matrix(rep(1,m),nrow = 1) # 约束条件，权和向量为1 \n  dir = c(\"==\")\n  rhs = c(1)\n  types = c(\"C\")\n  bounds <- list(lower = list(ind = 1L:m, val = lower_c),\n                 upper = list(ind = 1L:m, val = upper_c))\n  return(Rglpk_solve_LP(obj, mat, dir, rhs, bounds, types,max =TRUE )$solution)\n}\nw = M_w(R,lower_c = c(0.1,0.12,0.11,0.12,0.07,0.2,0.18,0.09),\n        upper_c = c(0.2,0.14,0.15,0.16,0.12,0.3,0.21,0.22))\nw # 权重\n#> [1] 0.10 0.12 0.12 0.12 0.07 0.20 0.18 0.09\n\n##### 第三步： 求出各方案的综合属性值\nz = apply(R, 1, function(x)sum(x*w))\nz\n#> [1] 0.8085000 0.8358776 0.7611425\n#########第四步，#按降序排列，最大的为方案最优\nround(z,4)%>% rank %>% order(.,decreasing=T)#按降序排列，最大的为最优\n#> [1] 2 1 3"
  },
  {
    "objectID": "posts/post/list操作.html",
    "href": "posts/post/list操作.html",
    "title": "list操作",
    "section": "",
    "text": "以前提过可参考：(这里直接copy)\n1.捕获省略号中的内容\n​ 先看一个例子：构造一个函数然后对所有的参数进行相加求和。\n\nShow the codeaddemup <- function(x, ...){\n   args <- list(...)# 推荐把省略号的内容分配给list,然后在对该list进行操作\n   for (a in args){\n                x <- x + a \n   } \n   x\n }\n\naddemup(1,1)\n#> [1] 2\naddemup(1,2,3,4,5)\n#> [1] 15\n\n\n​ 我们还可以通过..1,..2到..9等直接引用列表…中的内容。..1表示第一项，..2表示第二项，以此类推。\n对list操作可以结合purrr包中的map, reduce, accumulate和基础函数do.call等 操作更方便。一个实际的例子，\nDGM_U = function(...){\n  #######  第一部分是对参数的检查 #####################\n  # 输入的参数为U_{k}，U_{k}代表一个完整的区间乘积互反判断矩阵。\n  n = nrow(..1)\n  m = ncol(..1)\n  args <- list(...)\n  stopifnot( length(args) >=2, all( map_lgl(args,is.matrix)),2*n ==m )\n  # 检查所有的矩阵维度是否一样\n  library(purrr)\n  t = map(args,dim) %>% do.call(rbind, .) \n  stopifnot( nrow(unique(t)) == 1)\n  \n  ####### 第二部分 对参数的操作，达到想要的目的###########\n  ## 1. 使用快捷的函数\n  k = 1 / length(args)\n  UB = reduce( map(args,function(x)fenjie(x)$B),`*`)^k\n  UD = reduce( map(args, function(x)fenjie(x)$D), `*`)^k\n  \n  ## 2. 使用循环操作\n  # UB = matrix(1,nrow = n, ncol = n)\n  # UD = matrix(1,nrow = n, ncol = n)\n  # for(xx in args){\n  #   B = fenjie(xx)$B\n  #   D = fenjie(xx)$D\n  #   for(i in 1:n){\n  #     for(j in 1:n){\n  #       UB[i,j] = UB[i,j] * B[i,j]\n  #       UD[i,j] = UD[i,j] * D[i,j]\n  #     }\n  #   }\n  # }\n  # k = 1 / length(args)\n  # UB = UB^( k)\n  # UD = UD^(k)\n  return( hecheng(UB,UD))\n}\n\nDGM_U(U_t1,U_t2,U_t3)\n2.map函数\n​ 当然R自带也提供类似的Map函数，但是我们这里只讨论purrr::map函数 ,类似的有map2() , pmap()\nmap(.x, .f, ...)\n# 该函数作用是把每一个函数应用在list中的每一个元素上，或者向量中的每一个元素上。\n# x为一个list或者向量\n# .f 提供的函数\n什么叫list中的每一个元素，比如：\n\nShow the codel = list(a = 1:3,b=matrix(1:9,nrow =3), d = list(1:9))\nl\n#> $a\n#> [1] 1 2 3\n#> \n#> $b\n#>      [,1] [,2] [,3]\n#> [1,]    1    4    7\n#> [2,]    2    5    8\n#> [3,]    3    6    9\n#> \n#> $d\n#> $d[[1]]\n#> [1] 1 2 3 4 5 6 7 8 9\n\n\n​ 该list 中只有3个元素，第一个元素是向量1:3, 第二个元素是矩阵，第三个元素是一个list。我们可以用length()函数求一个list中元素的个数。\n注意： 我们在利用函数参数...包装成list时候，一般输入的...的内容具有统一的格式.类似上面的情况。\n3.reduce 函数和accumulate 函数\n​ 这些函数都是对list中每一个元素进行操作的。无论这个元素的数据结构是什么，该元素可以是数值型向量，字符型向量、矩阵、数据框、list，这些都可以。\n4. do.call函数\n​ 操作对象也是list中的每一个元素，该函数有点类似于reduce,eg: 把list中的元素转变为matrix\nl = list(a= 1:3,b = 4:6,d = 7:9)\nreduce(l,rbind) # purrr包中的函数\ndo.call(rbind,l)\n\nreduce(l,cbind)\ndo.call(cbind,l)\n5. 把正常数据(数据框)转变为list\n​ 常常结合split函数进行使用, 首先给一个数据框，按照某种准则划分为一个list，最后利用purrr包中的函数对list中的每一个元素进行处理，\n\nShow the code## 以下分类建立一个线性回归模型\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(purrr)\n## 方法1：\nmod_fun <- function(df) lm(Sepal.Length ~ ., data = df)\nn_iris = iris %>% group_by(Species) %>% nest()\nn_iris %>% mutate(model = map(data, mod_fun))\n#> # A tibble: 3 × 3\n#> # Groups:   Species [3]\n#>   Species    data              model \n#>   <fct>      <list>            <list>\n#> 1 setosa     <tibble [50 × 4]> <lm>  \n#> 2 versicolor <tibble [50 × 4]> <lm>  \n#> 3 virginica  <tibble [50 × 4]> <lm>\n\nn_iris\n#> # A tibble: 3 × 2\n#> # Groups:   Species [3]\n#>   Species    data             \n#>   <fct>      <list>           \n#> 1 setosa     <tibble [50 × 4]>\n#> 2 versicolor <tibble [50 × 4]>\n#> 3 virginica  <tibble [50 × 4]>\n\n\n# 方法2：\nn_iris_1 = split(iris,iris$Species) \nn_iris_1 %>% map(., function(df)lm(Sepal.Length ~ ., data = df[,-5] )  )\n#> $setosa\n#> \n#> Call:\n#> lm(formula = Sepal.Length ~ ., data = df[, -5])\n#> \n#> Coefficients:\n#>  (Intercept)   Sepal.Width  Petal.Length   Petal.Width  \n#>       2.3519        0.6548        0.2376        0.2521  \n#> \n#> \n#> $versicolor\n#> \n#> Call:\n#> lm(formula = Sepal.Length ~ ., data = df[, -5])\n#> \n#> Coefficients:\n#>  (Intercept)   Sepal.Width  Petal.Length   Petal.Width  \n#>       1.8955        0.3869        0.9083       -0.6792  \n#> \n#> \n#> $virginica\n#> \n#> Call:\n#> lm(formula = Sepal.Length ~ ., data = df[, -5])\n#> \n#> Coefficients:\n#>  (Intercept)   Sepal.Width  Petal.Length   Petal.Width  \n#>       0.6999        0.3303        0.9455       -0.1698\n\n\nn_iris_1\n#> $setosa\n#>    Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1           5.1         3.5          1.4         0.2  setosa\n#> 2           4.9         3.0          1.4         0.2  setosa\n#> 3           4.7         3.2          1.3         0.2  setosa\n#> 4           4.6         3.1          1.5         0.2  setosa\n#> 5           5.0         3.6          1.4         0.2  setosa\n#> 6           5.4         3.9          1.7         0.4  setosa\n#> 7           4.6         3.4          1.4         0.3  setosa\n#> 8           5.0         3.4          1.5         0.2  setosa\n#> 9           4.4         2.9          1.4         0.2  setosa\n#> 10          4.9         3.1          1.5         0.1  setosa\n#> 11          5.4         3.7          1.5         0.2  setosa\n#> 12          4.8         3.4          1.6         0.2  setosa\n#> 13          4.8         3.0          1.4         0.1  setosa\n#> 14          4.3         3.0          1.1         0.1  setosa\n#> 15          5.8         4.0          1.2         0.2  setosa\n#> 16          5.7         4.4          1.5         0.4  setosa\n#> 17          5.4         3.9          1.3         0.4  setosa\n#> 18          5.1         3.5          1.4         0.3  setosa\n#> 19          5.7         3.8          1.7         0.3  setosa\n#> 20          5.1         3.8          1.5         0.3  setosa\n#> 21          5.4         3.4          1.7         0.2  setosa\n#> 22          5.1         3.7          1.5         0.4  setosa\n#> 23          4.6         3.6          1.0         0.2  setosa\n#> 24          5.1         3.3          1.7         0.5  setosa\n#> 25          4.8         3.4          1.9         0.2  setosa\n#> 26          5.0         3.0          1.6         0.2  setosa\n#> 27          5.0         3.4          1.6         0.4  setosa\n#> 28          5.2         3.5          1.5         0.2  setosa\n#> 29          5.2         3.4          1.4         0.2  setosa\n#> 30          4.7         3.2          1.6         0.2  setosa\n#> 31          4.8         3.1          1.6         0.2  setosa\n#> 32          5.4         3.4          1.5         0.4  setosa\n#> 33          5.2         4.1          1.5         0.1  setosa\n#> 34          5.5         4.2          1.4         0.2  setosa\n#> 35          4.9         3.1          1.5         0.2  setosa\n#> 36          5.0         3.2          1.2         0.2  setosa\n#> 37          5.5         3.5          1.3         0.2  setosa\n#> 38          4.9         3.6          1.4         0.1  setosa\n#> 39          4.4         3.0          1.3         0.2  setosa\n#> 40          5.1         3.4          1.5         0.2  setosa\n#> 41          5.0         3.5          1.3         0.3  setosa\n#> 42          4.5         2.3          1.3         0.3  setosa\n#> 43          4.4         3.2          1.3         0.2  setosa\n#> 44          5.0         3.5          1.6         0.6  setosa\n#> 45          5.1         3.8          1.9         0.4  setosa\n#> 46          4.8         3.0          1.4         0.3  setosa\n#> 47          5.1         3.8          1.6         0.2  setosa\n#> 48          4.6         3.2          1.4         0.2  setosa\n#> 49          5.3         3.7          1.5         0.2  setosa\n#> 50          5.0         3.3          1.4         0.2  setosa\n#> \n#> $versicolor\n#>     Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n#> 51           7.0         3.2          4.7         1.4 versicolor\n#> 52           6.4         3.2          4.5         1.5 versicolor\n#> 53           6.9         3.1          4.9         1.5 versicolor\n#> 54           5.5         2.3          4.0         1.3 versicolor\n#> 55           6.5         2.8          4.6         1.5 versicolor\n#> 56           5.7         2.8          4.5         1.3 versicolor\n#> 57           6.3         3.3          4.7         1.6 versicolor\n#> 58           4.9         2.4          3.3         1.0 versicolor\n#> 59           6.6         2.9          4.6         1.3 versicolor\n#> 60           5.2         2.7          3.9         1.4 versicolor\n#> 61           5.0         2.0          3.5         1.0 versicolor\n#> 62           5.9         3.0          4.2         1.5 versicolor\n#> 63           6.0         2.2          4.0         1.0 versicolor\n#> 64           6.1         2.9          4.7         1.4 versicolor\n#> 65           5.6         2.9          3.6         1.3 versicolor\n#> 66           6.7         3.1          4.4         1.4 versicolor\n#> 67           5.6         3.0          4.5         1.5 versicolor\n#> 68           5.8         2.7          4.1         1.0 versicolor\n#> 69           6.2         2.2          4.5         1.5 versicolor\n#> 70           5.6         2.5          3.9         1.1 versicolor\n#> 71           5.9         3.2          4.8         1.8 versicolor\n#> 72           6.1         2.8          4.0         1.3 versicolor\n#> 73           6.3         2.5          4.9         1.5 versicolor\n#> 74           6.1         2.8          4.7         1.2 versicolor\n#> 75           6.4         2.9          4.3         1.3 versicolor\n#> 76           6.6         3.0          4.4         1.4 versicolor\n#> 77           6.8         2.8          4.8         1.4 versicolor\n#> 78           6.7         3.0          5.0         1.7 versicolor\n#> 79           6.0         2.9          4.5         1.5 versicolor\n#> 80           5.7         2.6          3.5         1.0 versicolor\n#> 81           5.5         2.4          3.8         1.1 versicolor\n#> 82           5.5         2.4          3.7         1.0 versicolor\n#> 83           5.8         2.7          3.9         1.2 versicolor\n#> 84           6.0         2.7          5.1         1.6 versicolor\n#> 85           5.4         3.0          4.5         1.5 versicolor\n#> 86           6.0         3.4          4.5         1.6 versicolor\n#> 87           6.7         3.1          4.7         1.5 versicolor\n#> 88           6.3         2.3          4.4         1.3 versicolor\n#> 89           5.6         3.0          4.1         1.3 versicolor\n#> 90           5.5         2.5          4.0         1.3 versicolor\n#> 91           5.5         2.6          4.4         1.2 versicolor\n#> 92           6.1         3.0          4.6         1.4 versicolor\n#> 93           5.8         2.6          4.0         1.2 versicolor\n#> 94           5.0         2.3          3.3         1.0 versicolor\n#> 95           5.6         2.7          4.2         1.3 versicolor\n#> 96           5.7         3.0          4.2         1.2 versicolor\n#> 97           5.7         2.9          4.2         1.3 versicolor\n#> 98           6.2         2.9          4.3         1.3 versicolor\n#> 99           5.1         2.5          3.0         1.1 versicolor\n#> 100          5.7         2.8          4.1         1.3 versicolor\n#> \n#> $virginica\n#>     Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n#> 101          6.3         3.3          6.0         2.5 virginica\n#> 102          5.8         2.7          5.1         1.9 virginica\n#> 103          7.1         3.0          5.9         2.1 virginica\n#> 104          6.3         2.9          5.6         1.8 virginica\n#> 105          6.5         3.0          5.8         2.2 virginica\n#> 106          7.6         3.0          6.6         2.1 virginica\n#> 107          4.9         2.5          4.5         1.7 virginica\n#> 108          7.3         2.9          6.3         1.8 virginica\n#> 109          6.7         2.5          5.8         1.8 virginica\n#> 110          7.2         3.6          6.1         2.5 virginica\n#> 111          6.5         3.2          5.1         2.0 virginica\n#> 112          6.4         2.7          5.3         1.9 virginica\n#> 113          6.8         3.0          5.5         2.1 virginica\n#> 114          5.7         2.5          5.0         2.0 virginica\n#> 115          5.8         2.8          5.1         2.4 virginica\n#> 116          6.4         3.2          5.3         2.3 virginica\n#> 117          6.5         3.0          5.5         1.8 virginica\n#> 118          7.7         3.8          6.7         2.2 virginica\n#> 119          7.7         2.6          6.9         2.3 virginica\n#> 120          6.0         2.2          5.0         1.5 virginica\n#> 121          6.9         3.2          5.7         2.3 virginica\n#> 122          5.6         2.8          4.9         2.0 virginica\n#> 123          7.7         2.8          6.7         2.0 virginica\n#> 124          6.3         2.7          4.9         1.8 virginica\n#> 125          6.7         3.3          5.7         2.1 virginica\n#> 126          7.2         3.2          6.0         1.8 virginica\n#> 127          6.2         2.8          4.8         1.8 virginica\n#> 128          6.1         3.0          4.9         1.8 virginica\n#> 129          6.4         2.8          5.6         2.1 virginica\n#> 130          7.2         3.0          5.8         1.6 virginica\n#> 131          7.4         2.8          6.1         1.9 virginica\n#> 132          7.9         3.8          6.4         2.0 virginica\n#> 133          6.4         2.8          5.6         2.2 virginica\n#> 134          6.3         2.8          5.1         1.5 virginica\n#> 135          6.1         2.6          5.6         1.4 virginica\n#> 136          7.7         3.0          6.1         2.3 virginica\n#> 137          6.3         3.4          5.6         2.4 virginica\n#> 138          6.4         3.1          5.5         1.8 virginica\n#> 139          6.0         3.0          4.8         1.8 virginica\n#> 140          6.9         3.1          5.4         2.1 virginica\n#> 141          6.7         3.1          5.6         2.4 virginica\n#> 142          6.9         3.1          5.1         2.3 virginica\n#> 143          5.8         2.7          5.1         1.9 virginica\n#> 144          6.8         3.2          5.9         2.3 virginica\n#> 145          6.7         3.3          5.7         2.5 virginica\n#> 146          6.7         3.0          5.2         2.3 virginica\n#> 147          6.3         2.5          5.0         1.9 virginica\n#> 148          6.5         3.0          5.2         2.0 virginica\n#> 149          6.2         3.4          5.4         2.3 virginica\n#> 150          5.9         3.0          5.1         1.8 virginica\n\n\n\nShow the codesessionInfo()\n#> R version 4.2.1 (2022-06-23)\n#> Platform: aarch64-apple-darwin20 (64-bit)\n#> Running under: macOS Monterey 12.5.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n#> \n#> locale:\n#> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> other attached packages:\n#> [1] purrr_0.3.4 tidyr_1.2.0 dplyr_1.0.9\n#> \n#> loaded via a namespace (and not attached):\n#>  [1] rstudioapi_0.14   knitr_1.40        magrittr_2.0.3    tidyselect_1.1.2 \n#>  [5] R6_2.5.1          rlang_1.0.4       fastmap_1.1.0     fansi_1.0.3      \n#>  [9] stringr_1.4.1     tools_4.2.1       xfun_0.32         utf8_1.2.2       \n#> [13] DBI_1.1.3         cli_3.3.0         ellipsis_0.3.2    htmltools_0.5.3  \n#> [17] assertthat_0.2.1  yaml_2.3.5        digest_0.6.29     tibble_3.1.8     \n#> [21] lifecycle_1.0.1   htmlwidgets_1.5.4 vctrs_0.4.1       glue_1.6.2       \n#> [25] evaluate_0.16     rmarkdown_2.16.1  stringi_1.7.8     compiler_4.2.1   \n#> [29] pillar_1.8.1      generics_0.1.3    jsonlite_1.8.0    pkgconfig_2.0.3\n\n\n6. 更多list操作\n可以参考purrr包，并且rstudio官网上提供相应的总结表(备忘单)。"
  },
  {
    "objectID": "posts/post/R函数参数的有关问题.html",
    "href": "posts/post/R函数参数的有关问题.html",
    "title": "R函数参数的有关问题",
    "section": "",
    "text": "2. 匹配参数— match.arg()\n我们经常看见函数中有多个可选的字符串，用来做不同的模型，比如：这里的例子没有意义，但是做法值得注意。\n方法一：\n\nShow the code## 方法一：\ncenter <- function(x, type = c(\"mean\", \"median\", \"trimmed\")) {\n  type <- match.arg(type)\n  switch(type,\n         mean = mean(x),\n         median = median(x),\n         trimmed = mean(x, trim = .1))\n}\ncenter(c(1:4,100),\"mean\") # 返回向量的均值\n#> [1] 22\ncenter(c(1:4,100),\"median\") # 返回向量的中位数\n#> [1] 3\ncenter(c(1:4,100)) # 默认为第一个候选值，\n#> [1] 22\n\n\n方法二：\n\nShow the code## 方法二：\ncenter <- function(x, type) {\n  type <- match.arg(type,choices = c(\"mean\", \"median\", \"trimmed\"))\n  switch(type,\n         mean = mean(x),\n         median = median(x),\n         trimmed = mean(x, trim = .1))\n}\ncenter(c(1:4,100),\"mean\") # 返回向量的均值\n#> [1] 22\ncenter(c(1:4,100),\"median\") # 返回向量的中位数\n#> [1] 3\ntry( center(c(1:4,100)) )# 这里由于没有默认值会报错\n#> Error in match.arg(type, choices = c(\"mean\", \"median\", \"trimmed\")) : \n#>   argument \"type\" is missing, with no default\n\n\nmatch.arg()函数的功能是，根据输入来进行匹配, 比如，上面的式子，我们输入的type是”mean”，然后经过match.arg()以后通过switch可以直接调用该mean函数。\n还可以这样操作，（方法三）\n\nShow the code# 检查一个参数在函数内部是否已被初始化。\n# 对参数进行默认值处理，当然为了更方面也可以直接在函数参数处直接赋予默认值\nh = function(x,y){\n  args = as.list(match.call())\n  if(is.null(args$y)){\n    y = 10\n  }\n  x+y\n}\nh(2)\n#> [1] 12\nh(2,19)\n#> [1] 21\n\n\n类似的还有 match.call() 和match.fun()\n\nShow the code# match.call()创建一个只使用命名参数的调用， 常用于某些指定参数的更新\n# sys.call() 准确地捕获用户的输入。\n\nf <- function(abc = 1, def = 2, ghi = 3){\n  list(s = sys.call(),m = match.call())\n}\nf(d =2,2)\n#> $s\n#> f(d = 2, 2)\n#> \n#> $m\n#> f(abc = 2, def = 2)\n\n\nmatch.fun() 类似下面介绍的get()函数, 都可以把字符串变成我们想要调用的对象。\n3. 以字符串作为函数名 — get函数\n巧妙的利用get函数，把字符串变成我们想要调用的函数，因为get函数输入一个字符串，返回一个函数对象\n\nShow the code# eg： 前面的函数---可以进行对比\ncenter <- function(x, type = c(\"mean\", \"median\", \"trimmed\")) {\n  type <- match.arg(type)\n  f = get(type)\n  f(x)\n}\ncenter(c(1:4,100),\"mean\")\n#> [1] 22\ncenter(c(1:4,100),\"median\")\n#> [1] 3\ncenter(c(1:4,100))\n#> [1] 22\n\n\n\n# eg： 用match.fun  来替代get()\ncenter2 <- function(x, type = c(\"mean\", \"median\", \"trimmed\")) {\n  type <- match.arg(type)\n  f = match.fun(type)\n  f(x)\n}\ncenter2(c(1:4,100),\"mean\")\n#> [1] 22\ncenter2(c(1:4,100),\"median\")\n#> [1] 3\ncenter2(c(1:4,100))\n#> [1] 22\n\n\n两者的区别是get还可以返回某个对象，比如数据框、向量等，而match.fun 只能返回函数类型\n\nShow the codev = 1:10\n# match.fun('v') # 这里会报错\nget('v')\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n\n\nouter <- 1:5\ntry(match.fun(outer, descend = FALSE)) #-> Error:  not a function\n#> function (X, Y, FUN = \"*\", ...) \n#> {\n#>     if (is.array(X)) {\n#>         dX <- dim(X)\n#>         nx <- dimnames(X)\n#>         no.nx <- is.null(nx)\n#>     }\n#>     else {\n#>         dX <- length(X)\n#>         no.nx <- is.null(names(X))\n#>         if (!no.nx) \n#>             nx <- list(names(X))\n#>     }\n#>     if (is.array(Y)) {\n#>         dY <- dim(Y)\n#>         ny <- dimnames(Y)\n#>         no.ny <- is.null(ny)\n#>     }\n#>     else {\n#>         dY <- length(Y)\n#>         no.ny <- is.null(names(Y))\n#>         if (!no.ny) \n#>             ny <- list(names(Y))\n#>     }\n#>     robj <- if (is.character(FUN) && FUN == \"*\") {\n#>         if (!missing(...)) \n#>             stop(\"using ... with FUN = \\\"*\\\" is an error\")\n#>         tcrossprod(as.vector(X), as.vector(Y))\n#>     }\n#>     else {\n#>         FUN <- match.fun(FUN)\n#>         Y <- rep(Y, rep.int(length(X), length(Y)))\n#>         if (length(X)) \n#>             X <- rep(X, times = ceiling(length(Y)/length(X)))\n#>         FUN(X, Y, ...)\n#>     }\n#>     dim(robj) <- c(dX, dY)\n#>     if (!(no.nx && no.ny)) {\n#>         if (no.nx) \n#>             nx <- vector(\"list\", length(dX))\n#>         else if (no.ny) \n#>             ny <- vector(\"list\", length(dY))\n#>         dimnames(robj) <- c(nx, ny)\n#>     }\n#>     robj\n#> }\n#> <bytecode: 0x122e9df78>\n#> <environment: namespace:base>\nmatch.fun(outer) # finds it anyway，由于outer是R内部的函数，只不过现在被覆盖了，但是还是能找到\n#> function (X, Y, FUN = \"*\", ...) \n#> {\n#>     if (is.array(X)) {\n#>         dX <- dim(X)\n#>         nx <- dimnames(X)\n#>         no.nx <- is.null(nx)\n#>     }\n#>     else {\n#>         dX <- length(X)\n#>         no.nx <- is.null(names(X))\n#>         if (!no.nx) \n#>             nx <- list(names(X))\n#>     }\n#>     if (is.array(Y)) {\n#>         dY <- dim(Y)\n#>         ny <- dimnames(Y)\n#>         no.ny <- is.null(ny)\n#>     }\n#>     else {\n#>         dY <- length(Y)\n#>         no.ny <- is.null(names(Y))\n#>         if (!no.ny) \n#>             ny <- list(names(Y))\n#>     }\n#>     robj <- if (is.character(FUN) && FUN == \"*\") {\n#>         if (!missing(...)) \n#>             stop(\"using ... with FUN = \\\"*\\\" is an error\")\n#>         tcrossprod(as.vector(X), as.vector(Y))\n#>     }\n#>     else {\n#>         FUN <- match.fun(FUN)\n#>         Y <- rep(Y, rep.int(length(X), length(Y)))\n#>         if (length(X)) \n#>             X <- rep(X, times = ceiling(length(Y)/length(X)))\n#>         FUN(X, Y, ...)\n#>     }\n#>     dim(robj) <- c(dX, dY)\n#>     if (!(no.nx && no.ny)) {\n#>         if (no.nx) \n#>             nx <- vector(\"list\", length(dX))\n#>         else if (no.ny) \n#>             ny <- vector(\"list\", length(dY))\n#>         dimnames(robj) <- c(nx, ny)\n#>     }\n#>     robj\n#> }\n#> <bytecode: 0x122e9df78>\n#> <environment: namespace:base>\nmatch.fun(\"outer\")\n#> function (X, Y, FUN = \"*\", ...) \n#> {\n#>     if (is.array(X)) {\n#>         dX <- dim(X)\n#>         nx <- dimnames(X)\n#>         no.nx <- is.null(nx)\n#>     }\n#>     else {\n#>         dX <- length(X)\n#>         no.nx <- is.null(names(X))\n#>         if (!no.nx) \n#>             nx <- list(names(X))\n#>     }\n#>     if (is.array(Y)) {\n#>         dY <- dim(Y)\n#>         ny <- dimnames(Y)\n#>         no.ny <- is.null(ny)\n#>     }\n#>     else {\n#>         dY <- length(Y)\n#>         no.ny <- is.null(names(Y))\n#>         if (!no.ny) \n#>             ny <- list(names(Y))\n#>     }\n#>     robj <- if (is.character(FUN) && FUN == \"*\") {\n#>         if (!missing(...)) \n#>             stop(\"using ... with FUN = \\\"*\\\" is an error\")\n#>         tcrossprod(as.vector(X), as.vector(Y))\n#>     }\n#>     else {\n#>         FUN <- match.fun(FUN)\n#>         Y <- rep(Y, rep.int(length(X), length(Y)))\n#>         if (length(X)) \n#>             X <- rep(X, times = ceiling(length(Y)/length(X)))\n#>         FUN(X, Y, ...)\n#>     }\n#>     dim(robj) <- c(dX, dY)\n#>     if (!(no.nx && no.ny)) {\n#>         if (no.nx) \n#>             nx <- vector(\"list\", length(dX))\n#>         else if (no.ny) \n#>             ny <- vector(\"list\", length(dY))\n#>         dimnames(robj) <- c(nx, ny)\n#>     }\n#>     robj\n#> }\n#> <bytecode: 0x122e9df78>\n#> <environment: namespace:base>\n\n\n4. 以字符串作为函数名 — call()函数\ncall函数，可以直接通过字符串的形式调用某个函数(只要环境空间中存在)，\n\nShow the codeget(\"rnorm\")(5,mean = 300)\n#> [1] 299.7240 300.7482 302.8964 299.5659 300.5361\n\neval( call('rnorm',5,mean=300) ) # 执行函数调用，本质上call是创建一个函数调用，最后通过eval进行执行\n#> [1] 299.8097 300.0864 298.5465 299.4390 298.9760\n\ncall_1 = quote(rnorm(5,mean = 3))\ncall_2 = call(\"rnorm\",5,mean = 3)\ncall_3 = as.call( list(quote(rnorm),5,mean = 3) )\n# 这里call_1,call_2,call_3 完全等价，是一个表达式。需要进一步执行表达式需要利用eval来执行。\n\n\n5. 把函数参数(不带字符串参数)转变为字符串\ndeparse(substitute(函数参数))\n\nShow the codenicePlot = function(X,Y,...){\n  xlabel = deparse(substitute(X)) # 捕获X的输入\n  ylabel = deparse(substitute(Y)) # 捕获Y的输入\n  \n  plot(X,Y,type ='o',xlab = xlabel,ylab = ylabel,main = paste(xlabel,ylabel,sep = '--'), ...)\n}\n\nDate = 1:7\nSales = c(100,120,150,130,160,210,120)\nnicePlot(Date,Sales,col='red')\n\n\n\n\n\nShow the codesessionInfo()\n#> R version 4.2.1 (2022-06-23)\n#> Platform: aarch64-apple-darwin20 (64-bit)\n#> Running under: macOS Monterey 12.5.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n#> \n#> locale:\n#> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] digest_0.6.29     jsonlite_1.8.0    magrittr_2.0.3    evaluate_0.16    \n#>  [5] rlang_1.0.4       stringi_1.7.8     cli_3.3.0         rstudioapi_0.14  \n#>  [9] rmarkdown_2.16.1  tools_4.2.1       stringr_1.4.1     htmlwidgets_1.5.4\n#> [13] xfun_0.32         yaml_2.3.5        fastmap_1.1.0     compiler_4.2.1   \n#> [17] htmltools_0.5.3   knitr_1.40"
  },
  {
    "objectID": "posts/post/ggfortify包简介.html",
    "href": "posts/post/ggfortify包简介.html",
    "title": "ggfortify包简介",
    "section": "",
    "text": "Show the codeknitr::opts_chunk$set(message=FALSE, warning=FALSE)\nggfortify 是一个简单易用的R软件包，它可以仅仅使用一行代码来对许多受欢迎的R软件包结果进行二维可视化，这让统计学家以及数据科学家省去了许多繁琐和重复的过程，不用对结果进行任何处理就能以 ggplot 的风格画出好看的图，大大地提高了工作的效率。\n接下来我将简单介绍一下怎么用 ggplot2 和 ggfortify 来很快地对PCA、聚类以及LFDA的结果进行可视化，然后将简单介绍用 ggfortify 来对时间序列进行快速可视化的方法。一下都是个人理解，"
  },
  {
    "objectID": "posts/post/ggfortify包简介.html#pca-主成分分析",
    "href": "posts/post/ggfortify包简介.html#pca-主成分分析",
    "title": "ggfortify包简介",
    "section": "1、PCA (主成分分析)",
    "text": "1、PCA (主成分分析)\n其实本包，大多数画图都是采用主成分（不包括因子分析）降维得到两个主成分，在进一步使其主成分为坐标，对应与每个点给出相应的颜色和类别\nggfortify 使 ggplot2 知道怎么诠释PCA对象。加载好 ggfortify 包之后, 你可以对stats::prcomp 和stats::princomp对象使用 ggplot2::autoplot。\nautoplot()函数是ggplot2中的，不过ggfortify包里面有泛函s3类的autoplot解释这个函数\nggbiplot()函数中的参数就是autoplot()函数中的参数\nautoplot(object, data = NULL, scale = 1, x = 1, y = 2, ...)\n\nobject                          :  对象\ndata                            :  对应的数据框\ncolour = 'Species'              :  若有分类因子变量，可以对不同的类别添加颜色,当为连续值时为逐渐变色\nshape = FALSE                   ： 调整点的形状，可以让所有的点消失，只留下标识（可以为具体的数字，就是形状类型）\nmain    、xlab   、ylab            ： 标题\nlabel = TRUE \n      label.size = 3            :  可以给每个点加上标识（以rownames为标准），也可以调整标识的大小.（默认为FALSE）\n      label.label               :  标识标签（默认rownames）\n      label.colour              :  文本标签的颜色\n      label.alpha               ： 透明度\n      label.angle               ： 旋转的角度\n      label.family              :  字体\n      label.fontface\n      label.lineheight\n      label.hjust\n      label.vjust\n      label.repel\n\n\nloadings = TRUE                 ： 可以很快地画出特征向量\n      loadings.colour = 'blue'  ： 特征向量的颜色\n      loadings.label = TRUE     ：  特征向量的标识(默认为特征向量的名字)\n          loadings.label.size = 3   ：  特征向量的大小\n          loadings.label.label      :\n          loadings.label.colour\n          loadings.label.alpha\n          loadings.label.angle\n          loadings.label.family\n          loadings.label.fontface\n          loadings.label.lineheight\n          loadings.label.hjust\n          loadings.label.vjust\n          loadings.label.repel\n          \n\nframe = TRUE                    ： 可以把每个类圈出来。图中没有分类则看成一类，全部圈出来（支持 stats::kmeans 和 cluster::* 等等）\n      frame.colour = 'Species'   :  对分类变量进行颜色标注，并把它们类别圈出来（类似colour = 'Species'  ）\n      frame.type = 't'          ： 选择圈的类型(默认多边形)\n      frame.level\n      frame.alpha\n\nShow the codelibrary(ggfortify)\ndf <- iris[c(1, 2, 3, 4)]\nautoplot(prcomp(df))#等价autoplot(prcomp(iris[-5]), data = iris)\n\n\n\n\n你还可以选择数据中的一列来给画出的点按类别自动分颜色。输入help(autoplot.prcomp) 可以了解到更多的其他选择。\n\nShow the codeautoplot(prcomp(df), data = iris, colour = 'Species')\n\n\n\n\n比如说给定label = TRUE 可以给每个点加上标识（以rownames为标准），也可以调整标识的大小。\n\nShow the codeautoplot(prcomp(df), data = iris, colour = 'Species', label = TRUE,label.size = 3)\n\n\n\n\n给定 shape = FALSE 可以让所有的点消失，只留下标识，这样可以让图更清晰，辨识度更大。\n\nShow the codeautoplot(prcomp(df), data = iris, colour = 'Species', shape =14,label.size = 3,label = TRUE)\n\n\n\n\n给定 loadings = TRUE 可以很快地画出特征向量。\n\nShow the codeautoplot(prcomp(df), data = iris, colour = 'Species', loadings = TRUE)\n\n\n\n\n同样的，你也可以显示特征向量的标识以及调整他们的大小，更多选择请参考帮助文件。\n\nShow the codeautoplot(prcomp(df), data = iris, colour = 'Species',\n         loadings = TRUE, loadings.colour = 'blue',\n         loadings.label = TRUE, loadings.label.size = 3)"
  },
  {
    "objectID": "posts/post/ggfortify包简介.html#因子分析",
    "href": "posts/post/ggfortify包简介.html#因子分析",
    "title": "ggfortify包简介",
    "section": "2、因子分析",
    "text": "2、因子分析\n和PCA类似，ggfortify 也支持 stats::factanal 对象。可调的选择也很广泛。以下给出了简单的例子： 注意 当你使用 factanal 来计算分数的话，你必须给定 scores 的值。 下面都是建立在因子分析模型上，但是几乎参数和主成分分析一样。。\n\nShow the code#因子分析 ，记住3个因子和2个因子画出来的图是不一样的\n\n(d.factanal <- factanal(state.x77, factors = 3, scores = 'regression'))#因子分析,\n\n\nCall:\nfactanal(x = state.x77, factors = 3, scores = \"regression\")\n\nUniquenesses:\nPopulation     Income Illiteracy   Life Exp     Murder    HS Grad      Frost \n     0.813      0.474      0.266      0.240      0.050      0.167      0.005 \n      Area \n     0.613 \n\nLoadings:\n           Factor1 Factor2 Factor3\nPopulation -0.156   0.361   0.181 \nIncome      0.316           0.651 \nIlliteracy -0.576   0.543  -0.328 \nLife Exp    0.856  -0.128   0.103 \nMurder     -0.854   0.459   0.103 \nHS Grad     0.576  -0.149   0.692 \nFrost       0.137  -0.966   0.209 \nArea       -0.184           0.593 \n\n               Factor1 Factor2 Factor3\nSS loadings      2.301   1.612   1.459\nProportion Var   0.288   0.201   0.182\nCumulative Var   0.288   0.489   0.671\n\nTest of the hypothesis that 3 factors are sufficient.\nThe chi square statistic is 20.47 on 7 degrees of freedom.\nThe p-value is 0.00464 \n\nShow the code#图的坐标应该和因子有关系，但是因子为3个的时候，图中有时怎么表达的呢？\nautoplot(d.factanal, data = state.x77, colour = 'Income')# colour为连续值(data、和colour只是纯粹的添加颜色而已)\n\n\n\nShow the codeautoplot(d.factanal, label = TRUE, label.size = 3,\n         loadings = TRUE, loadings.label = TRUE, loadings.label.size  = 3)#把特征向量画出来"
  },
  {
    "objectID": "posts/post/ggfortify包简介.html#聚类",
    "href": "posts/post/ggfortify包简介.html#聚类",
    "title": "ggfortify包简介",
    "section": "3、聚类",
    "text": "3、聚类\n3.1K-均值聚类—–若是聚类的话（自带类别，会自动画出颜色分类）\n和因子分析、主成分类似\n\nShow the codeautoplot(kmeans(iris[,-5], 3), data = iris)#坐标用的是主成分的坐标\n\n\n\nShow the codeautoplot(kmeans(iris[,-5], 3), data = iris, label = TRUE, label.size = 3)\n\n\n\n\n3.2其他聚类\nggfortify 也支持 cluster::clara, cluster::fanny, cluster::pam。\n其实本包，大多数画图都是采用主成分（不包括因子分析）降维得到两个主成分，在进一步使其主成分为坐标，对应与每个点给出相应的颜色和类别\n\nShow the codelibrary(cluster)\nautoplot(clara(iris[-5], 3))\n\n\n\nShow the codeautoplot(fanny(iris[-5], 3), frame = TRUE)#给定 frame = TRUE，可以把stats::kmeans 和 cluster::* 的每个集群圈出来。\n\n\n\nShow the codeautoplot(pam(iris[-5], 3), frame = TRUE, frame.type = 'norm')#你也可以通过 frame.type 来选择圈的类型。更多选择请参照ggplot2::stat_ellipse里面的frame.type的type关键词。\n\n\n\n\n3.3、lfda(Fisher局部判别分析)\nlfda包支持一系列的Fisher局部判别分析方法，包括半监督lfda，非线性lfda。你也可以使用ggfortify来对他们的结果进行可视化。\n\nShow the codelibrary(lfda)\n# Fisher局部判别分析 (LFDA)\nmodel <- lfda(iris[-5], iris[, 5], 4, metric=\"plain\")\nautoplot(model, data = iris, frame = TRUE, frame.colour = 'Species')#给定 frame = TRUE，可以把 stats::kmeans 和 cluster::* 中的每个类圈出来。\n\n\n\nShow the code# 半监督Fisher局部判别分析 (SELF)\nmodel <- self(iris[-5], iris[, 5], beta = 0.1, r = 3, metric=\"plain\")\nautoplot(model, data = iris, frame = TRUE, frame.colour = 'Species')"
  },
  {
    "objectID": "posts/post/ggfortify包简介.html#时间序列的可视化",
    "href": "posts/post/ggfortify包简介.html#时间序列的可视化",
    "title": "ggfortify包简介",
    "section": "4、时间序列的可视化",
    "text": "4、时间序列的可视化\n用 ggfortify 使时间序列的可视化变得及其简单。接下来我将给出一些简单的例子。\n\n\nautoplot可支持的R包有：\n\n基本stats:: ts对象\nzoo::zooreg\nxts::xts\ntimeSeries::timSeries\ntseries::irts"
  },
  {
    "objectID": "posts/post/ggfortify包简介.html#ts对象",
    "href": "posts/post/ggfortify包简介.html#ts对象",
    "title": "ggfortify包简介",
    "section": "4.1、ts对象",
    "text": "4.1、ts对象\n\nShow the codelibrary(ggfortify)\nclass(AirPassengers)#时间序列的对象为ts\n\n[1] \"ts\"\n\nShow the codeAirPassengers\n\n     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n1949 112 118 132 129 121 135 148 148 136 119 104 118\n1950 115 126 141 135 125 149 170 170 158 133 114 140\n1951 145 150 178 163 172 178 199 199 184 162 146 166\n1952 171 180 193 181 183 218 230 242 209 191 172 194\n1953 196 196 236 235 229 243 264 272 237 211 180 201\n1954 204 188 235 227 234 264 302 293 259 229 203 229\n1955 242 233 267 269 270 315 364 347 312 274 237 278\n1956 284 277 317 313 318 374 413 405 355 306 271 306\n1957 315 301 356 348 355 422 465 467 404 347 305 336\n1958 340 318 362 348 363 435 491 505 404 359 310 337\n1959 360 342 406 396 420 472 548 559 463 407 362 405\n1960 417 391 419 461 472 535 622 606 508 461 390 432\n\nShow the codeautoplot(AirPassengers)\n\n\n\nShow the code#可以使用 ts.colour 和 ts.linetype来改变线的颜色和形状。更多的选择请参考 help(autoplot.ts)。\n# 也可以像ggplot函数那样设置样式，比如\nautoplot(AirPassengers, ts.colour = 'red', ts.linetype = 'dashed',xlab = \"时间\",ylab = \"飞机乘客数量\",main= \"飞机乘客人数的变化\")\n\n\n\nShow the code#等价\nautoplot(AirPassengers, ts.colour = 'red', ts.linetype = 'dashed')+xlab(\"时间\")+ylab(\"飞机乘客数量\")+ggtitle( \"飞机乘客人数的变化\")\n\n\n\n\n4.1.1、多变量时间序列\n\nShow the codelibrary(vars)\ndata(Canada)\nclass(Canada)\n\n[1] \"mts\" \"ts\" \n\nShow the codeCanada\n\n               e     prod       rw     U\n1980 Q1 929.6105 405.3665 386.1361  7.53\n1980 Q2 929.8040 404.6398 388.1358  7.70\n1980 Q3 930.3184 403.8149 390.5401  7.47\n1980 Q4 931.4277 404.2158 393.9638  7.27\n1981 Q1 932.6620 405.0467 396.7647  7.37\n1981 Q2 933.5509 404.4167 400.0217  7.13\n1981 Q3 933.5315 402.8191 400.7515  7.40\n1981 Q4 933.0769 401.9773 405.7335  8.33\n1982 Q1 932.1238 402.0897 409.0504  8.83\n1982 Q2 930.6359 401.3067 411.3984 10.43\n1982 Q3 929.0971 401.6302 413.0194 12.20\n1982 Q4 928.5633 401.5638 415.1670 12.77\n1983 Q1 929.0694 402.8157 414.6621 12.43\n1983 Q2 930.2655 403.1421 415.7319 12.23\n1983 Q3 931.6770 403.0786 416.2315 11.70\n1983 Q4 932.1390 403.7188 418.1439 11.20\n1984 Q1 932.2767 404.8668 419.7352 11.27\n1984 Q2 932.8328 405.6362 420.4842 11.47\n1984 Q3 933.7334 405.1363 420.9309 11.30\n1984 Q4 934.1772 406.0246 422.1124 11.17\n1985 Q1 934.5928 406.4123 423.6278 11.00\n1985 Q2 935.6067 406.3009 423.9887 10.63\n1985 Q3 936.5111 406.3354 424.1902 10.27\n1985 Q4 937.4201 406.7737 426.1270 10.20\n1986 Q1 938.4159 405.1525 426.8578  9.67\n1986 Q2 938.9992 404.9298 426.7457  9.60\n1986 Q3 939.2354 404.5765 426.8858  9.60\n1986 Q4 939.6795 404.1995 428.8403  9.50\n1987 Q1 940.2497 405.9499 430.1223  9.50\n1987 Q2 941.4358 405.8221 430.2307  9.03\n1987 Q3 942.2981 406.4463 430.3930  8.70\n1987 Q4 943.5322 407.0512 432.0284  8.13\n1988 Q1 944.3490 407.9460 433.3886  7.87\n1988 Q2 944.8215 408.1796 433.9641  7.67\n1988 Q3 945.0671 408.5998 434.4844  7.80\n1988 Q4 945.8067 409.0906 436.1569  7.73\n1989 Q1 946.8697 408.7042 438.2651  7.57\n1989 Q2 946.8766 408.9803 438.7636  7.57\n1989 Q3 947.2497 408.3287 439.9498  7.33\n1989 Q4 947.6513 407.8857 441.8359  7.57\n1990 Q1 948.1840 407.2605 443.1769  7.63\n1990 Q2 948.3492 406.7752 444.3592  7.60\n1990 Q3 948.0322 406.1794 444.5236  8.17\n1990 Q4 947.1065 405.4398 446.9694  9.20\n1991 Q1 946.0796 403.2800 450.1586 10.17\n1991 Q2 946.1838 403.3649 451.5464 10.33\n1991 Q3 946.2258 403.3807 452.2984 10.40\n1991 Q4 945.9978 404.0032 453.1201 10.37\n1992 Q1 945.5183 404.4774 453.9991 10.60\n1992 Q2 945.3514 404.7868 454.9552 11.00\n1992 Q3 945.2918 405.2710 455.4824 11.40\n1992 Q4 945.4008 405.3830 456.1009 11.73\n1993 Q1 945.9058 405.1564 457.2027 11.07\n1993 Q2 945.9035 406.4700 457.3886 11.67\n1993 Q3 946.3190 406.2293 457.7799 11.47\n1993 Q4 946.5796 406.7265 457.5535 11.30\n1994 Q1 946.7800 408.5785 458.8024 10.97\n1994 Q2 947.6283 409.6767 459.0564 10.63\n1994 Q3 948.6221 410.3858 459.1578 10.10\n1994 Q4 949.3992 410.5395 459.7037  9.67\n1995 Q1 949.9481 410.4453 459.7037  9.53\n1995 Q2 949.7945 410.6256 460.0258  9.47\n1995 Q3 949.9534 410.8672 461.0257  9.50\n1995 Q4 950.2502 411.2359 461.3039  9.27\n1996 Q1 950.5380 410.6637 461.4031  9.50\n1996 Q2 950.7871 410.8085 462.9277  9.43\n1996 Q3 950.8695 412.1160 464.6888  9.70\n1996 Q4 950.9281 412.9994 465.0717  9.90\n1997 Q1 951.8457 412.9551 464.2851  9.43\n1997 Q2 952.6005 412.8241 464.0344  9.30\n1997 Q3 953.5976 413.0489 463.4535  8.87\n1997 Q4 954.1434 413.6110 465.0717  8.77\n1998 Q1 954.5426 413.6048 466.0889  8.60\n1998 Q2 955.2631 412.9684 466.6171  8.33\n1998 Q3 956.0561 412.2659 465.7478  8.17\n1998 Q4 956.7966 412.9106 465.8995  8.03\n1999 Q1 957.3865 413.8294 466.4099  7.90\n1999 Q2 958.0634 414.2242 466.9552  7.87\n1999 Q3 958.7166 415.1678 467.6281  7.53\n1999 Q4 959.4881 415.7016 467.7026  6.93\n2000 Q1 960.3625 416.8674 469.1348  6.80\n2000 Q2 960.7834 417.6104 469.3364  6.70\n2000 Q3 961.0290 418.0030 470.0117  6.93\n2000 Q4 961.7657 417.2667 469.6472  6.87\n\nShow the codeautoplot(Canada)## 需要用到的数据集，包含e、prod、rw和U四个变量，自动把全部变量添加到图中，\n\n\n\nShow the code#也可以指定相应变量，画前面3列\nautoplot(Canada[,-4])\n\n\n\nShow the code#使用 facets = FALSE 可以把所有变量画在一条轴上。\nautoplot(Canada, facets = FALSE)\n\n\n\n\n4.2 xts对象\nlibrary(xts)\nautoplot(as.xts(AirPassengers),ts.colour = 'green')#好像出问题\n4.3 timSeries对象\n\nShow the codelibrary(timeSeries)\nautoplot(as.timeSeries(AirPassengers), ts.colour = ('dodgerblue3'))"
  },
  {
    "objectID": "posts/post/ggfortify包简介.html#面板设计",
    "href": "posts/post/ggfortify包简介.html#面板设计",
    "title": "ggfortify包简介",
    "section": "5、面板设计",
    "text": "5、面板设计\n\nShow the codelibrary(purrr)\nres <- purrr::map(c(3, 4, 5), ~ kmeans(iris[-5], .))\nautoplot(res, data = iris[-5], ncol = 3)\n\n\n\n\n\nShow the codesessionInfo()\n\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.5.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] purrr_0.3.4         timeSeries_4021.104 timeDate_4021.104  \n [4] vars_1.5-6          lmtest_0.9-40       urca_1.3-0         \n [7] strucchange_1.5-3   sandwich_3.0-2      zoo_1.8-10         \n[10] MASS_7.3-58.1       lfda_1.1.3          cluster_2.1.4      \n[13] ggfortify_0.4.14    ggplot2_3.3.6      \n\nloaded via a namespace (and not attached):\n [1] tidyselect_1.1.2  xfun_0.32         lattice_0.20-45   colorspace_2.0-3 \n [5] vctrs_0.4.1       generics_0.1.3    htmltools_0.5.3   yaml_2.3.5       \n [9] utf8_1.2.2        rlang_1.0.4       pillar_1.8.1      glue_1.6.2       \n[13] withr_2.5.0       DBI_1.1.3         lifecycle_1.0.1   stringr_1.4.1    \n[17] munsell_0.5.0     gtable_0.3.0      htmlwidgets_1.5.4 evaluate_0.16    \n[21] labeling_0.4.2    knitr_1.40        fastmap_1.1.0     fansi_1.0.3      \n[25] rARPACK_0.11-0    Rcpp_1.0.9        scales_1.2.1      jsonlite_1.8.0   \n[29] farver_2.1.1      RSpectra_0.16-1   gridExtra_2.3     digest_0.6.29    \n[33] stringi_1.7.8     dplyr_1.0.9       grid_4.2.1        cli_3.3.0        \n[37] tools_4.2.1       magrittr_2.0.3    tibble_3.1.8      crayon_1.5.1     \n[41] tidyr_1.2.0       pkgconfig_2.0.3   ellipsis_0.3.2    Matrix_1.4-1     \n[45] assertthat_0.2.1  rmarkdown_2.16.1  rstudioapi_0.14   R6_2.5.1         \n[49] nlme_3.1-159      compiler_4.2.1"
  },
  {
    "objectID": "posts/post/回归树与模型树.html",
    "href": "posts/post/回归树与模型树.html",
    "title": "回归树与模型树",
    "section": "",
    "text": "决策树可用于聚类（类别变量），也可用于数值预测,但是本节只考虑决策树用于数值预测.\n决策树用于数值预测可以分为回归树和模型树\n\n回归树: 回归树中并没用使用线性回归的方法，而是基于到达叶节点的案例的平均值做出预测\n模型树: 模型树和回归树以大致相同的方式生长，但是在每个叶节点，根据到达该节点的案例建立多元线性回归模型。根据叶节点的数目，一棵模型树可能会建立几十甚至上百个这样的模型，可能会使模型树比同等的回归树更难解释，但好处也行能提高精确度。"
  },
  {
    "objectID": "posts/post/回归树与模型树.html#回归树与模型树的优缺点",
    "href": "posts/post/回归树与模型树.html#回归树与模型树的优缺点",
    "title": "回归树与模型树",
    "section": "2、回归树与模型树的优缺点",
    "text": "2、回归树与模型树的优缺点\n\n\n\n\n\n\n优点\n缺点\n\n\n\n将决策树的优点对数值型数据建立模型的能力相结合\n不像线性回归那么常用\n\n\n能自动选择特征，允许该方法与大量特征一起使用\n需要大量的训练数据\n\n\n不需要使用者事先指定模型\n难以确定单个特征对于结果的总体净影响\n\n\n拟合某些类型的数据可能会比线性回归好\n可能比回归模型难以解释\n\n\n不要求用统计的知识来解释模型\n\n\n\n\n用于数值预测的决策树的建立方式与用于分类的决策树建立的方式大致相同。从根节点开始，按照特征使用分而治之的决策对数据进行划分，在进行一次分割后，将会导致结果最大化的均匀增长。\n\n\n在分类决策树中，一致性(均匀性)是有熵值度量 ，而对于数值型数据是未定义的，\n\n对于数值型决策，一致性(均匀性)可通过统计量(方差、标准差、平均绝对偏差)来度量,根据使用的决策树生长算法，度量方法可能用所不同，但基本原理相同.\n\n常见的一个分割标准成为标准偏差减少(Standard Deciation Reduction,SDR),其公式定义如下\\[SDR=sd(T)\\]"
  },
  {
    "objectID": "posts/post/回归树与模型树.html#例子-估计葡萄酒的质量",
    "href": "posts/post/回归树与模型树.html#例子-估计葡萄酒的质量",
    "title": "回归树与模型树",
    "section": "3、例子——-估计葡萄酒的质量",
    "text": "3、例子——-估计葡萄酒的质量\n白葡萄酒包含4898个葡萄酒案例的11种化学特征的信息，对于每种葡萄酒，实验室分析测量的特征包括酸性、含糖量、氯化物含量、硫的含量、酒精度、PH值和密度值\n3.1读入数据\n其所有特征都是数值型\n\nShow the codewine <- read.csv(\"whitewines.csv\")\n\n\n研究一下结果变量的分布,由于是离散的，可用直方图来研究葡萄酒质量的分布：\n\nShow the codehist(wine$quality)\n\n\n\n\n符合正态分布。大约以数值为6为中心(也可用summary()函数发现一些数据的异常值等等)，最后划分训练数据与测试数据(数据是随机排序),75%的训练数据，25%的测试数据\n\nShow the codewine_train <- wine[1:3750, ]\nwine_test <- wine[3751:4898, ]\n\n\n3.2基于数据训练模型—-回归树\n\nShow the codelibrary(rpart)\nm.rpart <- rpart(quality ~ ., data = wine_train)\nm.rpart# 获取该树的基本信息,#summary(m.rpart)\n\nn= 3750 \n\nnode), split, n, deviance, yval\n      * denotes terminal node\n\n 1) root 3750 2945.53200 5.870933  \n   2) alcohol< 10.85 2372 1418.86100 5.604975  \n     4) volatile.acidity>=0.2275 1611  821.30730 5.432030  \n       8) volatile.acidity>=0.3025 688  278.97670 5.255814 *\n       9) volatile.acidity< 0.3025 923  505.04230 5.563380 *\n     5) volatile.acidity< 0.2275 761  447.36400 5.971091 *\n   3) alcohol>=10.85 1378 1070.08200 6.328737  \n     6) free.sulfur.dioxide< 10.5 84   95.55952 5.369048 *\n     7) free.sulfur.dioxide>=10.5 1294  892.13600 6.391036  \n      14) alcohol< 11.76667 629  430.11130 6.173291  \n        28) volatile.acidity>=0.465 11   10.72727 4.545455 *\n        29) volatile.acidity< 0.465 618  389.71680 6.202265 *\n      15) alcohol>=11.76667 665  403.99400 6.596992 *\n\n\n对于决策树中的每个节点，到达决策点的案例数量都列出来了，例如：所有的3750个案例从根节点开始，其中\n\n(1)有2372个案例的alcohol< 10.85 2372，\n\n1378个案例的 alcohol>=10.85 。\n\n\n因为alcohol（酒精）是决策树中第一个使用的变量，所以它是葡萄酒质量中唯一最重要的指标。\n用* 表示的节点是终端或者叶节点，这意味着他们会产生预测(这里作为yavl列出来)。例如节点5有一个5.971091的yval。当该决策树用来预测时，对任意一个葡萄酒案例，如果alcohol< 10.85 2372 且volatile.acidity< 0.2275，那么它的质量值将预测为5.97\n3.3可视化决策时\n\nShow the codelibrary(rpart.plot)\n\nrpart.plot(m.rpart, digits = 3)#基本决策树图\n\n\n\nShow the coderpart.plot(m.rpart, digits = 4, fallen.leaves = TRUE, type = 3, extra = 101)#对图表的一些调整\n\n\n\n\n3.4评估模型的性能\n\nShow the codep.rpart <- predict(m.rpart, wine_test)\n#我们预测的主要统计量表明了一个潜在的问题，预测值与真实值相比落在一个更窄的范围内\nsummary(p.rpart)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  4.545   5.563   5.971   5.893   6.202   6.597 \n\nShow the codesummary(wine_test$quality)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  3.000   5.000   6.000   5.901   6.000   9.000 \n\n\n这一发现表面，该模型不能正确识别极端的情形，尤其是最好的和最差葡萄酒，反过来，另一方面，在第一四分位数和第三四分位数之间，我们可能做的不错。\n3.5用平均绝对误差度量性能\n平均绝对误差:考虑它的预测值离真实值有多远，方程如下：\\[MAE=1/n\\]\n由于误差是预测值与真实值之间的差值，所以可以简单创建一个MSE()函数，如下：\n\nShow the codeMAE <- function(actual, predicted) {\n  mean(abs(actual - predicted))  \n}\n\n# 预测值和实际值之间的平均绝对误差\nMAE(p.rpart, wine_test$quality)#MAS越小越好\n\n[1] 0.5872652\n\n\n就平均而言，这意味着模型的预测值与真实值的质量分数之间的差值大约为0.59，基于质量的尺度是从0~10，这似乎表面我们的模型做的还可以\n另一反面，大多数的葡萄酒既不是很好也不是很差，通常情况下，质量分数大约为5~6.因此根据这个指标，一个什么都没有做而是仅仅预测了均值的分类器可能同样会做的相当好（意思是直接为均值===相当于这个模型了）\n训练数据中的平均质量等级如下：（用平均值试试）\n\nShow the code# result = 5.87平均值\nmean(wine_train$quality) \n\n[1] 5.870933\n\nShow the code#如果我们对一个葡萄酒案例预测的值为5.87，那么我们将只有大约0.67的平均绝对误差\n#mean_abserror(5.87, wine_test$quality)\nmean(abs(rep(5.87,length(wine_test$quality))-wine_test$quality))#平均值的MAE为0.67\n\n[1] 0.6722474\n\n\n回归树(MSE=0.59)比估算的均值(MSE=0.67)平均更接近于真实的质量分数，但相差不大,所以模型需要改进"
  },
  {
    "objectID": "posts/post/回归树与模型树.html#提高模型的性能-模型树改进模型",
    "href": "posts/post/回归树与模型树.html#提高模型的性能-模型树改进模型",
    "title": "回归树与模型树",
    "section": "3.6提高模型的性能—-模型树（改进模型）",
    "text": "3.6提高模型的性能—-模型树（改进模型）\n模型树算法为M5算法—改进以后为M5’算法 M5‘算法在R中通过Rweka包和M5P()函数可以得到\n\nShow the codelibrary(RWeka)#调用的时候需要联网,还要安装该软件\n##############\n####  make_Weka_package_loader(\"lazyBayesianRules\") #加载weka相关的包\n####  list_Weka_interfaces()  #列出weka中可以调用的函数，不够的话可以下载\n####  WPM(\"list-packages\", \"installed\")\n####  WPM(\"list-packages\", \"available\")\n######################################\n# 应该是Rweka中默认没有这个函数，需要自己安装以后调用\n#好像在这里调用的时候，要安装weka\n## 调用方法cbind(d,iris[,5])\n#LBR=make_Weka_classifier(\"weka/classifiers/lazy/LBR\")\n#a=LBR(Species~., data=iris)\n#RF <-make_Weka_classifier(\"weka/classifiers/trees/RandomForest\")\n# a=RF(Species~., data=iris)\n\n###############################\n####\nM5P <- make_Weka_classifier(\"weka/classifiers/trees/M5P\")#必须调用\nm.m5p <- M5P(quality~., data = wine_train)\n\n# 画树图\nm.m5p\n\n\n这里的分割与前面的回归树很相似，然而关键的区别在于节点不是以一个数值预测终止，而是以一个线性模型终止（这里表示为LM1和LM2）\n线性模型本身显示在输出后面，例如LM1模型如下，这些值完全可以和多元模型一样解释，每一个数字都是相关特征对于预测的葡萄酒质量的净影响（效应）。对于固定酸度系数0.266意味着每增加一个单位的酸度，葡萄酒的质量预计会增加0.266\n注意的是，估计的影响只适用于到达该节点的葡萄酒案例。在这个模型树中一共建立了36个线性回归模型，每一个模型对于固定的酸度和其他10个特征的影响都有不同的估计\n对于预测数据来说：\n\nShow the code# 生成模型的预测\np.m5p <- predict(m.m5p, wine_test)\n\n# 模型树的预测返回比回归树的广\nsummary(p.m5p)\n\n\n#模型的MSE也有改善\nMAE(wine_test$quality, p.m5p)\n\n\n\nShow the codesessionInfo()\n\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.5.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] rpart.plot_3.1.1 rpart_4.1.16    \n\nloaded via a namespace (and not attached):\n [1] digest_0.6.29     jsonlite_1.8.0    magrittr_2.0.3    evaluate_0.16    \n [5] rlang_1.0.4       stringi_1.7.8     cli_3.3.0         rstudioapi_0.14  \n [9] rmarkdown_2.16.1  tools_4.2.1       stringr_1.4.1     htmlwidgets_1.5.4\n[13] xfun_0.32         yaml_2.3.5        fastmap_1.1.0     compiler_4.2.1   \n[17] htmltools_0.5.3   knitr_1.40"
  },
  {
    "objectID": "posts/post/智能算法测试函数可视化.html",
    "href": "posts/post/智能算法测试函数可视化.html",
    "title": "智能算法测试函数可视化",
    "section": "",
    "text": "\\[\nf(x) = \\sum^n_{i=1}x_i^2\n\\]\n全局最优点为\\(x =(0,0,\\cdots ,0 ),f(x) =0\\)\n\nShow the code#############################\n#### 二维函数 --- 可视化\n##############################\n\n## 1 、 Sphere 函数\nf1_Sphere2 = function(x,y){\n  return(x^2 + y^2)\n}\n\n\n\nShow the codey = x <- seq(-10, 10, 0.1)\nz <- outer(x, y, f1_Sphere2)\nlibrary(plotly)\n\nLoading required package: ggplot2\n\n\n\nAttaching package: 'plotly'\n\n\nThe following object is masked from 'package:ggplot2':\n\n    last_plot\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\n\nThe following object is masked from 'package:graphics':\n\n    layout\n\nShow the codelibrary(widgetframe)\n\nLoading required package: htmlwidgets\n\nShow the codep = plot_ly() %>% add_surface(x = ~x, y = ~y, z = ~z)\nframeWidget(p)\n\n\n\n\n\n\n\\[\nf(x) = \\sum^n_i|x_i| + \\prod^n_i|x_i|\n\\]\n全局最优点为\\(x =(0,0,\\cdots ,0 ),f(x) =0\\)\n\nShow the code## 2、Schwefel 函数\nf2_Schwefel2 = function(x,y){\n  sum(abs(x),abs(y)) + abs(x)*abs(y)\n}\n\n\n\nShow the codey = x <- seq(-10, 10, 0.1)\nz <- outer(x, y, f2_Schwefel2)\np = plot_ly() %>% add_surface(x = ~x, y = ~y, z = ~z)\nframeWidget(p)\n\n\n\n\n\n\n\\[\nf(x) = \\sum^n_{i=1}  \\left( 100 ( x_{i+1}- x_i^2 )^2+ (x_i -1)^2 \\right)\n\\]\n全局最优点为\\(x =(1,1,\\cdots ,1 ),f(x) =0\\)\n\nShow the code## 3、Rosenbrock 函数\nf2_Rosenbrock2 = function(x,y){\n  100*(y-x^2)^2 + (x-1)^2\n}\n\n\n\nShow the codey = x <- seq(-10, 10, 0.1)\nz <- outer(x, y, f2_Rosenbrock2)\np = plot_ly() %>% add_surface(x = ~x, y = ~y, z = ~z)\nframeWidget(p)\n\n\n\n\n\n\n\\[\nf(x) = \\sum_{i=1}^n \\left(  x_i^2 - 10cos(2\\pi x_i) +10 \\right)\n\\]\n全局最优点为\\(x =(0,0,\\cdots ,0 ),f(x) =0\\)\n\nShow the code## 4、Rastrigin\nf2_Rastrigin2 = function(x,y){\n   x^2-10*cos(2*pi*x)+10 + y^2-10*cos(2*pi*y)+10\n}\n\n\n\nShow the codey = x <- seq(-10, 10, 0.1)\nz <- outer(x, y, f2_Rastrigin2)\np = plot_ly() %>% add_surface(x = ~x, y = ~y, z = ~z)\nframeWidget(p)\n\n\n\n\n\n\n\\[\nf(x) = \\frac{1}{4000}\\sum_{i=1}^n x_i^2 -\\prod^n_{i=1}cos\\left( \\frac{x_i}{\\sqrt{i}}\\right) +1\n\\]\n全局最优点为\\(x =(0,0,\\cdots ,0 ),f(x) =0\\)\n\nShow the code## 5/Griewank 函数\nf2_Griewank = function(x,y){\n  1/4000 *(x^2+y^2)-cos(x/1)*cos(y/sqrt(2))+1\n}\n\n\n\nShow the codey = x <- seq(-10, 10, 0.1)\nz <- outer(x, y, f2_Griewank)\np = plot_ly() %>% add_surface(x = ~x, y = ~y, z = ~z)\nframeWidget(p)\n\n\n\n\n\n\n\\[\nf(x) = -20 Exp  \\left(-0.2  \\times \\sqrt{\\frac{1}{30} \\sum_{i=1}^n x_i^2 } \\right) - Exp  \\left(\\sqrt{\\frac{1}{30} \\cos(2 \\pi x_i) } \\right) +20 +e\n\\]\n全局最优点为\\(x =(0,0,\\cdots ,0 ),f(x) =0\\)\n\nShow the code## 6 Ackley 函数\nf2_Ackley2 = function(x,y){\n  -20*exp(-0.2*sqrt(1/30 * (x^2+y^2))) -exp(1/30*(cos(2*pi*x)+cos(2*pi*y)))+20+exp(1)\n}\n\n\n\nShow the codey = x <- seq(-10, 10, 0.1)\nz <- outer(x, y, f2_Ackley2)\np = plot_ly() %>% add_surface(x = ~x, y = ~y, z = ~z)\nframeWidget(p)\n\n\n\n\n\n\n\\[\nf(x) = \\sum_{i=1}^nix_i^4 + rand[0,1)\n\\]\n全局最优点为\\(x =(0,0,\\cdots ,0 ),f(x) =0\\)\n\nShow the code## 7 、Noise函数\nf2_Niose2 = function(x,y){\n  x^4+2*y^2 + rnorm(1,0,1)\n}\n\n\n\nShow the codey = x <- seq(-10, 10, 0.1)\nz <- outer(x, y, f2_Niose2)\np = plot_ly() %>% add_surface(x = ~x, y = ~y, z = ~z)\nframeWidget(p)\n\n\n\n\n\n\n\\[\nf(x) = \\frac{\\sin^2(\\sqrt{x_i^2 +x_2^2}) - 0.5 }{[1+0.001(x_1+x_2)]^2} - 0.5\n\\]\n全局最优点为\\(x =(0,0,\\cdots ,0 ),f(x) = -1\\)\n\nShow the code## 8/shaffer函数\nf2_shaffer2 = function(x,y){\n  (sin(x^2+y^2)^2 -0.5)/(1+0.001*(x^2+y^2))^2 - 0.5\n}\n\n\n\nShow the codey = x <- seq(-10, 10, 0.1)\nz <- outer(x, y, f2_shaffer2)\np = plot_ly() %>% add_surface(x = ~x, y = ~y, z = ~z)\nframeWidget(p)\n\n\n\n\n\n\nShow the codesessionInfo()\n\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.5.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] widgetframe_0.3.1 htmlwidgets_1.5.4 plotly_4.10.0     ggplot2_3.3.6    \n\nloaded via a namespace (and not attached):\n [1] pillar_1.8.1      compiler_4.2.1    tools_4.2.1       digest_0.6.29    \n [5] viridisLite_0.4.1 jsonlite_1.8.0    evaluate_0.16     lifecycle_1.0.1  \n [9] tibble_3.1.8      gtable_0.3.0      pkgconfig_2.0.3   rlang_1.0.4      \n[13] cli_3.3.0         DBI_1.1.3         rstudioapi_0.14   crosstalk_1.2.0  \n[17] yaml_2.3.5        xfun_0.32         fastmap_1.1.0     httr_1.4.4       \n[21] withr_2.5.0       stringr_1.4.1     dplyr_1.0.9       knitr_1.40       \n[25] generics_0.1.3    vctrs_0.4.1       grid_4.2.1        tidyselect_1.1.2 \n[29] data.table_1.14.2 glue_1.6.2        R6_2.5.1          fansi_1.0.3      \n[33] rmarkdown_2.16.1  farver_2.1.1      tidyr_1.2.0       purrr_0.3.4      \n[37] magrittr_2.0.3    scales_1.2.1      htmltools_0.5.3   assertthat_0.2.1 \n[41] colorspace_2.0-3  utf8_1.2.2        stringi_1.7.8     lazyeval_0.2.2   \n[45] munsell_0.5.0"
  },
  {
    "objectID": "posts/post/rmd输出页面.html",
    "href": "posts/post/rmd输出页面.html",
    "title": "测试rmarkdown输出页面",
    "section": "",
    "text": "这是行内公式\\(a^2+b^2+\\sqrt{c}\\),这是行间公式 \\[x^2+y^2= z^2\\] ## 动态图\n\nShow the codelibrary(ggplot2)\nlibrary(plotly)\np <- ggplot(data = diamonds, aes(x = cut, fill = clarity)) +\n            geom_bar(position = \"dodge\")\nggplotly(p)\n\n\n\nShow the codelibrary(rbokeh)\nfigure() %>%\n  ly_points(Sepal.Length, Sepal.Width, data = iris,\n    color = Species, glyph = Species,\n    hover = list(Sepal.Length, Sepal.Width))\n\n\n\nShow the codelibrary(dygraphs)\ndygraph(nhtemp, main = \"New Haven Temperatures\") %>% \n  dyRangeSelector(dateWindow = c(\"1920-01-01\", \"1960-01-01\"))\n\n\n\n\n\nShow the codesummary(cars)\n#>      speed           dist       \n#>  Min.   : 4.0   Min.   :  2.00  \n#>  1st Qu.:12.0   1st Qu.: 26.00  \n#>  Median :15.0   Median : 36.00  \n#>  Mean   :15.4   Mean   : 42.98  \n#>  3rd Qu.:19.0   3rd Qu.: 56.00  \n#>  Max.   :25.0   Max.   :120.00\n\n\n\n\n\nShow the codesummary(iris)\n#>   Sepal.Length    Sepal.Width     Petal.Length    Petal.Width          Species  \n#>  Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.100   setosa    :50  \n#>  1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.600   1st Qu.:0.300   versicolor:50  \n#>  Median :5.800   Median :3.000   Median :4.350   Median :1.300   virginica :50  \n#>  Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199                  \n#>  3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.800                  \n#>  Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500\n\n\n\n\n\nShow the codesummary(iris)\n#>   Sepal.Length    Sepal.Width     Petal.Length    Petal.Width          Species  \n#>  Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.100   setosa    :50  \n#>  1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.600   1st Qu.:0.300   versicolor:50  \n#>  Median :5.800   Median :3.000   Median :4.350   Median :1.300   virginica :50  \n#>  Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199                  \n#>  3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.800                  \n#>  Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500\n\n\n\n\n\n\nint foo (void) {\n    int i;\n}\n\n\nint foo (void) {\n    int i;\n}\n\n\nint foo (void) {\n    int i;\n}\n\n\n\nShow the codesessionInfo()\n#> R version 4.2.1 (2022-06-23)\n#> Platform: aarch64-apple-darwin20 (64-bit)\n#> Running under: macOS Monterey 12.5.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n#> \n#> locale:\n#> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] digest_0.6.29     jsonlite_1.8.0    magrittr_2.0.3    evaluate_0.16     rlang_1.0.4       stringi_1.7.8     cli_3.3.0         rstudioapi_0.14   rmarkdown_2.16.1  tools_4.2.1       stringr_1.4.1     htmlwidgets_1.5.4 xfun_0.32         yaml_2.3.5        fastmap_1.1.0     compiler_4.2.1    htmltools_0.5.3   knitr_1.40"
  },
  {
    "objectID": "posts/post/R画带箭头的坐标轴.html",
    "href": "posts/post/R画带箭头的坐标轴.html",
    "title": "R画带箭头的坐标轴",
    "section": "",
    "text": "本质的方法：就是去掉原有的坐标轴，然后通过R的低等函数一步一步的画出坐标轴以及需要的曲线，以下是google到的几种方法：\n\n\nShow the code##################  画带箭头的坐标轴\n## estimate curve\nx <- seq(-1,1.5,0.1);\ny <- c(1.3,1.32,1.33,1.32,1.25,1.1,0.7,0.5,0.4,0.38,0.4,0.41,0.42,0.43,0.44,0.4,0.3,0.1,0,-0.05,-0.1,-0.15,-0.2,-0.24,-0.28,-0.3);\nf <- splinefun(x,y);\n\n## calculate precise points along estimated curve\nx <- seq(-1,1.5,0.01);\ny <- f(x);\n\n## precompute limits\nxlim <- c(min(x),max(x));\nylim <- c(min(y)-0.4,max(y)+0.2);\n\n## set global plot params\npar(xaxs='i',yaxs='i',mar=c(1,1,3,3)+0.1); ## \"internal\" axis spacing, meaning no extended range, and slightly adjust margins\n\n## draw plot\nplot(NA,xlim=xlim,ylim=ylim,axes=F,ann=F); ## set plot bounds, no default ornaments\narrows(c(0,xlim[1]),c(ylim[1],0),c(0,xlim[2]),c(ylim[2],0),0.05); ## draw custom axes\nmtext('y',3,1,at=0,las=1,cex=0.8,family='serif'); ## y label\nmtext('x',4,1,at=0,las=1,cex=0.8,family='serif'); ## x label\nlines(x,y,col='#aaaacc'); ## draw line on top\n\n\n\n\n\n\nShow the code##  Simulate your data:\nx <- seq(-1, 3, by=0.01)\ny <- 0.5*x - 0.3*x^2 + 0.4*x^3\n\n##  Plot the polynomial function, removing axis ticks and bounding box,\n##    as well as the axis labels:\nplot(x, y, \n     type=\"l\", \n     xaxt='n', yaxt='n', \n     bty='n', \n     xlab='', ylab='', \n     col=\"blue\")# 画图\n\n##  Next add in your axis arrows:\n# 适当缩小坐标轴 \nsmall = 0.9\narrows(min(x)*small, 0, max(x)*small, 0, lwd=1, length=0.15)\narrows(0, min(y)*small, 0, max(y)*small, lwd=1, length=0.15)\n\n\n\n\n\n在方法二的基础上进行进一步修改\n\nShow the code##  Simulate your data:\nx <- seq(-1, 3, by=0.01)\ny <- 0.5*x - 0.3*x^2 + 0.4*x^3\n\n##  Plot the polynomial function, removing axis ticks and bounding box,\n##    as well as the axis labels:\nplot(x, y, \n     type=\"l\", \n     xaxt='n', yaxt='n', \n     bty='n', \n     xlab='', ylab='', \n     col=\"blue\")# 画图\n\n##  Next add in your axis arrows:\n# 适当缩小坐标轴 \nsmall = 0.9\narrows(min(x)*small, 0, max(x)*small, 0, lwd=1, length=0.15)\narrows(0, min(y)*small, 0, max(y)*small, lwd=1, length=0.15)\npar(family='STKaiti')\n\ntext(max(x), (max(y) - min(y))*0.1,'X轴')\n\ntext((max(x)-min(x))*0.1, max(y),'Y轴')\n\n# 画标度---x 标度\nk1 =ceiling(range(x)[1]*small)\nk2 = floor(range(x)[2] *small )\nk = 0.5 #k为刻度\nfor (i in seq(k1,k2,k)) {\n  n=10\n  if(i == 0 ) next()\n  lines(rep(i,n),seq(0,k*0.3,length.out = n),type = \"l\")# 垂直X轴的直线长度\n  \n  text(i,-(max(x) - min(x) )*0.1,i)\n  \n}\n\n\n# 画标度---y 标度\nk1 =ceiling(range(y)[1]*small) \nk2 = floor(range(y)[2]*small)\nk = 1\nfor (i in seq(k1,k2,k)) { # 坐标轴的间隔，以1为单位,k为刻度\n  n=10\n  if(i == 0 ) next()\n  lines(seq(0,k*0.01,length.out = n),rep(i,n),type = \"l\")\n  text(-0.02*(max(x)-min(x) ),i,i)\n}\n## 画原点\ntext(-(max(x) - min(x))*0.03,-(max(y) - min(y))*0.03,\"O\",cex=1.3)"
  },
  {
    "objectID": "posts/post/R画带箭头的坐标轴.html#基本函数画多折线图",
    "href": "posts/post/R画带箭头的坐标轴.html#基本函数画多折线图",
    "title": "R画带箭头的坐标轴",
    "section": "基本函数画多折线图",
    "text": "基本函数画多折线图\n\nShow the codet = seq(1,10,length.out = 10000)\nmatplot(t,cbind(sin(t),cos(t)),type ='b',pch = 19,cex = 0.1)\n\n\n\n\n\nShow the codesessionInfo()\n#> R version 4.2.1 (2022-06-23)\n#> Platform: aarch64-apple-darwin20 (64-bit)\n#> Running under: macOS Monterey 12.5.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n#> \n#> locale:\n#> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] digest_0.6.29     jsonlite_1.8.0    magrittr_2.0.3    evaluate_0.16    \n#>  [5] rlang_1.0.4       stringi_1.7.8     cli_3.3.0         rstudioapi_0.14  \n#>  [9] rmarkdown_2.16.1  tools_4.2.1       stringr_1.4.1     htmlwidgets_1.5.4\n#> [13] xfun_0.32         yaml_2.3.5        fastmap_1.1.0     compiler_4.2.1   \n#> [17] htmltools_0.5.3   knitr_1.40"
  },
  {
    "objectID": "posts/post/glmnet包.html",
    "href": "posts/post/glmnet包.html",
    "title": "glmnet包解读",
    "section": "",
    "text": "glmnet 包解决了一下问题（目标函数） \\[\n\\min_{\\beta_0,\\beta} \\frac{1}{N} \\sum_{i=1}^{N} w_i l(y_i,\\beta_0+\\beta^T x_i) + \\lambda\\left[(1-\\alpha)||\\beta||_2^2/2 + \\alpha ||\\beta||_1\\right],\n\\] #### 1.1 glmnet包安装\n\nShow the codeinstall.packages(\"glmnet\", repos = \"http://cran.us.r-project.org\")"
  },
  {
    "objectID": "posts/post/glmnet包.html#快速开始",
    "href": "posts/post/glmnet包.html#快速开始",
    "title": "glmnet包解读",
    "section": "2 快速开始",
    "text": "2 快速开始\n这节介绍glmnet包中的主要函数以及它们的一般用法，对常用函数的输入参数以及输出结果做简要的说明。\n2.1 加载glmnet包\n\nShow the codelibrary(glmnet)# 加载glmnet包\n\n\n以线性回归为例，来说明glmnet包的用法。\n2.2 准备数据\n\nShow the codedata(QuickStartExample)#x为100*20的矩阵 ,y为100 * 1的矩阵。\nx = QuickStartExample$x\ny = QuickStartExample$y\n\n\n该命令R数据存档中加载输入矩阵x和响应向量y。 x为100*20的矩阵 ,y为100 * 1的矩阵。\n2.3 拟合模型\n数据有了，我们就可以调用包中与之同名的glmnet函数来做线性回归了：\n\nShow the codefit = glmnet(x, y)\n\n\n这里生成的结果 “fit”是类的对象glmnet，包含拟合模型的所有相关信息。不鼓励用户直接提取组件（像list那样提取）。推荐使用各种方法plot，print，coef和predict提取信息，这样能够使我们更优雅执行这些任务。\n2.4 模型对象的可视化\n采用plot函数对拟合出的模型系数进行可视化：\n\nShow the code# label = T，可以显示变量的标签。\n# 参数xvar = c(\"norm\", \"lambda\", \"dev\")\n# norm（默认）:  显示系数值和L1范数之间的变化关系\n# lambda： 显示系数值和对数lambda之间的变化关系\n# dev : 显示系数值如何随解释偏差百分比（dev）之间的变化关系\nplot(fit,label = T)\n\n\n\n\n上图中，每一条曲线代表一个变量的系数。Y轴是回归系数的值，X轴是L1范数，图中上方有另一条x轴，其数值表示模型的特征数，\n2.5 模型对象信息的提取\n回到我们的拟合结果fit。作为一个 R 对象，我们可以把它当作很多函数的输入。比如说，我们可以查看详细的拟合结果：\n\nShow the codeprint(fit)\n#> \n#> Call:  glmnet(x = x, y = y) \n#> \n#>    Df  %Dev  Lambda\n#> 1   0  0.00 1.63100\n#> 2   2  5.53 1.48600\n#> 3   2 14.59 1.35400\n#> 4   2 22.11 1.23400\n#> 5   2 28.36 1.12400\n#> 6   2 33.54 1.02400\n#> 7   4 39.04 0.93320\n#> 8   5 45.60 0.85030\n#> 9   5 51.54 0.77470\n#> 10  6 57.35 0.70590\n#> 11  6 62.55 0.64320\n#> 12  6 66.87 0.58610\n#> 13  6 70.46 0.53400\n#> 14  6 73.44 0.48660\n#> 15  7 76.21 0.44330\n#> 16  7 78.57 0.40400\n#> 17  7 80.53 0.36810\n#> 18  7 82.15 0.33540\n#> 19  7 83.50 0.30560\n#> 20  7 84.62 0.27840\n#> 21  7 85.55 0.25370\n#> 22  7 86.33 0.23120\n#> 23  8 87.06 0.21060\n#> 24  8 87.69 0.19190\n#> 25  8 88.21 0.17490\n#> 26  8 88.65 0.15930\n#> 27  8 89.01 0.14520\n#> 28  8 89.31 0.13230\n#> 29  8 89.56 0.12050\n#> 30  8 89.76 0.10980\n#> 31  9 89.94 0.10010\n#> 32  9 90.10 0.09117\n#> 33  9 90.23 0.08307\n#> 34  9 90.34 0.07569\n#> 35 10 90.43 0.06897\n#> 36 11 90.53 0.06284\n#> 37 11 90.62 0.05726\n#> 38 12 90.70 0.05217\n#> 39 15 90.78 0.04754\n#> 40 16 90.86 0.04331\n#> 41 16 90.93 0.03947\n#> 42 16 90.98 0.03596\n#> 43 17 91.03 0.03277\n#> 44 17 91.07 0.02985\n#> 45 18 91.11 0.02720\n#> 46 18 91.14 0.02479\n#> 47 19 91.17 0.02258\n#> 48 19 91.20 0.02058\n#> 49 19 91.22 0.01875\n#> 50 19 91.24 0.01708\n#> 51 19 91.25 0.01557\n#> 52 19 91.26 0.01418\n#> 53 19 91.27 0.01292\n#> 54 19 91.28 0.01178\n#> 55 19 91.29 0.01073\n#> 56 19 91.29 0.00978\n#> 57 19 91.30 0.00891\n#> 58 19 91.30 0.00812\n#> 59 19 91.31 0.00739\n#> 60 19 91.31 0.00674\n#> 61 19 91.31 0.00614\n#> 62 20 91.31 0.00559\n#> 63 20 91.31 0.00510\n#> 64 20 91.31 0.00464\n#> 65 20 91.32 0.00423\n#> 66 20 91.32 0.00386\n#> 67 20 91.32 0.00351\n\n\n每一行代表了一个模型 ,它从左到右显示非零系数的个数（Df），模型所解释的偏差的百分比（%dev）和λ的值（Lambda） （注意岭回归中列Df的值是不会变的）\n通过coef来提取模型的系数：\n\nShow the code# 参数s：指定lambda的值，可以是一个向量，则提取多个模型的系数，每一列对应一个模型的系数\n# 参数complete: 逻辑值,表示是否应该返回全系数向量.\ncoef(fit,s=0.1,exact=FALSE)\n#> 21 x 1 sparse Matrix of class \"dgCMatrix\"\n#>                       s1\n#> (Intercept)  0.150928072\n#> V1           1.320597195\n#> V2           .          \n#> V3           0.675110234\n#> V4           .          \n#> V5          -0.817411518\n#> V6           0.521436671\n#> V7           0.004829335\n#> V8           0.319415917\n#> V9           .          \n#> V10          .          \n#> V11          0.142498519\n#> V12          .          \n#> V13          .          \n#> V14         -1.059978702\n#> V15          .          \n#> V16          .          \n#> V17          .          \n#> V18          .          \n#> V19          .          \n#> V20         -1.021873704\n\n\n用coef来提取模型的系数,参数采用的是s 而不是lambda,—同样在predict函数中一样的道理,eg:\n2.6 预测\n预测采用predict函数，参数newx用来设置输入数据，s用来设置\\(\\lambda\\)的值：\n\nShow the codenx = matrix(rnorm(10*20),10,20)\n#predict函数与coef函数相比多了一些参数的设置，参数newx设置待预测的输入数据集，以及tpye参数选项\npredict(fit,newx=nx,s=c(0.1,0.05))\n#>               s1         s2\n#>  [1,]  3.0645177  3.1692489\n#>  [2,] -3.8464436 -4.0214530\n#>  [3,] -2.7960974 -2.8602526\n#>  [4,]  2.9600417  2.9398673\n#>  [5,]  0.5909848  0.5552065\n#>  [6,]  3.1098915  3.0987444\n#>  [7,] -0.6805110 -0.6753306\n#>  [8,] -1.9822822 -2.1139755\n#>  [9,]  0.6055422  0.5990625\n#> [10,]  1.0461363  1.0735680\n\n\n2.7 交叉验证\nglmnet提供了一系列的模型可供选择，而在大多数情况下我们需要从中挑选出一个最合适的来用就可以了。这时可以通过交叉验证的方法来筛选最优的λ值了，cv.glmnet函数实现了这一功能。 也支持绘图和预测方法。\n继续沿用之前的样本数据，调用cv.glmnet函数：\n\nShow the codecvfit = cv.glmnet(x, y)\n\n\n可以看到，cv.glmnet返回的结果是一个cv.glmnet类的对象，该对象的类型和glmnet函数返回的结果一样，它们本质上都是R中的list。 不鼓励直接提取信息，推荐使用各种函数提取.\n我们用可视化的图形来展示cv.glmnet的结果：\n\nShow the codeplot(cvfit)\n\n\n\n\n从图中可以看到MSE是如何随着lambda的不同取值而变化的。红色的散点为交叉验证的散点图，横轴为logλ，纵轴为均方误差，每个点的标准偏差上界和下界也画出来了。图的顶部字数表示非零系数的个数，第一条垂直线对应的是lambda.min的值，它是交叉验证提取出的最优值，第二条（从左往右看）是lambda.lse属性的值，它对应了距离lambda.min一个标准误差的值，并产生了一个更为正则化的模型 （lambda.1se为离最小均方误差一倍标准差的λ值。 ）\n最优的λ 值可以直接采用如下命令来提取：\n\nShow the codecvfit$lambda.min\n#> [1] 0.07569327\ncvfit$lambda.1se\n#> [1] 0.1593271\n\n\n用coef函数来提取回归模型的系数：\n\nShow the codecoef(cvfit, s = \"lambda.min\")\n#> 21 x 1 sparse Matrix of class \"dgCMatrix\"\n#>                      s1\n#> (Intercept)  0.14867414\n#> V1           1.33377821\n#> V2           .         \n#> V3           0.69787701\n#> V4           .         \n#> V5          -0.83726751\n#> V6           0.54334327\n#> V7           0.02668633\n#> V8           0.33741131\n#> V9           .         \n#> V10          .         \n#> V11          0.17105029\n#> V12          .         \n#> V13          .         \n#> V14         -1.07552680\n#> V15          .         \n#> V16          .         \n#> V17          .         \n#> V18          .         \n#> V19          .         \n#> V20         -1.05278699\n\n\n可以看到回归模型的系数是采用稀疏矩阵的形式来存储的。由于计算出的模型系数经常是稀疏的，这时采用稀疏矩阵的方式来存储和计算更有效率。如果你不习惯稀疏矩阵的输出形式，可以用as.matrix()将其转化为传统的矩阵形式。\n预测同glmnet，直接采用predict泛型函数即可：\n\nShow the codepredict(cvfit, newx = x[1:5,], s = \"lambda.min\")\n#>      lambda.min\n#> [1,] -1.3638848\n#> [2,]  2.5713428\n#> [3,]  0.5729785\n#> [4,]  1.9881422\n#> [5,]  1.5179882\n\n\n自此，glmnet的入门介绍完了，你可以用来他做一些基本的回归模型了。\n接下来，我们对glmnet包进行更为深入的介绍。"
  },
  {
    "objectID": "posts/post/glmnet包.html#线性回归",
    "href": "posts/post/glmnet包.html#线性回归",
    "title": "glmnet包解读",
    "section": "3 线性回归",
    "text": "3 线性回归\nglmnet中的线性回归主要包含两类。一定是高斯簇gaussian，还有一类是多响应高斯簇mgaussian。我们依次介绍：\n3.1 高斯簇\ngaussian 是glmnet函数中的默认函数簇，它本质上是带正则项的多元线性回归的估计问题。\n3.1.1 优化目标\n优化的目标函数如下：（高斯族采用的是平方损失函数） \\[\n\\min_{(\\beta_0, \\beta) \\in \\mathbb{R}^{p+1}}\\frac{1}{2N} \\sum_{i=1}^N (y_i -\\beta_0-x_i^T \\beta)^2+\\lambda \\left[ \\dfrac{1}{2}(1-\\alpha)||\\beta||_2^2 + \\alpha||\\beta||_1\\right],\n\\] 其中 \\(\\lambda \\geq 0\\) 是模型复杂度参数 ;\\(0 \\leq \\alpha \\leq 1\\) ，当\\(\\alpha = 0\\) 时为岭回归，当\\(\\alpha = 1\\)为lasso，在\\(0 <\\alpha < 1\\)则为两者的折中.\n3.1.2 glmnet参数设置\nglmnet提供了很多参数可以供我们选择。下面介绍一些常用的参数设置：\n\n\nalpha之前介绍过，它是弹性网的参数，取值范围是[0, 1], (且只能一个一个取，不能为向量)\n\nweights配置观测的权重。默认每个观测的权重取值均为1。\n\nnlambda默认值是100。(系统自动挑选 100 个不同的 λ 值，拟合出 100 个系数不同的模型 ）\n\nlambda一般是程序自动构建，也可以自己定义（可以是向量）。\n\nstandardize表示在拟合模型前，x变量是否需要标准化。默认standardize=TRUE。\n\n更多参数设置参考帮助文档help(glmnet)。\n我们用下面的例子来看看这些参数的用法： 还是用原来的样本数据，不同的是取α = 0.2（接近岭回归的正则项），设置观测的权重以及 λ序列的数量：\n\nShow the codefit = glmnet(x, y, alpha = 0.2, weights = c(rep(1,50),rep(2,50)), nlambda = 20)\n\n\n用print函数打印结果：\n\nShow the codeprint(fit)\n#> \n#> Call:  glmnet(x = x, y = y, weights = c(rep(1, 50), rep(2, 50)), alpha = 0.2,      nlambda = 20) \n#> \n#>    Df  %Dev Lambda\n#> 1   0  0.00 7.9390\n#> 2   4 17.89 4.8890\n#> 3   7 44.45 3.0110\n#> 4   7 65.67 1.8540\n#> 5   8 78.50 1.1420\n#> 6   9 85.39 0.7033\n#> 7  10 88.67 0.4331\n#> 8  11 90.25 0.2667\n#> 9  14 91.01 0.1643\n#> 10 17 91.38 0.1012\n#> 11 17 91.54 0.0623\n#> 12 17 91.60 0.0384\n#> 13 19 91.63 0.0236\n#> 14 20 91.64 0.0146\n#> 15 20 91.64 0.0090\n#> 16 20 91.65 0.0055\n#> 17 20 91.65 0.0034\n\n\n打印结果之前已做过说明，这里不再赘述。可以看到这里λ并没有达到预设的20。这是因为在偏差解释率达到0.999或者其变化小于10e-5时计算就会终止。而这些预设的计算终止条件可以通过glmnet.control来设置，详见help(glmnet.control)。\n注意，可以设置digits选项可用于指定打印输出中的有效数字\n3.1.3 plot参数设置\nY轴为模型的系数值。\nplot函数可以用xvar来定义X轴的度量，有三种选项：\n\n“norm” 表示系数的L1-范数(默认)，显示系数值和L1范数之间的变化关系\n“lambda” 表示对数lambda值，显示系数值和对数lambda之间的变化关系\n“dev” 表示偏差解释率，显示系数值如何随解释偏差百分比（dev）之间的变化关系\n\n在plot函数中添加参数label = TRUE可以显示变量的标签\n\nShow the codelayout(matrix(c(1,2,3),1,3))\nplot(fit, xvar = \"norm\", label = TRUE,main='nrom\\n')\nplot(fit, xvar = \"lambda\", label = TRUE,main='lambda\\n')\nplot(fit, xvar = \"dev\", label = TRUE,main='dev\\n')\n\n\n\n\n每一条曲线代表一个变量的系数。Y轴是回归系数的值，X轴是L1范数(默认)，图中上方有另一条x轴，其数值表示模型的特征数，\n3.1.4 coef参数设置\ncoef函数中最常用的两个参数为:\n\n\ns 指定λ值\n\ncomplete 表示是否应该返回全系数向量.\n\n\nShow the codeany(fit$lambda == 0.5)\n#> [1] FALSE\ncoef.exact = coef(fit, s = 0.5, complete = TRUE)\ncoef.apprx = coef(fit, s = 0.5, complete = FALSE)\ncbind2(coef.exact, coef.apprx)\n#> 21 x 2 sparse Matrix of class \"dgCMatrix\"\n#>                       s1           s1\n#> (Intercept)  0.199098747  0.199098747\n#> V1           1.174650452  1.174650452\n#> V2           .            .          \n#> V3           0.531934651  0.531934651\n#> V4           .            .          \n#> V5          -0.760959480 -0.760959480\n#> V6           0.468209413  0.468209413\n#> V7           0.061926756  0.061926756\n#> V8           0.380301491  0.380301491\n#> V9           .            .          \n#> V10          .            .          \n#> V11          0.143260991  0.143260991\n#> V12          .            .          \n#> V13          .            .          \n#> V14         -0.911207368 -0.911207368\n#> V15          .            .          \n#> V16          .            .          \n#> V17          .            .          \n#> V18          0.009196628  0.009196628\n#> V19          .            .          \n#> V20         -0.863117051 -0.863117051\n\n\n结论： 当exact选取不同的参数时，提取的系数也存在一定程度的差异，但差距不大。没有特别要求的话，使用线性插值得到的结果已经够用了。\n3.1.5 predict参数设置\npredict函数与coef函数相比多了一些参数的设置：newx是待预测的输入数据集。\ntype有多个选项可供选择：\n\n“link” 给出预测值\n“response” 对于gaussian簇，同“link”\n“coefficients” 计算给定s下的系数矩阵\n“nonzero” list对象，存储每个s下非0系数对应的下标\n\n\nShow the codepredict(fit, newx = x[1:5,], type = \"response\", s = 0.05)\n#>              s1\n#> [1,] -0.9802591\n#> [2,]  2.2992453\n#> [3,]  0.6010886\n#> [4,]  2.3572668\n#> [5,]  1.7520421\n\n\n上述命令表示在λ = 0.05时计算x头5条观测的预测值。这里的s可以是一个向量，当s是一个多数值向量时，预测值则为一个矩阵。\n3.1.6 交叉验证\n3.1.6.1 普通计算\n这小节对cv.glmnet函数的参数做简要说明：\n\n\nnfolds – 交叉验证数据集划分的份数\n\nfoldid – 自定义划分数据\n\ntype.measure – 定义交叉验证的损失函数，“deviance”和“mse”用的是平方损失，“mae”用的是平均绝对损失\n\n举一个列子：\n\nShow the code# 做20重交叉验证，采用平均绝对损失\ncvfit <- cv.glmnet(x, y, type.measure = \"mse\", nfolds = 20)\n\n\n3.1.6.2 并行计算\ncv.glmnet也支持并行计算，不过要使其工作，用户必须加载doMC并注册并行数量. 在这里给出一个简单的比较示例。 (不过很遗憾，win不能用)\n\nShow the coderequire(doMC) # win不能用,可以下载下来，但是不能平行计算。\n# install.packages(\"doMC\", repos=\"http://R-Forge.R-project.org\")\nregisterDoMC(cores=2)\nX = matrix(rnorm(1e4 * 200), 1e4, 200)\nY = rnorm(1e4)\nsystem.time(cv.glmnet(X, Y))\n#>    user  system elapsed \n#>   0.704   0.039   0.744\nsystem.time(cv.glmnet(X, Y, parallel = TRUE))\n#>    user  system elapsed \n#>   0.952   0.215   0.736\n\n\n\nShow the code# 看了一下帮助文档 可以改成doParallel 也不能用很奇怪\nlibrary(doParallel)\n# Windows 可以使用的并行包，但在这里也不能进行并行计算，时间不变\ncl<-makeCluster(6)\nregisterDoParallel(cl)\nsystem.time({cvfit = cv.glmnet(x,y,parallel=TRUE)})\n#>    user  system elapsed \n#>   0.021   0.013   0.924\nstopCluster(cl)# 时间也没有明显提高\n\n\n如上所述，并行计算可以显着加速计算过程，尤其是对于大规模问题。\n3.1.6.3 提取最优参数\n函数 coef 和 predict 处理cv.glmnet 对象和处理 glmnet 对象类似。不过处理cv.glmnet对象时，在指定\\(s\\)参数是可以用两个特殊的字符:lambda.1se和lambda.min\n\n“lambda.1se”: 为离最小均方误差MSE一倍标准差的\\(\\lambda\\)值。\n“lambda.min”: 达到最小MSE对应的\\(\\lambda\\)值（即 交叉验证提取出的最优值）\n\n\nShow the codecvfit$lambda.min\n#> [1] 0.07569327\ncoef(cvfit, s = \"lambda.min\")\n#> 21 x 1 sparse Matrix of class \"dgCMatrix\"\n#>                      s1\n#> (Intercept)  0.14867414\n#> V1           1.33377821\n#> V2           .         \n#> V3           0.69787701\n#> V4           .         \n#> V5          -0.83726751\n#> V6           0.54334327\n#> V7           0.02668633\n#> V8           0.33741131\n#> V9           .         \n#> V10          .         \n#> V11          0.17105029\n#> V12          .         \n#> V13          .         \n#> V14         -1.07552680\n#> V15          .         \n#> V16          .         \n#> V17          .         \n#> V18          .         \n#> V19          .         \n#> V20         -1.05278699\npredict(cvfit, newx = x[1:5,], s = \"lambda.min\")\n#>      lambda.min\n#> [1,] -1.3638848\n#> [2,]  2.5713428\n#> [3,]  0.5729785\n#> [4,]  1.9881422\n#> [5,]  1.5179882\n\n\n3.1.6.4 数据划分问题\n除了可以设置nfolds来寻找合适的模型外，我们还可以通过foldid设置相同的数据划分来选择最优的α值。\n\nShow the codefoldid=sample(1:10,size=length(y),replace=TRUE)\ncv1=cv.glmnet(x,y,foldid=foldid,alpha=1)\ncv.5=cv.glmnet(x,y,foldid=foldid,alpha=.5)\ncv0=cv.glmnet(x,y,foldid=foldid,alpha=0)\n\n\n进行对比\n\nShow the codepar(mfrow=c(2,2))\nplot(cv1);plot(cv.5);plot(cv0)\nplot(log(cv1$lambda),cv1$cvm,pch=19,col=\"red\",xlab=\"log(Lambda)\",ylab=cv1$name)\npoints(log(cv.5$lambda),cv.5$cvm,pch=19,col=\"grey\")\npoints(log(cv0$lambda),cv0$cvm,pch=19,col=\"blue\")\nlegend(\"topleft\",legend=c(\"alpha= 1\",\"alpha= .5\",\"alpha 0\"),pch=19,col=c(\"red\",\"grey\",\"blue\"))\n\n\n\n\n我们可以看到这里选择lasso(alpha=1)时，模型的均方误差最小。\n3.1.7 系数上限和下限\n这些是最近添加的功能，可以增强模型的范围。假设我们想要拟合我们的模型，但是要将系数限制为大于-0.7且小于0.5。这可以通过upper.limits和lower.limits参数轻松实现：\n\nShow the codetfit=glmnet(x,y,lower=-.7,upper=.5)\nplot(tfit)\n\n\n\n\n这些是相当随意的限制; 通常我们希望系数为正，所以我们只能设置lower.limit为0\n\n注意,上下限的取值范围 ：upper.limits的值不能小于0，lower.limits的值不能大于0 ,另外，如果想对每一个变量的系数对不同的限定，需要将这里的单点值即标量改为向量的形式就可以了。\n\n3.1.8 惩罚因子\n这个参数可以给每一个系数提供一个单独的惩罚因子。该惩罚因子默认是1，它也支持自定义。如果将惩罚因子全部设置成为0的话，相当于就没有惩罚项了。\n看看以下公式就一目了然了： \\[\n\\lambda \\sum_{j=1}^p \\boldsymbol{v_j} P_\\alpha(\\beta_j) = \\lambda \\sum_{j=1}^p \\boldsymbol{v_j} \\left[ (1-\\alpha)\\frac{1}{2} \\beta_j^2 + \\alpha |\\beta_j| \\right].\n\\] 这个参数设置选项很有用，假如我们知道了一些先验信息，知道了其中一些变量很重要，需要在建模正则化的同时一直保留这些变量，那么可以把这些变量对应系数的惩罚因子设置为0。\n同样用之前的数据，我们把第5、10、15个变量对应的惩罚因子设置为0：\n\nShow the codep.fac = rep(1, 20)\np.fac[c(5, 10, 15)] = 0\npfit = glmnet(x, y, penalty.factor = p.fac)\nplot(pfit, label = TRUE)\n\n\n\n\n从上图中可以看到，变量5、10、15对应的系数一直都在模型中。\n还有一些其它的有用的参数，比如，exclude参数可以用来限制指定的变量入选模型；intercept参数可以用来设定模型是否含有截距项等等。更多设置参考帮助文档help(cv.glmnet).\n3.1.9 自定义图\n有时，特别是当变量数量很少时，我们希望将变量标签添加到绘图中，而不是用变量的所在数据集中的下标。 如下：简单生成一组数据，拟合一个glmnet模型 ，并画出图\n\nShow the codeset.seed(101)\nx=matrix(rnorm(1000),100,10)\ny=rnorm(100)\nvn=paste(\"var\",1:10) \nfit=glmnet(x,y)\nplot(fit)\n\n\n\n\n然而我们想要的是用变量名称标记曲线 ，如下：\n\nShow the codepar(mar=c(4.5,4.5,1,4))\nplot(fit)\nvnat=coef(fit)\nvnat=vnat[-1,ncol(vnat)] # remove the intercept, and get the coefficients at the end of the path\naxis(4, at=vnat,line=-.5,label=vn,las=1,tick=FALSE, cex.axis=0.5)\n\n\n\n\n3.2 多响应高斯簇\n多响应高斯簇模型的估计需要在glmnet函数中设置family = \"mgaussian\"。与以上单变量响应模型类似，它只是响应变量增多了，我们通常称之为“多任务学习”问题。虽然响应变量增多了，但是建模时所选择的自变量是完全一样的，只是待估系数不同而已。\n很显然，模型的因变量不再是一个向量形式，而是一个二维矩阵，这时估计出的系数也会是一个矩阵，先看看多响应高斯簇模型解决的问题： \\[\n\\min_{(\\beta_0, \\beta) \\in \\mathbb{R}^{(p+1)\\times K}}\\frac{1}{2N} \\sum_{i=1}^N ||y_i -\\beta_0-\\beta^T x_i||^2_F+\\lambda \\left[ (1-\\alpha)||\\beta||_F^2/2 + \\alpha\\sum_{j=1}^p||\\beta_j||_2\\right].\n\\] 这里的βj是\\(p\\times K\\)维的系数矩阵\\(\\beta\\)的第j行。\n3.2.1 载入演示数据\n\nShow the codedata(MultiGaussianExample)# 产生x,y两个矩阵，x的维度100*20 ,y的维度100 * 4。\nx = MultiGaussianExample$x\ny = MultiGaussianExample$y\n\n\n3.2.2 拟合模型\n\nShow the codemfit = glmnet(x, y, family = \"mgaussian\")\n\n\n多响应高斯模型与单响应高斯模型的大部分参数设置相同，如alpha,weights,nlambda,standardize。但是mgaussian簇有一个额外的参数standardize.response，它可以用来给响应变量做标准化，默认为FALSE。\n3.2.3 查看拟合效果\n用plot函数查看系数的变化：\n\nShow the codeplot(mfit, xvar = \"lambda\", label = TRUE, type.coef = \"2norm\")\n\n\n\nShow the codeplot(mfit, xvar = \"lambda\", label = TRUE, type.coef = \"coef\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n其中xvar并且label两个参数的设置与单响应的高斯模型一样 。这里的type.coef = \"2norm\"表示每个变量的系数以二范数的形式展现。默认设置为type.coef = \"coef\"，这时每个响应变量会展示一张系数变化的图。\n3.2.4 预测\n可以通过coef函数提取系数 ，predict函数进行预测。用法和但响应的高斯模型一样，下面看看predict的用法：\n\nShow the codepredict(mfit, newx = x[1:5,], s = c(0.1, 0.01))\n#> , , 1\n#> \n#>              y1         y2         y3       y4\n#> [1,] -4.7106263 -1.1634574  0.6027634 3.740989\n#> [2,]  4.1301735 -3.0507968 -1.2122630 4.970141\n#> [3,]  3.1595229 -0.5759621  0.2607981 2.053976\n#> [4,]  0.6459242  2.1205605 -0.2252050 3.146286\n#> [5,] -1.1791890  0.1056262 -7.3352965 3.248370\n#> \n#> , , 2\n#> \n#>              y1         y2         y3       y4\n#> [1,] -4.6415158 -1.2290282  0.6118289 3.779521\n#> [2,]  4.4712843 -3.2529658 -1.2572583 5.266039\n#> [3,]  3.4735228 -0.6929231  0.4684037 2.055574\n#> [4,]  0.7353311  2.2965083 -0.2190297 2.989371\n#> [5,] -1.2759930  0.2892536 -7.8259206 3.205211\n\n\n3.2.5 交叉验证\n同样的交叉验证用cv.glmnet函数：\n\nShow the codecvmfit = cv.glmnet(x, y, family = \"mgaussian\")\n\n\n画出交叉验证的结果：\n\nShow the codeplot(cvmfit)\n\n\n\n\n想要查看最优的\\(\\lambda\\),,采用如下命令:\n\nShow the codecvmfit$lambda.min\n#> [1] 0.05193158\ncvmfit$lambda.1se\n#> [1] 0.174054\n\n\n和以前一样，第一个是达到最小均方误差的值，第二个是最正则化模型，其均方误差在最小值的一个标准误差范围内"
  },
  {
    "objectID": "posts/post/glmnet包.html#逻辑回归",
    "href": "posts/post/glmnet包.html#逻辑回归",
    "title": "glmnet包解读",
    "section": "4 逻辑回归",
    "text": "4 逻辑回归\n逻辑回归是分类问题中最常用的模型之一。如果是一个二分类问题，一般假定响应变量服从二项分布，如果是多分类问题，则假定服从多项式分布。\n4.1 二项分布逻辑回归\n假定响应变量的取值为 \\(\\mathcal{G}=\\{1,2\\}\\).定义 \\(y_i = I(g_i=1)\\).则有\n\\[\n\\mbox{Pr}(G=2|X=x)+\\frac{e^{\\beta_0+\\beta^Tx}}{1+e^{\\beta_0+\\beta^Tx}}\n\\] 我们可以两边取对数，改写为如下形式（称为对数似然函数）：\n\\[\n\\log\\frac{\\mbox{Pr}(G=2|X=x)}{\\mbox{Pr}(G=1|X=x)}=\\beta_0+\\beta^Tx\n\\]\n这个带惩罚逻辑回归的目标函数的对数似然如下： \\[\n\\min_{(\\beta_0, \\beta) \\in \\mathbb{R}^{p+1}} -\\left[\\frac{1}{N} \\sum_{i=1}^N y_i \\cdot (\\beta_0 + x_i^T \\beta) - \\log (1+e^{(\\beta_0+x_i^T \\beta)})\\right] + \\lambda \\big[ (1-\\alpha)||\\beta||_2^2/2 + \\alpha||\\beta||_1\\big].\n\\] 当 \\(p > N\\) 时，逻辑回归常常伴随着退化的困扰 ，当\\(N\\)接近\\(p\\)时，甚至在表现出野蛮的行为 。弹性网惩罚缓解了这些问题。\n4.1.1 载入示例数据集\n\nShow the codedata(BinomialExample)# 产生名为x维度为100*30的矩阵 ,名为y长度为100的int向量（0、1向量）\nx = BinomialExample$x\ny = BinomialExample$y\n\n\n这里的输入x与其他分布簇相同，对于二项Logistic回归，响应变量y应该是具有两个级别的因子，或者是计数或比例的两列矩阵\n4.1.2 拟合模型\nglmnet二项式回归的其他可选参数与高斯族的几乎相同.仅需要把函数簇改为family = \"binomial\"即可：\n\nShow the codefit = glmnet(x, y, family = \"binomial\")\n\n\n4.1.3 查看拟合效果\n同样， 我们可以用print和plot函数去查看对象 , 用coef提取特定λ的系数，用predict可以做出预测 .\n\nShow the codeplot(fit, xvar = \"dev\", label = TRUE)\n\n\n\n\n4.1.4 预测\n逻辑回归的预测同高斯簇函数的用法有点不同，主要体现在参数type的设置上，详细概括如下：\n\n“link” 线性拟合值\n“response” 拟合的概率值\n“class” 给出计算出的最大概率对应的类的标签\n“coefficients” 计算给定s下的系数的估计值\n“nonzero” 返回一个list对象，该list包含每一个s对应非零系数的索引\n\n\n对于“二项式”模型，预测结果仅仅是针对响应变量的第二个水平(“link”, “response”, “coefficients”, “nonzero”) (可以用level函数查看第二级别的类)\n\n\nShow the codepredict(fit, newx = x[1:5,], type = \"class\", s = c(0.05, 0.01))\n#>      s1  s2 \n#> [1,] \"0\" \"0\"\n#> [2,] \"1\" \"1\"\n#> [3,] \"1\" \"1\"\n#> [4,] \"0\" \"0\"\n#> [5,] \"1\" \"1\"\n\n\n4.1.5 交叉验证\n逻辑回归的cv.glmnet的用法同高斯簇函数，nfolds, weights, lambda,parallel的设置一样，区别主要在type.measure：\n\n“mse” 用平方损失\n“deviance” 用真实偏差\n“mae” 用平均绝对误差\n“class” 用误分类率\n“auc” ROC曲线的下面积(这个选项仅针对两分类逻辑回归)。是现在最流行的综合考量模型性能的一种参数\n\n例如，用误分类率误差为标准做十折交叉验证，代码如下：\n\nShow the codecvfit = cv.glmnet(x, y, family = \"binomial\", type.measure = \"class\")\n\n\n用plot查看cv.glmnet生成的结果： .\n\nShow the codeplot(cvfit)\n\n\n\n\n\nShow the codecvfit$lambda.min #查看最优的λ值\n#> [1] 0.01116192\ncvfit$lambda.1se\n#> [1] 0.0310587\n\n\ncoef和predict与高斯簇类似：\n\nShow the codecoef(cvfit, s = \"lambda.min\") # 如前所述，此处返回的结果仅适用于响应变量的第二个水平。\n#> 31 x 1 sparse Matrix of class \"dgCMatrix\"\n#>                       s1\n#> (Intercept)  0.219571057\n#> V1           0.127143184\n#> V2           0.773438291\n#> V3          -0.622026677\n#> V4          -1.249153390\n#> V5          -0.236036348\n#> V6          -1.086126631\n#> V7           .          \n#> V8          -0.662605660\n#> V9           0.903895121\n#> V10         -1.662994099\n#> V11         -0.069429691\n#> V12         -0.109197705\n#> V13          .          \n#> V14          .          \n#> V15          .          \n#> V16          0.489302061\n#> V17          .          \n#> V18         -0.123121403\n#> V19         -0.009732698\n#> V20         -0.063913565\n#> V21          .          \n#> V22          0.237278301\n#> V23          0.413516340\n#> V24         -0.040687440\n#> V25          0.746129317\n#> V26         -0.376173275\n#> V27         -0.168082915\n#> V28          0.312045066\n#> V29         -0.254478998\n#> V30          0.157077463\n\n\nAs mentioned previously, the results returned here are only for the second level of the factor response.\n\nShow the codepredict(cvfit, newx = x[1:10,], s = \"lambda.min\", type = \"class\")\n#>       lambda.min\n#>  [1,] \"0\"       \n#>  [2,] \"1\"       \n#>  [3,] \"1\"       \n#>  [4,] \"0\"       \n#>  [5,] \"1\"       \n#>  [6,] \"0\"       \n#>  [7,] \"0\"       \n#>  [8,] \"0\"       \n#>  [9,] \"1\"       \n#> [10,] \"1\"\n\n\n4.2 多分类逻辑回归\n多分类逻辑回归假定响应变量服从多项式分布, 假定响应变量有K个水平 \\({\\cal G}=\\{1,2,\\ldots,K\\}\\)。则有\n\\[\n\\mbox{Pr}(G=k|X=x)=\\frac{e^{\\beta_{0k}+\\beta_k^Tx}}{\\sum_{\\ell=1}^Ke^{\\beta_{0\\ell}+\\beta_\\ell^Tx}}.\n\\]\n\\({Y}\\) 应该是 \\(N \\times K\\) 的响应矩阵（把离散变量进行one-hot编码即可） ,那么带弹性网惩罚项的非负对数似然函数如下： \\[\n\\ell(\\{\\beta_{0k},\\beta_{k}\\}_1^K) = -\\left[\\frac{1}{N} \\sum_{i=1}^N \\Big(\\sum_{k=1}^Ky_{il} (\\beta_{0k} + x_i^T \\beta_k)- \\log \\big(\\sum_{k=1}^K e^{\\beta_{0k}+x_i^T \\beta_k}\\big)\\Big)\\right] +\\lambda \\left[ (1-\\alpha)||\\beta||_F^2/2 + \\alpha\\sum_{j=1}^p||\\beta_j||_q\\right].\n\\] 这里β是一个\\(p\\times K\\)维的系数矩阵 \\(\\beta_k\\) 是其中的第\\(k\\)列,表示第\\(k\\)个模型对应模型的系数 , \\(\\beta_j\\) 第\\(j\\)行，表示第\\(j\\)个变量前面的系数。\n后面的惩罚项 \\(||\\beta_j||_q\\), 有两种情形 \\(q\\in \\{1,2\\}\\).当q=1时，它是一个lasso惩罚项；当q=2时，它是一个grouped-lasso惩罚项。\n4.2.1 载入示例数据集\n首先载入数据集：\n\nShow the codedata(MultinomialExample)# 产生名为x维度为100*30的矩阵 ,名为y长度为100的数字向量（水平1,2,3组成）训练是内部自动转换\nx = MultinomialExample$x\ny = MultinomialExample$y\n\n\n4.2.2 拟合模型\n多分类逻辑回归的模型拟和二分类逻辑回归类似，只是这里新增加了一个特殊的参数type.multinomial，当type.multinomial = \"grouped\"时，模型拟合时会让每个变量前面的系数全为0或者全不为零，其实就是对于每个类建立逻辑回归时所用到的变量完全相同。\n\nShow the codefit = glmnet(x, y, family = \"multinomial\", type.multinomial = \"grouped\")\n\n\n4.2.3 查看拟合效果\n用plot查看模型拟合结果：\n\nShow the codeplot(fit, xvar = \"lambda\", label = TRUE, type.coef = \"2norm\")\n\n\n\nShow the codeplot(fit, xvar = \"lambda\", label = TRUE, type.coef = \"coef\")\n\n\n\n\n\n\n\n\n\n\n这里xvar和label的使用和之前相同，但是多了一个type.coef选项，这个选项仅适用于对多分类逻辑回归以及多响应变量线性回归，若type.coef = \"coef\"会用多张图分别展示每个响应变量的系数，若type.coef = \"2norm\"则会展示系数的L2-范数。\n4.2.4 交叉验证和预测\n我们同样也可以做交叉验证：\n\nShow the codelibrary(doParallel)\n# Windows System\ncl<-makeCluster(7)\nregisterDoParallel(cl)\ncvfit=cv.glmnet(x, y, family=\"multinomial\", type.multinomial = \"grouped\", parallel = TRUE)\nstopCluster(cl)\nplot(cvfit)\n\n\n\n\n用拟合的模型来预测：\n\nShow the codepredict(cvfit, newx = x[1:10,], s = \"lambda.min\", type = \"class\")\n#>       1  \n#>  [1,] \"3\"\n#>  [2,] \"2\"\n#>  [3,] \"2\"\n#>  [4,] \"3\"\n#>  [5,] \"1\"\n#>  [6,] \"3\"\n#>  [7,] \"3\"\n#>  [8,] \"1\"\n#>  [9,] \"1\"\n#> [10,] \"2\""
  },
  {
    "objectID": "posts/post/glmnet包.html#泊松回归",
    "href": "posts/post/glmnet包.html#泊松回归",
    "title": "glmnet包解读",
    "section": "5 泊松回归",
    "text": "5 泊松回归\n泊松回归经常会用到计数模型中，假定其误差满足泊松分布。\n经常用其均值的对数来建模：\\(\\log \\mu(x) = \\beta_0+\\beta' x\\).\n给定 \\(\\{x_i,y_i\\}_1^N\\)下的对数似然为: \\[\nl(\\beta|X, Y) = \\sum_{i=1}^N (y_i (\\beta_0+\\beta' x_i) - e^{\\beta_0+\\beta^Tx_i}.\n\\] 于是问题变成优化如下带惩罚的对数似然： \\[\n\\min_{\\beta_0,\\beta} -\\frac1N l(\\beta|X, Y)  + \\lambda \\left((1-\\alpha) \\sum_{i=1}^N \\beta_i^2/2) +\\alpha \\sum_{i=1}^N |\\beta_i|\\right).\n\\]\n5.1 加载数据集\n\nShow the codedata(PoissonExample)# 产生名为x维度为500*20的矩阵 ,名为y长度为500的数字向量,全是大于0的数字（泊松函数也是大于0的函数）\nx = PoissonExample$x\ny = PoissonExample$y\n\n\n5.2 拟合模型\n采用glmnet函数，设置family = \"poisson\"：\n\nShow the codefit = glmnet(x, y, family = \"poisson\")\n\n\n5.3 查看拟合效果\n\nShow the codeplot(fit)\n\n\n\n\n5.4 预测\n用predict做预测,在参数选项的设置中，主要是type存在一些差异，做出说明如下：\n\n“link” 给出线性拟合值\n“response” 给出拟合的均值\n“coefficients” 计算给定s下的系数，也可以直接用coef函数\n“nonzero” 返回一个list对象，该list包含每一个s对应非零系数的索引\n\n\nShow the codecoef(fit, s = 1)\n#> 21 x 1 sparse Matrix of class \"dgCMatrix\"\n#>                      s1\n#> (Intercept)  0.61123371\n#> V1           0.45819758\n#> V2          -0.77060709\n#> V3           1.34015128\n#> V4           0.04350500\n#> V5          -0.20325967\n#> V6           .         \n#> V7           .         \n#> V8           .         \n#> V9           .         \n#> V10          .         \n#> V11          .         \n#> V12          0.01816309\n#> V13          .         \n#> V14          .         \n#> V15          .         \n#> V16          .         \n#> V17          .         \n#> V18          .         \n#> V19          .         \n#> V20          .\npredict(fit, newx = x[1:5,], type = \"response\", s = c(0.1,1))\n#>              s1         s2\n#> [1,]  2.4944232  4.4263365\n#> [2,] 10.3513120 11.0586174\n#> [3,]  0.1179704  0.1781626\n#> [4,]  0.9713412  1.6828778\n#> [5,]  1.1133472  1.9934537\n\n\n我们同样也可以做交叉验证：\n\nShow the codecvfit = cv.glmnet(x, y, family = \"poisson\")\n\n\n选项与高斯族几乎相同，除了 type.measure\n\n\ncv.glmnet中type.measure的设置：\n\n“deviance” 偏差\n“mse” 均方误差\n“mae” 平均绝对误差\n\n\n\n绘制cv.glmnet对象。\n\nShow the codeplot(cvfit)\n\n\n\n\n提取最优λ对应的模型系数：\n\nShow the codeopt.lam = c(cvfit$lambda.min, cvfit$lambda.1se)\ncoef(cvfit, s = opt.lam)\n#> 21 x 2 sparse Matrix of class \"dgCMatrix\"\n#>                       s1           s2\n#> (Intercept)  0.070584044  0.200007600\n#> V1           0.609229006  0.571833738\n#> V2          -0.972486782 -0.927099773\n#> V3           1.509004735  1.466409190\n#> V4           0.225598648  0.192138902\n#> V5          -0.328715117 -0.301559295\n#> V6           .            .          \n#> V7          -0.005088443  .          \n#> V8           .            .          \n#> V9           .            .          \n#> V10          0.006071219  .          \n#> V11          .            .          \n#> V12          0.029070537  0.025801372\n#> V13         -0.014882186  .          \n#> V14          0.020864442  .          \n#> V15          .            .          \n#> V16          0.008606587  .          \n#> V17          .            .          \n#> V18          .            .          \n#> V19         -0.023621751  .          \n#> V20          0.011789503  0.009436612\n\n\n可以使用predict进行预测，方法类似，在重复"
  },
  {
    "objectID": "posts/post/glmnet包.html#cox模型",
    "href": "posts/post/glmnet包.html#cox模型",
    "title": "glmnet包解读",
    "section": "6 Cox模型",
    "text": "6 Cox模型\n不是很了解。\nThe Cox proportional hazards model is commonly used for the study of the relationship beteween predictor variables and survival time. In the usual survival analysis framework, we have data of the form \\((y_1, x_1, \\delta_1), \\ldots, (y_n, x_n, \\delta_n)\\) where \\(y_i\\), the observed time, is a time of failure if \\(\\delta_i\\) is 1 or right-censoring if \\(\\delta_i\\) is 0. We also let \\(t_1 < t_2 < \\ldots < t_m\\) be the increasing list of unique failure times, and \\(j(i)\\) denote the index of the observation failing at time \\(t_i\\).\nThe Cox model assumes a semi-parametric form for the hazard \\[\nh_i(t) = h_0(t) e^{x_i^T \\beta},\n\\] where \\(h_i(t)\\) is the hazard for patient \\(i\\) at time \\(t\\), \\(h_0(t)\\) is a shared baseline hazard, and \\(\\beta\\) is a fixed, length \\(p\\) vector. In the classic setting \\(n \\geq p\\), inference is made via the partial likelihood \\[\nL(\\beta) = \\prod_{i=1}^m \\frac{e^{x_{j(i)}^T \\beta}}{\\sum_{j \\in R_i} e^{x_j^T \\beta}},\n\\] where \\(R_i\\) is the set of indices \\(j\\) with \\(y_j \\geq t_i\\) (those at risk at time \\(t_i\\)).\nNote there is no intercept in the Cox mode (its built into the baseline hazard, and like it, would cancel in the partial likelihood.)\nWe penalize the negative log of the partial likelihood, just like the other models, with an elastic-net penalty.\n6.1 载入数据集\n同样地，我们加载预先生成好的样本数据和响应变量，但是这里需要注意的是，这里采用了生存分析的分析框架，输入数据略有差别。首先，我们加载数据集：\n\nShow the codedata(CoxExample)# 产生名为x的矩阵，其维度为1000*30 ，名为y的矩阵，其维度为1000*2\nx = CoxExample$x\ny = CoxExample$y\ny[1:5,] # status列表示time列对应下的状态，第一列必须是数值型的时间，第二列参数是逻辑向量，0/1表示死亡与否\n#>            time status\n#> [1,] 1.76877757      1\n#> [2,] 0.54528404      1\n#> [3,] 0.04485918      0\n#> [4,] 0.85032298      0\n#> [5,] 0.61488426      1\n\n\n可以看到加载的数据还是包含自变量x以及响应变量y两部分：x是n×p维的矩阵；不同的是y，y为\\(n \\times 1\\)维的矩阵，其中名为time的列是观察时间，名为status的列为该观察时间下对应的状态，0表示生成，1表示死亡。\n6.2 拟合模型\n同样用glmnet建模:\n\nShow the codefit = glmnet(x, y, family = \"cox\")\n\n\n6.3 查看拟合效果\n\nShow the codeplot(fit)\n\n\n\n\n提取给定 \\(\\lambda\\)下对应的系数：\n\nShow the codecoef(fit, s = 0.05)\n#> 30 x 1 sparse Matrix of class \"dgCMatrix\"\n#>               1\n#> V1   0.37693638\n#> V2  -0.09547797\n#> V3  -0.13595972\n#> V4   0.09814146\n#> V5  -0.11437545\n#> V6  -0.38898545\n#> V7   0.24291400\n#> V8   0.03647596\n#> V9   0.34739813\n#> V10  0.03865115\n#> V11  .         \n#> V12  .         \n#> V13  .         \n#> V14  .         \n#> V15  .         \n#> V16  .         \n#> V17  .         \n#> V18  .         \n#> V19  .         \n#> V20  .         \n#> V21  .         \n#> V22  .         \n#> V23  .         \n#> V24  .         \n#> V25  .         \n#> V26  .         \n#> V27  .         \n#> V28  .         \n#> V29  .         \n#> V30  .\n\n\n由于Cox模型不常用于预测，所以没有给出预测的样例 。如果需要，可以参考帮助文件help(predict.glmnet)。\n6.4 交叉验证\n用cv.glmnet做K折交叉验证时，type.measure的选项仅支持“deviance”：\n\nShow the codecvfit = cv.glmnet(x, y, family = \"cox\")\n\n\n\nShow the codeplot(cvfit)\n\n\n\n\n提取最优的 \\(\\lambda\\) 值\n\nShow the codecvfit$lambda.min\n#> [1] 0.02107668\ncvfit$lambda.1se\n#> [1] 0.05343706\n\n\n提取模型系数：\n\nShow the codecoef.min = coef(cvfit, s = \"lambda.min\")\nactive.min = which(coef.min != 0)\nindex.min = coef.min[active.min]\n\n\n\nShow the codeindex.min\n#>  [1]  0.47296769 -0.16213158 -0.20518470  0.16374470 -0.17544445 -0.47500198\n#>  [7]  0.32076305  0.08339592  0.43422644  0.10423130  0.01054257 -0.01125802\n#> [13] -0.01541834\ncoef.min\n#> 30 x 1 sparse Matrix of class \"dgCMatrix\"\n#>               1\n#> V1   0.47296769\n#> V2  -0.16213158\n#> V3  -0.20518470\n#> V4   0.16374470\n#> V5  -0.17544445\n#> V6  -0.47500198\n#> V7   0.32076305\n#> V8   0.08339592\n#> V9   0.43422644\n#> V10  0.10423130\n#> V11  .         \n#> V12  .         \n#> V13  0.01054257\n#> V14  .         \n#> V15  .         \n#> V16  .         \n#> V17 -0.01125802\n#> V18  .         \n#> V19  .         \n#> V20  .         \n#> V21  .         \n#> V22  .         \n#> V23  .         \n#> V24  .         \n#> V25 -0.01541834\n#> V26  .         \n#> V27  .         \n#> V28  .         \n#> V29  .         \n#> V30  ."
  },
  {
    "objectID": "posts/post/glmnet包.html#稀疏矩阵",
    "href": "posts/post/glmnet包.html#稀疏矩阵",
    "title": "glmnet包解读",
    "section": "7 稀疏矩阵",
    "text": "7 稀疏矩阵\n除了cox模型外，glmnet均支持稀疏矩阵作为输入，它的用法同常规矩阵的用法相同。\n我们加载一个稀疏矩阵示例：\n\nShow the codedata(SparseExample)\nx = SparseExample$x\ny = SparseExample$y\n\n\n加载的数据x为100*20的一个稀疏矩阵，y为响应变量(长度为100的向量）。\n\nShow the codeclass(x)\n#> [1] \"dgCMatrix\"\n#> attr(,\"package\")\n#> [1] \"Matrix\"\n\n\n创建稀疏矩阵有两种方式，一种方式是采用sparseMatrix生成；还有一种方式是直接采用Matrix来构建。\n当输入是稀疏矩阵时，调用glmnet的方式跟普通矩阵没有差别：\n\nShow the codefit = glmnet(x, y)\n\n\n交叉验证也一样：\n\nShow the codecvfit = cv.glmnet(x, y)\nplot(cvfit)\n\n\n\n\n稀疏矩阵除了可以用作glmnet的输入x，还可以用作predict函数的输入newx，我们来看看如下的例子：\n\nShow the codei = sample(1:5, size = 25, replace = TRUE)\nj = sample(1:20, size = 25, replace = TRUE)\nx = rnorm(25)\nnx = sparseMatrix(i = i, j = j, x = x, dims = c(5, 20))\npredict(cvfit, newx = nx, s = \"lambda.min\")\n#>      lambda.min\n#> [1,]  0.8286576\n#> [2,] -0.1938951\n#> [3,]  0.7690298\n#> [4,] -0.4358310\n#> [5,] -0.1450590\n\n\n\nShow the codesessionInfo()\n#> R version 4.2.1 (2022-06-23)\n#> Platform: aarch64-apple-darwin20 (64-bit)\n#> Running under: macOS Monterey 12.5.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n#> \n#> locale:\n#> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#> \n#> attached base packages:\n#> [1] parallel  stats     graphics  grDevices utils     datasets  methods  \n#> [8] base     \n#> \n#> other attached packages:\n#> [1] doParallel_1.0.17 doMC_1.3.8        iterators_1.0.14  foreach_1.5.2    \n#> [5] glmnet_4.1-4      Matrix_1.4-1     \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] Rcpp_1.0.9        rstudioapi_0.14   knitr_1.40        magrittr_2.0.3   \n#>  [5] splines_4.2.1     lattice_0.20-45   rlang_1.0.4       fastmap_1.1.0    \n#>  [9] stringr_1.4.1     tools_4.2.1       grid_4.2.1        xfun_0.32        \n#> [13] cli_3.3.0         htmltools_0.5.3   yaml_2.3.5        survival_3.4-0   \n#> [17] digest_0.6.29     htmlwidgets_1.5.4 codetools_0.2-18  shape_1.4.6      \n#> [21] evaluate_0.16     rmarkdown_2.16.1  stringi_1.7.8     compiler_4.2.1   \n#> [25] jsonlite_1.8.0\n\n\n参考：https://web.stanford.edu/~hastie/glmnet/glmnet_beta.html"
  },
  {
    "objectID": "posts/post/省略号参数.html",
    "href": "posts/post/省略号参数.html",
    "title": "省略号参数— 可变长参数",
    "section": "",
    "text": "​ 在R中我们查看别人的函数或者内部函数，经常用到…这种参数，...也称把可变长参数，今天就来聊一聊中方法的使用。\n\n先看一个例子：构造一个函数然后对所有的参数进行相加求和。\n\nShow the codeaddemup <- function(x, ...){\n   args <- list(...)# 推荐把省略号的内容分配给list,然后在对该list进行操作\n   for (a in args){\n                x <- x + a \n   } \n   x\n }\n\naddemup(1,1)\n#> [1] 2\naddemup(1,2,3,4,5)\n#> [1] 15\n\n\n我们还可以通过..1,..2到..9等直接引用列表…中的内容。..1表示第一项，..2表示第二项，以此类推。\n对list操作可以结合purrr包中的map, reduce, accumulate和基础函数do.call等 操作更方便。一个实际的例子，\nDGM_U = function(...){\n  #######  第一部分是对参数的检查 #####################\n  # 输入的参数为U_{k}，U_{k}代表一个完整的区间乘积互反判断矩阵。\n  n = nrow(..1)\n  m = ncol(..1)\n  args <- list(...)\n  stopifnot( length(args) >=2, all( map_lgl(args,is.matrix)),2*n ==m )\n  # 检查所有的矩阵维度是否一样\n  library(purrr)\n  t = map(args,dim) %>% do.call(rbind, .) \n  stopifnot( nrow(unique(t)) == 1)\n  \n  ####### 第二部分 对参数的操作，达到想要的目的###########\n  ## 1. 使用快捷的函数\n  k = 1 / length(args)\n  UB = reduce( map(args,function(x)fenjie(x)$B),`*`)^k\n  UD = reduce( map(args, function(x)fenjie(x)$D), `*`)^k\n  \n  ## 2. 使用循环操作 -- 对比操作\n  # UB = matrix(1,nrow = n, ncol = n)\n  # UD = matrix(1,nrow = n, ncol = n)\n  # for(xx in args){\n  #   B = fenjie(xx)$B\n  #   D = fenjie(xx)$D\n  #   for(i in 1:n){\n  #     for(j in 1:n){\n  #       UB[i,j] = UB[i,j] * B[i,j]\n  #       UD[i,j] = UD[i,j] * D[i,j]\n  #     }\n  #   }\n  # }\n  # k = 1 / length(args)\n  # UB = UB^( k)\n  # UD = UD^(k)\n  return( hecheng(UB,UD))\n}\n# 由于该函数引用了部分其他函数，故这里不能运行\nDGM_U(U_t1,U_t2,U_t3)\n\n我们知道R中的图形参数是有很多的，可以把它传递给图形参数。\n\nShow the codenicePlot = function(X,Y,...){\n  xlabel = deparse(substitute(X)) # 捕获X的输入\n  ylabel = deparse(substitute(Y)) # 捕获Y的输入\n  \n  plot(X,Y,type ='o',\n      xlab = xlabel,ylab = ylabel,main = paste(xlabel,ylabel,sep = '--'),\n      ...)\n}\n\nDate = 1:7\nSales = c(100,120,150,130,160,210,120)\nnicePlot(Date,Sales,col='red')\n\n\n\n\n其中substitute()函数捕获输入的内容(无论输入什么样的内容，则原样输出)，deparse() 函数将其转变为字符串\n\n\nShow the codev <- c(sqrt(1:100))\nf <- function(x, ...) { \n   print(x); \n   summary(...)\n  }\nf(\"Here is the summary for v.\", v, digits=2)\n#> [1] \"Here is the summary for v.\"\n#>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#>     1.0     5.1     7.1     6.7     8.7    10.0\n\n\n\n实际上，参数本身的值不是通过省略号参数传递的唯一信息。也可以使用参数的名称（如果指定），例如：\n\nShow the codef <- function(...) {\n  names(list(...))\n  \n   # 进一步的分析\n}\n\nf(some_number = 123,some_string ='abc',some_missing_value = NA)\n#> [1] \"some_number\"        \"some_string\"        \"some_missing_value\"\n\n\n\n\nShow the coderm(list = ls())\nf <- function(...) {\n  args <- list(...)\n  for( i in 1:length(args) ){ \n    assign( x = names(args)[i],value = args[[i]] )\n  }\n  ls()#显示可用的变量 #使用省略号参数作为当前变量进行进一步操作\n  \n  # 进一步的分析\n}\n\nf( some_number = 123,some_string =\"abc\")\n#> [1] \"args\"        \"i\"           \"some_number\" \"some_string\"\n\n\n\nShow the codesessionInfo()\n#> R version 4.2.1 (2022-06-23)\n#> Platform: aarch64-apple-darwin20 (64-bit)\n#> Running under: macOS Monterey 12.5.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n#> \n#> locale:\n#> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] digest_0.6.29     jsonlite_1.8.0    magrittr_2.0.3    evaluate_0.16    \n#>  [5] rlang_1.0.4       stringi_1.7.8     cli_3.3.0         rstudioapi_0.14  \n#>  [9] rmarkdown_2.16.1  tools_4.2.1       stringr_1.4.1     htmlwidgets_1.5.4\n#> [13] xfun_0.32         yaml_2.3.5        fastmap_1.1.0     compiler_4.2.1   \n#> [17] htmltools_0.5.3   knitr_1.40"
  },
  {
    "objectID": "posts/post/R非标准计算.html",
    "href": "posts/post/R非标准计算.html",
    "title": "R非标准计算",
    "section": "",
    "text": "将表达式捕获转为语言对象，捕获表达式意味着防止表达式被执行，而将其本身存储为变量的形式。具有这个功能的函数有如下几个函数，注意其不同。\n\n​ quote()捕获到函数调用是会返回调用，而捕获到变量名时会返回一个符号，只要代码语法正确，它就会返回表示被捕获表达式本身的语言对象。即便函数不存在或者变量未定义，也可以捕获表达式本身。\n\nShow the coderm(list  = ls() )\nx =  quote(a+b)   # 定义一个表达式调用,但是这些变量没有定义\nx\n#> a + b\nclass(x)\n#> [1] \"call\"\ntypeof(x) # 变成语言对象类型，\n#> [1] \"language\"\n\nx = quote(rnorm)\nx\n#> rnorm\nclass(x)\n#> [1] \"name\"\ntypeof(x) # 变成符号对象类型，\n#> [1] \"symbol\"\n\nquote(xfun(a = 1:n)) # xfun都么有定义\n#> xfun(a = 1:n)\n\n\n理解：变量和符号对象的区别，以及函数和调用对象的区别。\n变量是对象的名称，而符号对象就是名称的本身。函数是可以被调用的对象，而调用对象是不会被计算的，它表示整个函数调用的语言对象。\neg： rnorm()就是一个可以被调用的函数(可以使用rnorm(5)进行调用,产生5个随机数)，但是quote(rnorm)返回一个符号对象，quote(rnorm(5))返回一个调用的对象，这两者都是语言本身。\n\nShow the coderm(list  = ls() )\nrnorm(5)\n#> [1] -0.1316684  1.1643017 -0.1560567 -1.3104017  0.5226794\nx = quote(rnorm)\ntypeof(x) # 返回一个符号对象\n#> [1] \"symbol\"\n\nx1 = quote(rnorm(5))\ntypeof(x1) # 返回一个调用对象\n#> [1] \"language\"\n\nas.list(x1) # 将调用对象转变为list，以便查看其内部结构， 可以看出本次调用有两部分组成：函数符号和一个参数\n#> [[1]]\n#> rnorm\n#> \n#> [[2]]\n#> [1] 5\nx1[[1]]\n#> rnorm\ntypeof(x1[[1]]) # 第一个元素是一个符号对象\n#> [1] \"symbol\"\nclass(x1[[1]])\n#> [1] \"name\"\n\nx1[[2]] \n#> [1] 5\ntypeof(x1[[2]]) # 第二个元素是一个数值\n#> [1] \"double\"\nclass(x1[[2]])\n#> [1] \"numeric\"\n## 总结：\n# 1.quote()将变量名捕获为符号对象，将一个函数捕获为调用对象。这两者都是语言对象\n# 2.可以用is.symbol() / is.name() 和 is.call 分别检查对象是否为符号对象或调用对象\n# 3.可以用is.language()同时检查符号和调用\n# 4. quote不把字面值(这里指的的表达式里使用数值等，而非数值变量。eg：数字、逻辑值、字符串)转变为语言对象，而是使其保持原样。--- 少用\n\n\n常常捕获全局环境中的表达式，函数环境中建议用substitute()，substitute()用于捕获表达式，并且用捕获的表达式替换现有的符号,而quote()不会进行第二步，把表达式替换成现有的符号\n\n\n​ substitute()可以作用任意的用户输入，该函数用于捕获表达式，并且用捕获的表达式替换现有的符号。常常与deparse()连用，出现在函数环境中(对表达式进行替换, 不能替换的则保留下来)。\ndeparse(substitute())函数以substitute() 的结果(一个表达式)为参数，并把它转变成一个字符串。\n\nShow the coderm(list  = ls() )\n### 1.substitute() 的使用对比\na = 1\nb = 2\nsubstitute(a + b + z)\n#> a + b + z\n\nf = function(){\n  a= 1\n  b = 2\n  substitute(a+b+z)\n}\nf()\n#> 1 + 2 + z\n\n\nsubstitute(a+b+z)\n#> a + b + z\nsubstitute(a+b+z , list(a = 1,b = 2))# 可以指定list(用名称--值的形式)，进行表达式替换\n#> 1 + 2 + z\n\n\nsubstitute()还可以替换表达式中的函数.\n\nShow the coderm(list  = ls() )\nsubstitute(a+b+z ,list('+' =quote(f)) )\n#> f(f(a, b), z)\nsubstitute(a+b+z ,list('+' =quote(sin)) )\n#> sin(sin(a, b), z)\nsubstitute(a+b+z ,list('+' =quote(`*`)) )\n#> a * b * z\n\n\n总结： 形式上，通过用list的形式对表达式中的所有名字进行检查替换(注意R中的所有动作都是函数，也可以对函数进行替换，如上)，其表达式中的名字替换规则如下：\n\n一个普通变量，它就被变量的值替换。\n一个函数参数，它就被与约定相关联的表达式替换。\n\n...，它被...的内容替换。\n以上都没有，则名字原样保留不变\n\n\n如果某个表达式存储在变量中，则它不会对表达式进行替换。这时需要用到pryr::substitute_q()函数。\n如果substitute它在全局环境中运行时(不特殊指定替换)，它从不进行替换，最好用作函数环境中。这时可以用pryr::subs()函数\n\n\nShow the coderm(list  = ls() )\nx  = quote(a + b)  # x存储了一个表达式\nsubstitute(x,list(a = 1,b = 2)) # 对x调用参数替换，无效\n#> x\n\na = 3 \nb = 5\nsubstitute(a+b+z) # 无效\n#> a + b + z\n\n\n注意：subs()和substitute()函数都可以用第二个参数重写正在使用的当前环境，并通过名字—值的列表对来提供替换。后面讲解subs()函数\n\n前面已学习函数调用相关内容，我们可以通过以下方式创建函数调用，注意：下面方式得到的结果等价(一模一样)\n\nShow the coderm(list  = ls() )\ncall_1 = quote(rnorm(5,mean = 3))\ncall_2 = call(\"rnorm\",5,mean = 3)\ncall_3 = as.call( list(quote(rnorm),5,mean = 3) )\n\ncall_1\n#> rnorm(5, mean = 3)\n\nidentical(call_1,call_2)\n#> [1] TRUE\nidentical(call_2,call_3)\n#> [1] TRUE\n\n\n\n前面提到substitute()存在缺点，当某个表达式存储在变量中，则它不会对表达式进行替换。此时可以用substitute_q()函数。\n\nShow the coderm(list  = ls() )\nx  = quote(a + b)  # x存储了一个表达式\nsubstitute(x,list(a = 1,b = 2)) # 对x调用参数替换，无效\n#> x\nsubstitute(a+b,list(a = 1,b = 2))  # 对直接变量参数替换,有效\n#> 1 + 2\n\npryr::substitute_q(x, list(a = 1,b=2)) # 对x调用参数替换，有效\n#> 1 + 2\n\n\n\nsubs()函数，可以在全局环境中直接对变量表达式替换。subs() 和substitute()的第二个参数都可以重写正在使用的当前环境。并通过名字—值的列表对来提供替换。这里就不在多说。subs的其它的工作方式与substitute()函数相同。\n\nShow the coderm(list  = ls() )\na = 1\nb = 2\nsubstitute(a+b) #  对变量表达式替换，无效\n#> a + b\npryr::subs(a+b) # 对变量表达式替换\n#> 1 + 2\n\nsubstitute(a+b,list(a =10,b =20)) \n#> 10 + 20\npryr::subs(a+b,list(a =10,b =20)) \n#> 10 + 20"
  },
  {
    "objectID": "posts/post/R非标准计算.html#对捕获表达式后的处理方式",
    "href": "posts/post/R非标准计算.html#对捕获表达式后的处理方式",
    "title": "R非标准计算",
    "section": "2. 对捕获表达式后的处理方式",
    "text": "2. 对捕获表达式后的处理方式\n2.1. 执行表达式 — — eval()\n​ 前面提到的几种方法都可以捕获表达式，捕获表达式之后，下一步就是对其进行求值，可以用eval()函数完成。\n​ 比如：我们直接在控制台输入sin(1),其本质相当于执行了两个步骤：1.先捕获这个表达式，2在执行这个这个表达式。于是我们可以通过quote和eval进行分步计算.\n\nShow the coderm(list  = ls() )\nsin(1) # 直接一步完成。\n#> [1] 0.841471\n\n## 分步进行\ncall_1 = quote(sin(1))\ncall_1\n#> sin(1)\neval(call_1)\n#> [1] 0.841471\n\n\n# 由于quote可以捕获未定义的变量，故eval执行时可能会报错,eg:\ncall_2 = quote(sin(xx))\ncall_2\n#> sin(xx)\ntry( eval(call_2) )\n#> Error in eval(call_2) : object 'xx' not found\n\ntry( sin(xx) ) # 报错信息和上面的类似\n#> Error in try(sin(xx)) : object 'xx' not found\n\n\n# eval()可以允许我们提供一个list来计算给定的表达式，从而可以不需要创建一个变量x\n\neval(call_2 ,list(xx =1))\n#> [1] 0.841471\n\n\n2.2 eval 函数的用法\neval(expr, envir = parent.frame(),\n           enclos = if(is.list(envir) || is.pairlist(envir))\n                       parent.frame() else baseenv())\nexpr : 要计算的表达式，如果只提供这一个参数，即在当前环境中对表达式求值\nenvir： 是一个用于计算expr的环境，数据框或者列表。\nencols： 如果在envir中找不到相应的变量，它会在encols参数中找，然后在encols参数的父环境中查找。如果能在envir参数中找到，则encols会被忽略。\n以下有是哪个便捷函数：(其实本质上都可以用eval来实现)\n\n\nevalq(expr, envir, enclos) 等价于 eval(quote(expr),…) ，在当前环境中计算表达式。\n\neval.parent(expr, n = 1) 等价于 eval(expr,parent.frame(n))，在父环境中计算表达式。\n\nlocal(expr, envir = new.env()) 等价于 eval(quote(expr),environment = new.nev())，在新环境中计算表达式。\n\n\nShow the coderm(list  = ls() )\n## 参考《R语言编程指南》\nrm(list = ls())\nqs = function(x,range){\n  range = substitute(range)\n  selector = eval(range,list(. = length(x)), parent.frame())\n  # parent.frame()指的是eval()的调用环境，也就是qs()的执行环境。\n  return( x[selector])\n}\n\n# trim_margin删除向量x的前n个元素和后n个元素，保留中间的元素\ntrim_margin = function(x,n){\n  qs(x,(n+1):(.-n-1))\n}\nx= 1:10\ntrim_margin(x,3)\n#> [1] 4 5 6\n\n\n2 .3 .表达式与字符串相互转变\n\n\ndeparse(): 将表达式转变为字符串.\n\nparse(): 将字符串转变成表达式.由于parse的主要用途是将代码文件解析到硬盘，所以第一个参数是文件路径。注意如果代码是字符向量，那么需要使用text参数。\n\nparse(file = \"\", n = NULL, text = NULL, prompt = \"?\",\n      keep.source = getOption(\"keep.source\"), srcfile,\n      encoding = \"unknown\")\n      \ndeparse(expr, width.cutoff = 60L,\n        backtick = mode(expr) %in% c(\"call\", \"expression\", \"(\", \"function\"),\n        control = c(\"keepNA\", \"keepInteger\", \"niceNames\", \"showAttributes\"),\n        nlines = -1L)\n\nShow the coderm(list = ls())\n\nz <- quote(y <- x*10) # 表达式里面用 <- ,等号为出错\ndeparse(z)\n#> [1] \"y <- x * 10\"\n\nparse(text = deparse(z))\n#> expression(y <- x * 10)\n\n## 把代码写入一个文件中\n# cat(\"x <- c(1, 4)\\n  x ^ 3 -10 ; outer(1:7, 5:9)\\n\", file = 'aa.txt')\n# parse(file = 'a.txt', n = 3)# 把文件中的代码转变为表达式\n\n\n\nShow the codesessionInfo()\n#> R version 4.2.1 (2022-06-23)\n#> Platform: aarch64-apple-darwin20 (64-bit)\n#> Running under: macOS Monterey 12.5.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n#> \n#> locale:\n#> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] Rcpp_1.0.9        codetools_0.2-18  digest_0.6.29     jsonlite_1.8.0   \n#>  [5] magrittr_2.0.3    evaluate_0.16     rlang_1.0.4       stringi_1.7.8    \n#>  [9] cli_3.3.0         pryr_0.1.5        rstudioapi_0.14   rmarkdown_2.16.1 \n#> [13] tools_4.2.1       stringr_1.4.1     htmlwidgets_1.5.4 xfun_0.32        \n#> [17] yaml_2.3.5        fastmap_1.1.0     compiler_4.2.1    htmltools_0.5.3  \n#> [21] knitr_1.40"
  },
  {
    "objectID": "posts/post/R非标准计算.html#参考",
    "href": "posts/post/R非标准计算.html#参考",
    "title": "R非标准计算",
    "section": "参考",
    "text": "参考\n《高级R语言编程》\n《R语言编程指南》\n《R语言核心编程技巧第二版》"
  },
  {
    "objectID": "posts/post/R语言绘制双坐标图.html",
    "href": "posts/post/R语言绘制双坐标图.html",
    "title": "R语言绘制双坐标图",
    "section": "",
    "text": "Show the code#png(\"2y_1.png\")\nrm(list = ls())\nlibrary(plotrix)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nShow the codenew_iris = arrange(iris,Sepal.Length)# 按照花瓣的长度进行排序 --- 为了后面好看  \nhead(new_iris,10)\n\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1           4.3         3.0          1.1         0.1  setosa\n2           4.4         2.9          1.4         0.2  setosa\n3           4.4         3.0          1.3         0.2  setosa\n4           4.4         3.2          1.3         0.2  setosa\n5           4.5         2.3          1.3         0.3  setosa\n6           4.6         3.1          1.5         0.2  setosa\n7           4.6         3.4          1.4         0.3  setosa\n8           4.6         3.6          1.0         0.2  setosa\n9           4.6         3.2          1.4         0.2  setosa\n10          4.7         3.2          1.3         0.2  setosa\n\nShow the code# 设置数据 -\ny1 = new_iris$Sepal.Length[1:10]\nx1_axis = 1:length(y1)\n\ny2 = new_iris$Petal.Length[1:10]\nx2_axis = 1:length(y2)\n\n\npar(family='STKaiti')\ntwoord.plot(x1_axis, y1, x2_axis, y2,main = '双折线图') #  这线图\n\n\n\nShow the codepar(family='STKaiti')\ntwoord.plot(x1_axis, y1, x2_axis, y2,lylim=c(4.2,4.8),rylim=c(1,1.5),lcol=4,rcol=2,main = '折线图和条形图',\n            xlab=\"x轴\",ylab=\"y1轴\",rylab=\"y2轴\",type=c(\"bar\",\"b\"),halfwidth=0.2) # 折线图和条形图\n\n\n\nShow the code#dev.off()"
  },
  {
    "objectID": "posts/post/R语言绘制双坐标图.html#twoord.plot-参数解释",
    "href": "posts/post/R语言绘制双坐标图.html#twoord.plot-参数解释",
    "title": "R语言绘制双坐标图",
    "section": "twoord.plot() 参数解释",
    "text": "twoord.plot() 参数解释\ntwoord.plot()函数语法及参数含义：\n twoord.plot(lx,ly,rx,ry,data=NULL,main=\"\",xlim=NULL,lylim=NULL,rylim=NULL,\n        mar=c(5,4,4,4),lcol=1,rcol=2,xlab=\"\",lytickpos=NA,ylab=\"\",ylab.at=NA,\n        rytickpos=NA,rylab=\"\",rylab.at=NA,lpch=1,rpch=2,\n        type=\"b\",xtickpos=NULL,xticklab=NULL,halfwidth=0.4,axislab.cex=1,do.first=NULL,...)\n\nlx,ly,rx,ry：分别指定左坐标轴和右坐标轴的值，必须是连续的值\ndata：需要绘制双轴图形的数据框\nmain：为图形指定标题\nxlim：限制横坐标值的范围\nlylim,rylim：限制左右纵坐标值的范围\nmar：设置图形边界距，默认值为(5,4,4,4)\nlcol,rcol：设置左右坐标轴的颜色，这样可以起到图例的作用\nxlab：设置横坐标轴标签\nlytickpos：设置左坐标轴刻度标签的位置\nylab：设置左坐标轴标签\nylab.at：设置左坐标轴标签位置\nrytickpos：设置右坐标轴刻度标签的位置\nrylab：设置又坐标轴标签\nrylab.at：设置右坐标轴标签位置\nlpch,rpch：设置左右坐标轴图形的外观\ntype：指定图形类型,参考plot参数的类型\n\n\np 为 points，I for lines， b for both，“c” for the lines part alone of “b”,\n“o” for both ‘overplotted’，“h” for ‘histogram’ like (or ‘high-density’) vertical lines,\n“s” for stair steps, “S” for other steps, “n” for no plotting.\n\n\nxtickpos：设置横坐标轴刻度标签位置\nxticklab：设置横坐标轴刻度标签\nhalfwidth：设置用户给定条形图宽度的一半\naxislab.cex：设置坐标轴标签和刻度标签的大小\ndo.first：通过该参数可以往图形中添加背景色或网格线\n\n\nShow the codesessionInfo()\n\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.5.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] dplyr_1.0.9   plotrix_3.8-2\n\nloaded via a namespace (and not attached):\n [1] rstudioapi_0.14   knitr_1.40        magrittr_2.0.3    tidyselect_1.1.2 \n [5] R6_2.5.1          rlang_1.0.4       fastmap_1.1.0     fansi_1.0.3      \n [9] stringr_1.4.1     tools_4.2.1       xfun_0.32         utf8_1.2.2       \n[13] DBI_1.1.3         cli_3.3.0         htmltools_0.5.3   assertthat_0.2.1 \n[17] yaml_2.3.5        digest_0.6.29     tibble_3.1.8      lifecycle_1.0.1  \n[21] purrr_0.3.4       htmlwidgets_1.5.4 vctrs_0.4.1       glue_1.6.2       \n[25] evaluate_0.16     rmarkdown_2.16.1  stringi_1.7.8     compiler_4.2.1   \n[29] pillar_1.8.1      generics_0.1.3    jsonlite_1.8.0    pkgconfig_2.0.3"
  },
  {
    "objectID": "posts/post/因子数据类型factor.html",
    "href": "posts/post/因子数据类型factor.html",
    "title": "因子数据类型处理",
    "section": "",
    "text": "类别（名义型）变量和有序类别（有序型）变量在R中称为因子（factor） ，如性别、省份、职业。\n\n类别（名义型）变量是没有顺序之分的类别变量。\n有序型变量表示一种顺序关系，代表有序量度，如打分结果，疾病严重程度等。而非数量关系。\n\n连续型变量可以呈现为某个范围内的任意值，比如年龄\n1、基础函数\n针对因子型数据，我们一般需要用到三种变化\n\n更改level标签名\n更改level顺序\n创建有序因子\n\n用factor()函数把字符型向量转换成因子，如\n\nShow the codex <- c(\"男\", \"女\", \"男\", \"男\",  \"女\")\nsex <- factor(x) #将此向量存储为(1, 2, 1, 1，2)，并在内部将其关联为1=\"男\"和2=\"女\"（具体赋值根据字母顺序而定）。\nsex\n\n[1] 男 女 男 男 女\nLevels: 女 男\n\n\n\nShow the codeattributes(sex)\n\n$levels\n[1] \"女\" \"男\"\n\n$class\n[1] \"factor\"\n\n\n因子有class属性，取值为\"factor\"， 还有一个levels(水平值)属性， 此属性可以用levels()函数访问，如\n\nShow the codelevels(sex)#查看某个因子的标签有哪些\n\n[1] \"女\" \"男\"\n\n\n因子的levels属性可以看成是一个映射， 把整数值1,2,…,映射成这些水平值， 因子在保存时会保存成整数值1,2,等与水平值对应的编号。 这样可以节省存储空间， 在建模计算的程序中也比较有利于进行数学运算。\n要表示有序型变量，需要为函数factor()指定参数ordered=TRUE。给定向量：\n\nShow the codestatus <- c(\"Poor\", \"Improved\", \"Excellent\", \"Poor\")\nstatus1 <- factor(status, ordered=TRUE)#会默认关联其值并且按关联的值排序（其实按ascii码表排序），\nstatus1  # 明显可以看出这要的排序并不是我们想要的。\n\n[1] Poor      Improved  Excellent Poor     \nLevels: Excellent < Improved < Poor\n\nShow the code#可以用选项levels自行指定各水平值, 不指定时由x的不同值来求得。\nstatus2 <- factor(status, order=TRUE,levels=c(\"Poor\", \"Improved\", \"Excellent\"))\nstatus2\n\n[1] Poor      Improved  Excellent Poor     \nLevels: Poor < Improved < Excellent\n\nShow the code#也可以将数字型变量转为因子变量 ，\nx <- c(1, 2, 1, 1, 2)\n(sex=factor(x)) #可以看出，因子水平没有任何区分,可以用labels指定标签\n\n[1] 1 2 1 1 2\nLevels: 1 2\n\nShow the codesex <- factor(x, levels=c(1, 2),labels=c(\"Male\", \"Female\")) #注意到标签的顺序必须和水平相一致\nsex\n\n[1] Male   Female Male   Male   Female\nLevels: Male Female\n\n\nfactor()函数的一般形式为\nfactor(x, levels = sort(unique(x), na.last = TRUE), labels, exclude = NA, ordered = FALSE)\n可以用选项levels自行指定各水平值, 不指定时由x的不同值来求得。 可以用选项labels指定各水平的标签, 不指定时用各水平值的对应字符串。可以用exclude选项指定要转换为缺失值(NA)的元素值集合。 如果指定了levels, 则当自变量x的某个元素等于第个水平值时输出的因子对应元素值取整数, 如果该元素值没有出现在levels中则输出的因子对应元素值取NA。 ordered取真值时表示因子水平是有次序的(按编码次序)。\n事实上，经常处理数据的时候，数据都是给定的，读入数据的时候常用 read.csv()函数的默认操作会把输入文件的字符型列自动转换成因子， 这对于性别、职业、地名这样的列是合适的， 但是对于姓名、日期、详细地址这样的列则不合适。 所以，在read.csv()调用中经常加选项stringsAsFactors=FALSE选项禁止这样的自动转换，还可以用colClasses选项逐个指定每列的类型。\n用as.numeric()可以把因子转换为纯粹的整数值，如\n\nShow the codeas.numeric(sex)\n\n[1] 1 2 1 1 2\n\n\n因为因子实际保存为整数值， 所以对因子进行一些字符型操作可能导致错误。 用as.character()可以把因子转换成原来的字符型，如\n\nShow the codeas.character(sex)\n\n[1] \"Male\"   \"Female\" \"Male\"   \"Male\"   \"Female\"\n\n\n为了对因子执行字符型操作（如取子串）， 保险的做法是先用as.character()函数强制转换为字符型。\n因为一个因子的levels属性是该因子独有的， 所以合并两个因子有可能造成错误。如\n\nShow the codeli1 <- factor(c('男', '女'))\nli2 <- factor(c('男', '男'))\nc(li1, li2)\n\n[1] 男 女 男 男\nLevels: 女 男\n\n\n结果不再是因子。 正确的做法是\n\nShow the codefactor(c(as.character(li1), as.character(li2)))#合并因子正确的方法\n\n[1] 男 女 男 男\nLevels: 女 男\n\n\n即恢复成字符型后合并， 然后再转换为因子。 在合并两个数据框时也存在这样的问题。 当然，如果在定义li1和li2 时都用了levels=c('男', '女')选项， c(li1, li2)也能给出正确结果。\n\ntable()函数\n用table()函数统计因子各水平的出现次数（称为频数或频率）。\n\nShow the codetable(sex) #返回一个特殊的有元素名的向量\n\nsex\n  Male Female \n     3      2 \n\n\n对一个变量用table函数计数的结果是一个特殊的有元素名的向量， 元素名是自变量的不同取值， 结果的元素值是对应的频数。 单个因子或单个向量的频数结果可以用向量的下标访问方法取出单个频数或若干个频数的子集。\n2、forcats包的处理因子函数\n在分类变量类数较多时，往往需要对因子水平另外排序、合并等， forcats包提供了一些针对因子的方便函数。\n其中的函数分为如下几类，未特别指明levels和标签一样\n1.修改levels顺序的函数，向量内元素不变\n\n\n\n\n\n\n函数\n功能\n\n\n\nfct_relevel(f, …, after = 0L)\n手动重新排列因子水平\n\n\nfct_inorder(f, ordered = NA)\n按照第一次出现的次序排列\n\n\nfct_infreq(f, ordered = NA)\n按照出现的频率排列\n\n\nfct_reorder(f, x, fun = median, …, .desc = FALSE)\n通过对另一个变量进行排序来重新排列因子水平\n\n\nfct_reorder2(f, x, y, fun = last2, …, .desc = TRUE)\n同上，作用不一样\n\n\nfct_shuffle(f)\n随机排列因子水平\n\n\nfct_rev(f)\n倒序\n\n\nfct_shift(f, n = 1L)\n实现前后移动，滚动变化\n\n\n\n2.变换levels名称的函数\n\n\n\n\n\n\n函数\n作用\n\n\n\nfct_anon(f,prefix=““)\nlevels用升序的数字替代，prefix参数表示在数字前面要保留的字符\n\n\nfct_collapse(f, …)\nlevels更改，主要用于levels的合并\n\n\nfct_recode(f, …)\n手动更改,把指定的标签进行更改\n\n\nfct_lump(f, n, prop, other_level = “Other”, ties.method = c(“min”,“average”, “first”, “last”, “random”, “max”))\n将最小/最常见的因子水平（levels）合并为“other”\n\n\n\n\n若n, prop的值丢失，则将出现次数比较低的标签结合在一起变为other(算法没弄懂，何为比较低)若指定n，表明保留n个最多的level，其余的变为other，指定负数，表明保留最少的若指定prop=0.1 表明保留数量超过10%的level，其余的变为other,同理可以指定负数ties.method可以指定计算方法（同时指定n），若为max,表明次数超过n的保留，低于n的改变为other指定other_level可以更改替换名称\n\n\nfct_other(f, keep, drop, other_level = “Other”)\n若指定keep,将指定的 level保留，其余变成”other”,若指定drop,将指定的 level 设置成”other”\n\n\nfct_relabel(f, fun, …)\n在原有基础上进行修改\n\n\n\n3.其他函数\n\n\n\n\n\n\n函数\n作用\n\n\n\nfct_c(f1,f2)\n将两个factor结合 或者fct_c(list(f1, f2))\n\n\nfct_count(f, sort = FALSE)\n对factor的标签进行统计计数并转化为tibble\n\n\nfct_unique(f)\n对每一个level只有一个，向量中元素按照level的顺序排列\n\n\nfct_drop(f)\n默认将没有对应level值去掉\n\n\nfct_explicit_na(f, na_level = “(Missing)”)\n使显式值缺失\n\n\n\n（下面三个更一般的函数，上面这些函数都有着特定的功能，基本上都是调用下面这三个函数实现的）\n\n\n函数\n作用\n\n\n\nlvls_reorder(f, idx, ordered = NA)\n更改level顺序\n\n\nlvls_revalue(f, new_levels)\n整体更改level名称\n\n\nlvls_expand(f, new_levels)\n增加额外的level值\n\n\n3、例子\n1.修改level顺序的函数使用\n\nShow the codelibrary(forcats)\nlibrary(ggplot2)\nf <- factor(c(\"a\", \"b\", \"c\", \"d\"))\nfct_relevel(f) # 查看f的levels\n\n[1] a b c d\nLevels: a b c d\n\nShow the codefct_relevel(f, \"c\") # 把水平c移动到第一位\n\n[1] a b c d\nLevels: c a b d\n\nShow the codefct_relevel(f, \"b\", \"a\") #把水平b a 移动到前两位\n\n[1] a b c d\nLevels: b a c d\n\nShow the codefct_relevel(f, \"a\", after = 2) # 把水平a放在第2位之后，即放在第3位\n\n[1] a b c d\nLevels: b c a d\n\nShow the codefct_relevel(f, \"a\", after = Inf) # 把水平a移动到最后\n\n[1] a b c d\nLevels: b c d a\n\nShow the code#########################################\nf <- factor(c(\"b\", \"b\", \"a\", \"c\", \"c\", \"c\"))\nfct_inorder(f) # 按照第一次出现的次序排列\n\n[1] b b a c c c\nLevels: b a c\n\nShow the codefct_infreq(f) # 按照出现的频率排列\n\n[1] b b a c c c\nLevels: c b a\n\nShow the code#######################\n# 随机排序\nf <- factor(c(\"a\", \"b\", \"c\"))\nfct_shuffle(f)\n\n[1] a b c\nLevels: c a b\n\nShow the codefct_shuffle(f)\n\n[1] a b c\nLevels: b a c\n\nShow the code########################\n# 倒序\nf <- factor(c(\"a\", \"b\", \"c\"))\nfct_rev(f)\n\n[1] a b c\nLevels: c b a\n\nShow the code#######################\nfct_shift(f) # 第一项放到最后\n\n[1] a b c\nLevels: b c a\n\nShow the codefct_shift(f, 2) # 前两项放在最后\n\n[1] a b c\nLevels: c a b\n\nShow the codefct_shift(f, -1) # 最后一项移到最前面\n\n[1] a b c\nLevels: c a b\n\n\n\nShow the code######################################################################\n##fac_reorder()可以根据不同因子水平分成的组中另一数值型变量的统计量值排序##\n######################################################################\npar(mfrow=c(1,3))\nboxplot(Sepal.Width ~ Species, data = iris,main=\"因子顺序按默认排序\")#默认的图,因子顺序按默认排序\n# 按照分组变量Sepal.Width的均值从小到大排列(默认)\nboxplot(Sepal.Width ~ fct_reorder(Species, Sepal.Width, median), data = iris,main=\"按分组变量Sepal.Width的均值升序排列\")\n# 设置.desc=T，则从大到小\nboxplot(Sepal.Width ~ fct_reorder(Species, Sepal.Width, median, .desc=T), data = iris,main=\"按分组变量Sepal.Width的均值降序排列\") \n\n\n\nShow the codepar(mfrow=c(1,1))\n# 按照分组变量time的最后一个值对应的weight的大小顺序排列（升序）\nchks <- subset(ChickWeight, as.integer(Chick) < 10)\nchks <- transform(chks, Chick = fct_shuffle(Chick))#fct_shuffle()函数随机排列因子水平\nggplot(chks, aes(Time, weight, colour = fct_reorder2(Chick, Time, weight))) +\n    geom_point()+geom_line() +labs(colour = \"Chick\")+ggtitle(\"按照分组变量time的最后一个值对应的weight的大小顺序排列(升序)\")+\n  theme(plot.title = element_text(hjust = 0.5))  #也就加上这一行标题就居中了\n\n\n\n\n2.修改level标签的函数使用\n\nShow the codef <- factor(c(\"b\", \"b\", \"a\", \"c\", \"c\", \"c\"))\nfct_anon(f)      #levels用升序的数字替代，\n\n[1] 2 2 1 3 3 3\nLevels: 1 2 3\n\nShow the codefct_anon(f, \"x\")     # prefix参数表示在数字前面要保留的字符\n\n[1] x3 x3 x1 x2 x2 x2\nLevels: x1 x2 x3\n\nShow the codefct_collapse(f, \"x\"=c(\"a\",\"b\"), \"y\"=\"c\") #把a。b标签合并成x，c标签替代为y\n\n[1] x x x y y y\nLevels: x y\n\nShow the codefct_collapse(f, \"x\"=c(\"a\",\"b\")) # 只改变一部分也可以\n\n[1] x x x c c c\nLevels: x c\n\nShow the codex <- factor(rep(LETTERS[1:9], times = c(40, 10, 5, 27, 1, 1, 1, 1, 1)))\nx %>% table() #统计标签的出现的次数\n\n.\n A  B  C  D  E  F  G  H  I \n40 10  5 27  1  1  1  1  1 \n\nShow the codex %>% fct_lump() %>% table() #把出现次数比较低值得标签保留，其余的变成other,并统计出现的次数\n\n.\n    A     D Other \n   40    27    20 \n\nShow the codex %>% fct_lump() %>% fct_inorder() %>% table()\n\n.\n    A Other     D \n   40    20    27 \n\nShow the code# 将指定的level设置成other\nx <- factor(rep(LETTERS[1:9], times = c(40, 10, 5, 27, 1, 1, 1, 1, 1)))\nfct_other(x, keep = c(\"A\", \"B\")) # 保留这两个A、B这两个标签，其余变为other\n\n [1] A     A     A     A     A     A     A     A     A     A     A     A    \n[13] A     A     A     A     A     A     A     A     A     A     A     A    \n[25] A     A     A     A     A     A     A     A     A     A     A     A    \n[37] A     A     A     A     B     B     B     B     B     B     B     B    \n[49] B     B     Other Other Other Other Other Other Other Other Other Other\n[61] Other Other Other Other Other Other Other Other Other Other Other Other\n[73] Other Other Other Other Other Other Other Other Other Other Other Other\n[85] Other Other Other\nLevels: A B Other\n\nShow the codefct_other(x, drop = c(\"A\", \"B\")) # 把A、B这个两个标签变成other\n\n [1] Other Other Other Other Other Other Other Other Other Other Other Other\n[13] Other Other Other Other Other Other Other Other Other Other Other Other\n[25] Other Other Other Other Other Other Other Other Other Other Other Other\n[37] Other Other Other Other Other Other Other Other Other Other Other Other\n[49] Other Other C     C     C     C     C     D     D     D     D     D    \n[61] D     D     D     D     D     D     D     D     D     D     D     D    \n[73] D     D     D     D     D     D     D     D     D     D     E     F    \n[85] G     H     I    \nLevels: C D E F G H I Other\n\nShow the code# 手动更改\nx <- factor(c(\"apple\", \"bear\", \"banana\", \"dear\"))\nfct_recode(x, fruit = \"apple\", \"fruit\" = \"banana\")#把标签apple替换为friut，banana也替换为friut,双引号可加可不加\n\n[1] fruit bear  fruit dear \nLevels: fruit bear dear\n\nShow the codefct_recode(x, NULL = \"apple\", fruit = \"banana\") # 移除apple标签，向量对应位置变成NA\n\n[1] <NA>  bear  fruit dear \nLevels: fruit bear dear\n\n\n3.其他函数\n\nShow the code# 对每一个level计数\nf <- factor(c(\"b\", \"b\", \"a\", \"c\", \"c\", \"c\"))\nfct_count(f)   # 对factor的标签进行统计计数并转化为tibble\n\n# A tibble: 3 × 2\n  f         n\n  <fct> <int>\n1 a         1\n2 b         2\n3 c         3\n\nShow the code# 唯一化\nunique(f)\n\n[1] b a c\nLevels: a b c\n\nShow the codefct_unique(f) # 向量中元素按照level的顺序排列\n\n[1] a b c\nLevels: a b c\n\nShow the codef <- factor(c(\"a\", \"b\"), levels = c(\"a\", \"b\", \"c\"))\nf\n\n[1] a b\nLevels: a b c\n\nShow the codefct_drop(f) # 默认将没有对应值的level去掉\n\n[1] a b\nLevels: a b\n\n\n4、forcats包因子总结\nfct_lump(f, n, prop)： 根据因子水平（levels）的值合并为“other”\nfct_collapse(f, …) : levels更改，主要用于levels的合并（主要合并现有的因子水平）\nfac_reorder() : 可以根据不同因子水平分成的组中另一数值型变量的统计量值排序。\nfct_count(f, sort = FALSE) : 对factor的标签进行统计计数并转化为tibble\n\nShow the codesessionInfo()\n\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.5.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] ggplot2_3.3.6 forcats_0.5.2\n\nloaded via a namespace (and not attached):\n [1] compiler_4.2.1    pillar_1.8.1      tools_4.2.1       digest_0.6.29    \n [5] viridisLite_0.4.1 jsonlite_1.8.0    evaluate_0.16     lifecycle_1.0.1  \n [9] tibble_3.1.8      gtable_0.3.0      pkgconfig_2.0.3   rlang_1.0.4      \n[13] DBI_1.1.3         cli_3.3.0         rstudioapi_0.14   yaml_2.3.5       \n[17] xfun_0.32         fastmap_1.1.0     withr_2.5.0       stringr_1.4.1    \n[21] dplyr_1.0.9       knitr_1.40        generics_0.1.3    htmlwidgets_1.5.4\n[25] vctrs_0.4.1       grid_4.2.1        tidyselect_1.1.2  glue_1.6.2       \n[29] R6_2.5.1          fansi_1.0.3       rmarkdown_2.16.1  farver_2.1.1     \n[33] purrr_0.3.4       magrittr_2.0.3    ellipsis_0.3.2    scales_1.2.1     \n[37] htmltools_0.5.3   assertthat_0.2.1  colorspace_2.0-3  labeling_0.4.2   \n[41] utf8_1.2.2        stringi_1.7.8     munsell_0.5.0"
  },
  {
    "objectID": "posts/post/R输出latex或html格式.html",
    "href": "posts/post/R输出latex或html格式.html",
    "title": "R语言输出latex或html",
    "section": "",
    "text": "有一些时候，我们想把R对象输出为LaTeX格式或者HTML格式，怎么办呢？"
  },
  {
    "objectID": "posts/post/R输出latex或html格式.html#简介knitr常用参数",
    "href": "posts/post/R输出latex或html格式.html#简介knitr常用参数",
    "title": "R语言输出latex或html",
    "section": "简介knitr常用参数",
    "text": "简介knitr常用参数"
  },
  {
    "objectID": "posts/post/R输出latex或html格式.html#xtable包",
    "href": "posts/post/R输出latex或html格式.html#xtable包",
    "title": "R语言输出latex或html",
    "section": "xtable包",
    "text": "xtable包\n输出为纯HTML格式或者LaTeX格式\n\nShow the codett <- head(iris) # 普通的输出\n\nlibrary(xtable)\nprint(xtable(tt),type=\"html\") # 输出为纯HTML格式\n\n<!-- html table generated in R 4.2.1 by xtable 1.8-4 package -->\n<!-- Tue Aug 30 08:48:54 2022 -->\n<table border=1>\n<tr> <th>  </th> <th> Sepal.Length </th> <th> Sepal.Width </th> <th> Petal.Length </th> <th> Petal.Width </th> <th> Species </th>  </tr>\n  <tr> <td align=\"right\"> 1 </td> <td align=\"right\"> 5.10 </td> <td align=\"right\"> 3.50 </td> <td align=\"right\"> 1.40 </td> <td align=\"right\"> 0.20 </td> <td> setosa </td> </tr>\n  <tr> <td align=\"right\"> 2 </td> <td align=\"right\"> 4.90 </td> <td align=\"right\"> 3.00 </td> <td align=\"right\"> 1.40 </td> <td align=\"right\"> 0.20 </td> <td> setosa </td> </tr>\n  <tr> <td align=\"right\"> 3 </td> <td align=\"right\"> 4.70 </td> <td align=\"right\"> 3.20 </td> <td align=\"right\"> 1.30 </td> <td align=\"right\"> 0.20 </td> <td> setosa </td> </tr>\n  <tr> <td align=\"right\"> 4 </td> <td align=\"right\"> 4.60 </td> <td align=\"right\"> 3.10 </td> <td align=\"right\"> 1.50 </td> <td align=\"right\"> 0.20 </td> <td> setosa </td> </tr>\n  <tr> <td align=\"right\"> 5 </td> <td align=\"right\"> 5.00 </td> <td align=\"right\"> 3.60 </td> <td align=\"right\"> 1.40 </td> <td align=\"right\"> 0.20 </td> <td> setosa </td> </tr>\n  <tr> <td align=\"right\"> 6 </td> <td align=\"right\"> 5.40 </td> <td align=\"right\"> 3.90 </td> <td align=\"right\"> 1.70 </td> <td align=\"right\"> 0.40 </td> <td> setosa </td> </tr>\n   </table>\n\n\n\nShow the codeprint(xtable(tt),type=\"latex\") # 输出为纯LaTeX格式\n\n% latex table generated in R 4.2.1 by xtable 1.8-4 package\n% Tue Aug 30 08:48:54 2022\n\\begin{table}[ht]\n\\centering\n\\begin{tabular}{rrrrrl}\n  \\hline\n & Sepal.Length & Sepal.Width & Petal.Length & Petal.Width & Species \\\\ \n  \\hline\n1 & 5.10 & 3.50 & 1.40 & 0.20 & setosa \\\\ \n  2 & 4.90 & 3.00 & 1.40 & 0.20 & setosa \\\\ \n  3 & 4.70 & 3.20 & 1.30 & 0.20 & setosa \\\\ \n  4 & 4.60 & 3.10 & 1.50 & 0.20 & setosa \\\\ \n  5 & 5.00 & 3.60 & 1.40 & 0.20 & setosa \\\\ \n  6 & 5.40 & 3.90 & 1.70 & 0.40 & setosa \\\\ \n   \\hline\n\\end{tabular}\n\\end{table}\n\n\n若想在rmarkdown中输出时能正常显示上面的格式怎么办了？\n只需添加参数即可\nShow the codelibrary(xtable)\nprint(xtable(tt),type=\"html\") # 输出latex 失效\n\n\n\n\n\nSepal.Length\n\n\nSepal.Width\n\n\nPetal.Length\n\n\nPetal.Width\n\n\nSpecies\n\n\n\n\n1\n\n\n5.10\n\n\n3.50\n\n\n1.40\n\n\n0.20\n\n\nsetosa\n\n\n\n\n2\n\n\n4.90\n\n\n3.00\n\n\n1.40\n\n\n0.20\n\n\nsetosa\n\n\n\n\n3\n\n\n4.70\n\n\n3.20\n\n\n1.30\n\n\n0.20\n\n\nsetosa\n\n\n\n\n4\n\n\n4.60\n\n\n3.10\n\n\n1.50\n\n\n0.20\n\n\nsetosa\n\n\n\n\n5\n\n\n5.00\n\n\n3.60\n\n\n1.40\n\n\n0.20\n\n\nsetosa\n\n\n\n\n6\n\n\n5.40\n\n\n3.90\n\n\n1.70\n\n\n0.40\n\n\nsetosa"
  },
  {
    "objectID": "posts/post/R输出latex或html格式.html#kableextra包",
    "href": "posts/post/R输出latex或html格式.html#kableextra包",
    "title": "R语言输出latex或html",
    "section": "kableExtra包",
    "text": "kableExtra包\n这个包在原有的输出上，做出了很大的改进，使得原有输出很丑的表格，瞬间变得高大上。而且不需要设置knit参数。很方便，推荐使用\n\nShow the codelibrary(knitr)\nlibrary(kableExtra)\ndt <- mtcars[1:5, 1:6]\n\n\n基于HTML的table\n\nShow the codekable(dt)\n\n\n\n\n   \n    mpg \n    cyl \n    disp \n    hp \n    drat \n    wt \n  \n\n\n Mazda RX4 \n    21.0 \n    6 \n    160 \n    110 \n    3.90 \n    2.620 \n  \n\n Mazda RX4 Wag \n    21.0 \n    6 \n    160 \n    110 \n    3.90 \n    2.875 \n  \n\n Datsun 710 \n    22.8 \n    4 \n    108 \n    93 \n    3.85 \n    2.320 \n  \n\n Hornet 4 Drive \n    21.4 \n    6 \n    258 \n    110 \n    3.08 \n    3.215 \n  \n\n Hornet Sportabout \n    18.7 \n    8 \n    360 \n    175 \n    3.15 \n    3.440 \n  \n\n\n\n\n设置主题\n\nShow the codedt %>%\n  kable() %>%\n  kable_styling()\n\n\n\n\n   \n    mpg \n    cyl \n    disp \n    hp \n    drat \n    wt \n  \n\n\n Mazda RX4 \n    21.0 \n    6 \n    160 \n    110 \n    3.90 \n    2.620 \n  \n\n Mazda RX4 Wag \n    21.0 \n    6 \n    160 \n    110 \n    3.90 \n    2.875 \n  \n\n Datsun 710 \n    22.8 \n    4 \n    108 \n    93 \n    3.85 \n    2.320 \n  \n\n Hornet 4 Drive \n    21.4 \n    6 \n    258 \n    110 \n    3.08 \n    3.215 \n  \n\n Hornet Sportabout \n    18.7 \n    8 \n    360 \n    175 \n    3.15 \n    3.440 \n  \n\n\n\n\n表格样式\n表格样式1\n\nShow the codekable(dt) %>%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\"))\n\n\n\n\n   \n    mpg \n    cyl \n    disp \n    hp \n    drat \n    wt \n  \n\n\n Mazda RX4 \n    21.0 \n    6 \n    160 \n    110 \n    3.90 \n    2.620 \n  \n\n Mazda RX4 Wag \n    21.0 \n    6 \n    160 \n    110 \n    3.90 \n    2.875 \n  \n\n Datsun 710 \n    22.8 \n    4 \n    108 \n    93 \n    3.85 \n    2.320 \n  \n\n Hornet 4 Drive \n    21.4 \n    6 \n    258 \n    110 \n    3.08 \n    3.215 \n  \n\n Hornet Sportabout \n    18.7 \n    8 \n    360 \n    175 \n    3.15 \n    3.440 \n  \n\n\n\n\n表格样式2\n\nShow the codekable(dt) %>%\n  kable_styling(bootstrap_options = \"striped\", full_width = F)\n\n\n\n\n   \n    mpg \n    cyl \n    disp \n    hp \n    drat \n    wt \n  \n\n\n Mazda RX4 \n    21.0 \n    6 \n    160 \n    110 \n    3.90 \n    2.620 \n  \n\n Mazda RX4 Wag \n    21.0 \n    6 \n    160 \n    110 \n    3.90 \n    2.875 \n  \n\n Datsun 710 \n    22.8 \n    4 \n    108 \n    93 \n    3.85 \n    2.320 \n  \n\n Hornet 4 Drive \n    21.4 \n    6 \n    258 \n    110 \n    3.08 \n    3.215 \n  \n\n Hornet Sportabout \n    18.7 \n    8 \n    360 \n    175 \n    3.15 \n    3.440 \n  \n\n\n\n\n\nShow the codesessionInfo()\n\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.5.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] kableExtra_1.3.4 knitr_1.40       xtable_1.8-4    \n\nloaded via a namespace (and not attached):\n [1] rstudioapi_0.14   xml2_1.3.3        magrittr_2.0.3    rvest_1.0.3      \n [5] munsell_0.5.0     viridisLite_0.4.1 colorspace_2.0-3  R6_2.5.1         \n [9] rlang_1.0.4       fastmap_1.1.0     highr_0.9         stringr_1.4.1    \n[13] httr_1.4.4        tools_4.2.1       webshot_0.5.3     xfun_0.32        \n[17] cli_3.3.0         systemfonts_1.0.4 htmltools_0.5.3   yaml_2.3.5       \n[21] digest_0.6.29     lifecycle_1.0.1   htmlwidgets_1.5.4 glue_1.6.2       \n[25] evaluate_0.16     rmarkdown_2.16.1  stringi_1.7.8     compiler_4.2.1   \n[29] scales_1.2.1      svglite_2.1.0     jsonlite_1.8.0"
  },
  {
    "objectID": "posts/post/R输出latex或html格式.html#gt-包",
    "href": "posts/post/R输出latex或html格式.html#gt-包",
    "title": "R语言输出latex或html",
    "section": "gt 包",
    "text": "gt 包\n可以官网看看"
  },
  {
    "objectID": "posts/md/常用批处理操作.html",
    "href": "posts/md/常用批处理操作.html",
    "title": "常用的批处理操作",
    "section": "",
    "text": "setwd('/Users/zsc/Desktop/音乐mp3/')\n\nlibrary(stringr)\noldname = list.files(pattern = '.*mp3')\nnewname = str_extract(d,'.*(?=158)')\ndf = data.frame(oldname = oldname, newname = newname)\ndf\nfile.rename(df$oldname, df$newname)"
  },
  {
    "objectID": "posts/md/常用批处理操作.html#批量统计-pdf-的页数",
    "href": "posts/md/常用批处理操作.html#批量统计-pdf-的页数",
    "title": "常用的批处理操作",
    "section": "批量统计 pdf 的页数",
    "text": "批量统计 pdf 的页数\nlibrary(qpdf)\nsetwd('/Users/zsc/Desktop/pdf/')\nd = list.files()\nd\n\nd1 = str_extract(d,'.*?.pdf$')\n\n\nlibrary(purrr)\nmap_dbl(d1, pdf_length)\n\nmap_dbl(d1, pdf_length) %>% sum()"
  },
  {
    "objectID": "posts/md/常用批处理操作.html#移除latex生成的临时文件",
    "href": "posts/md/常用批处理操作.html#移除latex生成的临时文件",
    "title": "常用的批处理操作",
    "section": "移除latex生成的临时文件",
    "text": "移除latex生成的临时文件\np = getwd()\ncat(p,'\\n')\nt = '*.aux|*.bbl|*.bcf|*.blg|*.log|*.xml|*.out|*.spl|*.synctex.gz' \ndel = list.files(path = p,pattern = t)\nfile.remove(del)"
  },
  {
    "objectID": "posts/md/数据框删除列的方法汇总.html",
    "href": "posts/md/数据框删除列的方法汇总.html",
    "title": "数据框删除列的方法汇总",
    "section": "",
    "text": "iris[1:10,-5] # 1. 通过索引删除列\niris[1:10,-c(4,5)] # 删除多列\n\niris[1:10,-which(names(iris)%in%c(\"Petal.Width\",\"Species\"))]# 2.根据列名进行删除\n\nsubset(iris, select = -c(Petal.Width, Species))# 3 根据列名进行删除\n\niris[1:10,1:4]# 筛选出需要的列"
  },
  {
    "objectID": "posts/md/R语言字符处理之stringr包.html",
    "href": "posts/md/R语言字符处理之stringr包.html",
    "title": "R语言字符处理函数包—stringr包",
    "section": "",
    "text": "stringr包被定义为一致的、简单易用的字符串工具集。所有的函数和参数定义都具有一致性，比如，用相同的方法进行NA处理和0长度的向量处理。\n字符串处理虽然不是R语言中最主要的功能，却也是必不可少的，数据清洗、可视化等的操作都会用到。对于R语言本身的base包提供的字符串基础函数，随着时间的积累，已经变得很多地方不一致，不规范的命名，不标准的参数定义，很难看一眼就上手使用。字符串处理在其他语言中都是非常方便的事情，R语言在这方面确实落后了。stringr包就是为了解决这个问题，让字符串处理变得简单易用，提供友好的字符串操作接口。"
  },
  {
    "objectID": "posts/md/R语言字符处理之stringr包.html#stringr的api介绍",
    "href": "posts/md/R语言字符处理之stringr包.html#stringr的api介绍",
    "title": "R语言字符处理函数包—stringr包",
    "section": "2.stringr的API介绍",
    "text": "2.stringr的API介绍\nstringr包常用的字符串的处理以str_开头来命名，方便更直观理解函数的定义。我们可以根据使用习惯对函数进行分类：\n\n字符串拼接函数\n\n\n\n\n\n\n\n\n函数\n说明\nR Base中对应函数\n\n\n\n\nstr_c()str_join() 同str_c()\n字符串拼接\npaste(),paste0()\n\n\nstr_trim())\n去掉字符串的空格和TAB(\n\n\n\nstr_pad()\n用pad参数填充字符串的长度，长度自己设定\n\n\n\nstr_dup()\n复制字符串\n\n\n\nstr_wrap()\n控制字符串输出格式\nstrtrim()\n\n\nstr_sub()str_sub() <- value\n截取字符串抽取或替换正则表达式匹配子串\nregmatches()regmatches() <- value\n\n\n\n\n\n字符串计算函数\n\n\n\n函数\n说明\nR Base中对应函数\n\n\n\n\nstr_count()\n字符串计数，返回指定匹配出现的次数\n\n\n\nstr_length()\n返回字符的长度\nnchar()\n\n\nstr_sort()\n对字符值进行排序\n\n\n\nstr_order()\n字符串索引排序，\n\n\n\n\n\n\n字符串匹配函数\n\n\n\n\n\n\n\n\n函数\n说明\nR Base中对应函数\n\n\n\n\nstr_split()str_split_fixed() 同上\n按照模式分割字符串\nstrsplit()\n\n\nstr_match()str_match_all()\n从字符串中提取首个匹配组\n\n\n\nstr_replacestr_replace_all\n替换首个匹配模式\nsub()gsub()\n\n\nstr_replace_na()\n把NA替换为NA字符串\n\n\n\nstr_locate()str_locate_all()\n返回首个匹配模式的字符的位置\nregexpr()gregexpr()\n\n\nstr_extract()str_extract_all()\n提取首个匹配模式的字符\n\n\n\nstr_subset()\n返回匹配的字符串\n\n\n\nstr_detect()\n检测字符是否存在某些指定模式\ngrepl()\n\n\nword()\n从文本中提取单词\n\n\n\n\n\n\n字符串变换函数\n\n\n\n\n\n\n\n\n函数\n说明\nR Base中对应函数\n\n\n\n\nstr_conv()\n字符编码转换,基本函数中的比较好用\niconv(x, from = ““, to =”“)\n\n\nstr_to_upper()str_to_lower()\n字符串转成大写/小写\ntolower(x)toupper(x)\n\n\nstr_to_title()同大小写转换\n字符串转成首字母大写\n\n\n\n\n\n\n参数控制函数，\n仅用于构造功能的参数，不能独立使用。\n\nboundary: 定义使用边界\n\ncoll: 定义字符串标准排序规则。\n\nfixed: 定义用于匹配的字符，包括正则表达式中的转义符\nregex: 定义正则表达式"
  },
  {
    "objectID": "posts/md/R语言字符处理之stringr包.html#stringr的详细使用",
    "href": "posts/md/R语言字符处理之stringr包.html#stringr的详细使用",
    "title": "R语言字符处理函数包—stringr包",
    "section": "3.stringr的详细使用",
    "text": "3.stringr的详细使用\n3.1 字符串拼接函数\n3.1.1 str_c，字符串拼接操作，与str_join完全相同，与paste()行为不完全一致。\n函数定义：\nstr_c(..., sep = \"\", collapse = NULL)\nstr_join(..., sep = \"\", collapse = NULL)\n参数列表：\n\n…: 多参数的输入\nsep: 把多个字符串拼接为一个大的字符串，用于字符串的分割符。\ncollapse: 把多个向量参数拼接为一个大的字符串，用于字符串的分割符。\n\n把多个字符串拼接为一个大的字符串。\n> str_c('a','b')\n[1] \"ab\"\n> str_c('a','b',sep='-')\n[1] \"a-b\"\n> str_c(c('a','a1'),c('b','b1'),sep='-')\n[1] \"a-b\"   \"a1-b1\"\n把多个向量参数拼接为一个大的字符串。\n> str_c(head(letters), collapse = \"\")\n[1] \"abcdef\"\n> str_c(head(letters), collapse = \", \")\n[1] \"a, b, c, d, e, f\"\n\n# collapse参数，对多个字符串无效\n> str_c('a','b',collapse = \"-\")   \n[1] \"ab\"\n> str_c(c('a','a1'),c('b','b1'),collapse='-')\n[1] \"ab-a1b1\"\n拼接有NA值的字符串向量时，NA还是NA\n> str_c(c(\"a\", NA, \"b\"), \"-d\")\n[1] \"a-d\" NA    \"b-d\"\n对比str_c()函数和paste()函数之间的不同点。\n# 多字符串拼接，默认的sep参数行为不一致\n> str_c('a','b')\n[1] \"ab\"\n> paste('a','b')\n[1] \"a b\"\n\n# 向量拼接字符串，collapse参数的行为一致\n> str_c(head(letters), collapse = \"\")\n[1] \"abcdef\"\n> paste(head(letters), collapse = \"\")\n[1] \"abcdef\"\n \n#拼接有NA值的字符串向量，对NA的处理行为不一致\n> str_c(c(\"a\", NA, \"b\"), \"-d\")\n[1] \"a-d\" NA    \"b-d\"\n> paste(c(\"a\", NA, \"b\"), \"-d\")\n[1] \"a -d\"  \"NA -d\" \"b -d\" \n3.1.2 str_trim:去掉字符串的空格和TAB(\n函数定义：\nstr_trim(string, side = c(\"both\", \"left\", \"right\"))\n参数列表：\n\nstring: 字符串，字符串向量。\nside: 过滤方式，both两边都过滤，left左边过滤，right右边过滤\n\n去掉字符串的空格和TAB(\n#只过滤左边的空格\n> str_trim(\"  left space\\t\\n\",side='left') \n[1] \"left space\\t\\n\"\n\n#只过滤右边的空格\n> str_trim(\"  left space\\t\\n\",side='right')\n[1] \"  left space\"\n\n#过滤两边的空格\n> str_trim(\"  left space\\t\\n\",side='both')\n[1] \"left space\"\n\n#过滤两边的空格\n> str_trim(\"\\nno space\\n\\t\")\n[1] \"no space\"\n3.1.3 str_pad:补充字符串的长度\n函数定义：\nstr_pad(string, width, side = c(\"left\", \"right\", \"both\"), pad = \" \")\n参数列表：\n\nstring: 字符串，字符串向量。\nwidth: 字符串填充后的长度\nside: 填充方向，both两边都填充，left左边填充，right右边填充\npad: 用于填充的字符\n\n补充字符串的长度。\n# 从左边补充空格，直到字符串长度为20\n> str_pad(\"conan\", 20, \"left\")\n[1] \"               conan\"\n\n# 从右边补充空格，直到字符串长度为20\n> str_pad(\"conan\", 20, \"right\")\n[1] \"conan               \"\n\n# 从左右两边各补充空格，直到字符串长度为20\n> str_pad(\"conan\", 20, \"both\")\n[1] \"       conan        \"\n\n# 从左右两边各补充x字符，直到字符串长度为20\n> str_pad(\"conan\", 20, \"both\",'x')\n[1] \"xxxxxxxconanxxxxxxxx\"\n3.1.4 str_dup: 复制字符串\n函数定义：\nstr_dup(string, times)\n参数列表：\n\nstring: 字符串，字符串向量。\ntimes: 复制数量\n\n复制一个字符串向量。\n> val <- c(\"abca4\", 123, \"cba2\")\n\n# 复制2次\n> str_dup(val, 2)\n[1] \"abca4abca4\" \"123123\"     \"cba2cba2\"  \n\n# 按位置复制\n> str_dup(val, 1:3)\n[1] \"abca4\"        \"123123\"       \"cba2cba2cba2\"\n3.1.5 str_wrap，控制字符串输出格式\n函数定义：\nstr_wrap(string, width = 80, indent = 0, exdent = 0)\n参数列表：\n\nstring: 字符串，字符串向量。\nwidth: 设置一行所占的宽度。\nindent: 段落首行的缩进值\nexdent: 段落非首行的缩进值\n\n txt<-'R语言作为统计学一门语言，一直在小众领域闪耀着光芒。直到大数据的爆发，R语言变成了一门炙手可热的数据分析的利器。随着越来越多的工程背景的人的加入，R语言的社区在迅速扩大成长。现在已不仅仅是统计领域，教育，银行，电商，互联网….都在使用R语言。'\n\n# 设置宽度为40个字符\n> cat(str_wrap(txt, width = 40), \"\\n\")\nR语言作为统计学一门语言，一直在小众领域\n闪耀着光芒。直到大数据的爆发，R语言变成\n了一门炙手可热的数据分析的利器。随着越来\n越多的工程背景的人的加入，R语言的社区在\n迅速扩大成长。现在已不仅仅是统计领域，教\n育，银行，电商，互联网….都在使用R语言。 \n\n# 设置宽度为60字符，首行缩进2字符\n> cat(str_wrap(txt, width = 60, indent = 2), \"\\n\")\n  R语言作为统计学一门语言，一直在小众领域闪耀着光芒。直到大数\n据的爆发，R语言变成了一门炙手可热的数据分析的利器。随着越来\n越多的工程背景的人的加入，R语言的社区在迅速扩大成长。现在已\n不仅仅是统计领域，教育，银行，电商，互联网….都在使用R语言。 \n\n# 设置宽度为10字符，非首行缩进4字符\n> cat(str_wrap(txt, width = 10, exdent = 4), \"\\n\")\nR语言作为\n    统计学一\n    门语言，\n    一直在小\n    众领域闪\n    耀着光芒。\n    直到大数据\n    的爆发，R\n    语言变成了\n    一门炙手可\n    热的数据分\n    析的利器。\n    随着越来\n    越多的工程\n    背景的人的\n    加入，R语\n    言的社区在\n    迅速扩大成\n    长。现在已\n    不仅仅是统\n    计领域，教\n    育，银行，\n    电商，互联\n    网….都在使\n    用R语言。 \n3.1.6 str_sub,截取字符串\n函数定义：\nstr_sub(string, start = 1L, end = -1L)\n参数列表：\n\nstring: 字符串，字符串向量。\nstart : 开始位置\nend : 结束位置\n\n截取字符串。\n> txt <- \"I am Conan.\"\n\n# 截取1-4的索引位置的字符串\n> str_sub(txt, 1, 4)\n[1] \"I am\"\n\n# 截取1-6的索引位置的字符串\n> str_sub(txt, end=6)\n[1] \"I am C\"\n\n# 截取6到结束的索引位置的字符串\n> str_sub(txt, 6)\n[1] \"Conan.\"\n\n# 分2段截取字符串\n> str_sub(txt, c(1, 4), c(6, 8))\n[1] \"I am C\" \"m Con\" \n\n# 通过负坐标截取字符串\n> str_sub(txt, -3)\n[1] \"an.\"\n> str_sub(txt, end = -3)\n[1] \"I am Cona\"\n对截取的字符串进行赋值。\n> x <- \"AAABBBCCC\"\n\n# 在字符串的1的位置赋值为1\n> str_sub(x, 1, 1) <- 1; x\n[1] \"1AABBBCCC\"\n\n# 在字符串从2到-2的位置赋值为2345\n> str_sub(x, 2, -2) <- \"2345\"; x\n[1] \"12345C\"\n3.2 字符串计算函数\n3.2.1 str_count, 字符串计数\n函数定义：\nstr_count(string, pattern = \"\")\n参数列表：\n\nstring: 字符串，字符串向量。\npattern: 匹配的字符。\n\n对字符串中匹配的字符计数\n> str_count('aaa444sssddd', \"a\")\n[1] 3\n对字符串向量中匹配的字符计数\n> fruit <- c(\"apple\", \"banana\", \"pear\", \"pineapple\")\n> str_count(fruit, \"a\")\n[1] 1 3 1 1\n> str_count(fruit, \"p\")\n[1] 2 0 1 3\n对字符串中的’.’字符计数，由于.是正则表达式的匹配符，直接判断计数的结果是不对的。\n> str_count(c(\"a.\", \".\", \".a.\",NA), \".\")\n[1]  2  1  3 NA\n\n# 用fixed匹配字符\n> str_count(c(\"a.\", \".\", \".a.\",NA), fixed(\".\"))\n[1]  1  1  2 NA\n\n# 用\\\\匹配字符\n> str_count(c(\"a.\", \".\", \".a.\",NA), \"\\\\.\")\n[1]  1  1  2 NA\n3.2.2 str_length,字符串长度\n函数定义：\nstr_length(string)\n参数列表：\n\nstring: 字符串，字符串向量。\n\n计算字符串的长度:\n> str_length(c(\"I\", \"am\", \"张丹\", NA))\n[1]  1  2  2 NA\n3.2.3 str_sort, 字符串值排序，同str_order索引排序\n函数定义：\nstr_sort(x, decreasing = FALSE, na_last = TRUE, locale = \"\", ...)\nstr_order(x, decreasing = FALSE, na_last = TRUE, locale = \"\", ...)\n参数列表：\n\nx: 字符串，字符串向量。\ndecreasing: 排序方向。\nna_last:NA值的存放位置，一共3个值，TRUE放到最后，FALSE放到最前，NA过滤处理\nlocale:按哪种语言习惯排序\n\n对字符串值进行排序。\n# 按ASCII字母排序\n> str_sort(c('a',1,2,'11'), locale = \"en\")  \n[1] \"1\"  \"11\" \"2\"  \"a\" \n\n# 倒序排序\n> str_sort(letters,decreasing=TRUE)         \n [1] \"z\" \"y\" \"x\" \"w\" \"v\" \"u\" \"t\" \"s\" \"r\" \"q\" \"p\" \"o\" \"n\" \"m\" \"l\" \"k\" \"j\" \"i\" \"h\"\n[20] \"g\" \"f\" \"e\" \"d\" \"c\" \"b\" \"a\"\n\n# 按拼音排序\n> str_sort(c('你','好','粉','丝','日','志'),locale = \"zh\")  \n[1] \"粉\" \"好\" \"你\" \"日\" \"丝\" \"志\"\n对NA值的排序处理\n #把NA放最后面\n> str_sort(c(NA,'1',NA),na_last=TRUE) \n[1] \"1\" NA  NA\n \n#把NA放最前面\n> str_sort(c(NA,'1',NA),na_last=FALSE) \n[1] NA  NA  \"1\"\n\n#去掉NA值 \n> str_sort(c(NA,'1',NA),na_last=NA)    \n[1] \"1\"\n3.3 字符串匹配函数\n3.3.1 str_split,字符串分割，同str_split_fixed\n函数定义：\nstr_split(string, pattern, n = Inf)\nstr_split_fixed(string, pattern, n)\n参数列表：\n\nstring: 字符串，字符串向量。\npattern: 匹配的字符。\nn: 分割个数\n\n对字符串进行分割。\n> val <- \"abc,123,234,iuuu\"\n\n# 以,进行分割\n> s1<-str_split(val, \",\");s1\n[[1]]\n[1] \"abc\"  \"123\"  \"234\"  \"iuuu\"\n\n# 以,进行分割，保留2块\n> s2<-str_split(val, \",\",2);s2\n[[1]]\n[1] \"abc\"          \"123,234,iuuu\"\n\n# 查看str_split()函数操作的结果类型list\n> class(s1)\n[1] \"list\"\n\n# 用str_split_fixed()函数分割，结果类型是matrix\n> s3<-str_split_fixed(val, \",\",2);s3\n     [,1]  [,2]          \n[1,] \"abc\" \"123,234,iuuu\"\n\n> class(s3)\n[1] \"matrix\"\n3.3.2 str_subset:返回的匹配字符串\n函数定义：\nstr_subset(string, pattern)\n参数列表：\n\nstring: 字符串，字符串向量。\npattern: 匹配的字符。\n\n> val <- c(\"abc\", 123, \"cba\")\n\n# 全文匹配\n> str_subset(val, \"a\")\n[1] \"abc\" \"cba\"\n\n# 开头匹配\n> str_subset(val, \"^a\")\n[1] \"abc\"\n\n# 结尾匹配\n> str_subset(val, \"a$\")\n[1] \"cba\"\n3.3.3 word, 从文本中提取单词\n函数定义：\nword(string, start = 1L, end = start, sep = fixed(\" \"))\n参数列表：\n\nstring: 字符串，字符串向量。\nstart: 开始位置。\nend: 结束位置。\nsep: 匹配字符。\n\n> val <- c(\"I am Conan.\", \"http://fens.me, ok\")\n\n# 默认以空格分割，取第一个位置的字符串\n> word(val, 1)\n[1] \"I\"               \"http://fens.me,\"\n> word(val, -1)\n[1] \"Conan.\" \"ok\"    \n> word(val, 2, -1)\n[1] \"am Conan.\" \"ok\"       \n\n# 以,分割，取第一个位置的字符串 \n> val<-'111,222,333,444'\n> word(val, 1, sep = fixed(','))\n[1] \"111\"\n> word(val, 3, sep = fixed(','))\n[1] \"333\"\n3.3.4 str_detect匹配字符串的字符\n函数定义：\nstr_detect(string, pattern)\n参数列表：\n\nstring: 字符串，字符串向量。\npattern: 匹配字符。\n\n> val <- c(\"abca4\", 123, \"cba2\")\n\n# 检查字符串向量，是否包括a\n> str_detect(val, \"a\")\n[1]  TRUE FALSE  TRUE\n\n# 检查字符串向量，是否以a为开头\n> str_detect(val, \"^a\")\n[1]  TRUE FALSE FALSE\n\n# 检查字符串向量，是否以a为结尾\n> str_detect(val, \"a$\")\n[1] FALSE FALSE FALSE\n3.3.6 str_match,从字符串中提取匹配组\n函数定义：\nstr_match(string, pattern)\nstr_match_all(string, pattern)\n参数列表：\n\nstring: 字符串，字符串向量。\npattern: 匹配字符。\n\n从字符串中提取匹配组\n> val <- c(\"abc\", 123, \"cba\")\n\n# 匹配字符a，并返回对应的字符\n> str_match(val, \"a\")\n     [,1]\n[1,] \"a\" \n[2,] NA  \n[3,] \"a\" \n\n# 匹配字符0-9，限1个，并返回对应的字符\n> str_match(val, \"[0-9]\")\n     [,1]\n[1,] NA  \n[2,] \"1\" \n[3,] NA  \n\n# 匹配字符0-9，不限数量，并返回对应的字符\n> str_match(val, \"[0-9]*\")\n     [,1] \n[1,] \"\"   \n[2,] \"123\"\n[3,] \"\"  \n从字符串中提取匹配组，以字符串matrix格式返回\n> str_match_all(val, \"a\")\n[[1]]\n     [,1]\n[1,] \"a\" \n\n[[2]]\n     [,1]\n\n[[3]]\n     [,1]\n[1,] \"a\" \n\n> str_match_all(val, \"[0-9]\")\n[[1]]\n     [,1]\n\n[[2]]\n     [,1]\n[1,] \"1\" \n[2,] \"2\" \n[3,] \"3\" \n\n[[3]]\n     [,1]\n3.3.7 str_replace，字符串替换\n函数定义：\nstr_replace(string, pattern, replacement)\n参数列表：\n\nstring: 字符串，字符串向量。\npattern: 匹配字符。\nreplacement: 用于替换的字符。\n\n> val <- c(\"abc\", 123, \"cba\")\n\n# 把目标字符串第一个出现的a或b，替换为-\n> str_replace(val, \"[ab]\", \"-\")\n[1] \"-bc\" \"123\" \"c-a\"\n\n# 把目标字符串所有出现的a或b，替换为-\n> str_replace_all(val, \"[ab]\", \"-\")\n[1] \"--c\" \"123\" \"c--\"\n\n# 把目标字符串所有出现的a，替换为被转义的字符\n> str_replace_all(val, \"[a]\", \"\\1\\1\")\n[1] \"\\001\\001bc\" \"123\"        \"cb\\001\\001\"\n3.3.8 str_replace_na把NA替换为NA字符串\n函数定义：\nstr_replace_na(string, replacement = \"NA\")\n参数列表：\n\nstring: 字符串，字符串向量。\nreplacement : 用于替换的字符。\n\n把NA替换为字符串\n> str_replace_na(c(NA,'NA',\"abc\"),'x')\n[1] \"x\"   \"NA\"  \"abc\"\n3.3.9 str_locate，找到的模式在字符串中的位置。\n函数定义：\nstr_locate(string, pattern)\nstr_locate_all(string, pattern)\n参数列表：\n\nstring: 字符串，字符串向量。\npattern: 匹配字符。\n\n> val <- c(\"abca\", 123, \"cba\")\n\n# 匹配a在字符串中的位置\n> str_locate(val, \"a\")\n     start end\n[1,]     1   1\n[2,]    NA  NA\n[3,]     3   3\n\n# 用向量匹配\n> str_locate(val, c(\"a\", 12, \"b\"))\n     start end\n[1,]     1   1\n[2,]     1   2\n[3,]     2   2\n\n# 以字符串matrix格式返回\n> str_locate_all(val, \"a\")\n[[1]]\n     start end\n[1,]     1   1\n[2,]     4   4\n\n[[2]]\n     start end\n\n[[3]]\n     start end\n[1,]     3   3\n\n# 匹配a或b字符，以字符串matrix格式返回\n> str_locate_all(val, \"[ab]\")\n[[1]]\n     start end\n[1,]     1   1\n[2,]     2   2\n[3,]     4   4\n\n[[2]]\n     start end\n\n[[3]]\n     start end\n[1,]     2   2\n[2,]     3   3\n3.3.10 str_extract从字符串中提取匹配模式\n函数定义：\nstr_extract(string, pattern)\nstr_extract_all(string, pattern, simplify = FALSE)\n参数列表：\n\nstring: 字符串，字符串向量。\npattern: 匹配字符。\nsimplify: 返回值，TRUE返回matrix，FALSE返回字符串向量\n\n> val <- c(\"abca4\", 123, \"cba2\")\n\n# 返回匹配的数字\n> str_extract(val, \"\\\\d\")\n[1] \"4\" \"1\" \"2\"\n\n# 返回匹配的字符\n> str_extract(val, \"[a-z]+\")\n[1] \"abca\" NA     \"cba\" \n\n\n> val <- c(\"abca4\", 123, \"cba2\")\n> str_extract_all(val, \"\\\\d\")\n[[1]]\n[1] \"4\"\n\n[[2]]\n[1] \"1\" \"2\" \"3\"\n\n[[3]]\n[1] \"2\"\n\n> str_extract_all(val, \"[a-z]+\")\n[[1]]\n[1] \"abca\"\n\n[[2]]\ncharacter(0)\n\n[[3]]\n[1] \"cba\"\n3.4 字符串变换函数\n3.4.1 str_conv:字符编码转换\n函数定义：\nstr_conv(string, encoding)\n参数列表：\n\nstring: 字符串，字符串向量。\nencoding: 编码名。\n\n对中文进行转码处理。\n# 把中文字符字节化\n> x <- charToRaw('你好');x\n[1] c4 e3 ba c3\n\n# 默认win系统字符集为GBK，GB2312为GBK字集，转码正常\n> str_conv(x, \"GBK\")\n[1] \"你好\"\n> str_conv(x, \"GB2312\")\n[1] \"你好\"\n\n# 转UTF-8失败\n> str_conv(x, \"UTF-8\")\n[1] \"���\"\nWarning messages:\n1: In stri_conv(string, encoding, \"UTF-8\") :\n  input data \\xffffffc4 in current source encoding could not be converted to Unicode\n2: In stri_conv(string, encoding, \"UTF-8\") :\n  input data \\xffffffe3\\xffffffba in current source encoding could not be converted to Unicode\n3: In stri_conv(string, encoding, \"UTF-8\") :\n  input data \\xffffffc3 in current source encoding could not be converted to Unicode\n把unicode转UTF-8\n> x1 <- \"\\u5317\\u4eac\"\n> str_conv(x1, \"UTF-8\")\n[1] \"北京\"\n3.4.2 str_to_upper,字符串大写转换。\n函数定义：\nstr_to_upper(string, locale = \"\")\nstr_to_lower(string, locale = \"\")\nstr_to_title(string, locale = \"\")\n参数列表：\n\nstring: 字符串。\nlocale:按哪种语言习惯排序\n\n字符串大写转换:\n> val <- \"I am conan. Welcome to my blog! http://fens.me\"\n\n# 全大写\n> str_to_upper(val)\n[1] \"I AM CONAN. WELCOME TO MY BLOG! HTTP://FENS.ME\"\n\n# 全小写\n> str_to_lower(val)\n[1] \"i am conan. welcome to my blog! http://fens.me\"\n\n# 首字母大写\n> str_to_title(val)\n[1] \"I Am Conan. Welcome To My Blog! Http://Fens.Me\"\n字符串在平常的数据处理中经常用过，需要对字符串进行分割、连接、转换等操作，本篇中通过介绍stringr，灵活的字符串处理库，可以有效地提高代码的编写效率。有了好的工具，在用R语言处理字符串就顺手了。\n本文转载张丹的粉丝日志，链接：http://blog.fens.me/r-stringr/，"
  },
  {
    "objectID": "posts/md/hugo分类标签添加.html",
    "href": "posts/md/hugo分类标签添加.html",
    "title": "hugo–分类标签添加",
    "section": "",
    "text": "2、也可以在导航栏添加一个分类汇总页面\n    [[menu.main]]\n    name = \"Tag\"\n    url = \"/tags/\"\n把terms.html文件拷贝到 _default下\n<meta charset=\"utf-8\"> {{ partial \"header.html\" . }}\n<main class=\"content\" role=\"main\">\n     <article class=\"article\">\n    <div class=\"tags0\">\n        <h1 class=\"tags1\">分类标签有{{ len .Data.Terms }}个</h1>\n\n        {{ $data := .Data }} {{ range .Data.Terms.ByCount }} {{ $termLink := printf \"/%s/%s/\" $data.Plural .Term | urlize }}\n        <h2 class=\"tags2\">\n            <a href=\"{{ $termLink }}\">{{ .Term }}</a> 有{{ .Count }}篇\n        </h2>\n        <div class=\"tags3\">\n            <ul>\n            {{ range .Pages | first 5 }}\n            <li><a href=\"{{ .Permalink }}\" class=\"tags4\">{{ .Title }}</a></li>\n            {{ end }} {{ if gt (len .Pages) 5 }}\n            <li><a href=\"{{ $termLink }}\" class=\"tags4\">……</a></li>\n            {{ end }}\n             </ul>\n        </div>\n\n        {{ end }}\n    </div>\n      </article>\n</main>\n<link rel=\"stylesheet\" href=\"{{ \"css/fonts.css\" | relURL }}\" media=\"all\">\n<link rel=\"stylesheet\" href=\"{{ \"css/main.css\" | relURL }}\" media=\"all\">\n<link rel=\"stylesheet\" href=\"{{ \"css/font-awesome.min.css\" | relURL }}\" media=\"all\">\n{{ partial \"footer.html\" . }}\n\n然后设置自己想要的css样式即可"
  },
  {
    "objectID": "posts/md/scrapy框架.html",
    "href": "posts/md/scrapy框架.html",
    "title": "Scrapy框架+selenium爬取京东相机",
    "section": "",
    "text": "（项目名为：jingdong)，会生成一系列文件夹，命令如下(cmd下运行)：\nscrapy startproject jingdong"
  },
  {
    "objectID": "posts/md/scrapy框架.html#创建爬虫文件",
    "href": "posts/md/scrapy框架.html#创建爬虫文件",
    "title": "Scrapy框架+selenium爬取京东相机",
    "section": "2 创建爬虫文件",
    "text": "2 创建爬虫文件\n在刚刚生成的jingdong文件夹下面找到spiders文件夹,在spider文件下创建一个爬虫文件（名字叫jd）– 用来解析网页的，命令如下(cmd下运行)：\nscarpy genspider jd \"list.jd.com\"\n# 创建一个jd.py的爬虫文件，爬虫名为jd ，以及指定爬虫允许爬取的范围：只能在jd.com下."
  },
  {
    "objectID": "posts/md/scrapy框架.html#编写items.py文件",
    "href": "posts/md/scrapy框架.html#编写items.py文件",
    "title": "Scrapy框架+selenium爬取京东相机",
    "section": "3 编写items.py文件",
    "text": "3 编写items.py文件\n创建爬虫目标（明确需要提取的数据），如下：\nimport scrapy\nclass JingdongItem(scrapy.Item):\n    # define the fields for your item here like:\n    # 所有商品的名称、链接、价格、销售店铺、评论数的信\n    # 商品名称\n    name = scrapy.Field()\n    # 商品的简介\n    abstract = scrapy.Field()\n    # 商品的链接\n    link = scrapy.Field()\n    # 商品的价格\n    price = scrapy.Field()\n    # 店铺名\n    shop_name = scrapy.Field()\n    # 评论数\n    commet = scrapy.Field()"
  },
  {
    "objectID": "posts/md/scrapy框架.html#设置setting文件开启管道",
    "href": "posts/md/scrapy框架.html#设置setting文件开启管道",
    "title": "Scrapy框架+selenium爬取京东相机",
    "section": "4 设置setting文件，开启管道",
    "text": "4 设置setting文件，开启管道\nITEM_PIPELINES = {\n    'jingdong.pipelines.JingdongPipeline': 300,\n}"
  },
  {
    "objectID": "posts/md/scrapy框架.html#编写spidersjd.py-文件-爬虫文件",
    "href": "posts/md/scrapy框架.html#编写spidersjd.py-文件-爬虫文件",
    "title": "Scrapy框架+selenium爬取京东相机",
    "section": "5 编写spiders/jd.py 文件 （爬虫文件）",
    "text": "5 编写spiders/jd.py 文件 （爬虫文件）\n编写爬虫文件（我们创建的jd.py,，在spiders这个文件夹下面），此文件用来处理请求和响应，以及提取数据\n# -*- coding: utf-8 -*-\nimport scrapy\nfrom jingdong.items import JingdongItem \n\nclass JdSpider(scrapy.Spider):\n    # 爬虫名\n    name = \"jd\"\n    # 允许爬虫作用的范围\n    allowed_domains = [\"list.jd.com\"]\n    # 页面提取url  也可以拼接url:https://list.jd.com/list.html?cat=652,654,831&page=0\n\n    # 爬虫起始的url\n    start_urls = ['https://list.jd.com/list.html?cat=652,654,831']\n    offset = 1 # 设置爬取的起始页数\n    def parse(self, response):\n        info_list = response.xpath('//div[@id=\"plist\"]//li[@class =\"gl-item\"]')\n        for each in info_list:\n            # 构建item对象，用来保存数据\n            item = JingdongItem()\n            ####################################################\n            ########## 一下为提取页面信息######################\n            # 提取商品的名称，\n            if len( each.xpath('./div/div[@class=\"p-name\"]/a/em/text()') ) == 0 :\n                item['name']=\"\"\n            else:\n                item['name'] = each.xpath('./div/div[@class=\"p-name\"]/a/em/text()').extract()[0]\n            \n            # 商品简介\n            if len(each.xpath('./div/div[@class=\"p-name\"]/a/i[@class=\"promo-words\"]/text()'))==0:\n                item['abstract']=\"\"\n            else:\n                item['abstract'] = each.xpath('./div/div[@class=\"p-name\"]/a/i[@class=\"promo-words\"]/text()').extract()[0]\n            \n            # 商品链接\n            if len(each.xpath('./div/div[@class=\"p-name\"]/a/@href'))==0:\n                item['link'] = \"\"\n            else:\n                item['link'] = each.xpath('./div/div[@class=\"p-name\"]/a/@href').extract()[0]\n            \n            # 商品价格\n            if len(each.xpath('./div/div[@class=\"p-price\"]/strong[1]/i/text()'))==0:\n                item['price'] = \"\"\n            else:\n                item['price'] = each.xpath('./div/div[@class=\"p-price\"]/strong[1]//i/text()').extract()[0]\n            \n            # 商品店铺名称\n            if len(each.xpath('./div/div[@class=\"p-shop\"]/span/a/text()'))==0:\n                item['shop_name']=\"\"\n            else:\n                item['shop_name'] = each.xpath('./div/div[@class=\"p-shop\"]/span/a/text()').extract()[0]\n            \n            # 商品评论数\n            if len(each.xpath('./div/div[@class=\"p-commit p-commit-n\"]/strong/a/text()'))==0:\n                item['commet']=\"\"\n            else:\n                item['commet'] = each.xpath('./div/div[@class=\"p-commit p-commit-n\"]/strong/a/text()').extract()[0]\n            # 通过yield 返回数据，返回数据后还能回来继续执行下面的代码\n            yield item\n        \n        # 直接从response获取需要爬取的链接，并发送给请求处理，直到链接处理完成\n        if len(response.xpath('//div[@class=\"p-wrap\"]//a[@class=\"pn-next\"]'))!= 0 and self.offset<1000:\n            # self.offset手动控制爬取的页面数  ，当然这里没有1000个页面，直到所有为止\n            self.offset = self.offset+1\n            next_url = response.xpath('//div[@class=\"p-wrap\"]//a[@class=\"pn-next\"]/@href').extract_first()\n            url = \"https://list.jd.com/\"+next_url# 找到下一页的url链接\n            yield scrapy.Request(url=url,callback= self.parse)"
  },
  {
    "objectID": "posts/md/scrapy框架.html#编写pipelines.py管道文件",
    "href": "posts/md/scrapy框架.html#编写pipelines.py管道文件",
    "title": "Scrapy框架+selenium爬取京东相机",
    "section": "6 编写pipelines.py(管道文件)",
    "text": "6 编写pipelines.py(管道文件)\n编写管道文件，处理spider返回的item数据，我把它存为json文件： 如下\nimport json\n\nclass JingdongPipeline(object):\n    def __init__(self):\n        self.f = open(\"jingdong_xiangji.json\",\"w\")\n        \n    def process_item(self, item, spider):\n        content = json.dumps(dict(item),ensure_ascii=False) + \",\\n\"\n        self.f.write(content)\n        return item # 一定要返回item  ，相当于告诉引擎，我做事做完了，请给我下一个item\n    \n    # 第一个方法：只执行一次\n    def close_spider(self,spider):\n        self.f.close()"
  },
  {
    "objectID": "posts/md/scrapy框架.html#编写middlewares.py下载中间件",
    "href": "posts/md/scrapy框架.html#编写middlewares.py下载中间件",
    "title": "Scrapy框架+selenium爬取京东相机",
    "section": "7 编写middlewares.py(下载中间件)",
    "text": "7 编写middlewares.py(下载中间件)\n由于京东这个网站，网页是动态加载的，于是结合selenium进行下载，（如果是静态页面，无需写这个文件，以及后面的第8步）\n\nfrom selenium import webdriver\n#检查页面是否加载完毕\nimport time\nfrom scrapy.http import HtmlResponse\nfrom selenium.common.exceptions import TimeoutException\nfrom selenium.webdriver.chrome.options import Options #设置Google的无头浏览器\n\nclass JingdongSpiderMiddleware(object):\n    # 开始运行的选项\n    def __init__(self):\n        chrome_options = Options()\n        prefs =  {\"profile.managed_default_content_settings.images\":2}\n        # 设置Chrome浏览器不加载图片的方法\n        chrome_options.add_experimental_option(\"prefs\",prefs) \n        #设置Google的无头浏览器\n        chrome_options.add_argument('--headless') \n        self.browser = webdriver.Chrome(chrome_options=chrome_options) \n        self.browser.maximize_window()  # 最大化浏览器\n        self.browser.implicitly_wait(10)#隐式等待10s\n        \n    #  最后结束的时候运行的选项\n    def __del__(self):\n        self.browser.close()\n        self.browser.quit()\n        \n    def process_request(self,request,spider):\n        try:\n            self.browser.get(request.url)\n            self.browser.implicitly_wait(6)\n            self.browser.execute_script('window.scrollTo(0,document.body.scrollHeight)')\n            time.sleep(3)\n            self.browser.execute_script('window.scrollTo(0,document.body.scrollHeight)')\n            time.sleep(3)\n            return HtmlResponse(url=self.browser.current_url,body=self.browser.page_source,encoding='utf-8',request=request,status=200)\n        except TimeoutException as e:\n            print(\"超时\")\n            self.browser.execute_script('window.stop()')\n            return HtmlResponse(url=request.url,status=500,request = request)"
  },
  {
    "objectID": "posts/md/scrapy框架.html#设置下载中间件",
    "href": "posts/md/scrapy框架.html#设置下载中间件",
    "title": "Scrapy框架+selenium爬取京东相机",
    "section": "8 设置下载中间件",
    "text": "8 设置下载中间件\nDOWNLOADER_MIDDLEWARES = {\n     'jingdong.middlewares.JingdongSpiderMiddleware': 543,\n}"
  },
  {
    "objectID": "posts/md/scrapy框架.html#最后的settings.py设置文件",
    "href": "posts/md/scrapy框架.html#最后的settings.py设置文件",
    "title": "Scrapy框架+selenium爬取京东相机",
    "section": "9 最后的settings.py(设置文件)",
    "text": "9 最后的settings.py(设置文件)\n由于爬虫有时候网站不让你爬 。有一个robots协议，我们不管这个，需要在setting.py设置，把ROBOTSTXT_OBEY = False即可\n最后我的setting.py 如下:\nBOT_NAME = 'jingdong'\n\nSPIDER_MODULES = ['jingdong.spiders']\nNEWSPIDER_MODULE = 'jingdong.spiders'\n########################### 以上全自动生成\n#以下为 手动改写\nROBOTSTXT_OBEY = False \nDOWNLOADER_MIDDLEWARES = {\n     'jingdong.middlewares.JingdongSpiderMiddleware': 543,\n}\nITEM_PIPELINES = {\n    'jingdong.pipelines.JingdongPipeline'\n    : 300,\n}\n\n## 解释： 'jingdong.pipelines.JingdongPipeline' ## 注意这里的字典 键要对应前面的类，\n#####  jingdong 为爬虫项目名，\n#####  pipelines为爬虫下面的pipelines.py文件的文件名，\n#####  JingdongPipeline为pipelines.py中的类名"
  },
  {
    "objectID": "posts/md/scrapy框架.html#最后执行爬虫文件",
    "href": "posts/md/scrapy框架.html#最后执行爬虫文件",
    "title": "Scrapy框架+selenium爬取京东相机",
    "section": "10 最后执行爬虫文件：",
    "text": "10 最后执行爬虫文件：\ncmd下执行：\nscrapy crawl jd\n# 注意：jd为 spiders/jd.py文件中name的值  即（name = \"jd\"）\n# 也可以执行  scrapy crawl jd  -o  jd_xiangji.csv  \n#### 即存为 json  又有保存了csv文件  ，生成的文件都在当前目录下（我们可以在爬虫的项目的文件下创建一个data文件夹，在这个文件夹下执行爬虫文件，就可以把代码和数据分开了。\n######################\n#  在cmd下运行的命令 只要在爬虫项目文件下运行都可以执行，"
  },
  {
    "objectID": "posts/md/scrapy框架.html#结果展示",
    "href": "posts/md/scrapy框架.html#结果展示",
    "title": "Scrapy框架+selenium爬取京东相机",
    "section": "11 结果展示",
    "text": "11 结果展示\n\n\n\n20180810scrapyjingdong\n\n\n一共 7192 条信息 = 120* 60 （最后一页没有60个商品）\n可以看出速度很快（大概20分钟左右）就抓取玩了"
  },
  {
    "objectID": "posts/md/R语言字符处理之base函数.html",
    "href": "posts/md/R语言字符处理之base函数.html",
    "title": "R语言字符处理—基本函数",
    "section": "",
    "text": "函数\n说明\n\n\n\n\nEncoding(x) Encoding(x) <- value enc2native(x) enc2utf8(x)\n读取或设置字符向量的编码常结合iconv(x, from = ““, to =”“)函数使用注意：Encoding(x) <- value 这是一种赋值函数\n\n\nnchar(x, type = “chars”, allowNA = FALSE, keepNA = NA)nzchar(x, keepNA = FALSE)\nnchar()返回字符长度nzchar()判断是否空字符keepNA为真是NA保留，不计入计数对于缺失值NA，nchar和nzchar函数默认是字符数为2的字符串。对于NULL，nchar和nzchar函数会忽略掉。\n\n\nsubstr(x, start, stop)substring(text, first, last = 1000000L)substr(x, start, stop) <- valuesubstring(text, first, last = 1000000L) <- value\n提取或替换字符向量的子字段，substring同substr功能一样\n\n\nstrtrim(x, width)\n按显示宽度截断字符串\n\n\npaste (…, sep = ” “, collapse = NULL)paste0(…, collapse = NULL)\n通过sep连接间隔连接对象,返回字符串向量设定collapse的话，会通过collapse连接间隔将上一步的字符串向量连接成一个字符串\n\n\nstrsplit(x, split, fixed = FALSE, perl = FALSE, useBytes = FALSE)\n基于split子句分割字符向量xfixed为TRUE的话，完全匹配split；否则，基于正则表达式。可以使用split=NULL来分割每个字符。\n\n\nchartr(old, new, x)\n将x中的字符old变换为字符new注意替换的是单个对应的字符，而非字符串\n\n\ntolower(x)toupper(x)\n大小写转换\n\n\nsprintf(fmt, …)\n系统C库函数sprintf封装器，格式化输出函数"
  },
  {
    "objectID": "posts/md/R语言字符处理之base函数.html#正则表达式字符串匹配函数",
    "href": "posts/md/R语言字符处理之base函数.html#正则表达式字符串匹配函数",
    "title": "R语言字符处理—基本函数",
    "section": "正则表达式—–字符串匹配函数",
    "text": "正则表达式—–字符串匹配函数\n\n\n\n\n\n\n\n函数\n说明\n\n\n\n\ngrep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE,fixed = FALSE, useBytes = FALSE)\n若x为list，则找出和(参数pattern)匹配的序列编号若x为字符串，则判别改字符串中是否包含特定的字符,包含返回1，不包含返回integer(0)若x为字符向量,同list只找到第一个即可\n\n\ngrepl(pattern, x, ignore.case = FALSE, perl = FALSE,fixed = FALSE, useBytes = FALSE)\n返回TRUE 或FALSE\n\n\nsub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE,fixed = FALSE, useBytes = FALSE)\n只替换匹配到的第一个字符串\n\n\ngsub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE,fixed = FALSE, useBytes = FALSE)\n替换匹配到的所用字符串\n\n\nregexpr(pattern, text, ignore.case = FALSE, perl = FALSE,fixed = FALSE, useBytes = FALSE)\n返回第一个和(参数pattern)匹配的起始位置(或下标)和匹配长度(pattern的长度，若为正则，则是匹配字符串的实际长度)若没有则返回: -1\n\n\ngregexpr(pattern, text, ignore.case = FALSE, perl = FALSE,fixed = FALSE, useBytes = FALSE)\nregexpr()函数只匹配第一个，想要多次匹配则用gregexpr()函数\n\n\nregexec(pattern, text, ignore.case = FALSE, perl = FALSE,fixed = FALSE, useBytes = FALSE)\n和regexpr()函数一样\n\n\n\n共同参数解析： 1、fixed = TRUE: 使用精确匹配 2、perl = TRUE: 使用Perl风格正则表达式 3、fixed = FALSE且perl = FALSE: 使用POSIX 1003.2扩展正则表达式 4、 useBytes = TRUE时逐字节匹配，否则逐字符匹配\n\n\nregmatches(x, m, invert = FALSE)regmatches(x, m, invert = FALSE) <- value\n抽取或替换正则表达式匹配子串 invert = TRUE则抽取或替换不匹配子串 str<-c(“Now is”,“the”,” time “) m<-regexpr(” +“,str)regmatches(str,m)<-”9999”str\n\n\nglob2rx(pattern, trim.head = FALSE, trim.tail = TRUE)\n将通配符模式变成正则表达式\n\n\n\n\n\n\n\n\ngrep()函数参数：\n\n\n\n\n\n\n\n参数\n功能\n\n\n\n\npattern\n包含正则表达式的字符串\n\n\nx\n寻找匹配的字符向量，或者可以通过字符向量强制转换的对象。支持长向量\n\n\nignore.case\n如果为FALSE，则模式匹配区分大小写；如果为TRUE，则在匹配期间忽略大小写\n\n\nperl\n如果为TRUE，使用perl匹配的正则表达式\n\n\nvalue\n如果为FALSE，则返回包含由grep确定的匹配的索引的向量，如果为TRUE，则返回包含匹配元素本身的向量\n\n\nfixed\n如果为TRUE，则pattern是要按原样匹配的字符串\n\n\nuseBytes\n如果为TRUE，则匹配是逐字节而不是逐字符完成的\n\n\ninvert\n如果为TRUE，则返回不匹配的元素的索引或值\n\n\n\ngrep()能对向量中特定条件的元素进行查询，默认return为index,。grep()语法与grep()大致相似，但默认return为logical。"
  },
  {
    "objectID": "posts/md/hugo安装.html",
    "href": "posts/md/hugo安装.html",
    "title": "install old hugo version",
    "section": "",
    "text": "最近发现自己更新了 hugo 软件导致了主题的某些功能失效了, 于是需要退回旧版本的 hugo(0.55.5),\n\n\nhttps://gohugo.io/getting-started/installing/ 文章中的Install Hugo from Tarball 这一部分(个人电脑是 mac)\n\n\n\n直接从 Rstduio 进行更新\n\n前提是: 必须保证 R 以及 R 包是最新的\n使用如下命令\n\nblogdown::install_hugo(version = \"0.55.5\", use_brew = F, force = T, extended = TRUE)"
  },
  {
    "objectID": "posts/md/R之画函数图像.html",
    "href": "posts/md/R之画函数图像.html",
    "title": "画函数图像–R语言",
    "section": "",
    "text": "据我了解, 计算机软件中画的函数图像大概有两种方法:\n在本文中我们将利用R语言来画函数图像—- 重点以ggplot2来展示"
  },
  {
    "objectID": "posts/md/R之画函数图像.html#y-fx-的函数图像",
    "href": "posts/md/R之画函数图像.html#y-fx-的函数图像",
    "title": "画函数图像–R语言",
    "section": "1. \\(y = f(x)\\) 的函数图像",
    "text": "1. \\(y = f(x)\\) 的函数图像\n比如:\n\\[\n\\begin{aligned}\ny &= sin(x),\\\\\ny &= cos(x), \\\\\ny &= \\dfrac{1}{1+e^{(-x)}},\\\\\ny &= x^2 .\n\\end{aligned}\n\\]\n这是我们中学最常见的函数.\n\n方法一: curve()画函数图像\n所用函数调用格式\ncurve(expr, from = NULL, to = NULL, n = 101, add = FALSE,\n      type = \"l\", xname = \"x\", xlab = xname, ylab = NULL,\n      log = NULL, xlim = NULL, ...)\n# expr：函数名称或一个关于变量x的函数表达式；\n# from，to：表示绘图的起止范围；\n# n：一个整数值，表示x取值的数量；\n# add：是一个逻辑值，当为TRUE时，表示将绘图添加到已存在的绘图中；\n# type：与plot函数中type含义相同\n#定义公式\nsigmoid <- function(x) 1/(1+exp(-x))\n\n#画sigmid图像\ncurve(sigmoid,-10,10)\n\n#画sin(x)函数图像\ncurve(sin,-10,10)\n\n# 画y=x^2的图像\ncurve(x^2,-10,10)\n\n\n\n方法二: ggplot2\n首先介绍两个映射\n\ngeom_path() 按照观测值在数据中出现的顺序连接观测值(如果画函数图,推荐此映射,原因后面知晓)。\ngeom_line()按变量在x轴上的顺序连接它们。\n\nlibrary(ggplot2)\n\n# 定义函数\nsigmoid <- function(x) 1/(1+exp(-x))\n\n# 创建数据点\nx<-seq(-5, 5, by=0.01)\ny<-sigmoid(x)\ndf<-data.frame(x, y)\n\n# 用ggplot2来画图\ng <- ggplot(df, aes(x,y))\ng <- g + geom_path(col='red') ## 用geom_line 替代也是可以的,但不推荐\ng <- g + geom_hline(yintercept = 0.5) + geom_vline(xintercept = 0) #坐标轴\ng <- g +  labs(title=\"sigmoid\", x=\"x\", y=\"y\")\ng <- g +theme(plot.title = element_text(hjust = 0.5))  #标题居中\ng"
  },
  {
    "objectID": "posts/md/R之画函数图像.html#函数图像具有参数方程",
    "href": "posts/md/R之画函数图像.html#函数图像具有参数方程",
    "title": "画函数图像–R语言",
    "section": "2. 函数图像具有参数方程",
    "text": "2. 函数图像具有参数方程\n例如: 圆, 椭圆, 抛物线, 双曲线 方程.\n\n2.1 画\\(x^2+y^2 = 4\\)的函数图像\n这里我们只以ggplot2为例,\n思路一: 可以利用分段函数的思想画,先把原函数解出显示的表达式 \\(y = -\\sqrt{4-x}\\) 或者\\(y = \\sqrt{4-x}\\), 然后分段画, 这里不讲解\n思路二: 像上面这些函数,都能表示成参数方程的形式, 利用参数方程来画该函数图像\n首先写出圆的参数方程一般形式:\n\\[\n\\begin{cases}\nx = rcos\\theta,\\\\\ny = rsin\\theta\n\\end{cases}\n\\]\nlibrary(ggplot2)\nr = 2\ntheta=seq(0, 2*pi, by=0.001)\nx = r*cos(theta)\ny = r*sin(theta) \ndf <- data.frame(x, y, theta,frame = 1:length(theta))\ng <- ggplot(df, aes(x,y))\ng <- g + geom_path(col='red')\ng\n\n###################\n####让上面的图动起来\nlibrary(gganimate)\nlibrary(transformr)\ntemp = g + transition_reveal(along = frame)\n\nanimate(temp,\n        nframes=100,#总帧数(默认)\n        duration=10 #总时长，单位为秒，默认为10秒\n        )\n\n\n\n2.2 椭圆\n椭圆的参数方程\n\\[\n\\begin{cases}\nx = acos\\theta,\\\\\ny = bsin\\theta\n\\end{cases}\n\\]\nlibrary(ggplot2)\na = 2\nb = 3\ntheta=seq(0, 2*pi, by=0.001)\nx = a*cos(theta)\ny = b*sin(theta) \ndf <- data.frame(x, y, theta,frame = 1:length(theta))\ng <- ggplot(df, aes(x,y))\ng <- g + geom_path(col='red')\n## 让图动起来\ntemp = g + transition_reveal(along = frame)\n\nanimate(temp)\n\n\n\n2.3 抛物线\n抛物线参数方程\n\\[\n\\begin{cases}\nx = 2pt^2, \\\\\ny = 2pt\n\\end{cases} (t为参数, t \\in R)\n\\]\np = 4\nt = seq(3,-3,-0.2)\nx = 2*p*t^2\ny = 2*p*t \ndf <- data.frame(x, y, t,frame = 1:length(t))\ng <- ggplot(df, aes(x,y))\ng <- g + geom_path(col='red')\n## 让图动起来\ntemp = g + transition_reveal(along = frame)\n\nanimate(temp)\n\n\n\n2.4 双曲线\n在ggplot中没有找到好的画法\na = 3\nb = 1\ntheta=round(seq(0,2*pi,0.2),2)\n\nx = a/cos(theta)\ny = b*tan(theta) \ndf <- data.frame(x, y, theta,frame = 1:length(theta))\ng <- ggplot(df, aes(x,y))\ng <- g + geom_path(col='red')\ng\n\n# 以分段的思想来画双曲线\n\n\nx <- seq(1,3,length = 100)\ny1 <- sqrt(x^2 - 1);y2 <- -sqrt(x^2 - 1)\n\nxx1 = c(rev(x),x); yy1 = c(rev(y2),y1)\n\nxx2 = c(rev(-x),-x);yy2 = c(rev(y2),y1)\n\ndf <- data.frame(xx1,yy1,xx2,yy2, frame = 1:length(xx1))\ng <- ggplot(df) + geom_path(aes(xx1,yy1),col='red') \ng <- g + geom_path(aes(xx2,yy2),col='blue')\ng \n\ntemp = g + transition_reveal(along = frame)\n\nanimate(temp)\n\n\n\n2.4 Lissajous 曲线(利萨如曲线)\n参数方程:\n\\[\n\\begin{cases}\nx = asin(p\\theta),\\\\\ny = 2sin(q\\theta+\\varphi)\n\\end{cases}\n\\]\na = 1\nb = 1\nphi = 0\np = 1\nq = 2\nt = seq(0, 2 * pi, by = 0.001)\nx = a * sin(p * t)\ny = b * sin(q * t + phi)\ndf <- data.frame(x, y, t, frame = 1:length(x))\ng <- ggplot(df, aes(x, y))\ng <- g + geom_path(col = 'red')\n\ntemp = g + transition_reveal(along = frame)\n\nanimate(temp)\n\na = 3\nb = 12\nphi = 0\np = 13\nq = 18\nt = seq(0, 2 * pi, by = 0.001)\nx = a * sin(p * t)\ny = b * sin(q * t + phi)\ndf <- data.frame(x, y, t, frame = 1:length(t))\ng <- ggplot(df, aes(x, y))\ng <- g + geom_path(col = 'red')\ng\n\ntemp = g + transition_reveal(along = frame)\n\nanimate(temp)"
  },
  {
    "objectID": "posts/md/R之画函数图像.html#隐函数",
    "href": "posts/md/R之画函数图像.html#隐函数",
    "title": "画函数图像–R语言",
    "section": "3 .隐函数",
    "text": "3 .隐函数\n这个暂时不知道, 且不常见,建议找MATLAB这种专业软件画或者ggb也行."
  },
  {
    "objectID": "posts/md/go语言安装与LiteIDE的配置.html",
    "href": "posts/md/go语言安装与LiteIDE的配置.html",
    "title": "1、go语言安装与LiteIDE的配置",
    "section": "",
    "text": "在cmd 命令中输入 ：go env 显示\nset GOARCH=amd64                              #    cpu架构   \nset GOBIN=                                  # 工作目录下的bin文件夹  \nset GOEXE=.exe                               # 生成可执行文件的后缀  \nset GOHOSTARCH=amd64                        #交叉编译参数  \nset GOHOSTOS=windows                        #交叉编译参数   \nset GOOS=windows                          #当前系统名称  \nset GOPATH=C:\\Users\\zsc\\go               # 我的工作目录  \nset GORACE=                                       #  \nset GOROOT=F:\\go                             #go的安装目录  \nset GOTOOLDIR=F:\\go\\pkg\\tool\\windows_amd64   #   \nset GCCGO=gccgo  \nset CC=gcc  \nset GOGCCFLAGS=-m64 -mthreads -fmessage-length=0 -fdebug-prefix-map=C:\\Users\\zsc\\AppData\\Local\\Temp\\go-build974907835=/tmp/go-build -gno-record-gcc-switches\nset CXX=g++  \nset CGO_ENABLED=1   \nset CGO_CFLAGS=-g -O2  \nset CGO_CPPFLAGS=  \nset CGO_CXXFLAGS=-g -O2  \nset CGO_FFLAGS=-g -O2  \nset CGO_LDFLAGS=-g -O2  \nset PKG_CONFIG=pkg-config  \n好像这后面的可以不用管，去电脑的环境变量里面新增\n\n\n\ngo1-2\n\n\n解压下载好的liteide，把解压后的目录放在go安装的目录中（我的安装go目录为F：）进入F:.exe 文件，双击进入\n接着配置liteide工具，点击【工具】–【选择环境】–【win64】 ，，再次进入【工具】–【编辑当前环境】\n\n\n\ngo1-3\n\n\n好像就成功了\n再次检查一下，进入cmd 输入 go env 与go version，go的版本1.9.2，成功\n\n\n\ngo1-4\n\n\n进入LiteIDE测试\n点击【文件】–新建—GO1 command Project 即可，输入go程序，\n// week1 project main.go\npackage main\n\nimport \"fmt\"\n\nfunc createMessage(name string) string {\n    if len(name) == 0 {\n        return \"Hello world\"\n    } else {\n        return \"Hello \" + name\n    }\n}\nfunc main() {\n    fmt.Println(createMessage(\"Tom\"))\n    fmt.Println(createMessage(\"\"))\n}\n先编译（ctrl+B）—在运行(ctrl+alt+R)，就能看到结果：（和c的运行一样）\n\n\n\ngo1-5\n\n\n对静态语言不熟悉，几乎小白，见谅！"
  },
  {
    "objectID": "posts/md/R语言文件目录相关操作.html",
    "href": "posts/md/R语言文件目录相关操作.html",
    "title": "R语言文件目录相关操作",
    "section": "",
    "text": "R语言对文件系统的操作，包括文件操作和目录操作，函数API都定义在base包中。"
  },
  {
    "objectID": "posts/md/R语言文件目录相关操作.html#目录操作",
    "href": "posts/md/R语言文件目录相关操作.html#目录操作",
    "title": "R语言文件目录相关操作",
    "section": "2. 目录操作",
    "text": "2. 目录操作\n2.1 查看目录\n查看当前目录下的子目录。\n setwd()               #设定某个目录为当前目录\n getwd()               # 当前的目录\n list.dirs()           # 查看当前目录的子目录  参数详见dir()\n \n dir()                 #查看当前目录的子目录和文件。\n dir(path=\"C:/windows\")#查看指定目录的子目录和文件\n dir(path=\"C:/windows\",all.files=TRUE)# 列出目录下所有的目录和文件，包括隐藏文件\n dir(path=\"C:/windows\",pattern='^R')#只列出以字母R开头的子目录或文件\n \n file.info(\".\")         # 查看当前目录权限\n2.2 创建目录\ndir.create(\"your dir\")        # 在当前目录下，新建一个目录\ndir.create(path=\"a1/b2/c3\",recursive = TRUE)  #递归创建一个3级子目录./a1/b2/c3，直接创建会出错\n2.3 检查目录是否存在\nsystem(\"tree\")                      # 通过系统命令查看目录结构\nfile.exists(\"./a1\")             # 查看某个目录是否存在,可以多层次调用目录\n2.4 检查目录的权限\ndf<-dir(full.names = TRUE)         #获取当前目录的所有目录(不含子目录)和文件名（含后缀）\nfile.access(df, model=0) == 0      # 检查文件或目录是否存在，mode=0\n                                  # 检查文件或目录是否可执行，mode=1，目录为可以执行\n                                  # 检查文件或目录是否可写，mode=2\n                                 # 检查文件或目录是否可读，mode=4\n2.5修改目录权限。\n Sys.chmod(\"./create\", mode = \"0555\", use_umask = TRUE)  # 修改目录权限，所有用户只读\n \n2.6 对目录重名\nfile.rename(\"create\", \"newcreate\")            # 对tcreate目录重命名为newcreate\nunlink(\"newcreate\", recursive = TRUE)         # 删除newcreate目录   递归删除\n2.7 其他功能函数\nfile.path(\"p1\",\"p2\",\"p3\")                  # 拼接目录字符串\ndirname(path=\"\")                           #获得某个路径的目录名\nbasename(path=\"\")                          #获得某个目录的最底层目录或者文件名\nnormalizePath(c(R.home(), tempdir()))      #获取目录的绝对路径"
  },
  {
    "objectID": "posts/md/R语言文件目录相关操作.html#文件操作",
    "href": "posts/md/R语言文件目录相关操作.html#文件操作",
    "title": "R语言文件目录相关操作",
    "section": "3. 文件操作",
    "text": "3. 文件操作\n3.1 查看文件\nfile.exists(\"readme.txt\")         # 检查文件是否存在\nfile.info(\"readme.txt\")            # 查看文件完整信息\nfile.access(\"readme.txt\",0)        # 查看文件访问权限，存在详情见2.4\nfile_test(\"-d\", \"readme.txt\")      #判断是文件还是目录。-d ,是目录返回ture\nfile_test(\"-f\", \"readme.txt\")      # 判断是否是文件 .  -f 是文件但会ture\n3.2 创建文件\nfile.create(\"A.txt\")            # 创建一个空文件 A.txt\ncat(\"file B\\n\", file = \"B.txt\") # 把相关的内容写入B.txt文件中，没有这个文件则创建文件并写入内容 \n\nreadLines(\"A.txt\")         # 读取A.txt并打印\nfile.append(\"A.txt\", rep(\"B.txt\", 10))   # 合并文件,把文件B.txt的内容，合并到 A.txt。\nfile.copy(\"A.txt\", \"C.txt\")    #把文件A.txt复制到文件C.txt ,文件复制\n3.3 修改文件权限\n# 修改文件权限，创建者可读可写可执行，其他人无权限\nSys.chmod(\"A.txt\", mode = \"0700\", use_umask = TRUE)\n3.4 文件重命名\nfile.rename(\"A.txt\",\"AA.txt\")     # 给文件A.txt重命名为AA.txt\n3.5 删除文件\n有两个函数可以使用file.remove和unlink，其中unlink函数使用同删除目录操作是一样的。\nfile.remove(\"A.txt\", \"B.txt\", \"C.txt\")      # 删除文件\nunlink(\"readme.txt\")                   # 删除文件\nsystem(\"ls -l\")            # 查看目录文件"
  },
  {
    "objectID": "posts/md/R语言文件目录相关操作.html#几个特殊的目录",
    "href": "posts/md/R语言文件目录相关操作.html#几个特殊的目录",
    "title": "R语言文件目录相关操作",
    "section": "4. 几个特殊的目录",
    "text": "4. 几个特殊的目录\n\nR.home() 查看R软件的相关目录\n.Library 查看R核心包的目录\n.Library.site 查看R核心包的目录和root用户安装包目录\n.libPaths() 查看R所有包的存放目录\nsystem.file() 查看指定包所在的目录\n\n参考：http://blog.fens.me/r-file-folder/"
  },
  {
    "objectID": "posts/md/hugo生成的目录.html",
    "href": "posts/md/hugo生成的目录.html",
    "title": "hugo–blogdown生成的目录",
    "section": "",
    "text": "2、静态文件\n不需要hugo处理的文件叫做静态文件。存放在 站点的static 目录是个好主意。\n\nstatic目录下的文件将会原封不动的复制到public下面，比如您建立了个img的目录存图片，在md文件中将直接使用”img/aaa.jpg”来引用图片，\n特别的，如果您的站点有php等脚本运用，和一些其他的文件，比如各搜索引擎的验证文件等，也可以放在这里。不建议直接将文件存放于public目录，因为我习惯不高兴就删了全来！相信你也会有不高兴的时候的。（后面比如要上传的google网站分析的html文件）\n\n\n\n3、站点配置文件\n站点根目录下有一个”config.toml“就是配置文件 E:\\test_blog下的config.toml\n\n信息存在的地，hugo有三个地方可以放信息，\n\n一个是站点的配置文件“config.toml”，\n一个是我们文章文件md文件的头部（默认的用三个“—”号开始和结束，也可以用三个“+++”号\n最后一个是“data”数据目录。\n\ncongfig.toml该文件默认支持的全部参数：可以用键值对，也可以用赋值语句\n以 hugo-lithium-theme主题为例\n介绍几个后面可能会用的参数\nbaseurl = \"http://qaz.netlify.com\"    # 基础路径,当自己有网站的时候就写自己的\nrelativeurls = true                    #使用想对路径方便本地浏览\nlanguageCode = \"zh-cn\"                #编码\ntitle = \"A Hugo website\"            #网站的title\ntheme = \"hugo-lithium-theme\"\ngoogleAnalytics = \"\"                 #谷歌网站分析添加自己的id，形如：UA-XXXXXX-X\ndisqusShortname = \"http-qaz-netlify-com\"  # disqusShortname 的名字，一定要找准\nignoreFiles = [\"\\\\.Rmd$\", \"\\\\.Rmarkdown$\", \"_files$\", \"_cache$\"] \nhasCJKLanguage = true         #若要统计中文字数设置为ture,默认统计英文\n\n\n\n4、自定义信息\n站点配置文件并不是只能存放默认的配置项目的，它一样可以存放自定义的数据，并且在模版中被调用。\n下面是本站的目录的自定义信息：\n[permalinks]\n    post = \"/:year/:month/:day/:slug/\"\n\n[[menu.main]]\n    name = \"About\"\n    url = \"/about/\"\n[[menu.main]]\n    name = \"GitHub\"\n    url = \"https://github.com/rstudio/blogdown\"\n[[menu.main]]\n    name = \"Twitter\"\n    url = \"https://twitter.com/rstudio\"\n\n[params]\n    description = \"A website built through Hugo and blogdown.\"\n\n    # options for highlight.js (version, additional languages, and theme)\n    highlightjsVersion = \"9.11.0\"\n    highlightjsCDN = \"//cdn.bootcss.com\"\n    highlightjsLang = [\"r\", \"yaml\"]\n    highlightjsTheme = \"github\"\n\n    MathJaxCDN = \"//cdn.bootcss.com\"\n    MathJaxVersion = \"2.7.1\"\n\n    [params.logo]\n    url = \"logo.png\"\n    width = 50\n    height = 50\n    alt = \"Logo\"\n找到E:\\test_blog\\themes\\hugo-lithium-theme\\layouts\\ 下面有两个文件夹\n一个_default/ partials/"
  },
  {
    "objectID": "posts/md/R环境.html",
    "href": "posts/md/R环境.html",
    "title": "环境",
    "section": "",
    "text": "详细的解释可以查看书《高级R语言编程指南》,这里总结一份与环境有关的函数总结：(参考R语言核心技术手册第二版)\n\n\n\n\n\n\n\n\n函数\n描述\n\n\n\n\n\nassign\n在envir环境中将名称x赋给value对象\n\n\n\nget\n在envir环境中获得与名称x关联的对象\n\n\n\nexists\n判断在环境envir是是否定义了名称x\n\n\n\nobjects\n以向量的形式返回envir环境中定义的所有(对象)名称\n\n\n\nremove\n从envir环境中将参数中罗列的对象删除(列表不适合作为参数的名称，尤其当参数是向量时)\n\n\n\nsearch\n以向量的形式列出全局环境的所有父环境，也称为搜索路径\n\n\n\nsearchpaths\n以向量的形式返回全局环境的所有父环境的路径\n\n\n\nattach\n将列表、数据框或数据文件中的对象添加到当前的搜索路径中\n\n\n\ndetach\n将列表、数据框或数据文件中的对象从当前的搜索路径中删除\n\n\n\nemptyenv\n空环境对象，它是所有环境的祖先，也是唯一一个没有父环境的的环境\n\n\n\nparent.env\n查看envir环境的父环境\n\n\n\nbaseenv\n基础环境，它是R基础软件包的环境，它的父环境是空环境\n\n\n\nglobalenv(或.GlobalEnv)\n用户的工作环境，也叫全局环境，通常情况下我们就是在这个环境中工作的，全局环境的父环境是由library() 或require()添加的最后一个添加包\n\n\n\nenvironment\n它是当前环境，(默认情况下，当前环境等于全局环境)\n\n\n\nnew.env\n手动创建一个新的环境对象\n\n\n\nparent.frame\n返回函数被调用的环境 ,即可以访问调用环境的父环境，常常作为参数使用，需要搭配其他函数eg:eval\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n调用栈的操作\n\n\n\n\n\n\n\n函数\n描述\n\n\n\n\nsys.call\n返回一个包含当前函数调用(包括参数)的语言对象\n\n\nsys.frame\n返回调用环境\n\n\nsys.nframe\n返回当前帧的编号(即在调用堆栈中的位置)，如果在R控制台中调用该函数，返回值为0,\n\n\nsys.function\n返回当前计算的函数\n\n\nsys.parent\n返回父环境的编号\n\n\nsys.calls\n返回栈中所有帧的调用\n\n\nsys.frames\n返回栈中所有的环境\n\n\nsys.parents\n返回栈中每个帧的父帧\n\n\nsys.on.exit\n返回当前on.exit所使用的表达式\n\n\nsys.status\n返回一个列表\n\n\nparent.frame\n返回sys.frame(sys.parent(n)) ,即返回函数被调用的父环境，即允许访问调用父环境.常常作为参数使用，需要搭配其他函数eg:eval\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n《R语言核心编程技巧第二版》"
  },
  {
    "objectID": "posts/测试文件.html",
    "href": "posts/测试文件.html",
    "title": "测试文件",
    "section": "",
    "text": "定义一个 center环境 ::: {.center} The contents of this div will be output in a center LaTeX environment, but will appear in HTML (and any other output format as a simple div with the class center) :::\n\n\n\n\n\n\nOptional caption (note)\n\n\n\n\n\n\nHide callout body with ‘collapse=true’\nRemove ‘collapse’ to prevent expandability\nSet appearance to ‘default’, ‘simple’ or ‘minimal’\nRemove icon with ‘icon=false’\n\n\n\n\n\n\n\n\n\n\n\n\n\nRPython\n\n\nTab content\n\n\nTab content\n\n\n\n\n\n\n\n\n\n注释\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.\n\n\n\n\n\n\n\n\nTip With Caption\n\n\n\nThis is an example of a callout with a caption.\n\n\n\n\n\n\n\n\nExpand To Learn About Collapse\n\n\n\n\n\nThis is an example of a ‘folded’ caution callout that can be expanded by the user. You can use collapse=\"true\" to collapse it by default or collapse=\"false\" to make a collapsible callout that is expanded by default."
  },
  {
    "objectID": "posts/post/相关图之corrplot.html#相关矩阵图二corrplot",
    "href": "posts/post/相关图之corrplot.html#相关矩阵图二corrplot",
    "title": "相关图之corrplot",
    "section": "",
    "text": "由于corrgram::corrgram()函数没有显示相关性的大小度量关系，于是经常用corrplot::corrplot()函数来画相关矩阵图，不过此图的缺点是title画出来不好看\ncorrplot(corr, \n  method = c(\"circle\", \"square\", \"ellipse\", \"number\", \"shade\",\"color\", \"pie\"), \n  type = c(\"full\", \"lower\", \"upper\"), add = FALSE,\n  col = NULL, bg = \"white\", title = \"\", is.corr = TRUE, diag = TRUE,\n  outline = FALSE, mar = c(0, 0, 0, 0), addgrid.col = NULL,\n  addCoef.col = NULL, addCoefasPercent = FALSE, order = c(\"original\",\n  \"AOE\", \"FPC\", \"hclust\", \"alphabet\"), hclust.method = c(\"complete\", \"ward\",\n  \"ward.D\", \"ward.D2\", \"single\", \"average\", \"mcquitty\", \"median\", \"centroid\"),\n  addrect = NULL, rect.col = \"black\", rect.lwd = 2, tl.pos = NULL,\n  tl.cex = 1, tl.col = \"red\", tl.offset = 0.4, tl.srt = 90,\n  cl.pos = NULL, cl.lim = NULL, cl.length = NULL, cl.cex = 0.8,\n  cl.ratio = 0.15, cl.align.text = \"c\", cl.offset = 0.5, number.cex = 1,\n  number.font = 2, number.digits = NULL, addshade = c(\"negative\",\n  \"positive\", \"all\"), shade.lwd = 1, shade.col = \"white\", p.mat = NULL,\n  sig.level = 0.05, insig = c(\"pch\", \"p-value\", \"blank\", \"n\", \"label_sig\"),\n  pch = 4, pch.col = \"black\", pch.cex = 3, plotCI = c(\"n\", \"square\",\n  \"circle\", \"rect\"), lowCI.mat = NULL, uppCI.mat = NULL, na.label = \"?\",\n  na.label.col = \"black\", win.asp = 1, ...)\n\n\n参数解释：\ncorr： 用于绘图的矩阵，必须是正方形矩阵(即相关系数矩阵)，如果是普通的矩阵，需要设置is.corr=FALSE \nmethod：可以是circle(圆形,默认),square(方形),ellipse(椭圆形),number(数值),shade(阴影),color(颜色),pie(饼图)。\ntype：用于设置相关矩阵图的显示区域：full(全部，默认), lower(下三角), upper(上三角)。\ncol：指定图形展示的颜色，默认以均匀的颜色展示，可以通过colorRampPalette函数向col参数赋值来设置颜色。\nbg：指定图的背景色 \ntitle：为图形添加标题\ndiag：是否展示对角线上的结果，默认为TRUE\noutline：是否绘制圆形、方形或椭圆形的轮廓，默认为FALSE\nmar：具体设置图形的四边间距\naddgrid.col：当选择的方法为颜色或阴影时，默认的网格线颜色为白色，否则为灰色\naddCoef.col：为相关系数添加颜色，默认不添加相关系数，只有方法为number时，该参数才起作用\naddCoefasPercent：为节省绘图空间，是否将相关系数转换为百分比格式，默认为FALSE\norder：指定相关系数排序的方法，一般”AOE”排序结果都比”FPC”要好\n        可以是：original(原始顺序)、AOE(特征向量角序)、FPC(第一主成分顺序)、hclust(层次聚类顺序)和alphabet(字母顺序)\n        \nhclust.method：当order为hclust时，该参数可以是层次聚类中ward法、最大距离法等7种之一\naddrect：当order为hclust时，可以为添加相关系数图添加矩形框，默认不添加框，如果想添加框时，只需为该参数指定一个整数即可\nrect.col：指定矩形框的颜色\nrect.lwd：指定矩形框的线宽\ntl.pos：指定文本标签(变量名称)的位置，字符型参数为：\"lt\", \"ld\", \"td\", \"d\" or \"n\"\n      当type=full时，默认标签位置在左边和顶部(lt)，\n    当type=lower时，默认标签在左边和对角线(ld)，\n      当type=upper时，默认标签在顶部和对角线， d表示diagonal(对角线)， n表示不添加文本标签\n\ntl.cex：指定文本标签的大小\ntl.col：指定文本标签的颜色\ncl.pos：图例（颜色条）位置，\n      当type=upper或full时，图例在右表(r)，\n      当type=lower时，图例在底部，\n      不需要图例时，只需指定该参数为n\n\naddshade：只有当method=shade时，该参数才有用，\n    参数值可以是negtive/positive和all，分表表示对负相关系数、正相关系数和所有相关系数添加阴影。\n    注意：正相关系数的阴影是45度，负相关系数的阴影是135度\n\nshade.lwd：指定阴影的线宽\nshade.col：指定阴影线的颜色\n\n参数 cl.*  用于设置图例的颜色（图例的色条），tl.* 用于设置图例的文本(标量名称)。\n对于文本标签，这两个函数 tl.col（文本标签颜色）和tl.srt（文本标签字符串旋转）用于更改文本颜色和旋转。\n\n\n代码library(corrplot)\n\nM &lt;- cor(mtcars)\nmethod = c(\"circle\", \"square\", \"ellipse\", \"number\", \"shade\",\"color\")\npar(mfrow=c(3,2))\nt = mapply(function(x){corrplot(M,method = x,order = \"AOE\",title=paste0(\"method=\",x))},method)\n\n\n\n\n\ntype = c(“full”, “lower”, “upper”)\ncorrplot.mixed() 是一个混合可视化风格的包装函数。\n\n代码M &lt;- cor(mtcars)\ntype = c(\"full\", \"lower\", \"upper\")\npar(mfrow=c(1,3))\nt = mapply(function(x){corrplot(M,order = \"hclust\",type = x,title=paste0(\"type=\",x))},type)\n\n\n\n\n\n代码par(mfrow=c(2,2))\ncorrplot.mixed(M)\ncorrplot.mixed(M, lower.col = \"black\", number.cex = .7)\ncorrplot.mixed(M, lower = \"ellipse\", upper = \"circle\")\ncorrplot.mixed(M, lower = \"square\", upper = \"circle\", tl.col = \"black\") # tl.col：指定文本标签的颜色\n\n\n\n\n\n\n代码order = c(\"original\",\"AOE\", \"FPC\", \"hclust\", \"alphabet\")\npar(mfrow=c(2,3))\nt = mapply(function(x){corrplot(M,order = x,title=paste0(\"order=\",x))},order)\n\n\n####### # 如果使用\"hclust\"，corrplot()可以根据层次聚类的结果在corrrlation矩阵图表周围绘制矩形。\npar(mfrow=c(1,2))\n\n\n\n代码corrplot(M, order = \"hclust\", addrect = 2)\ncorrplot(M, order = \"hclust\", addrect = 3)\n\n\n\n代码####### # 改变背景颜色以及图像颜色\npar(mfrow=c(1,1))\ncorrplot(M, type = \"upper\", order = \"hclust\", col = c(\"black\", \"white\"), bg = \"lightblue\")\n\n\n\n\n\n\n代码# 如上一节所示，可以定制相关图的颜色。该功能colorRampPalette()非常便于产生色谱。\n\ncol1 &lt;- colorRampPalette(c(\"#7F0000\", \"red\", \"#FF7F00\", \"yellow\", \"white\",\n                           \"cyan\", \"#007FFF\", \"blue\", \"#00007F\"))\ncol2 &lt;- colorRampPalette(c(\"#67001F\", \"#B2182B\", \"#D6604D\", \"#F4A582\",\n                           \"#FDDBC7\", \"#FFFFFF\", \"#D1E5F0\", \"#92C5DE\",\n                           \"#4393C3\", \"#2166AC\", \"#053061\"))\ncol3 &lt;- colorRampPalette(c(\"red\", \"white\", \"blue\")) \ncol4 &lt;- colorRampPalette(c(\"#7F0000\", \"red\", \"#FF7F00\", \"yellow\", \"#7FFF7F\",\n                           \"cyan\", \"#007FFF\", \"blue\", \"#00007F\"))\nwhiteblack &lt;- c(\"white\", \"black\")\n\n## using these color spectra\npar(mfrow=c(2,2))\ncorrplot(M, order = \"hclust\", addrect = 2, col = col1(100))\ncorrplot(M, order = \"hclust\", addrect = 2, col = col2(50))\ncorrplot(M, order = \"hclust\", addrect = 2, col = col3(20))\ncorrplot(M, order = \"hclust\", addrect = 2, col = col4(10))\n\n\n\n代码\n\npar(mfrow=c(1,1))\ncorrplot(M, order = \"hclust\", addrect = 2, col = whiteblack, bg = \"gold2\")\n\n\n\n代码\n\n### 使用调色板包\n# 您也可以使用标准调色板（包grDevices）\npar(mfrow=c(2,2))\ncorrplot(M, order = \"hclust\", addrect = 2, col = heat.colors(100))\ncorrplot(M, order = \"hclust\", addrect = 2, col = terrain.colors(100))\ncorrplot(M, order = \"hclust\", addrect = 2, col = cm.colors(100))\ncorrplot(M, order = \"hclust\", addrect = 2, col = gray.colors(100))\n\n\n\n代码\n\n### 使用调色板包---使用RcolorBrewer包。\n\nlibrary(RColorBrewer)\ncorrplot(M, type = \"upper\", order = \"hclust\",col = brewer.pal(n = 8, name = \"RdBu\"))\ncorrplot(M, type = \"upper\", order = \"hclust\",col = brewer.pal(n = 8, name = \"RdYlBu\"))\ncorrplot(M, type = \"upper\", order = \"hclust\",col = brewer.pal(n = 8, name = \"PuOr\"))\n\n\n\n\n\n参数 cl.* 用于设置图例的颜色，tl.* 用于设置图例的文本。\n对于文本标签，这两个函数tl.col（文本标签颜色）和tl.srt（文本标签字符串旋转）用于更改文本颜色和旋转。\n\n代码par(mfrow=c(2,2))\n\n## remove color legend and text legend 移除图例的颜色部分和文字标签部分\ncorrplot(M, order = \"AOE\", cl.pos = \"n\", tl.pos = \"n\")  \n\n## bottom  color legend, diagonal text legend, rotate text label\n## 图底图例，对角线文字图例，旋转文字标签\ncorrplot(M, order = \"AOE\", cl.pos = \"b\", tl.pos = \"d\", tl.srt = 60) \n\n## a wider color legend with numbers right aligned\ncorrplot(M, order = \"AOE\", cl.ratio = 0.2, cl.align = \"r\")\n\n## text labels rotated 45 degrees\ncorrplot(M, type = \"lower\", order = \"hclust\", tl.col = \"black\", tl.srt = 45)\n\n\n\n\n\n\n代码\npar(mfrow=c(2,2))\ncorrplot(abs(M),order = \"AOE\", col = col3(200), cl.lim = c(0, 1))\n\n## visualize a  matrix in [-100, 100]\nran &lt;- round(matrix(runif(225, -100,100), 15))\ncorrplot(ran, is.corr = FALSE, method = \"square\")\n\n## a beautiful color legend \ncorrplot(ran, is.corr = FALSE, method = \"ellipse\", cl.lim = c(-100, 100))\n\n#如果矩阵是矩形，则可以使用win.asp参数调整纵横比， 以使矩阵呈现为正方形。\nran &lt;- matrix(rnorm(70), ncol = 7)\ncorrplot(ran, is.corr = FALSE, win.asp = .7, method = \"circle\")\n\n\n\n\n\n默认情况下，corrplot将NA值呈现为”?“字符。使用na.label 参数，可以使用不同的值（最多支持两个字符）。\n\n代码M2 &lt;- M\ndiag(M2) = NA\ncorrplot(M2)\n\n\n\n代码par(mfrow=c(1,2))\ncorrplot(M2, na.label = \"o\")\ncorrplot(M2, na.label = \"NA\")\n\n\n\n\n\n从版本开始0.78，可以 在变量名中使用plotmath表达式。要激活plotmath渲染，请在标签前加上一个字符\":\"，\"=\"or \"$\"。\n\n代码M2 &lt;- M[1:5,1:5]\ncolnames(M2) &lt;- c(\"alpha\", \"beta\", \":alpha+beta\", \":a[0]\", \"=a[beta]\")\nrownames(M2) &lt;- c(\"alpha\", \"beta\", NA, \"$a[0]\", \"$ a[beta]\")\ncorrplot(M2)\n\n\n\n\n\n\n代码res1 &lt;- cor.mtest(mtcars, conf.level = .95)\nres2 &lt;- cor.mtest(mtcars, conf.level = .99)\npar(mfrow=c(1,3))\n## specialized the insignificant value according to the significant level\ncorrplot(M, p.mat = res1$p, sig.level = .2)\n\ncorrplot(M, p.mat = res1$p, sig.level = .05)\n\ncorrplot(M, p.mat = res1$p, sig.level = .01)\n\n\n\n代码\n\n\n## leave blank on no significant coefficient\ncorrplot(M, p.mat = res1$p, insig = \"blank\")\n\n## add p-values on no significant coefficient\ncorrplot(M, p.mat = res1$p, insig = \"p-value\")\n\n## add all p-values\ncorrplot(M, p.mat = res1$p, insig = \"p-value\", sig.level = -1)\n\n\n\n代码\n\n\n## add cross on no significant coefficient \npar(mfrow=c(1,1))\ncorrplot(M, p.mat = res1$p, order = \"hclust\", insig = \"pch\", addrect = 3)\n\n\n\n\n\n\n代码par(mfrow=c(3,2))\ncorrplot(M, low = res1$lowCI, upp = res1$uppCI, order = \"hclust\",\n         rect.col = \"navy\", plotC = \"rect\", cl.pos = \"n\")\n\n\n\ncorrplot(M, p.mat = res1$p, low = res1$lowCI, upp = res1$uppCI,\n         order = \"hclust\", pch.col = \"red\", sig.level = 0.01,\n         addrect = 3, rect.col = \"navy\", plotC = \"rect\", cl.pos = \"n\")\n\n\n\n\nres1 &lt;- cor.mtest(mtcars, conf.level = .95)\ncorrplot(M, p.mat = res1$p, insig = \"label_sig\",\n         sig.level = c(.001, .01, .05), pch.cex = .9, pch.col = \"white\")\n\n\n\ncorrplot(M, p.mat = res1$p, method = \"color\",\n         insig = \"label_sig\", pch.col = \"white\")\n\n\n\ncorrplot(M, p.mat = res1$p, method = \"color\", type = \"upper\",\n         sig.level = c(.001, .01, .05), pch.cex = .9,\n         insig = \"label_sig\", pch.col = \"white\", order = \"AOE\")\n\n\ncorrplot(M, p.mat = res1$p, insig = \"label_sig\", pch.col = \"white\",\n         pch = \"p&lt;.05\", pch.cex = .5, order = \"AOE\")\n\n\n\n\n\n略\n参考： https://cran.r-project.org/web/packages/corrplot/vignettes/corrplot-intro.html\n\n代码sessionInfo()\n#&gt; R version 4.2.1 (2022-06-23)\n#&gt; Platform: aarch64-apple-darwin20 (64-bit)\n#&gt; Running under: macOS Monterey 12.5.1\n#&gt; \n#&gt; Matrix products: default\n#&gt; BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n#&gt; LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n#&gt; \n#&gt; locale:\n#&gt; [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#&gt; \n#&gt; attached base packages:\n#&gt; [1] stats     graphics  grDevices utils     datasets  methods   base     \n#&gt; \n#&gt; other attached packages:\n#&gt; [1] RColorBrewer_1.1-3 corrplot_0.92     \n#&gt; \n#&gt; loaded via a namespace (and not attached):\n#&gt;  [1] digest_0.6.29     jsonlite_1.8.0    magrittr_2.0.3    evaluate_0.16    \n#&gt;  [5] rlang_1.0.4       stringi_1.7.8     cli_3.3.0         rstudioapi_0.14  \n#&gt;  [9] rmarkdown_2.16.1  tools_4.2.1       stringr_1.4.1     htmlwidgets_1.5.4\n#&gt; [13] xfun_0.32         yaml_2.3.5        fastmap_1.1.0     compiler_4.2.1   \n#&gt; [17] htmltools_0.5.3   knitr_1.40"
  },
  {
    "objectID": "posts/md/datatable2.html#键主键的概念",
    "href": "posts/md/datatable2.html#键主键的概念",
    "title": "data.table – 2基本概念",
    "section": "",
    "text": "data.table从来不使用行名。data.table类似有行名的形式为1:，2: , ...\n主键会对筛选的列进行重排序\n我们把data.table数据中的行名叫做键（或主键），他类似于python的字典，使用键值对类型查找数据，键要求唯一，每一行有且只有一个键。但是R中的键可以用多个甚至可以重复，键就相当于索引，通过键进行数据的查找\nsetkey() 和 setkeyv()可以直接更新输入的data.table，就和上一讲中的操作符”:=“一样。它们没有返回值。\n这个主键和其它语言不一样，例如python的键，唯一，在r中任意列都能使用setkey()来设置主键\n\nlibrary(data.table)\nmtcars_dt &lt;- data.table(mtcars)  # 可以看出mtcars数据集中的行名没有了，替而代之为1: ，2:\n\n# 若想保留行名，设置keep.rownames = T，当keep.rowname＝\"new\"时，列名改为new即可\nmtcars_dt &lt;- data.table(mtcars,keep.rownames = T)#默认创建一个叫做 rn的列，并且将行名赋值给这一列。\nmtcars_dt\n\n\n怎么将数据中的某一列设置为主键呢？—setkey()函数\n\nsetkey(DT, key)将DT中的key列设置为主键，但是类行名 1:，2:,…,不会发生改变,\n上面等价setkeyv(DT, \"key\") ，也将DT中的key列设置为主键\n一旦将某一列设置成data.table的主键，就可以在参数i里指定 .()来subset那些主键了(就可以进行行筛选了)。我们还是用mtcars数据集，我们增加一个新列new\n\nmtcars_dt &lt;- data.table(mtcars)\nmtcars_dt[,new:=Sys.Date()+1:32] #增加一列new，内容为时间\nsetkey(mtcars_dt,new)\nmtcars_dt   # 类似行名并没有发生改变，\nmtcars_dt[.(Sys.Date()+1)]\nkey(mtcars_dt)    #查询设置主键的列名\n\n\n# 也可以在r中任意列都能使用setkey()来设置主键\nsetkey(mtcars_dt,cyl,vs)    #会把先前设置的new主键给覆盖掉\nmtcars_dt[.(4,1)]   #如果主键是字符型的列，那么可以省略 .()\nkey(mtcars_dt)  #查询设置主键的列名\n\nhaskey(mtcars_dt) # 返回TF值，检查是否有Key"
  },
  {
    "objectID": "posts/md/datatable2.html#二级索引",
    "href": "posts/md/datatable2.html#二级索引",
    "title": "data.table – 2基本概念",
    "section": "",
    "text": "二级索引和data.table的主键类似（二级索引不重排序，主键会重排序），但有以下两点不同：\n\n它不会再内存里将整个data.table重新排序（setkey会）。它只会计算某列的顺序，将这个顺序向量保存在一个额外的，叫做index的属性里面。\n一个data.table可以有多个二级索引，我们把主键与二级索引提取行方法进行对比\n\n# 设置主键的过程\nmtcars_dt &lt;- data.table(mtcars)\nmtcars_dt[,new:=Sys.Date()+1:32] #增加一列new，内容为时间\nsetkey(mtcars_dt,cyl,vs)    #设置主键\nmtcars_dt[.(4,1)]   #提取cyl==4,vs==1的所有行\n#  设置二级索引的过程--方法1\nmtcars_dt &lt;- data.table(mtcars)\nmtcars_dt[,new:=Sys.Date()+1:32] #增加一列new，内容为时间\nsetindex(mtcars_dt,cyl,vs)# 把cyl,vs两列都设置二级索引的过程--方法1\nmtcars_dt   # 等价 setindexv(mtcars_dt,\"cyl\",\"vs\")\n\n#注意mtcars_dt实际上没有按照cyl列的升序重新排列。还记得吗？setkey()会重新排序！\n# setindex(mtcars_dt,NULL)  会删除所有的二级索引。\nindices(mtcars_dt,vectors = FALSE)#  获取数据的二级索引,  默认为FALSE\nsetindex(mtcars_dt,new) #再次建立一个二级索引\nindices(mtcars_dt)# 查看二级索引，可以发现在原有的二级索引上追加了新的索引，不会覆盖，还记得setkey(mtcars_dt,cyl,vs)会把先前设置的new主键给覆盖掉\n\n参数on能自动创建并重用二级索引－－等价setindex() 函数\n通过创建索引进行subset。每次都能节省setindex()的时间。\n通过检查属性，可以简单地重用已经存在的二级索引。\n语法简单。\n在参数i里面指定取值，在参数on里面指定列名。参数on必须是一个字符型的向量。\n注意参数on也可以用来指定主键。事实上，为了更佳的可读性，我们鼓励在参数on里面指定主键。\n\n#  设置二级索引的过程--方法2\nmtcars_dt &lt;- data.table(mtcars)\nmtcars_dt[,new:=Sys.Date()+1:32] #增加一列new，内容为时间\nmtcars_dt[.(6),on=\"cyl\"]#当为字符时，可以省略.()\nmtcars_dt[.(6,3),on=c(\"cyl\",\"gear\")]#同时满足cyl=6,gear=3的行\n主键与索引用来提取行，对参数i处理的一个变形，可以结合j，by参数进行处理"
  },
  {
    "objectID": "posts/md/datatable2.html#参数mult和nomatch",
    "href": "posts/md/datatable2.html#参数mult和nomatch",
    "title": "data.table – 2基本概念",
    "section": "",
    "text": "对于每次查询指定所有符合条件的行都被返回，若只返回第一行／最后一行设置为“first”或“last”。\n\n\n\n指定在没有找到符合条件的数据的情况下，是返回NA。设置 nomatch = 0L 跳过哪些不存在的数据\nlibrary(data.table)\nlibrary(magrittr)\niris_dt = data.table(iris) \niris_dt[.(5.1), on='Sepal.Length'] %&gt;% head(3)\niris_dt[.(100), on='Sepal.Length'] # 没有找到Sepal.Length==100 的行,则返回NA\niris_dt[.(100), on='Sepal.Length', nomatch = 0]"
  },
  {
    "objectID": "posts/md/datatable2.html#数据融合",
    "href": "posts/md/datatable2.html#数据融合",
    "title": "data.table – 2基本概念",
    "section": "",
    "text": "melt(data, id.vars, measure.vars, \n    variable.name = \"variable\", value.name = \"value\", \n    ..., na.rm = FALSE, variable.factor = TRUE, \n    value.factor = FALSE, \n    verbose = getOption(\"datatable.verbose\"))\n\n参数 measure.vars 指定了想要拆分（或合并）的列。我们也可以指定索引而不是列名。\n默认variable列是 factor类型的。如果你想返回一个字符型的向量，可以将参数 variable.factor 设为 FALSE。参数 variable.factor 是data.table的函数melt() 里独有的，增强包reshape2 里面没有这个参数。\nvariable.name = “variable”, value.name = “value”, 会把转化后的列被自动命名为 variable 和 value（默认值）。\n在结果里，函数melt() 保持了原来列的属性。\n\n\n\n\ndcast(data, formula, fun.aggregate = NULL, sep = \"_\", \n    ..., margins = NULL, subset = NULL, fill = NULL, \n    drop = TRUE, value.var = guess(data),\n    verbose = getOption(\"datatable.verbose\"))\n\n函数 dcast() 使用了操作符“~”，左边是作为 id.vars 的列，右边是作为 measure.vars 的列。\n参数 value.var 指定了需要被分拆扩张的列。\n函数 dcast() 也会在结果中尽量保持原来的属性\n可以给参数 fun.aggregate 传递一个函数。当操作符“~”不方便指定列名的时候，这个功能特别有用。"
  },
  {
    "objectID": "posts/md/datatable2.html#by的其他参数技巧",
    "href": "posts/md/datatable2.html#by的其他参数技巧",
    "title": "data.table – 2基本概念",
    "section": "",
    "text": "rleid —- 计算某向量的游程数（游程数：每次连续作为一组）（可以结合by参数使用）\n\nDT = data.table(grp=rep(c(\"A\", \"B\", \"C\", \"A\", \"B\"), c(2,2,3,1,2)), value=1:10)\nDT\nrleid(DT$grp) # 获取DT$grp的游程数，返回一个和原向量等长的向量\nrleidv(DT, \"grp\") # 与上面等价\n\nrleid(DT$grp, prefix=\"grp\") # 在游程数前面加\"grp\"\n\n# 也可以按游程数进行分组，并计算其游程数的个数等操作\nDT[, .N, by=.(rleid(grp))]\n\nrowid —–某个值在向量中出现的次数，出现第几次就显示为几\n\n\nDT = data.table(x=c(20,10,10,30,30,20), y=c(\"a\", \"a\", \"a\", \"b\", \"b\", \"b\"), z=1:6)\nDT\nrowid(DT$x) # 1,1,2,1,2,2\nrowidv(DT, cols=\"x\") # 和上面等价\n\nrowid(DT$x, prefix=\"group\") # 数字前面加\"group\"\n\n# 多列组合,看每一行的所有元素是否相同，相同则计数+1\nrowid(DT$x, DT$y)#等价rowidv(DT, cols=c(\"x\",\"y\")) \n\nDT[, .(N=seq_len(.N)), by=.(x,y)]$N # 上面相当于做了这样的事\n# 应用\ndcast(DT, x ~ rowid(x, prefix=\"group\"), value.var=\"z\") #\n\ntstrsplit —字符串拆分函数，类似strsplit函数,只不过结果和strsplit进行了转置\n\nname &lt;- 1:3\ndates &lt;- c(\"2016-3-4\",\"2016-3-14\",\"2016-3-24\")\nnd &lt;- data.table(name,dates)\nnd\nstrsplit(dates,\"-\")\ntstrsplit(dates,\"-\") \nnd[,c(\"year\",\"month\",\"day\"):=tstrsplit(dates,\"-\")] # 实现拆分\nnd"
  },
  {
    "objectID": "posts/md/datatable2.html#其他操作",
    "href": "posts/md/datatable2.html#其他操作",
    "title": "data.table – 2基本概念",
    "section": "",
    "text": "函数\n功能\n\n\n\n\n%between%\n快速查找某一区间：mtcars_dt[disp %between% c(150,200)]# 150&lt;= disp &lt;= 200之间DT[c %between% list(a,b)]#a列 &lt;= c &lt;=b 列之间(向量版本)\n\n\n%chin%\n快速匹配 （%in% 的加速版）： x %chin% table\n\n\n%inrange%\n快速查找某一区间： dft[V1 %inrange% c(50,60)] 即选择50 &lt;= V1 &lt;=60所有的行dft[V1 %inrange% list(V2,V3)] 即选择 V2 &lt;= V1 &lt;= V3的所有行\n\n\nA %like% B\n匹配字符串A中含有B的字符\n\n\n.I\n表示（分组后）每一行在原数据框中是第几行 dft[,.I[2],by=accept].I是一个整数向量，等于seq_len(nrow(x)), While grouping, it holds for each item in the group, its row location in x. This is useful to subset in j; e.g.DT[, .I[which.max(somecol)], by=grp]. 结合by,提取子集时,非常有用\n\n\n.N\n.N 代表行的数量，用by参数分组时则是每一组的行数量\n\n\n.SD\n是经过i 和by 处理之后剩下的那部分数据集,本质是一个data.table\n\n\n.SDcols\n.SDcols 指定.SD 代表的数据框包括哪些列\n\n\nsetDF(DT)\n将data.table转化为data.frame\n\n\nsetDT(df)\n将data.frame转化为data.table\n\n\nsetnames(DT,old,new)\n修改列名 也可以通过重新赋值操作 colnames(DT)\n\n\nfsort\n排序\n\n\nfrank\n求秩, 类似rank\n\n\nfintersect(x, y, all = FALSE)\nx与y的交集,相比于基础函数(默认为FALSE)， 增加了all参数，控制重复值\n\n\nfsetdiff(x, y, all = FALSE)\nx与y的差集，即x-y\n\n\nfunion(x, y, all = FALSE)\nx与y的并集\n\n\nfsetequal(x, y)\n检验x与y二者是否完全相等,返回逻辑值\n\n\nshift(x,n=1L,...)\n把向量x向前移动或者向后移动n个数字\n\n\n\n\n\n两者都是选择某列的值在一个范围内的所有行,即 \\(a \\leq c \\leq b\\)\nDT[c %between% list(a,b)] 这里的a,b 一定是DT自身的列名\nDT[c %inrange% list(a,b)] 这里的a,b 不是DT自身的列名,可以是外部的变量\n\n\n\nDT &lt;- data.table(A=1:5)\nDT[ , X := shift(A, 1, type=\"lag\")]\nDT[ , Y := shift(A, 1, type=\"lead\")]\nDT[ , Y1 := shift(A, 2, type=\"lead\")]\nDT\n\n\n\n由于data.table 没有行号,因此.I()一般不单独使用\nmtcars_dt &lt;- data.table(mtcars) \nmtcars_dt[, .I[cyl==6]] # 返回 cyl ==6 所在的行号\n## 等价于\nmtcars_dt[, which(cyl==6)]\n\n\n\n.SD代表行经过i 筛选后, 列除了by参数指定的列以外的所有列组成的新的data.table, 是原数据的子集\nlibrary(data.table)\nmtcars_dt = data.table::as.data.table(mtcars)\nmtcars_dt[, .SD, by=cyl]\noutput &lt;- mtcars_dt[, lapply(.SD[, 1:10, with=F], mean), by=cyl]\noutput"
  },
  {
    "objectID": "posts/md/datatable2.html#set-函数可以加快循环",
    "href": "posts/md/datatable2.html#set-函数可以加快循环",
    "title": "data.table – 2基本概念",
    "section": "",
    "text": "set(x, i = NULL, j, value)\n作用: 将value 值快速分配给i行j列元素, i , j 使用整数10L 而不是10, j参数不能省\nm = matrix(1,nrow=3,ncol=4)\nDT = as.data.table(m)    \nset(DT,3L,1L,10)# 第3行第1列元素改为10\nset(DT,,2L,20) # 第2列的所有元素都改为20\nDT\n\n\nm = matrix(1,nrow=100000,ncol=100)\nDF = as.data.frame(m)\nDT = as.data.table(m)  \nDT2 = copy(DT)\nsystem.time(for (i in 1:10000) DF[i,1] &lt;- i)\nsystem.time(for (i in 1:10000) DT[i,V1:=i])\nsystem.time(for (i in 1:10000) set(DT2,i,1L,i*10))"
  },
  {
    "objectID": "posts/md/datatable2.html#options设置",
    "href": "posts/md/datatable2.html#options设置",
    "title": "data.table – 2基本概念",
    "section": "",
    "text": "在控制台中输入options()会打印出一个list，这是当前的options设置值，比如显示保留几位小数等。加载data.table包之后，这里新增了一些data.table专用的参数，可以用下面的命令查看\nops &lt;- options() # ops就是一个list，参数和值的一一对应\n# 由于data.table专用参数都是以datatable为前缀，使用我们输入时可以这样\nops$datatable.print.nrows # 返回100，设置打印的最大行数，超过了则简单打印\ngetOption(\"datatable.print.topn\") #返回5，简单打印设置，前后各5行，其余行省略"
  },
  {
    "objectID": "posts/uncertain/2019-02-26-1-6基于信息熵的多属性决策方法.html#徐泽水不确定多属性决策方法与应用26页",
    "href": "posts/uncertain/2019-02-26-1-6基于信息熵的多属性决策方法.html#徐泽水不确定多属性决策方法与应用26页",
    "title": "1.6 基于信息熵的多属性决策方法",
    "section": "",
    "text": "代码##  1.6 基于信息熵的多属性决策方法---徐泽水《不确定多属性决策方法与应用》26页 --1.62 实例分析\n\nlibrary(data.table)\nlibrary(dplyr)\nA = c(2,1.5,2,5.5,5,9,\n      2.5,2.7,1.8,6.5,3,5,\n      1.8,2,2.1,4.5,7,7,\n      2.2,1.8,2,5,5,5)\nA= matrix(A,nrow = 4,ncol = 6,byrow = T) %&gt;% data.table()\nA # 原始决策矩阵\n#&gt;     V1  V2  V3  V4 V5 V6\n#&gt; 1: 2.0 1.5 2.0 5.5  5  9\n#&gt; 2: 2.5 2.7 1.8 6.5  3  5\n#&gt; 3: 1.8 2.0 2.1 4.5  7  7\n#&gt; 4: 2.2 1.8 2.0 5.0  5  5\n\n\n\n代码#######################################################\n##### 第一步把原始决策矩阵A 利用适当的方法进行规范化为R，R为归一化后的矩阵\n##########################################################\n### norm_matrix()函数，根据书中收益型属性（按公式1.2）与成本型属性(按公式1.4)分别进行归一化\n# 参数A表示决策矩阵,shouyi参数代表收益型属性，输入收益型属性在决策矩阵中第几列，若有多列，用数值型向量即可，\n# chengben参数代表成本型属性，与收益型属性类型。\n# 该参数可任选其一输入，也可同时指定。\nnorm_matrix = function(A,shouyi=NULL,chengben=NULL){\n  if(is.matrix(A))A = data.table(A)\n  stopifnot(!is.null(shouyi) | !is.null(chengben))\n  m = ncol(A)\n  if(is.null(chengben)) chengben =setdiff(1:m,shouyi) \n  if(is.null(shouyi)) shouyi = setdiff(1:m,chengben)\n  stopifnot(length(intersect(shouyi,chengben))==0,setequal(union(shouyi,chengben),1:m))\n  #对决策矩阵进行重命名\n  names(A)=paste0('V',1:m)\n  shouyi = paste0(\"V\",shouyi)\n  chengben = paste0(\"V\",chengben)\n  R = A\n  R[,':='(c(shouyi),lapply(.SD, function(x)x/max(x))),.SDcols =shouyi] # 收益型属性归一化 （书中1.2式）\n  R[,':='(c(chengben),lapply(.SD,function(x)min(x)/x)),.SDcol = chengben]# 成本型属性归一化 （书中1.3式）\n  R = as.data.frame(R)\n  return(R)\n}\n\nR = norm_matrix(A,chengben = 4)\nround(R,3)\n#&gt;     V1    V2    V3    V4    V5    V6\n#&gt; 1 0.80 0.556 0.952 0.818 0.714 1.000\n#&gt; 2 1.00 1.000 0.857 0.692 0.429 0.556\n#&gt; 3 0.72 0.741 1.000 1.000 1.000 0.778\n#&gt; 4 0.88 0.667 0.952 0.900 0.714 0.556\n\n\n\n代码#########################################################\n##### 第二步 计算矩阵R，得到列归一化矩阵R'\n#################################################\nR_t = sapply(R, function(x)x/sum(x))\nround(R_t,3)\n#&gt;         V1    V2    V3    V4   V5    V6\n#&gt; [1,] 0.235 0.188 0.253 0.240 0.25 0.346\n#&gt; [2,] 0.294 0.338 0.228 0.203 0.15 0.192\n#&gt; [3,] 0.212 0.250 0.266 0.293 0.35 0.269\n#&gt; [4,] 0.259 0.225 0.253 0.264 0.25 0.192\n#########################################################\n##### 第三步 根据R_t计算属性u_j的信息熵\n#################################################\nentropy = function(R_t){\n  if(!is.data.frame(R_t)) R_t = as.data.frame(R_t)\n  n = nrow(R_t)\n  E = sapply(R_t, function(x) (-1/log(n)) * sum( ifelse(x == 0 , 0 , x*log(x) ) ) )\n  return(E)\n}\nE = entropy(R_t)\nE\n#&gt;        V1        V2        V3        V4        V5        V6 \n#&gt; 0.9946889 0.9829482 0.9988876 0.9936177 0.9703227 0.9771412\n#########################################################\n##### 第四步 根据信息熵计算权重向量\n#################################################\nw = (1-E)/sum(1-E)\nround(w,3)\n#&gt;    V1    V2    V3    V4    V5    V6 \n#&gt; 0.064 0.207 0.014 0.077 0.360 0.277\n#########################################################\n##### 第五步 根据权重向量按照1.12式计算每一个方案的综合属性值Z\n#################################################\nz = t(as.matrix(R) %*% as.matrix(w,ncol=1)) %&gt;% as.data.frame() # 计算综合属性值\nround(z,4)\n#&gt;       V1     V2     V3     V4\n#&gt; 1 0.7775 0.6451 0.8666 0.6887\n#########################################################\n##### 第六步 根据综合属性值Z对方案进行排序\n#################################################\n#rank(z) #输出排序\nsort(rank(z),decreasing = T)\n#&gt; V3 V1 V4 V2 \n#&gt;  4  3  2  1"
  },
  {
    "objectID": "posts/uncertain/2019-02-26-1-7方案有偏好信息的多属性决策方法.html#徐泽水不确定多属性决策方法与应用2737页",
    "href": "posts/uncertain/2019-02-26-1-7方案有偏好信息的多属性决策方法.html#徐泽水不确定多属性决策方法与应用2737页",
    "title": "1.7方案有偏好信息的多属性决策方法",
    "section": "",
    "text": "代码## 1 对方案的偏好信息为互反判断矩阵的情形\nlibrary(data.table)\nlibrary(dplyr)\nA = c(3.0,100,10,7,\n      2.5,80,8,5,\n      1.8,50,20,11,\n      2.2,70,12,9)\nA= matrix(A,nrow = 4,ncol = 4,byrow = T) %&gt;% data.table()\nA # 原始决策矩阵\n#&gt;     V1  V2 V3 V4\n#&gt; 1: 3.0 100 10  7\n#&gt; 2: 2.5  80  8  5\n#&gt; 3: 1.8  50 20 11\n#&gt; 4: 2.2  70 12  9\n\n#######################################################\n##### 第一步把原始决策矩阵A 利用适当的方法进行规范化为R，R为归一化后的矩阵\n##########################################################\n### norm_matrix()函数，根据书中收益型属性（按公式1.2）与成本型属性(按公式1.4)分别进行归一化\n# 参数A表示决策矩阵,shouyi参数代表收益型属性，输入收益型属性在决策矩阵中第几列，若有多列，用数值型向量即可，\n# chengben参数代表成本型属性，与收益型属性类型。\n# 该参数可任选其一输入，也可同时指定。\nnorm_matrix = function(A,shouyi=NULL,chengben=NULL){\n  if(is.matrix(A))A = data.table(A)\n  stopifnot(!is.null(shouyi) | !is.null(chengben))\n  m = ncol(A)\n  if(is.null(chengben)) chengben =setdiff(1:m,shouyi) \n  if(is.null(shouyi)) shouyi = setdiff(1:m,chengben)\n  stopifnot(length(intersect(shouyi,chengben))==0,setequal(union(shouyi,chengben),1:m))\n  #对决策矩阵进行重命名\n  names(A)=paste0('V',1:m)\n  shouyi = paste0(\"V\",shouyi)\n  chengben = paste0(\"V\",chengben)\n  R = A\n  R[,':='(c(shouyi),lapply(.SD, function(x)x/max(x))),.SDcols =shouyi] # 收益型属性归一化 （书中1.2式）\n  R[,':='(c(chengben),lapply(.SD,function(x)min(x)/x)),.SDcol = chengben]# 成本型属性归一化 （书中1.3式）\n  R = as.data.frame(R)\n  return(R)\n}\n\nR = norm_matrix(A,chengben = c(1,3))\nround(R,3)\n#&gt;      V1  V2    V3    V4\n#&gt; 1 0.600 1.0 0.800 0.636\n#&gt; 2 0.720 0.8 1.000 0.455\n#&gt; 3 1.000 0.5 0.400 1.000\n#&gt; 4 0.818 0.7 0.667 0.818\n#########################################################\n##### 第二步 根据决策方案(即决策矩阵的行)进行成对比较，构造出判断矩阵\n#################################################\n# 假设如下判断矩阵\nH = c(1,2,1/4,1/5,\n      1/2,1,1/2,1/3,\n      4,2,1,1/2,\n      5,3,2,1)\nH = matrix(H, nrow = 4, ncol = 4, byrow = T)\nH\n#&gt;      [,1] [,2] [,3]      [,4]\n#&gt; [1,]  1.0    2 0.25 0.2000000\n#&gt; [2,]  0.5    1 0.50 0.3333333\n#&gt; [3,]  4.0    2 1.00 0.5000000\n#&gt; [4,]  5.0    3 2.00 1.0000000\nQ = matrix(0,nrow = 4,ncol = 4)\nfor(k in 1:4) {\n  for (l in 1:4) {\n    for (i in 1:4) {\n      for (j in 1:4) {\n        Q[k, l] = Q[k, l] + (H[i, j] * R[i, k] - R[i, k]) * ((H[i, j] * R[i, l] - R[i, l]))\n      }\n    }\n  }\n}\nQ\n#&gt;          [,1]     [,2]     [,3]     [,4]\n#&gt; [1,] 25.59035 19.01777 17.29175 25.45790\n#&gt; [2,] 19.01777 15.65944 14.36756 18.89730\n#&gt; [3,] 17.29175 14.36756 13.32738 17.10511\n#&gt; [4,] 25.45790 18.89730 17.10511 25.39491\ne_m = matrix(rep(1,4),nrow = 1)\nt(e_m)\n#&gt;      [,1]\n#&gt; [1,]    1\n#&gt; [2,]    1\n#&gt; [3,]    1\n#&gt; [4,]    1\n\n\n\n代码\n(solve(Q) %*% t(e_m) )/as.vector(e_m %*% solve(Q) %*% t(e_m))\n#&gt;           [,1]\n#&gt; [1,] -8.823475\n#&gt; [2,] -6.429099\n#&gt; [3,]  7.436625\n#&gt; [4,]  8.815949\n(solve(Q) %*% t(e_m) ) /0.2014189\n#&gt;           [,1]\n#&gt; [1,] -8.823476\n#&gt; [2,] -6.429100\n#&gt; [3,]  7.436626\n#&gt; [4,]  8.815950\n\n\n\n（待完善）\n\n（待完善）"
  }
]