<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.147">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="zsc">

<title>快乐的一天 - data.table – 1基本函数</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "没有结果",
    "search-matching-documents-text": "匹配的文档",
    "search-copy-link-title": "复制搜索链接",
    "search-hide-matches-text": "隐藏其它匹配结果",
    "search-more-match-text": "更多匹配结果",
    "search-more-matches-text": "更多匹配结果",
    "search-clear-button-title": "清除",
    "search-detached-cancel-button-title": "取消",
    "search-submit-button-title": "提交"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>


<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="快乐的一天 - data.table – 1基本函数">
<meta property="og:description" content="data.table本质上是一个list，它们的列包含的元素个数都相同。">
<meta property="og:site-name" content="快乐的一天">
</head>

<body class="nav-sidebar docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">快乐的一天</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../mac.html">mac</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../matlab.html">matlab</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../uncertain.html">uncertain</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html">About</a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/zoushucai/myblog"><i class="bi bi-github" role="img">
</i> 
 </a>
  </li>  
</ul>
              <div class="quarto-toggle-container">
                  <a href="" class="quarto-color-scheme-toggle nav-link" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
              </div>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title">data.table – 1基本函数</h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title d-none d-lg-block">data.table – 1基本函数</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i></button></div></div>
                                <div class="quarto-categories">
                <div class="quarto-category">r</div>
                <div class="quarto-category">data.table</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">作者</div>
      <div class="quarto-title-meta-contents">
               <p>zsc </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">发布日期</div>
      <div class="quarto-title-meta-contents">
        <p class="date">2018年1月16日</p>
      </div>
    </div>
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation docked overflow-auto">
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">该页面内容</h2>
   
  <ul>
  <li><a href="#数据的读写" id="toc-数据的读写" class="nav-link active" data-scroll-target="#数据的读写">1、数据的读写</a>
  <ul class="collapse">
  <li><a href="#数据读入fread" id="toc-数据读入fread" class="nav-link" data-scroll-target="#数据读入fread">1.1数据读入－－fread</a></li>
  <li><a href="#数据写入fwrite" id="toc-数据写入fwrite" class="nav-link" data-scroll-target="#数据写入fwrite">1.2数据写入－－fwrite</a></li>
  <li><a href="#数据框转为data.table" id="toc-数据框转为data.table" class="nav-link" data-scroll-target="#数据框转为data.table">1.3 数据框转为data.table</a></li>
  </ul></li>
  <li><a href="#数据行列筛选-i-参数" id="toc-数据行列筛选-i-参数" class="nav-link" data-scroll-target="#数据行列筛选-i-参数">2. 数据行列筛选 — i 参数</a>
  <ul class="collapse">
  <li><a href="#直接采用逻辑语句慢" id="toc-直接采用逻辑语句慢" class="nav-link" data-scroll-target="#直接采用逻辑语句慢">2.1 直接采用逻辑语句（慢）</a></li>
  <li><a href="#设置获取使用主键适中" id="toc-设置获取使用主键适中" class="nav-link" data-scroll-target="#设置获取使用主键适中">2.2 设置/获取/使用主键(适中)</a></li>
  <li><a href="#二级索引indices快" id="toc-二级索引indices快" class="nav-link" data-scroll-target="#二级索引indices快">2.3 二级索引<code>(indices)</code>（快）</a></li>
  <li><a href="#二级索引的快速使用-参数on" id="toc-二级索引的快速使用-参数on" class="nav-link" data-scroll-target="#二级索引的快速使用-参数on">2.4 二级索引的快速使用 — 参数on</a></li>
  <li><a href="#自动索引-只支持操作符-和-in" id="toc-自动索引-只支持操作符-和-in" class="nav-link" data-scroll-target="#自动索引-只支持操作符-和-in">2.5 自动索引 — 只支持操作符 == 和 %in%</a></li>
  </ul></li>
  <li><a href="#列筛选-j参数" id="toc-列筛选-j参数" class="nav-link" data-scroll-target="#列筛选-j参数">3 列筛选：– j参数</a>
  <ul class="collapse">
  <li><a href="#格式-等价list" id="toc-格式-等价list" class="nav-link" data-scroll-target="#格式-等价list">3.1 <code>.()</code>格式 == 等价list()</a></li>
  <li><a href="#在j参数上可以进行计算" id="toc-在j参数上可以进行计算" class="nav-link" data-scroll-target="#在j参数上可以进行计算">3.2 在j参数上可以进行计算：</a></li>
  <li><a href="#选取子集" id="toc-选取子集" class="nav-link" data-scroll-target="#选取子集">3.3 选取子集</a></li>
  <li><a href="#对列进行排序" id="toc-对列进行排序" class="nav-link" data-scroll-target="#对列进行排序">3.4 对列进行排序</a></li>
  <li><a href="#对列进行增删变量" id="toc-对列进行增删变量" class="nav-link" data-scroll-target="#对列进行增删变量">3.5 对列进行增删变量</a>
  <ul class="collapse">
  <li><a href="#添加变量有三种语法格式" id="toc-添加变量有三种语法格式" class="nav-link" data-scroll-target="#添加变量有三种语法格式">3.5.1 添加变量有三种语法格式：</a></li>
  <li><a href="#删除变量-变量null" id="toc-删除变量-变量null" class="nav-link" data-scroll-target="#删除变量-变量null">3.5.2 删除变量 — <code>变量:=NULL</code></a></li>
  </ul></li>
  </ul></li>
  <li><a href="#分组汇总by参数" id="toc-分组汇总by参数" class="nav-link" data-scroll-target="#分组汇总by参数">4. 分组汇总－－by参数</a>
  <ul class="collapse">
  <li><a href="#分组汇总只需在by指定分组变量在j指定计算函数即可" id="toc-分组汇总只需在by指定分组变量在j指定计算函数即可" class="nav-link" data-scroll-target="#分组汇总只需在by指定分组变量在j指定计算函数即可">4.1 分组汇总只需在<code>by</code>指定分组变量，在<code>j</code>指定计算函数即可</a></li>
  <li><a href="#data.table有一个特殊的变量.n可以直接计算分组的观测值个数" id="toc-data.table有一个特殊的变量.n可以直接计算分组的观测值个数" class="nav-link" data-scroll-target="#data.table有一个特殊的变量.n可以直接计算分组的观测值个数">4.2 data.table有一个<strong>特殊的变量<code>.N</code></strong>可以直接计算分组的观测值个数。</a></li>
  <li><a href="#by参数还有接受表达式" id="toc-by参数还有接受表达式" class="nav-link" data-scroll-target="#by参数还有接受表达式">4.3 by参数还有接受表达式：</a></li>
  <li><a href="#sd-和.sdcol-关键词" id="toc-sd-和.sdcol-关键词" class="nav-link" data-scroll-target="#sd-和.sdcol-关键词">4.4 <code>.SD</code> 和<code>.SDcol</code> 关键词</a></li>
  <li><a href="#如果要对子集进行分组统计怎么办即对选出的i进行分组统计." id="toc-如果要对子集进行分组统计怎么办即对选出的i进行分组统计." class="nav-link" data-scroll-target="#如果要对子集进行分组统计怎么办即对选出的i进行分组统计.">4.5 如果要对子集进行分组统计怎么办？，即对选出的i进行分组统计.</a></li>
  </ul></li>
  <li><a href="#分组汇总的同时排序-keyby" id="toc-分组汇总的同时排序-keyby" class="nav-link" data-scroll-target="#分组汇总的同时排序-keyby">5分组汇总的同时排序 —— keyby</a></li>
  <li><a href="#chaining表达式" id="toc-chaining表达式" class="nav-link" data-scroll-target="#chaining表达式">6. chaining表达式</a></li>
  <li><a href="#总结" id="toc-总结" class="nav-link" data-scroll-target="#总结">7总结</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>data.table本质上是一个list，它们的列包含的元素个数都相同。</p>
<section id="数据的读写" class="level1">
<h1>1、数据的读写</h1>
<section id="数据读入fread" class="level3">
<h3 class="anchored" data-anchor-id="数据读入fread">1.1数据读入－－fread</h3>
<p>选其常用的参数如下：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fread</span>(input,<span class="at">na.strings=</span><span class="st">"NA"</span>, file, <span class="at">stringsAsFactors=</span><span class="cn">FALSE</span>,<span class="at">encoding=</span><span class="st">"unknown"</span>, ...)</span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>input 入的文件对象，<code>fread</code>函数可以自动判断分隔符类型，自动判断首行是否是列标题，同时默认读入时字符型变量不会变为因子型。也可也从网页读取数据</li>
<li>na.strings,对NA的解释；</li>
<li>file文件路径，再确保没有执行shell命令时很有用，也可以在input参数输入;</li>
<li>stringsASFactors是否转化字符串为因子，</li>
<li>encoding，默认”unknown”，其它可能”UTF-8”或者”Latin-1”，不是用来重新编码的，而是允许处理的字符串在本机编码;</li>
<li>showProgress = T 显示进度条</li>
<li>integer64 当数据列中有大于2 ^ 31的整数,可能会丢失精度</li>
<li>quote 对带双引号的字符添加转义,在R中正常显示,但是输出时,可能会引起成倍的双引号,因此建议使用<code>fwrite</code>时,设置该参数<code>quote = FALSE</code></li>
</ul>
</section>
<section id="数据写入fwrite" class="level3">
<h3 class="anchored" data-anchor-id="数据写入fwrite">1.2数据写入－－fwrite</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fwrite</span>(x, <span class="at">file =</span> <span class="st">""</span>, <span class="at">append =</span> <span class="cn">FALSE</span>, <span class="at">na =</span> <span class="st">""</span>, <span class="at">row.names =</span> <span class="cn">FALSE</span>, <span class="at">col.names =</span> <span class="cn">TRUE</span>,<span class="at">logicalAsInt =</span> <span class="cn">FALSE</span>, ...)</span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>x,比如data.frame和data.table等R的对象；</li>
<li>file，输出文件名,““意味着直接输出到操作台；</li>
<li>append，如果TRUE,在原文件的后面添加；默认删除原来文件的数据，重新存储。</li>
<li>na,na值的表示，默认”“；</li>
<li>row.names，是否写出行名，因为data.table没有行名，所以默认FALSE；</li>
<li>col.names ，是否写出列名，默认TRUE，如果没有定义，并且append=TRUE和文件存在，那么就会默认使用FALSE;</li>
<li>logicalAsInt,逻辑值作为数字写出还是作为FALSE和TRUE写出；</li>
</ul>
</section>
<section id="数据框转为data.table" class="level2">
<h2 class="anchored" data-anchor-id="数据框转为data.table">1.3 数据框转为data.table</h2>
<p>对于数据的处理，<code>data.table</code>包提供了一个非常简洁的通用格式：<code>DT[i,j,by]</code>，</p>
<ul>
<li>其中<code>i</code>控制列, <code>j</code>控制列, <code>by</code>控制分组. 上述表达式的意思是: 对于数据集<code>DT</code>，先选取子集行<code>i</code>, 然后通过<code>by</code>分组计算<code>j</code>。<code>i</code>设定数据的选取条件，<code>j</code>设定结果的计算方式，<code>by</code>设定数据的分组情况。通过这个，我们可以在一行代码中很方便地完成处理过程。首先需要把数据变为data.table类型</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(data.table)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(magrittr)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="do">### 方法一: 赋值转换</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>mtcars_dt <span class="ot">&lt;-</span> <span class="fu">data.table</span>(mtcars) <span class="co"># 也可以强制转化 as.data.table()</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="do">### 方法二: 引用转换</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="fu">setDT</span>(mtcars)  <span class="co"># 不需要赋值,这是引用转换, mtcars这个数据集已经变成了data.table 数据类型了</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="数据行列筛选-i-参数" class="level1">
<h1>2. 数据行列筛选 — i 参数</h1>
<p><strong>行筛选：–i参数</strong></p>
<ul>
<li>直接采用逻辑语句（慢）</li>
<li>使用主键(会对筛选的数据进行重排序–适中)</li>
<li>二级索引（不重排序，按原数据的顺序排序–快）</li>
</ul>
<section id="直接采用逻辑语句慢" class="level2">
<h2 class="anchored" data-anchor-id="直接采用逻辑语句慢">2.1 直接采用逻辑语句（慢）</h2>
<div class="sourceCode" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>mtcars_dt <span class="ot">&lt;-</span> <span class="fu">data.table</span>(mtcars) <span class="co"># 一共32行,11列</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">#直接采用逻辑语句（慢）</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>mtcars_dt[cyl<span class="sc">==</span><span class="dv">8</span> ]</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>mtcars_dt[cyl<span class="sc">==</span><span class="dv">8</span> <span class="sc">&amp;</span> carb<span class="sc">==</span><span class="dv">4</span>]</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>mtcars_dt[cyl <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"8"</span>,<span class="st">"6"</span>)]<span class="co"># 等价 mtcars_dt[cyl %in% c(8,6)]</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="设置获取使用主键适中" class="level2">
<h2 class="anchored" data-anchor-id="设置获取使用主键适中">2.2 设置/获取/使用主键(适中)</h2>
<table class="table">
<colgroup>
<col style="width: 33%">
<col style="width: 66%">
</colgroup>
<thead>
<tr class="header">
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>setkey(x,V1)</code></td>
<td>该函数可以对一个data.table按照某一列进行排序,排序之后,这个data.table 对象会被标记为排过序了, 由于不会在内存中复制被排序的data.table对象,所以非常高效.</td>
</tr>
<tr class="even">
<td><code>setkey(x,V1,V2,V3, ...)</code></td>
<td>等价于<code>setkeyv(x,c("V1","V2",...) )</code></td>
</tr>
<tr class="odd">
<td><code>setkeyv(x,c("V1","V2",...) )</code></td>
<td>可以按照多列一起排序.先根据V1排序,然后根据V2排序, 以此类推.</td>
</tr>
<tr class="even">
<td><code>table()</code></td>
<td>查看内存中所有data.table 的详细信息,包括key键,</td>
</tr>
</tbody>
</table>
<ul>
<li><p><strong><code>setkey(x,V1)</code>传入列名作为参数，不需要引号, 而<code>setkeyv(x,c("V1","V2",...) )</code> 传入一个字符型的向量, 这两个函数都没有返回值, 直接对data.table进行更新操作,和<code>:=</code>类似</strong></p></li>
<li><p><strong>每一个table.table中只有一组key键, 像普通的data.frame, 每一行有且只有一个行名且行名具有唯一性, 行名可以看做是data.frame的索引. 而data.table可以利用主键进行索引, 且可以对多列设置主键,且主键不强调唯一性. 也就是说，不同列的主键可以是一样的。既然行可以通过主键排序，那么排序的时候，具有同样主键的一些行，会被排在一起。</strong></p></li>
<li><p><strong>在data.table里，操作符”:=“和所有的以set开头函数（比如setkey,setorder,setname等）一样，它们都会更新输入的原数据。</strong></p></li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">#使用主键(会对筛选的数据进行重排序--适中)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>mtcars_dt <span class="ot">&lt;-</span> <span class="fu">data.table</span>(mtcars) </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="fu">setkey</span>(mtcars_dt,cyl,carb)<span class="co"># 设置key键</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>mtcars_dt <span class="co">#可以看出已经排序了</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="fu">tables</span>()              <span class="co"># 查看内存中所有data.table 的详细信息,包括key键</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>iris_dt <span class="ot">=</span> <span class="fu">data.table</span>(iris)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="fu">tables</span>()              <span class="co"># </span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="fu">setkeyv</span>(mtcars_dt,<span class="fu">c</span>(<span class="st">"cyl"</span>,<span class="st">"carb"</span>))<span class="co">#先设置的cyl,carb列为主键</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>mtcars_dt[.(<span class="dv">8</span>,<span class="dv">4</span>)]     <span class="co"># 等价 mtcars_dt[cyl==8 &amp; carb==4]</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="fu">tables</span>()              <span class="co"># 查看内存中所有data.table 的详细信息</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="二级索引indices快" class="level2">
<h2 class="anchored" data-anchor-id="二级索引indices快">2.3 二级索引<code>(indices)</code>（快）</h2>
<section id="a-什么是二级索引-二级索引和主键有什么区别" class="level4">
<h4 class="anchored" data-anchor-id="a-什么是二级索引-二级索引和主键有什么区别">a) <strong>什么是二级索引? 二级索引和主键有什么区别?</strong></h4>
<ul>
<li>前面介绍了<code>setkey</code> 和<code>setkeyv</code>的使用,每一次使用<code>setkey</code>, data.table 对象都会在内存里被重新排序, 时间复杂度是<code>O(nlogn)</code>. 而 <code>setindex</code> 和<code>setindexv</code> 则不会对data.table对象进行重新排序, 它只会计算某列的顺序，将这个顺序向量保存在一个额外的，叫做index的属性里面。 此外,一个data.table对象只能有一组key, 但是可以有多个二级索引(indices). 二级索引的时间复杂度是<code>O(logn)</code></li>
</ul>
<table class="table">
<colgroup>
<col style="width: 34%">
<col style="width: 65%">
</colgroup>
<thead>
<tr class="header">
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>setindex(x,V1)</code></td>
<td>设置索引—即将V1列设置为该data.table的二级索引 <br> 等价<code>setindexv(x,c("V1"))</code></td>
</tr>
<tr class="even">
<td><code>setindex(x,V1,V2,...)</code></td>
<td>设置多列索引—即将V1,V2列设置为该data.table的二级索引<br> 等价<code>setindexv(x,c("V1","V2",...))</code></td>
</tr>
<tr class="odd">
<td><code>setindexv(x,c("V1","V2",...))</code></td>
<td>以字符的方式设置索引</td>
</tr>
<tr class="even">
<td><code>setindex(x, NULL)</code></td>
<td>删除所有的二级索引。</td>
</tr>
<tr class="odd">
<td><code>indices(x)</code></td>
<td>获取data.table对象的所有二级索引, 如果该data.table没有二级索引，那么返回NULL。</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 设置和获取二级索引</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>mtcars_dt <span class="ot">&lt;-</span> <span class="fu">data.table</span>(mtcars) </span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="fu">setindex</span>(mtcars_dt,cyl,carb) <span class="co"># 等价于 setindexv(mtcars_dt,c("cyl","carb"))</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(<span class="fu">attributes</span>(mtcars_dt)) <span class="co"># 查询data.table 的属性</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="fu">indices</span>(mtcars_dt)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>mtcars_dt <span class="co">#  注意并没有对数据进行重新排序, 而setkey会对数据进行重新排序</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="fu">setindexv</span>(mtcars_dt,<span class="fu">c</span>(<span class="st">"vs"</span>, <span class="st">"am"</span>, <span class="st">"gear"</span>,<span class="st">"carb"</span>))</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="fu">indices</span>(mtcars_dt)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="b为什么使用二级索引" class="level4">
<h4 class="anchored" data-anchor-id="b为什么使用二级索引">b)为什么使用二级索引</h4>
<p>原因是对一个data.table重新排序成本太高, 除非你要进行大量选子集的操作,建议使用setkey 来提取子集. 我们想快速地提取子集(subset)同时又不必重新排序,此时二级索引就派上用处了.</p>
</section>
</section>
<section id="二级索引的快速使用-参数on" class="level2">
<h2 class="anchored" data-anchor-id="二级索引的快速使用-参数on">2.4 二级索引的快速使用 — 参数on</h2>
<p>上面我们都在讲先设置二级索引,然后在进行操作,这样能不能合成一步?—-于是参数<code>on</code>诞生了, 参数<code>on</code>使得语法更简洁，并且能自动创建并重用二级索引</p>
<p><strong>参数on</strong></p>
<ul>
<li>通过创建索引进行subset。每次都能节省setindex()的时间。</li>
<li>通过检查属性，可以简单地重用已经存在的二级索引。</li>
<li>参数on必须是一个字符型的向量。</li>
<li>注意参数on也可以用来指定主键。事实上，为了更佳的可读性，我们鼓励在参数on里面指定主键。</li>
<li>参数<code>on</code>它不会把这个二级索引自动创建为data.table的一个属性。需要额外设置参数才可以(设<code>verbose = TRUE</code>).</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>mtcars_dt[.(<span class="dv">1</span>),on<span class="ot">=</span><span class="st">"am"</span>]<span class="co">#同时满足cyl=8,gear=4的行</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="do">## 等价的备选方案 -- mtcars_dt[list(1), on = "am"]</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="do">## 注意 on="am"表明我们要基于am这一列进行过滤,过滤的条件是am == 1, 1必须放置.()里面</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="do">## 原因是 am是numeric类型,如果不是numeric类型,就不用这样做</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>iris_dt <span class="ot">=</span> <span class="fu">data.table</span>(iris)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>iris_dt[<span class="st">"setosa"</span>,on<span class="ot">=</span><span class="st">"Species"</span>]  </span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co">#等价的备选方案</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>iris_dt[.(<span class="st">"setosa"</span>),on<span class="ot">=</span><span class="st">"Species"</span>] </span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>iris_dt[<span class="fu">list</span>(<span class="st">"setosa"</span>),on<span class="ot">=</span><span class="st">"Species"</span>] </span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 选择 Species =setosa 或者 Species =virginica</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>iris_dt[.(<span class="fu">c</span>(<span class="st">"setosa"</span>,<span class="st">"virginica"</span>)) ,on<span class="ot">=</span><span class="st">"Species"</span>] </span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>iris_dt[.(<span class="fu">c</span>(<span class="st">"setosa"</span>,<span class="st">"virginica"</span>),<span class="fu">c</span>(<span class="fl">3.0</span>)) ,on<span class="ot">=</span><span class="fu">c</span>(<span class="st">"Species"</span>,<span class="st">"Sepal.Width"</span>)] </span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="co"># 注意小心有NA行,原因在于Petal.Length列没有等于5.1的值</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>iris_dt[.(<span class="fu">c</span>(<span class="st">"setosa"</span>,<span class="st">"virginica"</span>),<span class="fu">c</span>(<span class="fl">5.1</span>)) ,on<span class="ot">=</span><span class="fu">c</span>(<span class="st">"Species"</span>,<span class="st">"Petal.Length"</span>)] </span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="do">#### on参数也可以像j那样直接使用列名 ,无需加引号</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>mtcars_dt[.(<span class="dv">8</span>,<span class="dv">4</span>),on<span class="ot">=</span><span class="fu">c</span>(<span class="st">"cyl"</span>,<span class="st">"carb"</span>)]<span class="co">#同时满足cyl=8,gear=4的行</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>mtcars_dt[.(<span class="dv">8</span>,<span class="dv">4</span>),on<span class="ot">=</span>.(cyl,carb)]<span class="co"># 等价同上,</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="自动索引-只支持操作符-和-in" class="level2">
<h2 class="anchored" data-anchor-id="自动索引-只支持操作符-和-in">2.5 自动索引 — 只支持操作符 == 和 %in%</h2>
<p>回顾一下，我们先学习如何通过主键使用快速二分法搜索进行subset。接着，我们学习了使用二级索引，它带来更好的效果，而且语法也更简洁。</p>
<p>等等，有没有更好的方法？</p>
<p>有！优化R的原生语法，使用内置的索引。这样我们毋需使用新的语法，就能得到同样的效果。这就是自动索引。 目前，<strong>它只支持操作符 == 和 %in% 。而且只对一列起作用</strong>。某一列会被自动创建为索引，并且作为data.table的属性保存起来。这跟参数on不同，参数on会每次创建一个临时索引，所以才会被叫做“二级索引”。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>iris_dt[Petal.Length <span class="sc">==</span> <span class="fl">5.1</span>, ] </span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>iris_dt[Petal.Length <span class="sc">%in%</span> <span class="fu">c</span>(<span class="fl">5.1</span>,<span class="fl">5.2</span>), ] </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>注意, 以上都是针对<code>i</code>参数设置,因此可以同<code>j</code>参数, <code>by</code>参数同时使用</strong></p>
<p><strong>还有, 在进行行筛选时,尽量打个逗号,区分<code>i</code>和<code>j</code></strong></p>
</section>
</section>
<section id="列筛选-j参数" class="level1">
<h1>3 列筛选：– j参数</h1>
<section id="格式-等价list" class="level2">
<h2 class="anchored" data-anchor-id="格式-等价list">3.1 <code>.()</code>格式 == 等价list()</h2>
<p><strong>用<code>.()</code>来包围列名，和<code>list()</code> 等价</strong></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 列筛选 --方法一, 直接输入列名</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, .(mpg, cyl, hp)] <span class="sc">%&gt;%</span> <span class="fu">head</span>()</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, <span class="fu">c</span>(<span class="st">"mpg"</span>, <span class="st">"cyl"</span>, <span class="st">"hp"</span>)]<span class="co"># 返回的都是data.table</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, <span class="fu">c</span>(<span class="st">"mpg"</span>, <span class="st">"cyl"</span>, <span class="st">"hp"</span>), with <span class="ot">=</span>F]</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 列筛选 --方法二 如果没用list()或者.()包围列名 ，则返回的是向量（这不是我们想要的结果），如下</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, <span class="fu">c</span>(mpg, cyl, hp)] <span class="sc">%&gt;%</span> <span class="fu">head</span>()</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 列筛选 --方法三, 可以把列名改写成对应的数字列,但返回的是data.table类型</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>)] <span class="sc">%&gt;%</span> <span class="fu">head</span>()</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>)] <span class="sc">%&gt;%</span> <span class="fu">class</span>()</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="co"># 列筛选-- 方法四, 如果列名已经存储到一个变量里面了, 怎么根据它来选择列</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(data.table)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>mtcars_dt <span class="ot">=</span> <span class="fu">as.data.table</span>(mtcars)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>)</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"mpg"</span>, <span class="st">"cyl"</span>, <span class="st">"hp"</span>)</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>mtcars_dt[,..a] <span class="co"># 在变量名前加两个点,  如果这样输入: mtcars_dt[,a], 则报错</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>mtcars_dt[,..b]<span class="co"># 在变量名前加两个点,  如果这样输入: mtcars_dt[,b], 则报错</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="co"># 列筛选 --方法五, 要排除列名怎么办，可以用数字</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, <span class="sc">-</span><span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>)] <span class="sc">%&gt;%</span> <span class="fu">head</span>() <span class="co"># 等价</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, <span class="fu">c</span>(<span class="st">"mpg"</span>, <span class="st">"cyl"</span>, <span class="st">"hp"</span>) <span class="sc">:</span><span class="er">=</span><span class="cn">NULL</span>]  <span class="co"># 等价</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, <span class="sc">-</span><span class="fu">c</span>(<span class="st">"mpg"</span>, <span class="st">"cyl"</span>, <span class="st">"hp"</span>), with <span class="ot">=</span> F] <span class="sc">%&gt;%</span> <span class="fu">head</span>() <span class="co"># 等价</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, <span class="sc">!</span><span class="fu">c</span>(<span class="st">"mpg"</span>, <span class="st">"cyl"</span>, <span class="st">"hp"</span>), with <span class="ot">=</span> F] <span class="sc">%&gt;%</span> <span class="fu">head</span>() <span class="co"># 等价</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a><span class="co"># 下面只能用冒号(:)链接，不然会报错</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, <span class="sc">-</span>(<span class="dv">2</span><span class="sc">:</span><span class="dv">4</span>)] <span class="sc">%&gt;%</span> <span class="fu">head</span>() <span class="co"># 删除第2:4列变量</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, mpg<span class="sc">:</span>disp, with <span class="ot">=</span> <span class="cn">FALSE</span>] <span class="sc">%&gt;%</span> <span class="fu">head</span>() <span class="co"># 等价</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>mtcars_dt[,<span class="sc">-</span>(mpg<span class="sc">:</span>disp), with <span class="ot">=</span> <span class="cn">FALSE</span>] <span class="sc">%&gt;%</span> <span class="fu">head</span>() <span class="co"># 等价</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="在j参数上可以进行计算" class="level2">
<h2 class="anchored" data-anchor-id="在j参数上可以进行计算">3.2 在j参数上可以进行计算：</h2>
<div class="sourceCode" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 返回按列计算的值</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>mtcars_dt[,.(<span class="fu">sum</span>(mpg),<span class="fu">mean</span>(cyl))]</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 当列的长度不一的时候，会循环对齐</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>mtcars_dt[,.(mpg,<span class="fu">mean</span>(cyl))] <span class="sc">%&gt;%</span> <span class="fu">head</span>()</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 还可以输入多个表达式，用花括号括起来即可</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>mtcars_dt[,{<span class="fu">print</span>(mpg);<span class="fu">plot</span>(disp)}]</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="co"># {} 还有帮助我们隐藏一些过度中间变量</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>mtcars_dt[,.(<span class="at">x =</span> cyl<span class="sc">^</span><span class="dv">2</span> <span class="sc">+</span><span class="dv">1</span>, <span class="at">y =</span> cyl<span class="sc">^</span><span class="dv">2</span> <span class="sc">+</span><span class="dv">2</span>)] <span class="sc">%&gt;%</span> <span class="fu">head</span>() <span class="co"># 这样cyl^2计算了两次,这样效率慢</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>mtcars_dt[,{temp <span class="ot">=</span> cyl<span class="sc">^</span><span class="dv">2</span>; .(<span class="at">x =</span> temp<span class="sc">+</span><span class="dv">1</span>,<span class="at">y=</span>temp<span class="sc">+</span><span class="dv">2</span>)}] <span class="sc">%&gt;%</span> <span class="fu">head</span>() </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>关键词<code>.SD</code> 和<code>.SDcol</code> 的作用</strong> , 后面会讲解</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="do">## 对data.table的每一列进行计算</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>mtcars_dt[,<span class="fu">sapply</span>(.SD, <span class="cf">function</span>(x){<span class="fu">sum</span>(<span class="fu">is.na</span>(x))<span class="sc">/</span>.N})]</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="do">## 也可以指定列进行计算</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>mtcars_dt[,<span class="fu">sapply</span>(.SD, <span class="cf">function</span>(x){<span class="fu">sum</span>(<span class="fu">is.na</span>(x))<span class="sc">/</span>.N}),.SDcol <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"A"</span>,<span class="st">"B"</span>,<span class="st">"C"</span>)]</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>iris_dt <span class="ot">=</span> <span class="fu">data.table</span>(iris)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>col_names <span class="ot">=</span> <span class="fu">colnames</span>(iris_dt)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="do">## 计算所有数值变量的均值, 可以先对变量名进行筛选</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>num_col <span class="ot">=</span> <span class="fu">sapply</span>(iris_dt, <span class="cf">function</span>(x) <span class="fu">class</span>(x) <span class="sc">==</span> <span class="st">"numeric"</span> )</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>iris_dt[, <span class="fu">lapply</span>(.SD, mean), .SDcols <span class="ot">=</span> num_col]</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="do">#####  在数据框中把指定的列转换为因子列</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a><span class="do">## 方法一   ---- 这种方法已被弃用 with=F, 推荐使用方法2 </span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="co"># col_names 为一个字符向量</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="co"># iris_dt[, col_names := lapply(.SD, function(x)as.factor(x)),.SDcols = col_names,with=F]</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>iris_dt[,col_names,with<span class="ot">=</span>F]  <span class="co"># 选择以col_names变量的内容的列</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a><span class="do">## 方法二</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a><span class="do">## (col_names):=  代表的是字符串向量，如果只使用col_names则表示列名为col_names的变量</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>iris_dt[, (col_names) <span class="sc">:</span><span class="er">=</span> <span class="fu">lapply</span>(.SD, <span class="cf">function</span>(x)<span class="fu">as.factor</span>(x)) , .SDcols <span class="ot">=</span> col_names]</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>iris_dt[,(<span class="st">"Sepal.Length"</span>)<span class="sc">:</span><span class="er">=</span><span class="fu">as.factor</span>(Sepal.Length)] <span class="co">#同上</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>                                </span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a><span class="do">## 如果左边用数字并打上() 代表第几列，指定第几列的操作</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>iris_dt[,(<span class="dv">2</span><span class="sc">:</span><span class="dv">3</span>)<span class="sc">:</span><span class="er">=</span>Species] <span class="co"># 把第2：3列的值进行更新，即第2:3列都为Species列</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a><span class="do">### 用函数对列名进行筛选后,然后对这些列进行统一处理</span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a><span class="co">#eg: 列名以S结尾的列全部转为因子,    </span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>iris_dt[, <span class="fu">lapply</span>(.SD, <span class="cf">function</span>(x)<span class="fu">as.factor</span>(x)) , .SDcols <span class="ot">=</span> <span class="fu">endsWith</span>(<span class="fu">names</span>(iris_dt), <span class="st">"S"</span>)]</span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a><span class="co"># startsWith(names(iris_dt), "S") # 表示以S开头的筛选变量方式</span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>                 </span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>                 </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="选取子集" class="level2">
<h2 class="anchored" data-anchor-id="选取子集">3.3 选取子集</h2>
<p>选取子集仍然采用<code>subeset</code>函数，语法格式为：<code>subset(x, subset, select)</code>，x是data.table对象，subset是行满足条件，select是列满足条件</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 用 .() 来包围列名，和list() 等价，都返回data.table数据类型,只要参数 j 返回一个list，这个list的每一个元素都会被转换成结果data.table的一列</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="fu">subset</span>(mtcars_dt,cyl<span class="sc">==</span><span class="dv">8</span>,<span class="at">select =</span><span class="fu">c</span>(<span class="st">'mpg'</span>,<span class="st">'cyl'</span>,<span class="st">'disp'</span>))</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 等价</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>mtcars_dt[cyl<span class="sc">==</span><span class="dv">8</span>,.(mpg,cyl,disp)]</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 等价</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>mtcars_dt[cyl<span class="sc">==</span><span class="dv">8</span>,<span class="fu">list</span>(mpg,cyl,disp)]</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="do">## 注意 ，没用list()或者.()包围列名 ，则返回的是向量，如下</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>mtcars_dt[,<span class="fu">c</span>(mpg,cyl,hp)] </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="对列进行排序" class="level2">
<h2 class="anchored" data-anchor-id="对列进行排序">3.4 对列进行排序</h2>
<ul>
<li>排序采用<code>setorder</code>函数，输入待排序的列名，默认升序，降序列名前加<code>-</code><br>
</li>
<li>注意：升序，降序都是按assic 值的大学排序</li>
</ul>
<div class="sourceCode" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">setorder</span>(mtcars_dt,mpg,<span class="sc">-</span>hp) <span class="co">#注意，这里直接对原数据进行了重排序，这点和R很多函数不一样，</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co">#几乎等价</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>mtcars_dt[<span class="fu">order</span>(cyl,<span class="sc">-</span>hp)] <span class="co">#这个就基本符合R语言规律，不改变原数据。</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 还可以使用key键排序,这样会改变原数据</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="对列进行增删变量" class="level2">
<h2 class="anchored" data-anchor-id="对列进行增删变量">3.5 对列进行增删变量</h2>
<p><strong>都是直接对原数据进行修改，无需重复赋值</strong></p>
<section id="添加变量有三种语法格式" class="level3">
<h3 class="anchored" data-anchor-id="添加变量有三种语法格式">3.5.1 添加变量有三种语法格式：</h3>
<div class="sourceCode" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>DT[i, LHS<span class="sc">:</span><span class="er">=</span>RHS, by<span class="ot">=</span>...] <span class="co">#适用单变量添加，等号（＝）前面为新的变量名,没有写明变量名，自动为V+  </span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>DT[i, <span class="fu">c</span>(<span class="st">"LHS1"</span>,<span class="st">"LHS2"</span>) <span class="sc">:</span><span class="er">=</span> <span class="fu">list</span>(RHS1, RHS2), by<span class="ot">=</span>...] <span class="co">#双变量添加  </span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>DT[i, <span class="st">`</span><span class="at">:=</span><span class="st">`</span>(<span class="at">LHS1=</span>RHS1,<span class="at">LHS2=</span>RHS2, ...), by<span class="ot">=</span>...] <span class="co">#多变量添加，注意`:=`  </span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 有条件的添加变量</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>mtcars_dt <span class="ot">&lt;-</span> <span class="fu">data.table</span>(mtcars) </span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, cyl1<span class="sc">:</span><span class="er">=</span> <span class="dv">1</span><span class="sc">*</span>(cyl <span class="sc">&lt;=</span> <span class="dv">6</span>)]</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, cyl2<span class="sc">:</span><span class="er">=</span> <span class="fu">ifelse</span>(cyl <span class="sc">&lt;=</span><span class="dv">6</span>, <span class="dv">1</span>,<span class="dv">0</span>)]</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, cyl_mpg<span class="sc">:</span><span class="er">=</span> <span class="fu">ifelse</span>(cyl <span class="sc">&lt;=</span><span class="dv">6</span>, mpg,cyl)]<span class="co"># 当cyl小于6时,则用mpg的数据,大于6时,则用cyl值保持不变</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="删除变量-变量null" class="level3">
<h3 class="anchored" data-anchor-id="删除变量-变量null">3.5.2 删除变量 — <code>变量:=NULL</code></h3>
<div class="sourceCode" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="co"># 这里发现一个bug，数据集被改动了,但是rstudio中的变量的维度没变，但是数据集确实改变了</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>mtcars_dt[,<span class="st">`</span><span class="at">:=</span><span class="st">`</span>(<span class="at">mpg1=</span><span class="dv">1</span><span class="sc">/</span>mpg,<span class="at">new=</span>cyl<span class="sc">+</span>gear)]<span class="co">#增加变量mpg1 与new变量</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>mtcars_dt[,mpg1<span class="sc">:</span><span class="er">=</span><span class="cn">NULL</span>] <span class="co">#删除变量mpg1  也可以mtcars_dt[,`:=`(mpg1=NULL,new=NULL)],也可以用 mtcars_dt[, c("mpg") :=NULL] </span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 如果要删除多列时，可用以下方法,</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, <span class="fu">c</span>(<span class="st">"mpg"</span>, <span class="st">"cyl"</span>, <span class="st">"hp"</span>) <span class="sc">:</span><span class="er">=</span><span class="cn">NULL</span>]  <span class="co"># 注意用 :=  会直接更改原数据</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, <span class="sc">-</span><span class="fu">c</span>(<span class="st">"mpg"</span>, <span class="st">"cyl"</span>, <span class="st">"hp"</span>), with <span class="ot">=</span> F]  <span class="co"># 这个会产生一个副本（或者叫拷贝）</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, <span class="sc">!</span><span class="fu">c</span>(<span class="st">"mpg"</span>, <span class="st">"cyl"</span>, <span class="st">"hp"</span>), with <span class="ot">=</span> F] <span class="co"># 同上，产生拷贝</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, <span class="sc">-</span><span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>)]     <span class="co">#  同上，产生拷贝</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 删除多列</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>col <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"mpg"</span>, <span class="st">"cyl"</span>, <span class="st">"hp"</span>)</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, col <span class="sc">:</span><span class="er">=</span><span class="cn">NULL</span>]  <span class="co"># 这个只能删除列名为col的变量</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, (col) <span class="sc">:</span><span class="er">=</span><span class="cn">NULL</span>] <span class="co"># 能删除以col为变量的内容作为mtcars的列名，</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a><span class="co"># 上面等价mtcars_dt[, c("mpg", "cyl", "hp") :=NULL] </span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a><span class="co"># 下面只能有冒号(:)链接，不然会报错</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, mpg<span class="sc">:</span>disp, with <span class="ot">=</span> <span class="cn">FALSE</span>] <span class="sc">%&gt;%</span> <span class="fu">head</span>() <span class="co"># 等价</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>mtcars_dt[,<span class="sc">-</span>(mpg<span class="sc">:</span>disp), with <span class="ot">=</span> <span class="cn">FALSE</span>] <span class="sc">%&gt;%</span> <span class="fu">head</span>() <span class="co"># 等价</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>理解数据存储以及变量名</strong> 。比如：数字，字符串 ，矩阵的内容，都会直接存在内存中，把数字3赋值给变量a,就相当于a指向数字3，改变a不会对内存进行修改，只是指针发生了改变，</p>
<p><strong>操作符“:=”会更新原数据</strong>。操作符“:=”对输入的数据进行浅度复制，只是一份指向列的指针向量的复制，在内存里，数据不是真的被复制了。他会随着指针指向的对象变化而变化，</p>
<p><strong>不更新原数据用函数 copy()。</strong>函数 copy() 对输入参数进行深度复制，因此对副本做的所有更新操作，都不会对原数据生效。简单理解：就是在内存中创建了一个和原来一模一样的数据.</p>
</section>
</section>
</section>
<section id="分组汇总by参数" class="level1">
<h1>4. 分组汇总－－by参数</h1>
<section id="分组汇总只需在by指定分组变量在j指定计算函数即可" class="level2">
<h2 class="anchored" data-anchor-id="分组汇总只需在by指定分组变量在j指定计算函数即可">4.1 分组汇总只需在<code>by</code>指定分组变量，在<code>j</code>指定计算函数即可</h2>
<div class="sourceCode" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">#按cyl与vs分组，对统计分组下的mpg均值，disp的总和,分组数据个数num，共返回cyl，vs，以及分组下的三个新变量 </span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>mtcars_dt[,.(<span class="at">mean_mpg =</span> <span class="fu">mean</span>(mpg),<span class="at">num=</span><span class="fu">length</span>(mpg),<span class="at">sum_disp =</span> <span class="fu">sum</span>(disp)),by<span class="ot">=</span>.(cyl,vs)] </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="data.table有一个特殊的变量.n可以直接计算分组的观测值个数" class="level2">
<h2 class="anchored" data-anchor-id="data.table有一个特殊的变量.n可以直接计算分组的观测值个数">4.2 data.table有一个<strong>特殊的变量<code>.N</code></strong>可以直接计算分组的观测值个数。</h2>
<pre><code>- 当参数j里面只有一列，我们可以省略 .()，如下：mtcars_dt[,.N,by=.(cyl,vs)]   
- 当参数by里面只有一列，我们可以省略 .()，如下：mtcars_dt[,.N,by=cyl]</code></pre>
<div class="sourceCode" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>mtcars_dt[,.(<span class="at">mean_mpg =</span> <span class="fu">mean</span>(mpg),.N),by<span class="ot">=</span>.(cyl,vs)]</span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="by参数还有接受表达式" class="level2">
<h2 class="anchored" data-anchor-id="by参数还有接受表达式">4.3 by参数还有接受表达式：</h2>
<div class="sourceCode" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 可以对要分组的列进行表达式判断，按其真假进行分组</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>mtcars_dt[,.(<span class="at">mean_mpg =</span> <span class="fu">mean</span>(mpg),.N),by<span class="ot">=</span>.(cyl<span class="sc">&gt;</span><span class="dv">5</span>,vs)]</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 也可以用函数进行简单的分组</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>mtcars_dt[,.(hp),by<span class="ot">=</span><span class="fu">sign</span>(cyl<span class="dv">-6</span>)]</span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="sd-和.sdcol-关键词" class="level2">
<h2 class="anchored" data-anchor-id="sd-和.sdcol-关键词">4.4 <code>.SD</code> 和<code>.SDcol</code> 关键词</h2>
<p><strong>对j参数进行计算时，必须分别对每列指定 mean() 函数吗 ？</strong></p>
<p>如上面的例子，要对分组变量进行计算难道都要指定每一列？可以采用<code>.SD</code> 函数，它常和<code>.SDcols</code>函数联合使用。</p>
<ul>
<li><code>.SD</code> 是经过<code>i</code> 和<code>by</code> 处理之后剩下的那部分数据集, 本质是一个<code>data.table</code>对象.</li>
<li>另一种理解, <strong><code>.SD</code>代表行经过<code>i</code> 筛选后, 除了<code>by</code>参数指定的列以外的所有列组成的新的data.table, 是原数据的子集</strong></li>
<li>首先,对<code>i</code>参数进行筛选, 然后把 <code>by</code>参数指定的那一列会被提前到首列, 其余列被按<code>by</code>指定的列进行分组组成新的<code>data.table</code>对象, 分成多少组,就有多少个<code>data.table</code> 对象, 这里的多个<code>data.table</code>对象出现的顺序是按照<code>by</code>指定列值出现的顺序</li>
<li><code>.SD</code>只能在位置j中使用, 且只能在<code>:=</code>右边使用</li>
<li>由于<code>.SD</code> 默认包含用于分组的所有列。我们需要指定列进行计算 —–可用关键词<code>.SDcol</code></li>
<li><code>.SDcols</code>指定<code>.SD</code>包括哪些列. eg: <code>.SDcols = c("disp","hp")</code>, 则 <code>.SD</code> 从默认的所有列改为只包含<code>disp</code>和<code>hp</code>这两列。</li>
<li>我们也可以使用<code>-</code> 或者<code>!</code>来移除列。比如:我们指定<code>!(colA:colB)</code> 或者<code>-(colA:colB)</code>表示移除从 <code>colA</code> 到 <code>colB</code> 的所有列。</li>
</ul>
<div class="sourceCode" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(data.table)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>mtcars_dt <span class="ot">=</span> data.table<span class="sc">::</span><span class="fu">as.data.table</span>(mtcars)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, .SD, by<span class="ot">=</span>cyl] <span class="co"># 注意此时cyl 从第二列变成了第一列,故by指定的列提前到第一列,其余列顺序保持不变</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, <span class="fu">print</span>(.SD), by<span class="ot">=</span>cyl] <span class="co"># 注意了多个data.table对象, 每一个对象是按照cyl值的先后顺序输出的</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, <span class="fu">lapply</span>(.SD[, <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>, <span class="at">with=</span>F], mean), by<span class="ot">=</span>cyl] <span class="co">#.SD代表除了by指定的所有列组成的新data.table, 并选择新的data.table的前两列进行计算</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 按cyl vs变量进行分组后，对其余的每一列求均值</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>mtcars_dt[,<span class="fu">lapply</span>(.SD, mean),by<span class="ot">=</span>.(cyl,vs)]</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 按cyl分组以后对其余变量求和</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>mtcars_dt[,<span class="fu">lapply</span>(.SD, sum),by<span class="ot">=</span>.(cyl)] </span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a><span class="co"># 如果要对大量的变量做聚合计算，可以使用.SD函数，和.SDcols函数。</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a><span class="co"># 默认的，.SD函数指对所有变量进行计算</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, <span class="fu">lapply</span>(.SD, mean)]</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a><span class="co">#只对某些特定的列 结合.SDcols参数</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, <span class="fu">lapply</span>(.SD, mean), .SDcols <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"cyl"</span>, <span class="st">"vs"</span>)]<span class="co">#只对cyl, vs列进行计算</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a><span class="co"># 对多个变量实现多个统计指标计算</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, <span class="fu">sapply</span>(.SD, <span class="cf">function</span>(x) <span class="fu">c</span>(<span class="at">mean=</span><span class="fu">mean</span>(x), <span class="at">median=</span><span class="fu">median</span>(x)))]</span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="如果要对子集进行分组统计怎么办即对选出的i进行分组统计." class="level2">
<h2 class="anchored" data-anchor-id="如果要对子集进行分组统计怎么办即对选出的i进行分组统计.">4.5 如果要对子集进行分组统计怎么办？，即对选出的i进行分组统计.</h2>
<p>可用<code>by=列名即可</code>允许按每一个已知i的子集分组，在使用by=.EACHI时需要设置键值</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>mtcars_dt[cyl<span class="sc">==</span><span class="dv">4</span> <span class="sc">|</span> cyl<span class="sc">==</span><span class="dv">8</span>,<span class="fu">mean</span>(mpg),by <span class="ot">=</span> cyl]</span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="分组汇总的同时排序-keyby" class="level1">
<h1>5分组汇总的同时排序 —— keyby</h1>
<p>和上面的by参数有什么不同？</p>
<p>data.table本身就被设计成能保持原数据的顺序。<strong>在一些情况下，必须保持原来的顺序</strong>。但是，有时我们<strong>希望自动根据分组的变量排序</strong>。使用<code>keyby</code>参数，使用参数<code>keyby</code>自动将引用的列设置为主键</p>
<ol type="1">
<li>如何按照分组的变量排序</li>
</ol>
<div class="sourceCode" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>mtcars_dt <span class="ot">&lt;-</span> <span class="fu">data.table</span>(mtcars)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="co"># 未设置主键时，分组变量cyl，vs是按原来mtcars_dt数据集中的顺序排序的</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, .(<span class="at">mean_mpg =</span> <span class="fu">mean</span>(mpg),.N), by<span class="ot">=</span>.(cyl,vs)]</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="co">#设置主键 ，把cyl,vs列设置主键--会根据分组的变量排序。</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>mtcars_dt[, .(<span class="at">mean_mpg =</span> <span class="fu">mean</span>(mpg),.N), keyby<span class="ot">=</span>.(cyl,vs)]<span class="co"># 注意这里keyby里面不能进行降序排列，若在vs前面加一个负号，这等于在变量vs乘－1</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 等价</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>mtcars_dt[,.(<span class="at">mean_mpg =</span> <span class="fu">mean</span>(mpg),.N),by<span class="ot">=</span>.(cyl,vs)][<span class="fu">order</span>(cyl,vs)]</span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="chaining表达式" class="level1">
<h1>6. chaining表达式</h1>
<div class="sourceCode" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>我们可以一个接一个地添加表达式，做一系列操作，就像这样：</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>   1，DT[...][...][...]。</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>   2，DT[...</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>             ][...</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>             ][...</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>                ]</span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>比如要提取前面几行就可以<code>DT[...][1:5]</code>,</p>
<ul>
<li>大多数情况下没有问题, 有些时候可以在最后面加个空, eg: <code>DT[...][1:5][]</code> , 这样可以保证返回<code>data.table</code> 数据格式</li>
<li>发生这种原因,大多数和 <code>:=</code> 有关系, 如下</li>
</ul>
<div class="sourceCode" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># eg:</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> iris_dt[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>][, id <span class="sc">:</span><span class="er">=</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>]  <span class="co"># 不会在控制台显示结果, 必须要显示打印: print(a)</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="do">### 如果换一个写法就不会啦</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> iris_dt[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>][, id <span class="sc">:</span><span class="er">=</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>][]  <span class="co"># 直接正常显示,打印</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>以上就是data.table的基本操作,后续更新一些本报的一些基本概念和其他函数</strong></p>
</section>
<section id="总结" class="level1">
<h1>7总结</h1>
<p>data.table的语法形式是：</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>DT[i, j, by]</span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>指定参数i：</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="sc">*</span> 类似于data.frame，我们可以subset行，除非不需要重复地使用 DT<span class="sc">$</span>，既然我们能将列当做变量来引用。 </span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="sc">*</span> 我们可以使用<span class="fu">order</span>()排序。为了得到更快速的效果，<span class="fu">order</span>()函数内部使用了data.table的快速排序。 </span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>我们可以通过参数i做更多的事，得到更快速的选取和连结。</span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>指定参数j：</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="sc">*</span> 以data.table的形式选取列：DT[, .(colA, colB)]。</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="sc">*</span> 以data.frame的形式选取列：DT[, <span class="fu">c</span>(<span class="st">"colA"</span>, <span class="st">"colB"</span>), with<span class="ot">=</span><span class="cn">FALSE</span>]。</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="sc">*</span> 按列进行计算：DT[, .(<span class="fu">sum</span>(colA), <span class="fu">mean</span>(colB))]。</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="sc">*</span> 如果需要：DT[, .(<span class="at">sA =</span><span class="fu">sum</span>(colA), <span class="at">mB =</span> <span class="fu">mean</span>(colB))]。</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="sc">*</span> 和i共同使用：DT[colA <span class="sc">&gt;</span> value, <span class="fu">sum</span>(colB)]。</span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>指定参数by：</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="sc">*</span> 通过by，我们可以指定列或表达式，进行分组。参数j可以很灵活地配置参数i和by实现强大的功能。</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="sc">*</span> by可以指定多个列，也可以指定表达式。</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="sc">*</span> 我们可以用 keyby，对分组的结果自动排序。</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="sc">*</span> 我们可以在参数j中指定 .SD 和 .SDcols，对复数的列进行操作。例如：   </span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>  <span class="fl">1.</span>把函数fun 应用到所有 .SDcols指定的列上，同时对参数by指定的列进行分组：</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>                            DT[, <span class="fu">lapply</span>(.SD, fun), by<span class="ot">=</span>., .SDcols<span class="ot">=</span>...]。 </span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>  <span class="fl">2.</span>返回每组册前两行：DT[, <span class="fu">head</span>(.SD, <span class="dv">2</span>), by<span class="ot">=</span>.]。</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>  <span class="fl">3.</span>三个参数联合使用：DT[col <span class="sc">&gt;</span> val, <span class="fu">head</span>(.SD, <span class="dv">1</span>), by<span class="ot">=</span>.]。</span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>小提示： 只要j返回一个list，这个list的每个元素都会是结果data.table的一列。</p>
<p>https://youngspring1.github.io/2016/2016-03-13-datatable1/</p>
<p>https://youngspring1.github.io/2016/2016-03-21-datatable2/</p>
<p>https://youngspring1.github.io/2016/2016-03-22-datatable3/</p>
<p>https://youngspring1.github.io/2016/2016-04-02-datatable4/</p>
<p>https://youngspring1.github.io/2016/2016-04-08-datatable5/</p>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } 
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "已复制");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">源代码</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<pre class="markdown" data-shortcodes="false"><code>---
title: data.table -- 1基本函数
date: '2018-01-16'
categories:
  - r
  - data.table
---


data.table本质上是一个list，它们的列包含的元素个数都相同。

# 1、数据的读写

### 1.1数据读入－－fread

选其常用的参数如下：

```R
fread(input,na.strings="NA", file, stringsAsFactors=FALSE,encoding="unknown", ...)
```

- input 入的文件对象，`fread`函数可以自动判断分隔符类型，自动判断首行是否是列标题，同时默认读入时字符型变量不会变为因子型。也可也从网页读取数据
- na.strings,对NA的解释；
- file文件路径，再确保没有执行shell命令时很有用，也可以在input参数输入;
- stringsASFactors是否转化字符串为因子，
- encoding，默认"unknown"，其它可能"UTF-8"或者"Latin-1"，不是用来重新编码的，而是允许处理的字符串在本机编码;
- showProgress = T   显示进度条
- integer64 当数据列中有大于2 ^ 31的整数,可能会丢失精度
- quote  对带双引号的字符添加转义,在R中正常显示,但是输出时,可能会引起成倍的双引号,因此建议使用`fwrite`时,设置该参数`quote = FALSE`

### 1.2数据写入－－fwrite

```R
fwrite(x, file = "", append = FALSE, na = "", row.names = FALSE, col.names = TRUE,logicalAsInt = FALSE, ...)
```

- x,比如data.frame和data.table等R的对象；
- file，输出文件名,""意味着直接输出到操作台；
- append，如果TRUE,在原文件的后面添加；默认删除原来文件的数据，重新存储。
- na,na值的表示，默认""；
- row.names，是否写出行名，因为data.table没有行名，所以默认FALSE；
- col.names ，是否写出列名，默认TRUE，如果没有定义，并且append=TRUE和文件存在，那么就会默认使用FALSE;
- logicalAsInt,逻辑值作为数字写出还是作为FALSE和TRUE写出；



## 1.3  数据框转为data.table

对于数据的处理，`data.table`包提供了一个非常简洁的通用格式：`DT[i,j,by]`，

- 其中`i`控制列, `j`控制列, `by`控制分组. 上述表达式的意思是: 对于数据集`DT`，先选取子集行`i`,  然后通过`by`分组计算`j`。`i`设定数据的选取条件，`j`设定结果的计算方式，`by`设定数据的分组情况。通过这个，我们可以在一行代码中很方便地完成处理过程。首先需要把数据变为data.table类型

```R
library(data.table)
library(magrittr)
### 方法一: 赋值转换
mtcars_dt &lt;- data.table(mtcars) # 也可以强制转化 as.data.table()

### 方法二: 引用转换
setDT(mtcars)  # 不需要赋值,这是引用转换, mtcars这个数据集已经变成了data.table 数据类型了
```

# 2. 数据行列筛选 --- i 参数

**行筛选：--i参数**

- 直接采用逻辑语句（慢）
- 使用主键(会对筛选的数据进行重排序--适中)
- 二级索引（不重排序，按原数据的顺序排序--快）

## 2.1 直接采用逻辑语句（慢）

```R
mtcars_dt &lt;- data.table(mtcars) # 一共32行,11列
#直接采用逻辑语句（慢）
mtcars_dt[cyl==8 ]
mtcars_dt[cyl==8 &amp; carb==4]
mtcars_dt[cyl %in% c("8","6")]# 等价 mtcars_dt[cyl %in% c(8,6)]
```

##  2.2 设置/获取/使用主键(适中)

| 函数                           | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| `setkey(x,V1)`                 | 该函数可以对一个data.table按照某一列进行排序,排序之后,这个data.table 对象会被标记为排过序了, 由于不会在内存中复制被排序的data.table对象,所以非常高效. |
| `setkey(x,V1,V2,V3, ...)`      | 等价于`setkeyv(x,c("V1","V2",...) )`                         |
| `setkeyv(x,c("V1","V2",...) )` | 可以按照多列一起排序.先根据V1排序,然后根据V2排序, 以此类推.  |
| `table()`                      | 查看内存中所有data.table 的详细信息,包括key键,               |

- **`setkey(x,V1)`传入列名作为参数，不需要引号, 而`setkeyv(x,c("V1","V2",...) )` 传入一个字符型的向量, 这两个函数都没有返回值, 直接对data.table进行更新操作,和`:=`类似**

- **每一个table.table中只有一组key键, 像普通的data.frame, 每一行有且只有一个行名且行名具有唯一性, 行名可以看做是data.frame的索引. 而data.table可以利用主键进行索引, 且可以对多列设置主键,且主键不强调唯一性. 也就是说，不同列的主键可以是一样的。既然行可以通过主键排序，那么排序的时候，具有同样主键的一些行，会被排在一起。**

- **在data.table里，操作符":="和所有的以set开头函数（比如setkey,setorder,setname等）一样，它们都会更新输入的原数据。**


```R
#使用主键(会对筛选的数据进行重排序--适中)
mtcars_dt &lt;- data.table(mtcars) 
setkey(mtcars_dt,cyl,carb)# 设置key键
mtcars_dt #可以看出已经排序了
tables()              # 查看内存中所有data.table 的详细信息,包括key键
iris_dt = data.table(iris)
tables()              # 
setkeyv(mtcars_dt,c("cyl","carb"))#先设置的cyl,carb列为主键
mtcars_dt[.(8,4)]     # 等价 mtcars_dt[cyl==8 &amp; carb==4]
tables()              # 查看内存中所有data.table 的详细信息
```
## 2.3 二级索引`(indices)`（快）

#### a)  **什么是二级索引? 二级索引和主键有什么区别?**

  - 前面介绍了`setkey` 和`setkeyv`的使用,每一次使用`setkey`, data.table 对象都会在内存里被重新排序, 时间复杂度是`O(nlogn)`. 而  `setindex` 和`setindexv` 则不会对data.table对象进行重新排序, 它只会计算某列的顺序，将这个顺序向量保存在一个额外的，叫做index的属性里面。 此外,一个data.table对象只能有一组key,  但是可以有多个二级索引(indices). 二级索引的时间复杂度是`O(logn)`

| 函数                            | 说明                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| `setindex(x,V1)`                | 设置索引---即将V1列设置为该data.table的二级索引 &lt;br&gt; 等价`setindexv(x,c("V1"))` |
| `setindex(x,V1,V2,...)`         | 设置多列索引---即将V1,V2列设置为该data.table的二级索引&lt;br/&gt; 等价`setindexv(x,c("V1","V2",...))` |
| `setindexv(x,c("V1","V2",...))` | 以字符的方式设置索引                                         |
| `setindex(x, NULL)`             | 删除所有的二级索引。                                         |
| `indices(x) `                   | 获取data.table对象的所有二级索引, 如果该data.table没有二级索引，那么返回NULL。 |

```R
# 设置和获取二级索引
mtcars_dt &lt;- data.table(mtcars) 
setindex(mtcars_dt,cyl,carb) # 等价于 setindexv(mtcars_dt,c("cyl","carb"))
names(attributes(mtcars_dt)) # 查询data.table 的属性
indices(mtcars_dt)
mtcars_dt #  注意并没有对数据进行重新排序, 而setkey会对数据进行重新排序
setindexv(mtcars_dt,c("vs", "am", "gear","carb"))
indices(mtcars_dt)


```
#### b)为什么使用二级索引 
原因是对一个data.table重新排序成本太高, 除非你要进行大量选子集的操作,建议使用setkey 来提取子集.
我们想快速地提取子集(subset)同时又不必重新排序,此时二级索引就派上用处了.

## 2.4 二级索引的快速使用 --- 参数on

上面我们都在讲先设置二级索引,然后在进行操作,这样能不能合成一步?----于是参数`on`诞生了, 参数`on`使得语法更简洁，并且能自动创建并重用二级索引

**参数on**

  - 通过创建索引进行subset。每次都能节省setindex()的时间。
  - 通过检查属性，可以简单地重用已经存在的二级索引。
  - 参数on必须是一个字符型的向量。
  - 注意参数on也可以用来指定主键。事实上，为了更佳的可读性，我们鼓励在参数on里面指定主键。
  - 参数`on`它不会把这个二级索引自动创建为data.table的一个属性。需要额外设置参数才可以(设`verbose = TRUE`).
```R
mtcars_dt[.(1),on="am"]#同时满足cyl=8,gear=4的行
## 等价的备选方案 -- mtcars_dt[list(1), on = "am"]
## 注意 on="am"表明我们要基于am这一列进行过滤,过滤的条件是am == 1, 1必须放置.()里面
## 原因是 am是numeric类型,如果不是numeric类型,就不用这样做

iris_dt = data.table(iris)
iris_dt["setosa",on="Species"]  
#等价的备选方案
iris_dt[.("setosa"),on="Species"] 
iris_dt[list("setosa"),on="Species"] 

# 选择 Species =setosa 或者 Species =virginica
iris_dt[.(c("setosa","virginica")) ,on="Species"] 
iris_dt[.(c("setosa","virginica"),c(3.0)) ,on=c("Species","Sepal.Width")] 

# 注意小心有NA行,原因在于Petal.Length列没有等于5.1的值
iris_dt[.(c("setosa","virginica"),c(5.1)) ,on=c("Species","Petal.Length")] 


#### on参数也可以像j那样直接使用列名 ,无需加引号
mtcars_dt[.(8,4),on=c("cyl","carb")]#同时满足cyl=8,gear=4的行
mtcars_dt[.(8,4),on=.(cyl,carb)]# 等价同上,

```

## 2.5 自动索引 --- 只支持操作符 == 和 %in% 

回顾一下，我们先学习如何通过主键使用快速二分法搜索进行subset。接着，我们学习了使用二级索引，它带来更好的效果，而且语法也更简洁。

等等，有没有更好的方法？

有！优化R的原生语法，使用内置的索引。这样我们毋需使用新的语法，就能得到同样的效果。这就是自动索引。
目前，**它只支持操作符 == 和 %in% 。而且只对一列起作用**。某一列会被自动创建为索引，并且作为data.table的属性保存起来。这跟参数on不同，参数on会每次创建一个临时索引，所以才会被叫做“二级索引”。

```R
iris_dt[Petal.Length == 5.1, ] 
iris_dt[Petal.Length %in% c(5.1,5.2), ] 
```



**注意, 以上都是针对`i`参数设置,因此可以同`j`参数, `by`参数同时使用**

**还有, 在进行行筛选时,尽量打个逗号,区分`i`和`j`**

# 3  列筛选：-- j参数

## 3.1 `.()`格式 == 等价list()

**用` .() `来包围列名，和`list()` 等价**    

```R
# 列筛选 --方法一, 直接输入列名
mtcars_dt[, .(mpg, cyl, hp)] %&gt;% head()
mtcars_dt[, c("mpg", "cyl", "hp")]# 返回的都是data.table
mtcars_dt[, c("mpg", "cyl", "hp"), with =F]

# 列筛选 --方法二 如果没用list()或者.()包围列名 ，则返回的是向量（这不是我们想要的结果），如下
mtcars_dt[, c(mpg, cyl, hp)] %&gt;% head()

# 列筛选 --方法三, 可以把列名改写成对应的数字列,但返回的是data.table类型
mtcars_dt[, c(1, 2, 4)] %&gt;% head()
mtcars_dt[, c(1, 2, 4)] %&gt;% class()

# 列筛选-- 方法四, 如果列名已经存储到一个变量里面了, 怎么根据它来选择列
library(data.table)
mtcars_dt = as.data.table(mtcars)
a = c(1,2,4)
b = c("mpg", "cyl", "hp")
mtcars_dt[,..a] # 在变量名前加两个点,  如果这样输入: mtcars_dt[,a], 则报错
mtcars_dt[,..b]# 在变量名前加两个点,  如果这样输入: mtcars_dt[,b], 则报错


# 列筛选 --方法五, 要排除列名怎么办，可以用数字
mtcars_dt[, -c(1, 2, 4)] %&gt;% head() # 等价
mtcars_dt[, c("mpg", "cyl", "hp") :=NULL]  # 等价
mtcars_dt[, -c("mpg", "cyl", "hp"), with = F] %&gt;% head() # 等价
mtcars_dt[, !c("mpg", "cyl", "hp"), with = F] %&gt;% head() # 等价

# 下面只能用冒号(:)链接，不然会报错
mtcars_dt[, -(2:4)] %&gt;% head() # 删除第2:4列变量
mtcars_dt[, mpg:disp, with = FALSE] %&gt;% head() # 等价
mtcars_dt[,-(mpg:disp), with = FALSE] %&gt;% head() # 等价
```

##  3.2 在j参数上可以进行计算： 

```R
# 返回按列计算的值
mtcars_dt[,.(sum(mpg),mean(cyl))]

# 当列的长度不一的时候，会循环对齐
mtcars_dt[,.(mpg,mean(cyl))] %&gt;% head()


# 还可以输入多个表达式，用花括号括起来即可
mtcars_dt[,{print(mpg);plot(disp)}]

# {} 还有帮助我们隐藏一些过度中间变量
mtcars_dt[,.(x = cyl^2 +1, y = cyl^2 +2)] %&gt;% head() # 这样cyl^2计算了两次,这样效率慢

mtcars_dt[,{temp = cyl^2; .(x = temp+1,y=temp+2)}] %&gt;% head() 

```

**关键词`.SD` 和`.SDcol` 的作用** , 后面会讲解

```R

## 对data.table的每一列进行计算
mtcars_dt[,sapply(.SD, function(x){sum(is.na(x))/.N})]

## 也可以指定列进行计算
mtcars_dt[,sapply(.SD, function(x){sum(is.na(x))/.N}),.SDcol = c("A","B","C")]

iris_dt = data.table(iris)
col_names = colnames(iris_dt)

## 计算所有数值变量的均值, 可以先对变量名进行筛选
num_col = sapply(iris_dt, function(x) class(x) == "numeric" )
iris_dt[, lapply(.SD, mean), .SDcols = num_col]

#####  在数据框中把指定的列转换为因子列
## 方法一   ---- 这种方法已被弃用 with=F, 推荐使用方法2 
# col_names 为一个字符向量
# iris_dt[, col_names := lapply(.SD, function(x)as.factor(x)),.SDcols = col_names,with=F]
iris_dt[,col_names,with=F]  # 选择以col_names变量的内容的列


## 方法二
## (col_names):=  代表的是字符串向量，如果只使用col_names则表示列名为col_names的变量
iris_dt[, (col_names) := lapply(.SD, function(x)as.factor(x)) , .SDcols = col_names]

iris_dt[,("Sepal.Length"):=as.factor(Sepal.Length)] #同上

                                
## 如果左边用数字并打上() 代表第几列，指定第几列的操作
iris_dt[,(2:3):=Species] # 把第2：3列的值进行更新，即第2:3列都为Species列

### 用函数对列名进行筛选后,然后对这些列进行统一处理
#eg: 列名以S结尾的列全部转为因子,    
iris_dt[, lapply(.SD, function(x)as.factor(x)) , .SDcols = endsWith(names(iris_dt), "S")]
# startsWith(names(iris_dt), "S") # 表示以S开头的筛选变量方式
                 
                 

```



##  3.3 选取子集

选取子集仍然采用`subeset`函数，语法格式为：`subset(x, subset, select)`，x是data.table对象，subset是行满足条件，select是列满足条件

```R
# 用 .() 来包围列名，和list() 等价，都返回data.table数据类型,只要参数 j 返回一个list，这个list的每一个元素都会被转换成结果data.table的一列

subset(mtcars_dt,cyl==8,select =c('mpg','cyl','disp'))
# 等价
mtcars_dt[cyl==8,.(mpg,cyl,disp)]
# 等价
mtcars_dt[cyl==8,list(mpg,cyl,disp)]

## 注意 ，没用list()或者.()包围列名 ，则返回的是向量，如下
mtcars_dt[,c(mpg,cyl,hp)] 
```

## 3.4  对列进行排序

  - 排序采用`setorder`函数，输入待排序的列名，默认升序，降序列名前加`-`    
  - 注意：升序，降序都是按assic 值的大学排序
    
```R
setorder(mtcars_dt,mpg,-hp) #注意，这里直接对原数据进行了重排序，这点和R很多函数不一样，
#几乎等价
mtcars_dt[order(cyl,-hp)] #这个就基本符合R语言规律，不改变原数据。

# 还可以使用key键排序,这样会改变原数据
```

## 3.5 对列进行增删变量

**都是直接对原数据进行修改，无需重复赋值**

### 3.5.1 添加变量有三种语法格式：

```R
DT[i, LHS:=RHS, by=...] #适用单变量添加，等号（＝）前面为新的变量名,没有写明变量名，自动为V+  
DT[i, c("LHS1","LHS2") := list(RHS1, RHS2), by=...] #双变量添加  
DT[i, `:=`(LHS1=RHS1,LHS2=RHS2, ...), by=...] #多变量添加，注意`:=`  

# 有条件的添加变量
mtcars_dt &lt;- data.table(mtcars) 
mtcars_dt[, cyl1:= 1*(cyl &lt;= 6)]
mtcars_dt[, cyl2:= ifelse(cyl &lt;=6, 1,0)]
mtcars_dt[, cyl_mpg:= ifelse(cyl &lt;=6, mpg,cyl)]# 当cyl小于6时,则用mpg的数据,大于6时,则用cyl值保持不变
```

### 3.5.2 删除变量 --- `变量:=NULL`

```R

# 这里发现一个bug，数据集被改动了,但是rstudio中的变量的维度没变，但是数据集确实改变了
mtcars_dt[,`:=`(mpg1=1/mpg,new=cyl+gear)]#增加变量mpg1 与new变量
mtcars_dt[,mpg1:=NULL] #删除变量mpg1  也可以mtcars_dt[,`:=`(mpg1=NULL,new=NULL)],也可以用 mtcars_dt[, c("mpg") :=NULL] 

# 如果要删除多列时，可用以下方法,
mtcars_dt[, c("mpg", "cyl", "hp") :=NULL]  # 注意用 :=  会直接更改原数据
mtcars_dt[, -c("mpg", "cyl", "hp"), with = F]  # 这个会产生一个副本（或者叫拷贝）
mtcars_dt[, !c("mpg", "cyl", "hp"), with = F] # 同上，产生拷贝
mtcars_dt[, -c(1, 2, 4)]     #  同上，产生拷贝

# 删除多列
col = c("mpg", "cyl", "hp")
mtcars_dt[, col :=NULL]  # 这个只能删除列名为col的变量

mtcars_dt[, (col) :=NULL] # 能删除以col为变量的内容作为mtcars的列名，
# 上面等价mtcars_dt[, c("mpg", "cyl", "hp") :=NULL] 

# 下面只能有冒号(:)链接，不然会报错
mtcars_dt[, mpg:disp, with = FALSE] %&gt;% head() # 等价
mtcars_dt[,-(mpg:disp), with = FALSE] %&gt;% head() # 等价

```

**理解数据存储以及变量名** 。比如：数字，字符串 ，矩阵的内容，都会直接存在内存中，把数字3赋值给变量a,就相当于a指向数字3，改变a不会对内存进行修改，只是指针发生了改变，

**操作符“:=”会更新原数据**。操作符“:=”对输入的数据进行浅度复制，只是一份指向列的指针向量的复制，在内存里，数据不是真的被复制了。他会随着指针指向的对象变化而变化，

**不更新原数据用函数 copy()。**函数 copy() 对输入参数进行深度复制，因此对副本做的所有更新操作，都不会对原数据生效。简单理解：就是在内存中创建了一个和原来一模一样的数据.



# 4. 分组汇总－－by参数

## 4.1 分组汇总只需在`by`指定分组变量，在`j`指定计算函数即可

```R
#按cyl与vs分组，对统计分组下的mpg均值，disp的总和,分组数据个数num，共返回cyl，vs，以及分组下的三个新变量 
mtcars_dt[,.(mean_mpg = mean(mpg),num=length(mpg),sum_disp = sum(disp)),by=.(cyl,vs)] 
```

## 4.2 data.table有一个**特殊的变量`.N`**可以直接计算分组的观测值个数。

    - 当参数j里面只有一列，我们可以省略 .()，如下：mtcars_dt[,.N,by=.(cyl,vs)]   
    - 当参数by里面只有一列，我们可以省略 .()，如下：mtcars_dt[,.N,by=cyl]

```R
mtcars_dt[,.(mean_mpg = mean(mpg),.N),by=.(cyl,vs)]
```

## 4.3 by参数还有接受表达式：

```R
# 可以对要分组的列进行表达式判断，按其真假进行分组
mtcars_dt[,.(mean_mpg = mean(mpg),.N),by=.(cyl&gt;5,vs)]
# 也可以用函数进行简单的分组
mtcars_dt[,.(hp),by=sign(cyl-6)]
```

## 4.4 `.SD` 和`.SDcol` 关键词

**对j参数进行计算时，必须分别对每列指定 mean() 函数吗 ？** 

如上面的例子，要对分组变量进行计算难道都要指定每一列？可以采用`.SD` 函数，它常和`.SDcols`函数联合使用。

  - `.SD` 是经过`i` 和`by` 处理之后剩下的那部分数据集, 本质是一个`data.table`对象.
  - 另一种理解, **`.SD`代表行经过`i` 筛选后, 除了`by`参数指定的列以外的所有列组成的新的data.table, 是原数据的子集**
  - 首先,对`i`参数进行筛选, 然后把 `by`参数指定的那一列会被提前到首列, 其余列被按`by`指定的列进行分组组成新的`data.table`对象, 分成多少组,就有多少个`data.table` 对象, 这里的多个`data.table`对象出现的顺序是按照`by`指定列值出现的顺序
  - `.SD`只能在位置j中使用, 且只能在`:=`右边使用
  - 由于`.SD` 默认包含用于分组的所有列。我们需要指定列进行计算 -----可用关键词`.SDcol`
  - `.SDcols`指定`.SD `包括哪些列. eg: `.SDcols = c("disp","hp")`,  则  `.SD` 从默认的所有列改为只包含`disp`和`hp`这两列。
  - 我们也可以使用` -` 或者` ! `来移除列。比如:我们指定` !(colA:colB)` 或者` -(colA:colB)`表示移除从 `colA` 到 `colB` 的所有列。

```R
library(data.table)
mtcars_dt = data.table::as.data.table(mtcars)
mtcars_dt[, .SD, by=cyl] # 注意此时cyl 从第二列变成了第一列,故by指定的列提前到第一列,其余列顺序保持不变

mtcars_dt[, print(.SD), by=cyl] # 注意了多个data.table对象, 每一个对象是按照cyl值的先后顺序输出的

mtcars_dt[, lapply(.SD[, 1:2, with=F], mean), by=cyl] #.SD代表除了by指定的所有列组成的新data.table, 并选择新的data.table的前两列进行计算

# 按cyl vs变量进行分组后，对其余的每一列求均值
mtcars_dt[,lapply(.SD, mean),by=.(cyl,vs)]

# 按cyl分组以后对其余变量求和
mtcars_dt[,lapply(.SD, sum),by=.(cyl)] 

# 如果要对大量的变量做聚合计算，可以使用.SD函数，和.SDcols函数。
# 默认的，.SD函数指对所有变量进行计算
mtcars_dt[, lapply(.SD, mean)]

#只对某些特定的列 结合.SDcols参数
mtcars_dt[, lapply(.SD, mean), .SDcols = c("cyl", "vs")]#只对cyl, vs列进行计算

# 对多个变量实现多个统计指标计算
mtcars_dt[, sapply(.SD, function(x) c(mean=mean(x), median=median(x)))]
```

## 4.5 如果要对子集进行分组统计怎么办？，即对选出的i进行分组统计.  

可用`by=列名即可`允许按每一个已知i的子集分组，在使用by=.EACHI时需要设置键值 

```R
mtcars_dt[cyl==4 | cyl==8,mean(mpg),by = cyl]
```

# 5分组汇总的同时排序 —— keyby

和上面的by参数有什么不同？

data.table本身就被设计成能保持原数据的顺序。**在一些情况下，必须保持原来的顺序**。但是，有时我们**希望自动根据分组的变量排序**。使用`keyby`参数，使用参数`keyby`自动将引用的列设置为主键

1.  如何按照分组的变量排序

```R
mtcars_dt &lt;- data.table(mtcars)
# 未设置主键时，分组变量cyl，vs是按原来mtcars_dt数据集中的顺序排序的
mtcars_dt[, .(mean_mpg = mean(mpg),.N), by=.(cyl,vs)]

#设置主键 ，把cyl,vs列设置主键--会根据分组的变量排序。
mtcars_dt[, .(mean_mpg = mean(mpg),.N), keyby=.(cyl,vs)]# 注意这里keyby里面不能进行降序排列，若在vs前面加一个负号，这等于在变量vs乘－1

# 等价
mtcars_dt[,.(mean_mpg = mean(mpg),.N),by=.(cyl,vs)][order(cyl,vs)]

```

# 6. chaining表达式

```R
我们可以一个接一个地添加表达式，做一系列操作，就像这样：
   1，DT[...][...][...]。
   2，DT[...
             ][...
             ][...
                ]
```

比如要提取前面几行就可以`DT[...][1:5]`, 

- 大多数情况下没有问题, 有些时候可以在最后面加个空, eg: `DT[...][1:5][]` , 这样可以保证返回`data.table` 数据格式
- 发生这种原因,大多数和 `:=` 有关系, 如下

```R
# eg:
a = iris_dt[1:3, 1:4][, id := 1:3]  # 不会在控制台显示结果, 必须要显示打印: print(a)
### 如果换一个写法就不会啦
a = iris_dt[1:3, 1:4][, id := 1:3][]  # 直接正常显示,打印
```

**以上就是data.table的基本操作,后续更新一些本报的一些基本概念和其他函数**



# 7总结

data.table的语法形式是： 

```R
DT[i, j, by]
```

指定参数i： 

```R
* 类似于data.frame，我们可以subset行，除非不需要重复地使用 DT$，既然我们能将列当做变量来引用。 
* 我们可以使用order()排序。为了得到更快速的效果，order()函数内部使用了data.table的快速排序。 
我们可以通过参数i做更多的事，得到更快速的选取和连结。
```

指定参数j：

```R
* 以data.table的形式选取列：DT[, .(colA, colB)]。
* 以data.frame的形式选取列：DT[, c("colA", "colB"), with=FALSE]。
* 按列进行计算：DT[, .(sum(colA), mean(colB))]。
* 如果需要：DT[, .(sA =sum(colA), mB = mean(colB))]。
* 和i共同使用：DT[colA &gt; value, sum(colB)]。
```

指定参数by：

```R
* 通过by，我们可以指定列或表达式，进行分组。参数j可以很灵活地配置参数i和by实现强大的功能。
* by可以指定多个列，也可以指定表达式。
* 我们可以用 keyby，对分组的结果自动排序。
* 我们可以在参数j中指定 .SD 和 .SDcols，对复数的列进行操作。例如：   
  1.把函数fun 应用到所有 .SDcols指定的列上，同时对参数by指定的列进行分组：
                            DT[, lapply(.SD, fun), by=., .SDcols=...]。 
  2.返回每组册前两行：DT[, head(.SD, 2), by=.]。
  3.三个参数联合使用：DT[col &gt; val, head(.SD, 1), by=.]。
```

小提示：
只要j返回一个list，这个list的每个元素都会是结果data.table的一列。

https://youngspring1.github.io/2016/2016-03-13-datatable1/

https://youngspring1.github.io/2016/2016-03-21-datatable2/

https://youngspring1.github.io/2016/2016-03-22-datatable3/

https://youngspring1.github.io/2016/2016-04-02-datatable4/

https://youngspring1.github.io/2016/2016-04-08-datatable5/
</code></pre>
</div></div></div></div></div>
</div> <!-- /content -->



<script src="../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>